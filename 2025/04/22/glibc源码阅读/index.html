<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":300},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":{"valine":{"order":-1}}},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="glibc2.31 malloc.c">
<meta property="og:type" content="article">
<meta property="og:title" content="glibc源码阅读">
<meta property="og:url" content="http://example.com/2025/04/22/glibc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.html">
<meta property="og:site_name" content="le0n-blog">
<meta property="og:description" content="glibc2.31 malloc.c">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/04/22/images/image-20250422212550966.png">
<meta property="article:published_time" content="2025-04-22T09:59:29.830Z">
<meta property="article:modified_time" content="2025-07-15T00:57:24.315Z">
<meta property="article:author" content="leon">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/04/22/images/image-20250422212550966.png">


<link rel="canonical" href="http://example.com/2025/04/22/glibc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/04/22/glibc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","path":"2025/04/22/glibc源码阅读/","title":"glibc源码阅读"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>glibc源码阅读 | le0n-blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">le0n-blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#malloc-c"><span class="nav-number">1.</span> <span class="nav-text">malloc.c</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-assert"><span class="nav-number">1.1.</span> <span class="nav-text">__malloc_assert</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USE-TCACHE"><span class="nav-number">1.2.</span> <span class="nav-text">USE_TCACHE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.3.</span> <span class="nav-text">一些设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.</span> <span class="nav-text">一些声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-malloc"><span class="nav-number">1.4.1.</span> <span class="nav-text">__libc_malloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-free"><span class="nav-number">1.4.2.</span> <span class="nav-text">__libc_free()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-calloc"><span class="nav-number">1.4.3.</span> <span class="nav-text">__libc_calloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-realloc"><span class="nav-number">1.4.4.</span> <span class="nav-text">__libc_realloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-memalign"><span class="nav-number">1.4.5.</span> <span class="nav-text">__libc_memalign</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-valloc"><span class="nav-number">1.4.6.</span> <span class="nav-text">__libc_valloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DEFAULT-MMAP-MAX"><span class="nav-number">1.5.</span> <span class="nav-text">DEFAULT_MMAP_MAX</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.6.</span> <span class="nav-text">重要函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk-representations"><span class="nav-number">1.7.</span> <span class="nav-text">chunk representations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.</span> <span class="nav-text">chunk的一些计算操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk%E7%9A%84%E7%89%A9%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">1.9.</span> <span class="nav-text">chunk的物理操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Indexing"><span class="nav-number">1.10.</span> <span class="nav-text">Indexing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unlink-chunk"><span class="nav-number">1.11.</span> <span class="nav-text">unlink_chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsorted-bin"><span class="nav-number">1.12.</span> <span class="nav-text">Unsorted_bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Top"><span class="nav-number">1.13.</span> <span class="nav-text">Top</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binmap"><span class="nav-number">1.14.</span> <span class="nav-text">Binmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fastbin"><span class="nav-number">1.15.</span> <span class="nav-text">Fastbin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Internal-state-representation-and-initialization"><span class="nav-number">1.16.</span> <span class="nav-text">Internal state representation and initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-state"><span class="nav-number">1.16.1.</span> <span class="nav-text">malloc_state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-par"><span class="nav-number">1.16.2.</span> <span class="nav-text">malloc_par</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hook%E5%87%BD%E6%95%B0"><span class="nav-number">1.17.</span> <span class="nav-text">hook函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%B9%B6%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E5%A0%86%E6%A3%80%E6%9F%A5"><span class="nav-number">1.18.</span> <span class="nav-text">声明并定义了一堆检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sysmalloc"><span class="nav-number">1.19.</span> <span class="nav-text">sysmalloc()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#systrim"><span class="nav-number">1.20.</span> <span class="nav-text">systrim()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#munmap"><span class="nav-number">1.21.</span> <span class="nav-text">munmap()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache"><span class="nav-number">1.22.</span> <span class="nav-text">tcache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-entry"><span class="nav-number">1.22.1.</span> <span class="nav-text">tcache_entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-perthread-struct"><span class="nav-number">1.22.2.</span> <span class="nav-text">tcache_perthread_struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-puts"><span class="nav-number">1.22.3.</span> <span class="nav-text">tcache_puts()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-get"><span class="nav-number">1.22.4.</span> <span class="nav-text">tcache_get()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-thread-shutdown"><span class="nav-number">1.22.5.</span> <span class="nav-text">tcache_thread_shutdown()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-init"><span class="nav-number">1.22.6.</span> <span class="nav-text">tcache_init()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-malloc-1"><span class="nav-number">1.23.</span> <span class="nav-text">__libc_malloc()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-free-1"><span class="nav-number">1.24.</span> <span class="nav-text">__libc_free()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc"><span class="nav-number">1.25.</span> <span class="nav-text">malloc()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fastbin"><span class="nav-number">1.25.1.</span> <span class="nav-text">fastbin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#smallbin"><span class="nav-number">1.25.2.</span> <span class="nav-text">smallbin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#largebin"><span class="nav-number">1.25.3.</span> <span class="nav-text">largebin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#use-top"><span class="nav-number">1.25.4.</span> <span class="nav-text">use_top</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-consolidate"><span class="nav-number">1.26.</span> <span class="nav-text">malloc_consolidate()</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="leon"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">leon</p>
  <div class="site-description" itemprop="description">Take more notes to reach higher efficiency.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/le0n-daily" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;le0n-daily" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1192876128@gmail.com" title="E-Mail → mailto:1192876128@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/22/glibc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="le0n-blog">
      <meta itemprop="description" content="Take more notes to reach higher efficiency.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="glibc源码阅读 | le0n-blog">
      <meta itemprop="description" content="glibc2.31 malloc.c">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          glibc源码阅读
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-04-22 17:59:29" itemprop="dateCreated datePublished" datetime="2025-04-22T17:59:29+08:00">2025-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-15 08:57:24" itemprop="dateModified" datetime="2025-07-15T08:57:24+08:00">2025-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>63k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>57 mins.</span>
    </span>
</div>

            <div class="post-description">glibc2.31 malloc.c</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>目标：</p>
<ul>
<li>做出malloc导图</li>
<li>理解largebin_attack等攻击利用</li>
<li></li>
</ul>
<h1 id="malloc-c"><a href="#malloc-c" class="headerlink" title="malloc.c"></a>malloc.c</h1><h2 id="malloc-assert"><a href="#malloc-assert" class="headerlink" title="__malloc_assert"></a>__malloc_assert</h2><p>__int_malloc()函数的断言，一个用于处理断言失败的 C 语言宏和函数实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __assert_fail(assertion, file, <span class="keyword">line</span>, function)			\</span></span><br><span class="line"><span class="meta">	 __malloc_assert(assertion, file, <span class="keyword">line</span>, function)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *__progname;<span class="comment">//声明一个外部变量 __progname，它存储程序的名称。</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span><span class="comment">//静态函数 __malloc_assert，用于处理断言失败的情况。因为它是静态的，所以它只能在当前文件中被访问。</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);<span class="comment">//刷新标准错误流</span></span><br><span class="line">  <span class="built_in">abort</span> ();<span class="comment">//函数被调用以异常终止程序执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>代码总结</strong></p>
<ul>
<li>此代码块定义了一个断言失败时的处理机制：<ul>
<li>在程序的调试版本中，如果某个断言失败，<code>__assert_fail</code> 宏会被调用。</li>
<li>宏调用 <code>__malloc_assert</code>，该函数会生成详细的错误信息，并将其输出到标准错误流，然后终止程序。</li>
</ul>
</li>
<li>由于整个处理是通过宏和函数来完成的，因此提供了灵活性和可读性，便于在需要时进行调试，而在发布版本中可以通过定义 <code>NDEBUG</code> 来禁用这些检查。</li>
</ul>
<h2 id="USE-TCACHE"><a href="#USE-TCACHE" class="headerlink" title="USE_TCACHE"></a>USE_TCACHE</h2><p>tcache的初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.定义了 tidx2usize 宏，这个宏用于将bin的idx转换为相应的字节大小。*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().定义了 csize2tidx 宏，将一个给定的chunk大小 x 转换为对应的bin idx。 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="comment">//tcache 中最多 7 个</span></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这里见名知意，例：tidx2usize —&gt; tcache_idx to unsigned_size</p>
<h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><p>目的：提高项目的可移植性和开启一些优化措施</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  REALLOC_ZERO_BYTES_FREES should be set if a call to</span></span><br><span class="line"><span class="comment">  realloc with zero bytes should be the same as a call to free.</span></span><br><span class="line"><span class="comment">  This is required by the C standard. Otherwise, since this malloc</span></span><br><span class="line"><span class="comment">  returns a unique pointer for malloc(0), so does realloc(p, 0).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//realloc()参数为 0 相当于free</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REALLOC_ZERO_BYTES_FREES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  TRIM_FASTBINS 控制非常小的内存块的 free() 调用是否可以立即导致内存修剪。</span></span><br><span class="line"><span class="comment">  将其设置为 true (1) 可以减少内存占用，但几乎总是会降低使用大量小块的程序的速度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  仅在您愿意牺牲一些速度以在释放大量小块内存的程序中更积极地减少系统级内存占用时，</span></span><br><span class="line"><span class="comment">  定义此选项。通过将 MXFAST 设置为 0，您可以获得基本相同的效果，但这可能导致</span></span><br><span class="line"><span class="comment">  使用许多小块的程序出现更大的性能下降。 TRIM_FASTBINS 是一个折中的编译时选项，</span></span><br><span class="line"><span class="comment">  它只禁用那些靠近顶部内存的块被放置在快速链表中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TRIM_FASTBINS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRIM_FASTBINS  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从操作系统获取更多内存的定义。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE         (*__morecore)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE_FAILURE 0</span></span><br><span class="line"><span class="type">void</span> * __default_morecore (<span class="type">ptrdiff_t</span>);</span><br><span class="line"><span class="type">void</span> *(*__morecore)(<span class="type">ptrdiff_t</span>) = __default_morecore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  与 MORECORE 相关的声明。默认情况下，依赖于 sbrk。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MORECORE 是从系统获取更多内存的函数名称。有关编写替代 MORECORE 函数的一般指导，</span></span><br><span class="line"><span class="comment">  以及 WIN32 的版本和 pre-OSX macOS 的示例版本，请参见下文。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE sbrk</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MORECORE_FAILURE 是 MORECORE 和 mmap 失败时返回的值。</span></span><br><span class="line"><span class="comment">  由于它不能是有效的内存地址，并且必须反映标准系统调用的值，</span></span><br><span class="line"><span class="comment">  因此您可能不应该尝试重新定义它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_FAILURE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE_FAILURE (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果 MORECORE_CONTIGUOUS 为真，则利用连续调用 MORECORE </span></span><br><span class="line"><span class="comment">  并使用正参数总是返回连续递增地址的事实。 </span></span><br><span class="line"><span class="comment">  这在 UNIX 的 sbrk 中是正确的。即使没有定义，</span></span><br><span class="line"><span class="comment">  当区域恰好是连续的时，malloc 也允许从不同调用中获得的区域跨越分配。</span></span><br><span class="line"><span class="comment">  但是在适用时定义这个可以启用更强的一致性检查和空间效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CONTIGUOUS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MORECORE_CONTIGUOUS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果您的 MORECORE 版本在给定负参数时无法将空间释放回系统，</span></span><br><span class="line"><span class="comment">  请定义 MORECORE_CANNOT_TRIM。 </span></span><br><span class="line"><span class="comment">  这通常仅在您使用无法处理负参数的手工编写的 MORECORE 函数时是必要的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* #define MORECORE_CANNOT_TRIM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  MORECORE_CLEARS (默认 1)</span></span><br><span class="line"><span class="comment">     被映射到 MORECORE 的例程清零内存的程度：</span></span><br><span class="line"><span class="comment">     从不 (0)、仅对新分配的空间 (1) 或总是 (2)。</span></span><br><span class="line"><span class="comment">     (1) 和 (2) 之间的区别是必要的，因为在某些系统上，</span></span><br><span class="line"><span class="comment">     如果应用程序先将断点值递减，然后再增加，</span></span><br><span class="line"><span class="comment">     则重新分配空间的内容是未指定的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CLEARS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MORECORE_CLEARS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   MMAP_AS_MORECORE_SIZE 是使用 mmap 作为备份时，如果 sbrk 失败，则使用的最小 mmap 大小参数。</span></span><br><span class="line"><span class="comment">   该值必须是页面大小的倍数。 </span></span><br><span class="line"><span class="comment">   此备份策略通常仅在系统的地址空间中存在“空洞”时适用，</span></span><br><span class="line"><span class="comment">   这样 sbrk 不能执行连续扩展，但系统上仍然有空间可用。</span></span><br><span class="line"><span class="comment">   对于已知对此有用的系统（即大多数 Linux 内核），</span></span><br><span class="line"><span class="comment">   这仅在程序分配大量内存时发生。</span></span><br><span class="line"><span class="comment">   鉴于此，以及 mmap 区域往往有限，大小应该较大，</span></span><br><span class="line"><span class="comment">   以避免过多的 mmap 调用，从而避免耗尽内核资源。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MMAP_AS_MORECORE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMAP_AS_MORECORE_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  定义 HAVE_MREMAP 以使 realloc() 使用 mremap() 重新分配大块内存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HAVE_MREMAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_MREMAP 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们可能需要支持 __malloc_initialize_hook 以实现向后兼容性。 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_24)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAVE_MALLOC_INIT_HOOK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HAVE_MALLOC_INIT_HOOK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="一些声明"><a href="#一些声明" class="headerlink" title="一些声明"></a>一些声明</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc()"></a>__libc_malloc()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这个版本的 malloc 支持标准的 SVID/XPG mallinfo </span></span><br><span class="line"><span class="comment">  函数，该函数返回一个包含使用属性和统计信息的结构体。</span></span><br><span class="line"><span class="comment">  它应该可以在任何符合 SVID/XPG 的系统上工作，该系统在 </span></span><br><span class="line"><span class="comment">  /usr/include/malloc.h 中定义了 struct mallinfo。</span></span><br><span class="line"><span class="comment">  （如果您想自己安装这样的东西，可以根据上面和下面的描述</span></span><br><span class="line"><span class="comment">  删除初步声明，并将其保存到一个 malloc.h 文件中。但实际上</span></span><br><span class="line"><span class="comment">  没有 compelling 的理由去费心去做这件事。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  主要需要的声明是由 mallinfo() 返回的 mallinfo 结构体。</span></span><br><span class="line"><span class="comment">  SVID/XPG 的 mallinfo 结构体包含了一些在这个版本的 malloc </span></span><br><span class="line"><span class="comment">  中甚至没有意义的字段。这些字段则被 mallinfo() 填充</span></span><br><span class="line"><span class="comment">  为其他可能感兴趣的数字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------- description of public routines ------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  返回一个指向新分配的至少 n 字节的内存块的指针，如果没有可用空间，则返回 null。</span></span><br><span class="line"><span class="comment">  此外，在失败时，ANSI C 系统上的 errno 被设置为 ENOMEM。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果 n 为零，malloc 返回一个最小大小的块。 </span></span><br><span class="line"><span class="comment">  （在大多数 32 位系统上，最小大小为 16 字节，而在 64 位系统上为 24 或 32 字节。）</span></span><br><span class="line"><span class="comment">  在大多数系统上，size_t 是一种无符号类型，因此对于负参数的调用</span></span><br><span class="line"><span class="comment">  被解释为请求巨大的空间，这通常会失败。</span></span><br><span class="line"><span class="comment">  支持的 n 的最大值在各系统之间有所不同，但在任何情况下都小于</span></span><br><span class="line"><span class="comment">  size_t 的最大可表示值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_malloc(<span class="type">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_malloc)<span class="comment">//宏，用于隐藏这个函数的实现细节，使其在外部不可见</span></span><br></pre></td></tr></table></figure>

<h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  释放由 p 指向的内存块，该内存块是之前使用 malloc 或相关例程（如 realloc）分配的。</span></span><br><span class="line"><span class="comment">  如果 p 为 null，则没有任何效果。如果 p 已经被释放，则可能会产生任意（即，不良的！）</span></span><br><span class="line"><span class="comment">  效果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  除非被禁用（使用 mallopt），否则释放非常大的空间时，系统会在可能的情况下</span></span><br><span class="line"><span class="comment">  自动触发将未使用的内存返回给系统的操作，从而减少程序的内存占用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>     __libc_free(<span class="type">void</span>*);</span><br><span class="line">libc_hidden_proto (__libc_free)<span class="comment">//宏，用于隐藏这个函数的实现细节，使其在外部不可见</span></span><br></pre></td></tr></table></figure>

<h3 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="__libc_calloc"></a>__libc_calloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  返回指向 n_elements * element_size 字节的指针，并将所有位置设置为零。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_calloc(<span class="type">size_t</span>, <span class="type">size_t</span>);</span><br></pre></td></tr></table></figure>

<h3 id="libc-realloc"><a href="#libc-realloc" class="headerlink" title="__libc_realloc()"></a>__libc_realloc()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  realloc(void* p, size_t n)</span></span><br><span class="line"><span class="comment">  返回一个大小为 n 的内存块指针，该内存块包含与指针 p 相同的数据，直到 (n, p 的大小) 中的最小值字节。如果没有可用空间，则返回 null。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  返回的指针可能与 p 相同，也可能不同。算法优先选择扩展 p，如果不可能，则使用相当于 malloc-copy-free 的序列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果 p 为 null，则 realloc 相当于 malloc。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果没有可用空间，realloc 将返回 null，errno 被设置（如果在 ANSI 下），同时 p 不会被释放。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果 n 小于 p 当前持有的字节数，新的未使用空间将被截断并在可能的情况下释放。除非定义了 #define REALLOC_ZERO_BYTES_FREES，否则 realloc 的大小参数为零时（重新）分配一个最小大小的块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  通过 mmap 方式内部获得的大块内存将始终使用 malloc-copy-free 序列扩展，除非系统支持 MREMAP（目前仅限于 Linux）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  不支持旧 Unix realloc 约定，即允许将最后释放的内存块作为 realloc 的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_realloc(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_realloc)</span><br></pre></td></tr></table></figure>

<h3 id="libc-memalign"><a href="#libc-memalign" class="headerlink" title="__libc_memalign"></a>__libc_memalign</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  memalign(size_t alignment, size_t n);</span></span><br><span class="line"><span class="comment">  返回指向新分配的 n 字节内存块的指针，该内存块的对齐方式符合 alignment 参数的要求。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  alignment 参数应该是 2 的幂。如果参数不是 2 的幂，则使用最近的较大 2 的幂。</span></span><br><span class="line"><span class="comment">  正常的 malloc 调用保证了 8 字节对齐，因此不要使用 8 或更小的参数调用 memalign。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  过度依赖 memalign 会导致内存碎片化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_memalign(<span class="type">size_t</span>, <span class="type">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_memalign)</span><br></pre></td></tr></table></figure>

<h3 id="libc-valloc"><a href="#libc-valloc" class="headerlink" title="__libc_valloc"></a>__libc_valloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  valloc(size_t n);</span></span><br><span class="line"><span class="comment">  等同于 memalign(pagesize, n)，其中 pagesize 是系统的页面大小。</span></span><br><span class="line"><span class="comment">  如果页面大小未知，则使用 4096 字节作为默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_valloc(<span class="type">size_t</span>);</span><br></pre></td></tr></table></figure>

<p>跳过，感觉这些没啥意思，跳转978行</p>
<h2 id="DEFAULT-MMAP-MAX"><a href="#DEFAULT-MMAP-MAX" class="headerlink" title="DEFAULT_MMAP_MAX"></a>DEFAULT_MMAP_MAX</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  M_MMAP_MAX 是同时使用 mmap 服务的最大请求数量。</span></span><br><span class="line"><span class="comment">  这个参数存在的原因是，有些系统对 mmap 使用的内部表有数量限制，</span></span><br><span class="line"><span class="comment">  超过一定数量可能会降低性能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  默认值设置为一个仅作为保护的值。</span></span><br><span class="line"><span class="comment">  将该值设置为 0 会禁用使用 mmap 来处理大请求。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M_MMAP_MAX             -4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_MAX       (65536)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RETURN_ADDRESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RETURN_ADDRESS(X_) (NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="重要函数声明"><a href="#重要函数声明" class="headerlink" title="重要函数声明"></a>重要函数声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Forward declarations.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span><span class="comment">//这个指针指向malloc_chunk的头部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal routines.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*  _int_malloc(mstate, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     _int_free(mstate, mchunkptr, <span class="type">int</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*  _int_realloc(mstate, mchunkptr, INTERNAL_SIZE_T,</span><br><span class="line">			   INTERNAL_SIZE_T);</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*  _int_memalign(mstate, <span class="type">size_t</span>, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*  _mid_memalign(<span class="type">size_t</span>, <span class="type">size_t</span>, <span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_printerr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> __<span class="title function_">attribute__</span> <span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">mem2mem_check</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> sz)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">top_check</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">munmap_chunk</span><span class="params">(mchunkptr p)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MREMAP</span></span><br><span class="line"><span class="type">static</span> mchunkptr <span class="title function_">mremap_chunk</span><span class="params">(mchunkptr p, <span class="type">size_t</span> new_size)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*   <span class="title function_">malloc_check</span><span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>      <span class="title function_">free_check</span><span class="params">(<span class="type">void</span>* mem, <span class="type">const</span> <span class="type">void</span> *caller)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*   <span class="title function_">realloc_check</span><span class="params">(<span class="type">void</span>* oldmem, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">			       <span class="type">const</span> <span class="type">void</span> *caller)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>*   <span class="title function_">memalign_check</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">void</span> *caller)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="chunk-representations"><a href="#chunk-representations" class="headerlink" title="chunk representations"></a>chunk representations</h2><p>chunk的表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="chunk的一些计算操作"><a href="#chunk的一些计算操作" class="headerlink" title="chunk的一些计算操作"></a>chunk的一些计算操作</h2><p>mem就是返回给用户的指针，即上面的 fd 的位置</p>
<p>堆地址是由低地址往高地址生长的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ---------- Size and alignment checks and conversions ----------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="comment">//计算最小内存块的大小，即从 struct malloc_chunk 结构体中 fd_nextsize 字段的偏移量。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//定义可以分配的最小内存块的大小。它确保计算出的大小是对齐的，使用 MALLOC_ALIGN_MASK 来进行对齐。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="comment">//判断给定内存块指针 p 是否对齐。如果对齐规则是 2 * SIZE_SZ，则直接使用指针 p，否则使用 chunk2mem(p) 进行转换。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个内联函数确保请求的大小 req 不会溢出 PTRDIFF_MAX。如果 req 大于 PTRDIFF_MAX，函数返回 false。否则，调用 request2size 计算可用大小，并将结果存储在 sz 中，最后返回 true */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="chunk的物理操作"><a href="#chunk的物理操作" class="headerlink" title="chunk的物理操作"></a>chunk的物理操作</h2><p>即 A M P 哪几个标志位</p>
<p>这里的东西可以在分析代码逻辑时跳转回来看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   --------------- Physical chunk operations ---------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   提取大小时需要屏蔽掉的位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   注意：IS_MMAPPED 在那些不应看到内存映射块的宏中被故意保留在大小字段中。这会导致在扩展或改编这个 malloc 时，如果不小心尝试访问这些块，会产生有用的核心转储。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC poison mchunk_size</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC poison mchunk_prev_size</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment">   内部数据结构</span></span><br><span class="line"><span class="comment">   所有内部状态都保存在下面定义的 malloc_state 实例中。除了在两种可选情况下，没有其他静态变量：</span></span><br><span class="line"><span class="comment"> * 如果定义了 USE_MALLOC_LOCK，则上面声明的 mALLOC_MUTEx。</span></span><br><span class="line"><span class="comment"> * 如果 mmap 不支持 MAP_ANONYMOUS，则为 mmap 提供一个虚拟文件描述符。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   注意许多技巧旨在最小化总的记账空间需求。结果大约是 1K 字节（对于 4 字节指针和 size_t）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   一个用于free chunk的数组。每个bin都是双向链接的。bins之间的间隔大致成比例（对数）分布。bin的数量非常多（128个）。这看起来可能有些过多，但在实际使用中效果非常好。大多数bin所包含的大小在 malloc 请求中并不常见，但对于片段和合并的块组合来说却是比较常见的，这正是这些箱子所存储的内容，因此可以快速找到。所有过程都保持不变，即没有一个合并的块物理上与另一个合并的chunk相邻，因此列表中的每个chunk都知道其前后是使用中的chunk或内存的末尾。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   bins中的chunk按大小顺序排列，大小相同的chunk在近似最近使用的块中进行排序。对于small bins而言，排序并不是必须的，因为它们都包含相同大小的chunk，但对于较大的chunk，有助于最佳适配分配。这些列表只是顺序的。保持它们有序几乎从来不需要遍历到足以使用更复杂的有序数据结构的程度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   相同大小的chunk以最近释放的chunk在前的顺序链接，分配则从后面取。这导致了 LRU（FIFO）分配顺序，这通常为每个chunk提供了与相邻释放的chunk合并的平等机会，从而产生了更大的自由块并减少了碎片化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   为了简化在双向链表中的使用，每个箱头都充当 malloc_chunk。这避免了对头的特殊处理。但为了节省空间并改善局部性，我们仅分配箱子的 fd/bk 指针，然后利用重定位技巧将这些视为 malloc_chunk* 的字段。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 地址计算 -- 请注意， bin_at(0) 不存在 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ++bin 的类似物 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关于箱子内列表方向性的提醒 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>

<p><code>bin_at()</code> 是一个宏，用于通过给定的索引从内存管理器（<code>m</code>）的 <code>bins</code> 数组中获取特定的 bin（内存块管理单元）。它的实现依赖于 <code>offsetof</code>，计算出特定 bin 的地址，并进行适当的类型转换。</p>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>m</code>: 这是一个指向内存管理结构的指针，通常是一个包含多个 bins 的结构体。</li>
<li><code>i</code>: 这是一个 bin 的索引，表示你想要获取的 bin 的位置（注意，索引是从 1 开始的，<code>bin_at(0)</code> 不存在）。</li>
</ul>
<p>宏 bin_at(m, i)通过 bin index 获得 bin 的链表头，chunk 中的fd 和 bk 用于将空闲 chunk 链入链表中，而对于每个 bin 的链表头，只需要这两个域就可以了，prev_size 和 size 对链表 都来说都没有意义，浪费空间，ptmalloc 为了节约这点内存空间，增大 cpu 高速缓存的命中 率，在 bins 数组中只为每个 bin 预留了两个指针的内存空间用于存放 bin 的链表头的 fb 和 bk 指针。 </p>
<p>从 bin_at(m, i)的定义可以看出，bin[0]不存在，以 SIZE_SZ 为 4B 的平台为例，bin[1]的前 4B 存储的是指针 fb，后 4B 存储的是指针 bk，而 bin_at 返回的是 malloc_chunk 的指针，由 于 fb 在 malloc_chunk 的偏移地址为 offsetof (struct malloc_chunk, fd))&#x3D;8，所以用 fb 的地址减 去 8 就得到 malloc_chunk 的地址。但切记，对 bin 的链表头的 chunk，一定不能修改 prev_size 和 size 域，这两个域是与其他 bin 的链表头的 fb 和 bk 内存复用的。 </p>
<p>宏 next_bin(b)用于获得下一个 bin 的地址，根据前面的分析，我们知道只需要将当前 bin 的地址向后移动两个指针的长度就得到下一个 bin 的链表头地址。 每个 bin 使用双向循环链表管理空闲 chunk，bin 的链表头的指针 fb 指向第一个可用的 chunk，指针 bk 指向最后一个可用的 chunk。宏 first(b)用于获得 bin 的第一个可用 chunk， 宏 last(b)用于获得 bin 的最后一个可用的 chunk，这两个宏便于遍历 bin，而跳过 bin 的链表 头。</p>
<h2 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h2><p>这段代码主要是根据chunk的size去计算出合适的bins。</p>
<p><strong>smallbin:</strong></p>
<p>ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index 有如下关系： Chunk_size&#x3D;2 * SIZE_SZ * index 在 SIZE_SZ 为 4B 的平台上，small bins 中的 chunk 大小是以 8B 为公差的等差数列，最大 的 chunk 大小为 504B，最小的 chunk 大小为 16B，所以实际共 62 个 bin。分别为 16B、24B、 32B，„„，504B。在 SIZE_SZ 为 8B 的平台上，small bins 中的 chunk 大小是以 16B 为公差 的等差数列，最大的 chunk 大小为 1008B，最小的 chunk 大小为 32B，所以实际共 62 个 bin。 分别为 32B、48B、64B，„„，1008B。 ptmalloc 维护了 62 个双向环形链表（每个链表都具有链表头节点，加头节点的最大作 用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲 chunk 的大小 一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样 既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可 以用 如下图来表示在 SIZE_SZ 为 4B 的平台上 ptmalloc 对 512B 字节以下的空闲 chunk 组织方 式 （所谓的分箱机制）。</p>
<img data-src="../images/image-20250422212550966.png" alt="image-20250422212550966" style="zoom:50%;" />

<p><strong>largebin:</strong></p>
<p>在 SIZE_SZ 为 4B 的平台上，大于等于 512B的空闲 chunk，或者，在 SIZE_SZ 为 8B 的平 台上，大小大于等于 1024B的空闲 chunk，由sorted bins 管理。Large bins 一共包括 63 个 bin， 每个 bin 中的 chunk 大小不是一个固定公差的等差数列，而是分成 6 组 bin，每组 bin 是一个 固定公差的等差数列，每组的 bin 数量依次为 32、16、8、4、2、1，公差依次为 64B、512B、 4096B、32768B、262144B 等。 以 SIZE_SZ 为 4B 的平台为例，第一个 large bin 的起始 chunk 大小为 512B，共 32 个 bin， 公差为 64B，等差数列满足如下关系： Chunk_size&#x3D;512 + 64 * index 第二个 large bin的起始 chunk 大小为第一组 bin 的结束 chunk 大小，满足如下关系： Chunk_size&#x3D;512 + 64 * 32 + 512 * index 同理，我们可计算出每个 bin 的起始 chunk 大小和结束 chunk 大小。这些 bin 都是很有 规律的，其实small bins 也是满足类似规律，small bins 可以看着是公差为 8 的等差数列，一 共有 64 个 bin（第 0和 1bin 不存在），所以我们可以将 small bins 和 large bins存放在同一个 包含 128 个 chunk 的数组上，数组的前一部分位 small bins，后一部分为 large bins，每个 bin 的 index 为 chunk 数组的下标，于是，我们可以根据数组下标计算出该 bin 的 chunk 大小（small bins）或是 chunk 大小范围（large bins），也可以根据需要分配内存块大小计算出所需 chunk 所属 bin 的 index，ptmalloc 使用了一组宏巧妙的实现了这种计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br></pre></td></tr></table></figure>

<p>宏bin_index(sz)根据所需内存大小计算出所需 bin 的 index，如果所需内存大小属于 small bins 的大小范围，调用 smallbin_index(sz)，否则调用 largebin_index(sz))。smallbin_index(sz) 的计算相当简单，如果 SIZE_SZ 为 4B，则将 sz 除以 8，如果 SIZE_SZ 为 8B，则将 sz 除以 16， 也就是除以small bins 中等差数列的公差。largebin_index(sz)的计算相对复杂一些，可以用如 下的表格直观的显示 chunk 的大小范围与 bin index 的关系。</p>
<h2 id="unlink-chunk"><a href="#unlink-chunk" class="headerlink" title="unlink_chunk"></a>unlink_chunk</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk; <span class="comment">//unlink操作的利用点</span></span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">	  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">	malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">	    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">	      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted_bin"></a>Unsorted_bin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   所有从内存块拆分而来的剩余部分，以及所有被释放的内存块，</span></span><br><span class="line"><span class="comment">   首先都会被放置在“未排序” bin 中。在 malloc 函数给它们</span></span><br><span class="line"><span class="comment">   一次使用的机会之前，这些块将不会被移入常规的 bin。因此，</span></span><br><span class="line"><span class="comment">   基本上，未排序的内存块列表充当一个队列，内存块在 free（和</span></span><br><span class="line"><span class="comment">   malloc_consolidate）时被放入该队列，而在 malloc 时被取出（要么</span></span><br><span class="line"><span class="comment">   被使用，要么放入常规的 bin）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   对于未排序的内存块，NON_MAIN_ARENA 标志永远不会被设置，</span></span><br><span class="line"><span class="comment">   因此在大小比较时不需要考虑这个标志。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure>

<h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   最上方可用的内存块（即，靠近可用内存末尾的块）被特殊处理。</span></span><br><span class="line"><span class="comment">   它从不被包含在任何 bin 中，仅在没有其他块可用时使用，</span></span><br><span class="line"><span class="comment">   如果它非常大，则会被释放回系统（参见 M_TRIM_THRESHOLD）。</span></span><br><span class="line"><span class="comment">   因为初始的 top 指向自身的 bin，初始大小为零，这样在第一次</span></span><br><span class="line"><span class="comment">   malloc 请求时强制进行扩展，从而避免在 malloc 中需要任何</span></span><br><span class="line"><span class="comment">   特殊代码来检查它是否已经存在。但是，在从系统获取内存时</span></span><br><span class="line"><span class="comment">   我们仍然需要这样做，因此在初始化和第一次调用 sysmalloc </span></span><br><span class="line"><span class="comment">   之间，我们让 initial_top 将 bin 视为在此期间合法但不可用的块。</span></span><br><span class="line"><span class="comment">   （这有点微妙，因为这依赖于在此期间前面的两个字都为零。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方便的是，未排序的 bin 可以在第一次调用时作为虚拟的顶部 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span></span><br></pre></td></tr></table></figure>

<h2 id="Binmap"><a href="#Binmap" class="headerlink" title="Binmap"></a>Binmap</h2><p>记录一个块内chunk的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   为了帮助补偿大量的bins，一个一层索引结构被用来逐个桶(bin by bin)地搜索。</span></span><br><span class="line"><span class="comment">   `binmap` 是一个位向量，用于记录bins是否绝对为空，以便在遍历</span></span><br><span class="line"><span class="comment">   时可以跳过它们。位并不会在桶变空后立即清除，而是仅在</span></span><br><span class="line"><span class="comment">   malloc 遍历过程中注意到它们是空时才会清除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在映射字中保守地使用32位，即使在64位系统上也是如此 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT      5  <span class="comment">// 每个映射字的位移量，表示每个字包含 2^5 = 32 位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)  <span class="comment">// 每个映射字包含的位数，这里是 32 位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP) <span class="comment">// 桶映射的大小，即总桶数除以每个映射字的位数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bin索引转换为桶映射字的索引</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="comment">// 根据bin的索引计算出对应的位掩码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"><span class="comment">// 标记指定的桶为空，更新映射字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line"><span class="comment">// 清除指定的桶位，标记为非空</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span></span><br><span class="line"><span class="comment">// 获取指定桶的映射状态（是否为空），返回对应的位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span></span><br></pre></td></tr></table></figure>

<h2 id="Fastbin"><a href="#Fastbin" class="headerlink" title="Fastbin"></a>Fastbin</h2><p>单向链表，头插法，即每次插入新的chunk都在头节点和头结点的下一个节点进行插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   快速桶（Fastbins）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   一组链表，保存最近释放的小块内存。fastbin</span></span><br><span class="line"><span class="comment">   不是双向链接的。单向链接更快，并且由于块从未</span></span><br><span class="line"><span class="comment">   从这些链表的中间位置删除，因此不需要双向链接。</span></span><br><span class="line"><span class="comment">   此外，与常规桶不同，它们甚至不是以先进先出</span></span><br><span class="line"><span class="comment">   的顺序处理（使用更快的后进先出），因为在fastbin</span></span><br><span class="line"><span class="comment">   通常使用的瞬态上下文中，顺序并不是非常重要。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   fastbin中的块保持其使用位被设置，因此不能与</span></span><br><span class="line"><span class="comment">   其他释放的块合并。malloc_consolidate 函数会释放</span></span><br><span class="line"><span class="comment">   所有fastbin中的块，并将它们与其他释放的块合并。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span>  <span class="comment">// 定义指向 malloc_chunk 结构的指针类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])  <span class="comment">// 获取指定索引的fastbin中的块</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 偏移量为 2，以使用其他不可索引的前两个桶 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)  <span class="comment">// 计算给定大小对应的fastbin索引</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们支持的最大fastbin请求大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)  <span class="comment">// 最大fastbin大小，根据系统字长调整</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS  (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)  <span class="comment">// fastbin的数量</span></span></span><br></pre></td></tr></table></figure>

<p>这个fastbin合并操作也可以利用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD 是在 free() 中触发</span></span><br><span class="line"><span class="comment">   自动合并可能周围的fastbin chunk。这个值是一个</span></span><br><span class="line"><span class="comment">   启发式的值，因此具体的数值不应该太过于重要。它</span></span><br><span class="line"><span class="comment">   被定义为默认修剪阈值的一半，作为一种折中启发式，</span></span><br><span class="line"><span class="comment">   仅在可能导致修剪的情况下尝试合并。然而，由于</span></span><br><span class="line"><span class="comment">   合并即使在不使用修剪时也能减少大块周围的碎片，</span></span><br><span class="line"><span class="comment">   所以这个值并不是动态可调的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT 表示 MORECORE 不返回连续的区域。</span></span><br><span class="line"><span class="comment">   否则，连续性在合并结果时会被利用，尽可能地</span></span><br><span class="line"><span class="comment">   合并连续的 MORECORE 调用结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   初始值来自 MORECORE_CONTIGUOUS，但如果使用 mmap</span></span><br><span class="line"><span class="comment">   作为 sbrk 的替代品，则会动态改变。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)  <span class="comment">// 判断内存块是否连续</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M)       (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)  <span class="comment">// 判断内存块是否非连续</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M)   ((M)-&gt;flags |= NONCONTIGUOUS_BIT)         <span class="comment">// 设置内存块为非连续</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M)      ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)        <span class="comment">// 设置内存块为连续</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fastbin中处理的最大内存大小。 */</span></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   设置 max_fast 的值。</span></span><br><span class="line"><span class="comment">   如果为 0，则使用不可能的较小值。</span></span><br><span class="line"><span class="comment">   前提条件：main_arena中没有现有的fastbin chunk。</span></span><br><span class="line"><span class="comment">   由于 do_check_malloc_state() 会检查这一点，</span></span><br><span class="line"><span class="comment">   我们在更改 max_fast 之前调用 malloc_consolidate()。</span></span><br><span class="line"><span class="comment">   请注意，如果 max_fast 被减少，则其他区域将泄露</span></span><br><span class="line"><span class="comment">   它们的fastbin条目。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">  global_max_fast = (((s) == 0)						      \</span></span><br><span class="line"><span class="meta">                     ? MIN_CHUNK_SIZE / 2 : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> INTERNAL_SIZE_T</span><br><span class="line"><span class="title function_">get_max_fast</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 告诉 GCC 优化器 global_max_fast 永远不会大于</span></span><br><span class="line"><span class="comment">     MAX_FAST_SIZE。这避免了在 _int_malloc 中</span></span><br><span class="line"><span class="comment">     的越界数组访问（在大小参数的常量传播后）。</span></span><br><span class="line"><span class="comment">     （这段代码不会执行，因为 malloc 保持</span></span><br><span class="line"><span class="comment">     global_max_fast 不变量，但优化器可能不会识别</span></span><br><span class="line"><span class="comment">     这一点。） */</span></span><br><span class="line">  <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">    __builtin_unreachable ();</span><br><span class="line">  <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Internal-state-representation-and-initialization"><a href="#Internal-state-representation-and-initialization" class="headerlink" title="Internal state representation and initialization"></a>Internal state representation and initialization</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p><code>malloc_state</code> 结构体是实现内存分配器的核心数据结构之一，它包含了多个用于管理内存分配和释放状态的字段。在多线程环境中，需要通过互斥锁来确保对这些状态的安全访问。</p>
<p><code>have_fastchunks</code> 字段虽然是近似值，但对于优化内存管理的性能十分重要，通过减少不必要的合并调用，可以提高分配效率。整体上，这种设计具有良好的性能和灵活性，适合在动态内存管理中使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   have_fastchunks 表示可能存在一些fastbin chunks。</span></span><br><span class="line"><span class="comment">   它在将块放入任何fastbin时设置为 true，并在</span></span><br><span class="line"><span class="comment">   malloc_consolidate 中被清除。这个值是近似的，</span></span><br><span class="line"><span class="comment">   因为它可能在没有fastbin chunk时被设置，或者即使</span></span><br><span class="line"><span class="comment">   存在fastbin chunk时也可能被清除。由于它的唯一目的是</span></span><br><span class="line"><span class="comment">   减少对 malloc_consolidate 的冗余调用，因此</span></span><br><span class="line"><span class="comment">   它并不影响正确性。因此我们可以安全地使用</span></span><br><span class="line"><span class="comment">   放松的原子访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* 序列化访问。 */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 标志（以前在 max_fast 中）。 */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果快速桶块包含最近插入的空闲块，则设置。 */</span></span><br><span class="line">  <span class="comment">/* 注意这是一个布尔值，但并不是所有目标都支持</span></span><br><span class="line"><span class="comment">     布尔类型的原子操作。 */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 快速桶 */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* top chunk的基址--不在其他桶中保存 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最近一次拆分小请求的剩余部分 */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 正常的桶，按照上述描述打包 */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 桶的位图 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 空闲区域的链表。该字段的访问由 arena.c 中的 free_list_lock 序列化。 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 附加到该区域的线程数量。 如果区域在空闲列表中，则为 0。</span></span><br><span class="line"><span class="comment">     该字段的访问由 arena.c 中的 free_list_lock 序列化。 */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从系统中在该区域分配的内存。 */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mutex是互斥锁，前面说到的arena为了解决多线程冲突的问题，所以如果使用了该arena，会进行上锁。<br>后面的flags是标志位标志着一些特征，这里不做深入只需要有个概念。fastbins是一个链表后面再做解释，top指的是top chunk，bins也是一个chunk的链表数组，next指针指向的是下一个malloc_state的位置。而后面那个*next_free指针是指向下一个未使用的malloc_state的位置。</p>
<h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><p><code>malloc_par</code> 结构体用于管理和配置内存分配器的参数。它包含了多个调节和监控内存分配行为的字段，这使得内存管理更加灵活和高效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* 可调参数 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;    <span class="comment">// 修剪阈值</span></span><br><span class="line">  INTERNAL_SIZE_T top_pad;         <span class="comment">// 顶部填充</span></span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;   <span class="comment">// mmap 阈值</span></span><br><span class="line">  INTERNAL_SIZE_T arena_test;       <span class="comment">// arena 测试</span></span><br><span class="line">  INTERNAL_SIZE_T arena_max;        <span class="comment">// arena 最大值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 内存映射支持 */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;                      <span class="comment">// 当前 mmap 的数量</span></span><br><span class="line">  <span class="type">int</span> n_mmaps_max;                  <span class="comment">// 当前 mmap 的最大数量</span></span><br><span class="line">  <span class="type">int</span> max_n_mmaps;                  <span class="comment">// 最大 mmap 数量</span></span><br><span class="line">  <span class="comment">/* mmap_threshold 是动态的，直到用户手动设置它，</span></span><br><span class="line"><span class="comment">     此时我们需要禁用任何动态行为。 */</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;             <span class="comment">// 禁用动态阈值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 统计信息 */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;      <span class="comment">// 已映射内存</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;  <span class="comment">// 最大映射内存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过 MORECORE/sbrk 分配的第一个地址。 */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;                  <span class="comment">// sbrk 基础地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* 使用的最大桶数量。 */</span></span><br><span class="line">  <span class="type">size_t</span> tcache_bins;               <span class="comment">// tcache 桶数量</span></span><br><span class="line">  <span class="type">size_t</span> tcache_max_bytes;          <span class="comment">// tcache 最大字节数</span></span><br><span class="line">  <span class="comment">/* 每个桶中最大块数。 */</span></span><br><span class="line">  <span class="type">size_t</span> tcache_count;              <span class="comment">// tcache 块数量</span></span><br><span class="line">  <span class="comment">/* 从未排序列表中移除的最大块数，这些块不用于</span></span><br><span class="line"><span class="comment">     填充缓存。 */</span></span><br><span class="line">  <span class="type">size_t</span> tcache_unsorted_limit;     <span class="comment">// tcache 未排序限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下<code>mp_</code>结构体后面经常用到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span></span><br><span class="line"><span class="comment">   malloc.  If you are adapting this malloc in a way that does NOT use</span></span><br><span class="line"><span class="comment">   a static or mmapped malloc_state, you MUST explicitly zero-fill it</span></span><br><span class="line"><span class="comment">   before using. This malloc relies on the property that malloc_state</span></span><br><span class="line"><span class="comment">   is initialized to all zeroes (as is true of C statics).  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* These variables are used for undumping support.  Chunked are marked</span></span><br><span class="line"><span class="comment">   as using mmap, but we leave them alone if they fall into this</span></span><br><span class="line"><span class="comment">   range.  NB: The chunk size for these chunks only includes the</span></span><br><span class="line"><span class="comment">   initial size field (of SIZE_SZ bytes), there is no trailing size</span></span><br><span class="line"><span class="comment">   field (unlike with regular mmapped chunks).  */</span></span><br><span class="line"><span class="type">static</span> mchunkptr dumped_main_arena_start; <span class="comment">/* Inclusive.  */</span></span><br><span class="line"><span class="type">static</span> mchunkptr dumped_main_arena_end;   <span class="comment">/* Exclusive.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* True if the pointer falls into the dumped arena.  Use this after</span></span><br><span class="line"><span class="comment">   chunk_is_mmapped indicates a chunk is mmapped.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUMPED_MAIN_ARENA_CHUNK(p) \</span></span><br><span class="line"><span class="meta">  ((p) &gt;= dumped_main_arena_start &amp;&amp; (p) &lt; dumped_main_arena_end)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is only one instance of the malloc parameters.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Initialize a malloc_state struct.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This is called from ptmalloc_init () or from _int_new_arena ()</span></span><br><span class="line"><span class="comment">   when creating a new arena.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Other internal utilities operating on mstates</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T, mstate)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>      <span class="title function_">systrim</span> <span class="params">(<span class="type">size_t</span>, mstate)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     <span class="title function_">malloc_consolidate</span> <span class="params">(mstate)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="hook函数"><a href="#hook函数" class="headerlink" title="hook函数"></a>hook函数</h2><p>在用户没有自定义之前，hook函数默认为空，所以我们常通过改hook函数为one_gadget来getshell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -------------- Early definitions for debugging hooks ---------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define and initialize the hook variables.  These weak definitions must</span></span><br><span class="line"><span class="comment">   appear before any use of the variables in a function (arena.c uses one).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> weak_variable</span></span><br><span class="line"><span class="comment">/* In GNU libc we want the hook variables to be weak definitions to</span></span><br><span class="line"><span class="comment">   avoid a problem with Emacs.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> weak_variable weak_function</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Forward declarations.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="type">void</span> *caller)</span> __THROW;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">realloc_hook_ini</span> <span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="type">void</span> *caller)</span> __THROW;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">memalign_hook_ini</span> <span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> sz,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span> *caller)</span> __THROW;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MALLOC_INIT_HOOK</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__malloc_initialize_hook)</span> <span class="params">(<span class="type">void</span>)</span> = <span class="literal">NULL</span>;</span><br><span class="line">compat_symbol (libc, __malloc_initialize_hook,</span><br><span class="line">	       __malloc_initialize_hook, GLIBC_2_0);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span> <span class="params">(<span class="type">void</span> *__ptr,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span> = malloc_hook_ini;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__realloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">void</span> *__ptr, <span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line">  = realloc_hook_ini;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__memalign_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __alignment, <span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line">  = memalign_hook_ini;</span><br><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__after_morecore_hook)</span> <span class="params">(<span class="type">void</span>)</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called from the arena shutdown hook, to free the</span></span><br><span class="line"><span class="comment">   thread cache (if it exists).  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span> <span class="params">(<span class="type">void</span> *__ptr, <span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><strong>语法分析</strong></p>
<ol>
<li><p><strong><code>void</code></strong>：</p>
<ul>
<li>这是返回类型，表示这个函数不返回任何值。</li>
</ul>
</li>
<li><p><strong><code>weak_variable</code></strong>：</p>
<ul>
<li>这是一个类型修饰符，通常用于指示编译器这是一个弱符号（weak symbol）。弱符号允许在链接时可以被同名的强符号（strong symbol）覆盖。这在库中常用，以允许用户自定义特定的行为而不影响库的默认实现。</li>
</ul>
</li>
<li><p><strong><code>(*__free_hook)</code></strong>：</p>
<ul>
<li>这里定义了一个函数指针，<code>__free_hook</code> 是指针的名字。<code>(*__free_hook)</code> 表示 <code>__free_hook</code> 是一个指向函数的指针。函数指针的定义需要括号将指针名称括起来，这是因为在 C 语言中，<code>*</code> 优先级高于函数的参数列表。</li>
</ul>
</li>
<li><p><strong><code>(void *__ptr, const void *)</code></strong>：</p>
<ul>
<li>这是函数指针所指向的函数的参数列表：<ul>
<li><code>void *__ptr</code>：第一个参数是一个指向 <code>void</code> 类型的指针，通常用于指向要释放的内存块。</li>
<li><code>const void *</code>：第二个参数也是一个指向 <code>void</code> 的常量指针，常用于传递上下文信息或其他数据，而不希望在钩子函数中修改它。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>= NULL;</code></strong>：</p>
<ul>
<li>这是对 <code>__free_hook</code> 的初始化，将其初始值设为 <code>NULL</code>，表示目前没有关联的具体实现。当这个钩子被调用时，如果没有用户提供的实现，指针为 <code>NULL</code> 时通常会导致调用默认的 <code>free</code> 函数或产生错误。</li>
</ul>
</li>
</ol>
<p><strong>整体含义</strong></p>
<p>综上所述，这行代码的作用是定义一个名为 <code>__free_hook</code> 的函数指针，这个指针可以指向一个特定的函数，该函数用于替代标准 <code>free</code> 操作。这个替代操作可以在内存管理系统中提供自定义行为，例如在释放内存时进行日志记录、统计等操作。由于它是一个弱符号，用户可以在链接时提供自己的实现来替代这个钩子，从而定制内存释放的行为。</p>
<p><strong>示例用法</strong></p>
<p>假设用户想要定义自己的 <code>free</code> 行为，他们可能会这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_free_hook</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">const</span> <span class="type">void</span> *context)</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义释放操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing memory at %p\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 调用标准的 free 函数释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某处的代码中</span></span><br><span class="line">__free_hook = my_free_hook; <span class="comment">// 将钩子指向用户自定义的实现</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，用户定义了一个自定义的 <code>my_free_hook</code> 函数，并将 <code>__free_hook</code> 指向它。这样，任何调用 <code>free</code> 的操作，都会通过 <code>my_free_hook</code> 先执行，从而实现用户自定义的内存释放逻辑。</p>
<h2 id="声明并定义了一堆检查"><a href="#声明并定义了一堆检查" class="headerlink" title="声明并定义了一堆检查"></a>声明并定义了一堆检查</h2><p>一部分是用于开发人员调试，一部分是实际用户用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !MALLOC_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_free_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_inuse_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloc_state(A)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_chunk(A, P)              do_check_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_free_chunk(A, P)         do_check_free_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloc_state(A)         do_check_malloc_state (A)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>分析后面的代码需要时直接跳转回了看就行</p>
<h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc()"></a>sysmalloc()</h2><p>当_int_malloc()函数尝试从 fast bins，last remainder chunk，small bins，large bins 和 top chunk 都失败之后，就会使用 sYSMALLOc()函数直接向系统申请内存用于分配所需的 chunk。 其实现源代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[开始]</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[检查 av 和请求大小]</span><br><span class="line">   |</span><br><span class="line">   +---是---&gt; [尝试 mmap 分配] ---&gt; [设置返回块] ---&gt; [结束]</span><br><span class="line">   |</span><br><span class="line">   +---否---&gt; [记录并检查当前top chunk]</span><br><span class="line">                   |</span><br><span class="line">                   v</span><br><span class="line">           [尝试扩展当前堆]</span><br><span class="line">                   |</span><br><span class="line">           +---是---&gt; [更新 av-&gt;system_mem]</span><br><span class="line">           |</span><br><span class="line">           +---否---&gt; [使用 MORECORE]</span><br><span class="line">                             |</span><br><span class="line">                             v</span><br><span class="line">                  [检查 MORECORE 返回值]</span><br><span class="line">                             |</span><br><span class="line">                 +---是---&gt; [对齐和更新]</span><br><span class="line">                 |</span><br><span class="line">                 +---否---&gt; [返回 ENOMEM]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>值得注意：</p>
<ul>
<li><code> _int_free (av, old_top, 1);</code>在179行</li>
<li><code> _int_free (av, old_top, 1);</code>在451行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------- Routines dealing with system allocation -------------- */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc 处理从系统请求更多内存的 malloc 情况。</span></span><br><span class="line"><span class="comment">   进入时，假设 av-&gt;top 没有足够的空间来满足 nb 字节的请求，</span></span><br><span class="line"><span class="comment">   因此需要扩展或替换 av-&gt;top。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span> <span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">char</span> *old_end;                  <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size;                      <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="type">char</span> *brk;                      <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction;                <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;                  <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;   <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果支持 mmap，并且请求的大小符合 mmap 阈值，    128kb</span></span><br><span class="line"><span class="comment">         并且系统支持 mmap，并且当前分配的 mmap 区域数量足够少，</span></span><br><span class="line"><span class="comment">         那么尝试直接映射此请求，而不是扩展 top。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line">	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br></pre></td></tr></table></figure>

<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap()分配的内存块小于设定的最大值，将使用mmap()系统调用直接向操作系统申请内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    try_mmap:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将大小向上舍入到最近的页面。</span></span><br><span class="line"><span class="comment">         对于通过 mmap 获取的块，开销比普通块多一个 SIZE_SZ 单位，因为没有后续块的 prev_size 字段可以使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         请参见下面的 front_misalign 处理，对于 glibc，除非我们有高对齐需求，否则不需要进一步的对齐处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">        size = ALIGN_UP (nb + SIZE_SZ, pagesize);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">      tried_mmap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>由于 nb 为所需 chunk 的大小，在_int_malloc()函数中已经将用户需要分配的大小转化为 chunk 大小，当如果这个 chunk 直接使用 mmap()分配的话，该 chunk 不存在下一个相邻的 chunk，也就没有 prev_size 的内存空间可以复用，所以还需要额外 SIZE_SZ 大小的内存。由 于 mmap()分配的内存块必须页对齐。如果使用 mmap()分配内存，需要重新计算分配的内存 大小 size。</p>
<h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim()"></a>systrim()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   systrim 在某种程度上是 sysmalloc 的反向操作。</span></span><br><span class="line"><span class="comment">   它通过对 sbrk 传递负参数，将未使用的内存返还给系统（如果在 malloc 池的“高”端有未使用的内存）。</span></span><br><span class="line"><span class="comment">   当 top 空间超过修整阈值时，它会被 free() 自动调用。</span></span><br><span class="line"><span class="comment">   它也可以被公共的 malloc_trim 例程调用。如果实际释放了任何内存，则返回 1，否则返回 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap()"></a>munmap()</h2><p><code>munmap_chunk</code> 函数用于<strong>释放</strong>通过内存映射分配的内存块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">munmap_chunk</span> <span class="params">(mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO (dl_pagesize); <span class="comment">// 获取系统页面大小</span></span><br><span class="line">  INTERNAL_SIZE_T size = chunksize (p); <span class="comment">// 获取当前块的大小</span></span><br><span class="line"></span><br><span class="line">  assert (chunk_is_mmapped (p)); <span class="comment">// 确保该块是一个内存映射块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果该块是一个在转储主区域中的伪内存映射块，则不执行任何操作。</span></span><br><span class="line"><span class="comment">     我们从不释放这块内存。  */</span></span><br><span class="line">  <span class="keyword">if</span> (DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uintptr_t</span> mem = (<span class="type">uintptr_t</span>) chunk2mem (p); <span class="comment">// 获取块的内存地址</span></span><br><span class="line">  <span class="type">uintptr_t</span> block = (<span class="type">uintptr_t</span>) p - prev_size (p); <span class="comment">// 计算块的起始地址</span></span><br><span class="line">  <span class="type">size_t</span> total_size = prev_size (p) + size; <span class="comment">// 计算总大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 不幸的是，我们必须手动完成编译器的工作。通常我们会分别测试</span></span><br><span class="line"><span class="comment">     BLOCK 和 TOTAL-SIZE 是否符合页面大小的要求。但 gcc 目前并不</span></span><br><span class="line"><span class="comment">     识别优化的可能性，因此我们在位测试之前将两个值合并为一个。 */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely ((block | total_size) &amp; (pagesize - <span class="number">1</span>)) != <span class="number">0</span></span><br><span class="line">      || __glibc_unlikely (!powerof2 (mem &amp; (pagesize - <span class="number">1</span>))))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;munmap_chunk(): 无效的指针&quot;</span>); <span class="comment">// 输出错误信息</span></span><br><span class="line"></span><br><span class="line">  atomic_decrement (&amp;mp_.n_mmaps); <span class="comment">// 减少内存映射块计数</span></span><br><span class="line">  <span class="type">atomic_add</span> (&amp;mp_.mmapped_mem, -total_size); <span class="comment">// 减少映射内存的总量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果 munmap 失败，进程的虚拟内存地址空间处于不良状态。</span></span><br><span class="line"><span class="comment">     只是让块悬挂在那里，进程很快就会终止，因为无能为力。 */</span></span><br><span class="line">  __munmap ((<span class="type">char</span> *) block, total_size); <span class="comment">// 尝试释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后闲了再看吧，直接看tcache，malloc()和free()</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><p>在glibc2.29之后加入了key变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 每个线程都有一个这样的结构体，</span></span><br><span class="line"><span class="comment">   它包含每个线程的缓存（因此称为“tcache_perthread_struct”）。</span></span><br><span class="line"><span class="comment">   保持总体大小较小是稍微重要的。</span></span><br><span class="line"><span class="comment">   请注意，COUNTS 和 ENTRIES 是冗余的（我们本可以每次只计算链表的长度），但这是出于性能考虑。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-puts"><a href="#tcache-puts" class="headerlink" title="tcache_puts()"></a>tcache_puts()</h3><p>将chunk放入tcache中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 调用者必须确保我们知道 tc_idx 是有效的，并且有足够的空间</span></span><br><span class="line"><span class="comment">   存放更多的块。 */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将这个块标记为“在 tcache 中”，以便在 _int_free 中测试</span></span><br><span class="line"><span class="comment">         可以检测到重复释放。 */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><p>从tcache中拿走chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 调用者必须确保 tc_idx 是有效的，并且有可移除的内存块。 */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-thread-shutdown"><a href="#tcache-thread-shutdown" class="headerlink" title="tcache_thread_shutdown()"></a>tcache_thread_shutdown()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">	&#123;</span><br><span class="line">	  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">	  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">	  __libc_free (e);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init()"></a>tcache_init()</h3><p>这里重要的就是<code>_int_malloc (ar_ptr, bytes);</code>他分配了每次程序运行起来后哪个0x290的chunk，这个chunk里面就是本线程的tcache的所有信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56493e4e9000</span><br><span class="line">Size: 0x290 (with flag bits: 0x291)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56493e4e9290</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x56493e4e92b0</span><br><span class="line">Size: 0x20d50 (with flag bits: 0x20d51)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);<span class="comment">//*</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc()"></a>__libc_malloc()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">_Static_assert</span> (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="number">2</span>,</span><br><span class="line">                  <span class="string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);</span><br><span class="line"><span class="comment">//存在hook函数则执行hook函数</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="comment">//若tcache启用，首先使用tcache来分配chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;<span class="comment">//获取 nb+2*SIZE_SZ (0x10在64位中) 的大小，并判断</span></span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//tcache不满足的话，再用_int_malloc()，下面这些和单多线程有关</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure>

<h2 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free()"></a>__libc_free()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"><span class="comment">//有hook函数调用hook函数</span></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* 查看动态的 brk/mmap 阈值是否需要调整。</span></span><br><span class="line"><span class="comment">		转储的虚假 mmap 块不会影响该阈值。 */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">	  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);<span class="comment">//这个就是前面那个munmap()释放通过内存映射(mmap)分配的内存块</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);<span class="comment">//调用_int_free()</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure>

<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h2><p>初始化声明变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="type">size_t</span> tcache_unsorted_count;	    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     将请求大小转换为内部形式，通过添加 SIZE_SZ 字节的</span></span><br><span class="line"><span class="comment">     额外开销，并可能需要更多以获得必要的对齐，或</span></span><br><span class="line"><span class="comment">     至少获得 MINSIZE，即最小可分配大小。</span></span><br><span class="line"><span class="comment">     同时，checked_request2size 对于请求大小过大</span></span><br><span class="line"><span class="comment">     的情况返回 false，这样在填充和对齐后会</span></span><br><span class="line"><span class="comment">     发生零值回绕。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!checked_request2size (bytes, &amp;nb))</span><br><span class="line">&#123;</span><br><span class="line">  __set_errno (ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 没有可用的内存区域。回退到 sysmalloc 从 mmap 获取一个 chunk。 */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;				\</span><br></pre></td></tr></table></figure>

<h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p>在启用tcache的情况下，从fastbin中取出chunk:</p>
<ul>
<li>首先会在fastbin中找到所需的chunk</li>
<li>然后在tcachebin未满或这为空的情况下，会将它放入tcachebin中</li>
<li>即在tcache启用后优先从tcachebin中取出chunk给用户，所以这里就显示出了tcachebin的优先级比fastbin更高</li>
</ul>
<p>注意：</p>
<ul>
<li>因为tcache的单向链表用的头插法，头插法的特点就是如下：<ul>
<li>插入input: 10 20 30</li>
<li>遍历output：30 20 10</li>
</ul>
</li>
<li>所以这就导致了在同样size时，当tcachehbin中的chunk被取出后，若fastbin中有多个chunk，它们会逆序放入到tcachebin中</li>
</ul>
<p>攻击手法：fastbin_reverse_into_tcache</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果大小符合快速分配（fastbin）的条件，首先检查相应的空闲bin。</span></span><br><span class="line"><span class="comment">   这段代码即使在 av 尚未初始化的情况下也可以安全执行，因此</span></span><br><span class="line"><span class="comment">   可以在不检查的情况下尝试，这样可以节省在快速路径上的时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line"><span class="meta">  do							\</span></span><br><span class="line"><span class="meta">    &#123;							\</span></span><br><span class="line"><span class="meta">      victim = pp;					\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)				\</span></span><br><span class="line"><span class="meta">	break;						\</span></span><br><span class="line"><span class="meta">    &#125;							\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta">	 != victim);</span></span><br><span class="line"><span class="comment">// 检查请求的内存大小是否小于等于最大快速分配大小</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算请求大小对应的fastbin索引</span></span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx); <span class="comment">// 获取相应的fastbin指针</span></span><br><span class="line">    mchunkptr pp; <span class="comment">// 定义一个指针，用于操作快速分配器中的块</span></span><br><span class="line">    victim = *fb; <span class="comment">// 从fastbin中获取一个空闲chunk</span></span><br><span class="line">    <span class="comment">// 检查是否有可用的内存块</span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在单线程环境下，直接更新快速分配器指针</span></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">            *fb = victim-&gt;fd; <span class="comment">// 将 fb 指向下一个空闲块</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            REMOVE_FB (fb, pp, victim); <span class="comment">// 在多线程环境下安全地移除该块</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保 victim 不为 NULL 以继续处理</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取 victim 的大小对应的索引</span></span><br><span class="line">            <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">            <span class="comment">// 检查 victim 的索引是否与请求的索引一致</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">                <span class="comment">// 如果不一致，报告内存损坏错误</span></span><br><span class="line">                malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行对 victim 块的进一步检查，确保其可以安全使用</span></span><br><span class="line">            check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)<span class="comment">//单线程</span></span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;<span class="comment">//多线程操作</span></span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//将victim放入tcache中</span></span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_list[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        chunk_list[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        <span class="built_in">free</span>(chunk_list[i]);</span><br><span class="line">	<span class="built_in">free</span>(chunk_list[<span class="number">9</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_list[<span class="number">7</span>]);<span class="comment">//这个进入了smallbin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x110</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_list[7]进入了smallbin&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//观察源代码的执行</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//这个就是从smallbin中取出来放进tcache的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果请求的内存较小，检查常规的内存池（small bins）。</span></span><br><span class="line"><span class="comment">  由于这些“smallbin”每个只包含一个大小，因此不需要在内存池内搜索。</span></span><br><span class="line"><span class="comment">  （对于较大的请求，我们需要等待unsortedbin被处理，以找到最佳匹配。</span></span><br><span class="line"><span class="comment">   但对于smallbin chunk请求，适配是准确的，因此我们现在可以检查，这样更快。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb))  <span class="comment">// 检查请求的大小是否在smallbin范围内</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index(nb);  <span class="comment">// 计算请求大小对应的smallbin索引</span></span><br><span class="line">    bin = bin_at(av, idx);  <span class="comment">// 获取对应的smallbin指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin)  <span class="comment">// 获取smllbin中的最后一个块，如果不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        bck = victim-&gt;bk;  <span class="comment">// 记录被分配chunk的后继chunk</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))  <span class="comment">// 检查双向链表的完整性</span></span><br><span class="line">            malloc_printerr(<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set_inuse_bit_at_offset(victim, nb);  <span class="comment">// 设置块状态为已使用</span></span><br><span class="line">        bin-&gt;bk = bck;  <span class="comment">// 更新小块指针</span></span><br><span class="line">        bck-&gt;fd = bin;  <span class="comment">// 维护双向链表的完整性</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)  <span class="comment">// 检查是否在主分配区</span></span><br><span class="line">            set_non_main_arena(victim);</span><br><span class="line">        </span><br><span class="line">        check_malloced_chunk(av, victim, nb);  <span class="comment">// 检查分配的块</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">/* 在这里，如果我们看到相同大小的其他块，</span></span><br><span class="line"><span class="comment">           将它们存入线程缓存（tcache）。 */</span></span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(nb);  <span class="comment">// 计算tcache索引</span></span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  <span class="comment">// 检查tcache是否有效</span></span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 当小块不为空且线程缓存未满时，复制块。 */</span></span><br><span class="line">            <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                &amp;&amp; (tc_victim = last(bin)) != bin)  <span class="comment">// 获取小块列表中的最后一个块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)  <span class="comment">// 检查块是否有效</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bck = tc_victim-&gt;bk;  <span class="comment">// 获取块的后继块</span></span><br><span class="line">                    set_inuse_bit_at_offset(tc_victim, nb);  <span class="comment">// 设置状态为已使用</span></span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena(tc_victim);  <span class="comment">// 更新非主分配区标志</span></span><br><span class="line"></span><br><span class="line">                    bin-&gt;bk = bck;  <span class="comment">// 更新小块指针</span></span><br><span class="line">                    bck-&gt;fd = bin;  <span class="comment">// 维护双向链表的完整性</span></span><br><span class="line"></span><br><span class="line">                    tcache_put(tc_victim, tc_idx);  <span class="comment">// 将victim放入tcache中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);  </span><br><span class="line">        alloc_perturb(p, bytes);  </span><br><span class="line">        <span class="keyword">return</span> p;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h3><p>首先处理unsortedbin中的空闲chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果这是一个大请求，在继续之前合并快速块（fastbins）。</span></span><br><span class="line"><span class="comment">  虽然在查看是否有可用空间之前处理所有快速块看起来有些过度，</span></span><br><span class="line"><span class="comment">  但这样可以避免通常与快速块相关的碎片问题。</span></span><br><span class="line"><span class="comment">  此外，实际上，程序倾向于连续产生小请求或大请求，</span></span><br><span class="line"><span class="comment">  而不常出现混合请求，因此在大多数程序中，</span></span><br><span class="line"><span class="comment">  不会频繁调用合并操作。而在那些频繁调用合并操作的程序</span></span><br><span class="line"><span class="comment">  中，往往会导致内存碎片。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index(nb);  <span class="comment">// 计算请求大小对应的大块索引</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks))  <span class="comment">// 检查fastbin中是否存在空闲chunk</span></span><br><span class="line">        malloc_consolidate(av);  <span class="comment">// 合并fastbin的空闲chunk</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  处理最近释放或剩余的内存块，仅在块完全匹配时才取用，</span></span><br><span class="line"><span class="comment">  或者如果这是一个小请求，则取用从最近的非完全匹配中剩余的块。</span></span><br><span class="line"><span class="comment">  将其他遍历到的块放入合适的池中。</span></span><br><span class="line"><span class="comment">  请注意，这个步骤是在任何例程中唯一将块放入池中的地方。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这里的外部循环是必要的，因为我们可能直到 malloc 接近结束时</span></span><br><span class="line"><span class="comment">  才意识到我们应该合并，因此必须执行合并并重试。</span></span><br><span class="line"><span class="comment">  这最多发生一次，并且只在我们需要扩展内存以满足“小”请求时。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;  <span class="comment">// 用于缓存的块大小</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx(nb);  <span class="comment">// 将请求大小转换为tcache索引</span></span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  <span class="comment">// 检查缓存是否启用并且索引有效</span></span><br><span class="line">    tcache_nb = nb;  <span class="comment">// 设置缓存块大小</span></span><br><span class="line">  <span class="type">int</span> return_cached = <span class="number">0</span>;  <span class="comment">// 标记返回缓存块的状态</span></span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>unsorted_chunks(av)</code></td>
<td>获取 unsorted bin 的链表头（伪 chunk），位于 <code>main_arena</code> 固定偏移处</td>
</tr>
<tr>
<td>循环条件</td>
<td>遍历 unsorted bin 中的真实 chunk，<strong>逆序处理</strong>直到链表头</td>
</tr>
<tr>
<td>链表头特性</td>
<td><code>fd</code> 指向第一个真实 chunk，<code>bk</code> 指向最后一个真实 chunk</td>
</tr>
</tbody></table>
<p>首先要搞明白一个宏<code>unsorted_chunks(av)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unsorted_chunks(av) = bin_at(av, <span class="number">1</span>)</span><br><span class="line">                    = (<span class="type">char</span>*)&amp;av-&gt;bins[(<span class="number">1</span><span class="number">-1</span>)*<span class="number">2</span>] - offsetof(malloc_chunk, fd)</span><br><span class="line">                    = (<span class="type">char</span>*)&amp;av-&gt;bins[<span class="number">0</span>] - <span class="number">0x10</span>  <span class="comment">// 因 malloc_chunk.fd 偏移为 0x10</span></span><br><span class="line">                    = main_arena + <span class="number">0x58</span> - <span class="number">0x10</span>    </span><br><span class="line">                    = main_arena + <span class="number">0x48</span>           <span class="comment">//这个是main_arena+88的head</span></span><br></pre></td></tr></table></figure>

<p>下面的源代码实现从 last remainder chunk，large bins 和top chunk 中分配所需的 chunk， 这里包含了多个多层循环，在这些循环中，主要工作是分配前两步都未分配成功的 small bin chunk，large bin chunk 和 large chunk。最外层的循环用于重新尝试分配 small bin chunk，因 为如果在前一步分配small bin chunk 不成功，并没有调用 malloc_consolidate()函数合并 fast bins 中的 chunk，将空闲 chunk 加入 unsorted bin 中，如果第一尝试从 last remainder chunk， top chunk 中分配 small bin chunk 都失败以后，如果 fast bins 中存在空闲 chunk，会调用 malloc_consolidate()函数，那么在 usorted bin 中就可能存在合适的 small bin chunk 供分配， 所以需要再次尝试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )<span class="comment">//遍历unsortedbin</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;<span class="comment">//记录循环的次数</span></span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;<span class="comment">//逆序</span></span><br><span class="line">        bck = victim-&gt;bk; <span class="comment">//bck需要注意</span></span><br><span class="line">        size = chunksize (victim);</span><br><span class="line">        mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">            || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">             如果是小内存请求，且unsorted bin中仅存最后一个剩余块（last_remainder），</span></span><br><span class="line"><span class="comment">             则尝试使用它。这有助于提升连续小内存请求的局部性。</span></span><br><span class="line"><span class="comment">             这是最佳适配策略的唯一例外，且仅适用于小内存块没有精确匹配的情况。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<span class="comment">//判断是否需要分配一个small bin chunk</span></span><br><span class="line">            bck == unsorted_chunks (av) &amp;&amp;<span class="comment">//unsortedbin中只有一个chunk</span></span><br><span class="line">            victim == av-&gt;last_remainder &amp;&amp;<span class="comment">//并且这个chunk为last_remainder chunk</span></span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))<span class="comment">//且大于所需chunk的size加上MINSIZE</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">            remainder_size = size - nb;<span class="comment">//计算切分后剩下的chunk大小</span></span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">            unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">            remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<span class="comment">//链入unsortedbin中</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">              &#123;<span class="comment">//如果属于largebin chunk将该chunk的fd_nextsize和bk_nextsize设置为NULL</span></span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">	  <span class="comment">//设置分配出的chunk和last_remainder chunk的相关信息</span></span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">          &#125;<span class="comment">//返回应用层，退出</span></span><br></pre></td></tr></table></figure>

<p>原unsortedbin_attack（向任意地址即bck的fd写入main_arena+88），因加了这个检查后就用不了了</p>
<p>若前面仍未完成分配，则将usnortedbin中最后一个chunk拿出来若与所需大小一致，将当前chunk返回，否则分类并归位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>启用tcache，将chunk先放入tcache中，再返回给给用户，当tcache满的时候才直接返回给用户</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>开始归为前面遍历到但不符合需求的chunk。</p>
<p>如果当前 chunk 属于small bins，获得当前 chunk 所属small bin 的 index，并将该 small bin 的链表表头赋值给 bck，第一个 chunk 赋值给 fwd，也就是当前的 chunk 会插入到 bck 和 fwd 之间，作为small bin 链表的第一个 chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果当前 chunk 属于 large bins，获得当前 chunk 所属 large bin 的 index，并将该 large bin 的链表表头赋值给 bck，第一个 chunk 赋值给 fwd，也就是当前的 chunk 会插入到 bck 和 fwd 之间，作为 large bin 链表的第一个 chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd</span><br></pre></td></tr></table></figure>

<p>如果fwd 不等于 bck，意味着<strong>large bin 中有空闲chunk 存在</strong>，由于large bin 中的空闲chunk 是按照大小顺序排序的，需要将当前从 unsorted bin 中取出的 chunk 插入到 large bin 中合适 的位置。将当前 chunk 的 size 的 inuse 标志 bit 置位，相当于加 1，便于加快 chunk 大小的比 较，找到合适的地方插入当前 chunk。这里还做了一次检查，断言在 large bin 双向循环链表 中的最后一个 chunk的 size 字段中的非主分配区的标志 bit没有置位，因为所有在 large bin 中的 chunk 都处于空闲状态，该标志位一定是清零的。</p>
<hr>
<p>根据内存结构理解largebin的fd和bk</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x1f2ae850 —▸ 0x1f2ae420 —▸ 0x1f2ae000 —▸ 0x7f5cf0f79f68 (main_arena+1096) ◂— 0x1f2ae850</span><br><span class="line">pwndbg&gt; x/10gx 0x1f2ae850 <span class="comment">#最大 </span></span><br><span class="line">0x1f2ae850:     0x0000000000000000      0x0000000000000421</span><br><span class="line">0x1f2ae860:     0x000000001f2ae420      0x00007f5cf0f79f68#bk-&gt;main_arena+1096</span><br><span class="line">0x1f2ae870:     0x000000001f2ae420      0x000000001f2ae000</span><br><span class="line">0x1f2ae880:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1f2ae890:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x1f2ae420 <span class="comment"># fd_nextsize-&gt;小的 bk_nextsize-&gt;大的</span></span><br><span class="line">0x1f2ae420:     0x0000000000000000      0x0000000000000411</span><br><span class="line">0x1f2ae430:     0x000000001f2ae000      0x000000001f2ae850</span><br><span class="line">0x1f2ae440:     0x000000001f2ae000      0x000000001f2ae850</span><br><span class="line">0x1f2ae450:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1f2ae460:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x1f2ae000 <span class="comment"># 最小</span></span><br><span class="line">0x1f2ae000:     0x0000000000000000      0x0000000000000401</span><br><span class="line">0x1f2ae010:     0x00007f5cf0f79f68      0x000000001f2ae420#fd-&gt;main_arena+1096</span><br><span class="line">0x1f2ae020:     0x000000001f2ae850      0x000000001f2ae420</span><br><span class="line">0x1f2ae030:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1f2ae040:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x7f5cf0f79f68 <span class="comment">#头节点  fd-&gt;最大  bk-&gt;最小</span></span><br><span class="line">0x7f5cf0f79f68 &lt;main_arena+1096&gt;:       0x00007f5cf0f79f58      0x00007f5cf0f79f58</span><br><span class="line">0x7f5cf0f79f78 &lt;main_arena+1112&gt;:       0x000000001f2ae850&lt;-fwd 0x000000001f2ae000&lt;-bck</span><br><span class="line">0x7f5cf0f79f88 &lt;main_arena+1128&gt;:       0x00007f5cf0f79f78      0x00007f5cf0f79f78</span><br><span class="line">0x7f5cf0f79f98 &lt;main_arena+1144&gt;:       0x00007f5cf0f79f88      0x00007f5cf0f79f88</span><br><span class="line">0x7f5cf0f79fa8 &lt;main_arena+1160&gt;:       0x00007f5cf0f79f98      0x00007f5cf0f79f98</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">largebins</span><br><span class="line">0x400-0x430: 0x1fa8f000 —▸ 0x1fa8f840 —▸ 0x1fa8f420 —▸ 0x7f9a8e388f68 (main_arena+1096) ◂— 0x1fa8f000</span><br><span class="line">pwndbg&gt; x/10gx 0x1fa8f000</span><br><span class="line">0x1fa8f000:     0x0000000000000000      0x0000000000000401</span><br><span class="line">0x1fa8f010:     0x000000001fa8f840      0x00007f9a8e388f68</span><br><span class="line">0x1fa8f020:     0x000000001fa8f000      0x000000001fa8f000</span><br><span class="line">0x1fa8f030:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f040:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x1fa8f840</span><br><span class="line">0x1fa8f840:     0x0000000000000000      0x0000000000000401</span><br><span class="line">0x1fa8f850:     0x000000001fa8f420      0x000000001fa8f000</span><br><span class="line">0x1fa8f860:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f870:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f880:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x1fa8f420</span><br><span class="line">0x1fa8f420:     0x0000000000000000      0x0000000000000401</span><br><span class="line">0x1fa8f430:     0x00007f9a8e388f68      0x000000001fa8f840</span><br><span class="line">0x1fa8f440:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f450:     0x0000000000000000      0x0000000000000000</span><br><span class="line">0x1fa8f460:     0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x7f9a8e388f68</span><br><span class="line">0x7f9a8e388f68 &lt;main_arena+1096&gt;:       0x00007f9a8e388f58      0x00007f9a8e388f58</span><br><span class="line">0x7f9a8e388f78 &lt;main_arena+1112&gt;:       0x000000001fa8f000      0x000000001fa8f420</span><br><span class="line">0x7f9a8e388f88 &lt;main_arena+1128&gt;:       0x00007f9a8e388f78      0x00007f9a8e388f78</span><br><span class="line">0x7f9a8e388f98 &lt;main_arena+1144&gt;:       0x00007f9a8e388f88      0x00007f9a8e388f88</span><br><span class="line">0x7f9a8e388fa8 &lt;main_arena+1160&gt;:       0x00007f9a8e388f98      0x00007f9a8e388f98</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>largebin_attack</strong></p>
<p>从上面的内存结构可以看出fwd-&gt;最小的；bck-&gt;最大的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">  &#123;<span class="comment">//large bin 中有空闲chunk 存在</span></span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert (chunk_main_arena (bck-&gt;bk));</span><br></pre></td></tr></table></figure>

<p>如果当前chunk比large bin的最后一个chunk的大小还小，那么当前chunk就插入到large bin 的链表的最后，作为最后一个 chunk。可以看出 large bin 中的 chunk 是按照从大到小的 顺序排序的，同时一个 chunk 存在于两个双向循环链表中，一个链表包含了 large bin 中所有 的chunk，另一个链表为chunk size 链表，该链表从每个相同大小的chunk 的取出第一个chunk 按照大小顺序链接在一起，便于一次跨域多个相同大小的 chunk 遍历下一个不同大小的 chunk，这样可以加快在 large bin 链表中的遍历速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))<span class="comment">//bck-&gt;bk是当前largebin中最小的chunk</span></span><br><span class="line">            &#123;<span class="comment">//直接链入largebin</span></span><br><span class="line">              fwd = bck;</span><br><span class="line">              bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">              victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>正向遍历 <strong>chunk size 链表</strong>，直到找到第一个 chunk 大小小于等于当前 chunk 大小的 chunk 退出循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line">               &#123;<span class="comment">//即等于或大于fwd的size</span></span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;<span class="comment">//正向遍历largebin</span></span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>

<p>如果从 large bin 链表中找到了与当前 chunk 大小相同的 chunk，则同一大小的 chunk 已 经存在，那么 chunk size 链表中一定包含了fwd 所指向的 chunk，为了不修改 chunk size 链 表，当前 chunk 只能插入 fwd 之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))<span class="comment">//直到等于fwd的情况成立</span></span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;<span class="comment">//直接链在fwd后面</span></span><br></pre></td></tr></table></figure>



<p>如果 chunk size 链表中还没有包含当前 chunk 大小的 chunk，也就是说当前 chunk 的大小大于 fwd 的大小，则将当前 chunk 作为该 chunk size 的代表加入 chunk size 链表，chunk size 链表也是按照由大到小的顺序排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">                 &#123;</span><br><span class="line">                   victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                   victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                   <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                     malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted 									  (nextsize)&quot;</span>);</span><br><span class="line">                   fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                   victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>

<p>如果 large bin 链表中没有 chunk，直接将当前 chunk加入 chunk size 链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        bck = fwd-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>上面的代码将当前 chunk 插入到 large bin 的空闲 chunk 链表中，并将 large bin 所对应 binmap 的相应 bit 置位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>最多遍历unsortedbin 10000次，后面的一部分（在use_top）之前在pwn中可能很少用到，简略分析</p>
<p>当将 unsorted bin 中的空闲 chunk 加入到相应的 small bins 和 large bins 后，将使用<strong>最佳匹配法</strong>分配 large bin chunk。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">   sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line"> &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (victim)</span><br><span class="line">   &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br></pre></td></tr></table></figure>

<p>如果所需分配的 chunk为 large bin chunk，查询对应的 large bin 链表，如果 large bin 链 表为空，或者链表中最大的 chunk 也不能满足要求，则不能从 large bin 中分配。否则，遍历 98 large bin 链表，找到合适的 chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  victim = victim-&gt;bk_nextsize;</span><br><span class="line">  <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure>

<p>反向遍历chunk size链表(由小到大)，直到找到第一个大于等于所需chunk大小的chunk退出循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">             list does not have to be rerouted.  */</span></span><br><span class="line">          <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">&amp;&amp; chunksize_nomask (victim)</span><br><span class="line">  == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">            victim = victim-&gt;fd;</span><br></pre></td></tr></table></figure>

<p>如果从 large bin 链表中选取的 chunk victim 不是链表中的最后一个 chunk，并且与 victim 大小相同的chunk 不止一个，那么意味着victim 为chunk size 链表中的节点，为了不调整chunk size 链表，需要避免将 chunk size 链表中的节点取出，所以取 victim-&gt;fd 节点对应的 chunk 作为候选 chunk。由于 large bin 链表中的 chunk 也是按大小排序，同一大小的 chunk 有多个 时，这些 chunk 必定排在一起，所以 victim-&gt;fd 节点对应的 chunk 的大小必定与 victim 的大 小一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">unlink_chunk (av, victim);</span><br></pre></td></tr></table></figure>

<p>计算将victim切分后剩余大小，并调用 unlink()宏函数将 victim从 large bin 链表中取出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>如果将 victim 切分后剩余大小小于 MINSIZE，则将整个 victim 分配给应用层，这种情况 下，实际分配的 chunk 比所需的 chunk 要大一些。以 64 位系统为例，remainder_size 的可能 大小为 0 和 16，如果为 0，表示victim 的大小刚好等于所需 chunk 的大小，设置 victim 的 inuse 标志，inuse 标志位于下一个相邻的 chunk 的 size 字段中。如果 remainder_size 为 16，则这 16 字节就浪费掉了。如果当前分配区不是主分配区，将 victim 的 size 字段中的非主分配区 标志置位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* Split */</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                 have to perform a complete insert here.  */</span></span><br><span class="line">              bck = unsorted_chunks (av);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">              remainder-&gt;bk = bck;</span><br><span class="line">              remainder-&gt;fd = fwd;</span><br><span class="line">              bck-&gt;fd = remainder;</span><br><span class="line">              fwd-&gt;bk = remainder;</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>从victim 中切分出所需的chunk，剩余部分作为一个新的 chunk 加入到 unsorted bin 中。 如果剩余部分 chunk 属于large bins，将剩余部分 chunk 的 chunk size 链表指针设置为NULL， 因为 unsorted bin 中的 chunk 是不排序的，这两个指针无用，必须清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 large bin中使用<strong>最佳匹配法</strong>找到了合适的 chunk，设置victim和remainder的状态，由于 remainder 为空闲 chunk，所以需要设置该 chunk 的 foot；调用 chunk2mem()获得 chunk 中可 用的内存指针，返回给应用层，退出。</p>
<p>如果通过上面的方式从最合适的 small bin 或 large bin 中都<strong>没有分配到需要的chunk</strong>，则 查看比当前 bin 的 index 大的 small bin 或 large bin 是否有空闲 chunk 可利用来分配所需的 chunk。源代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         通过扫描bins来搜索chunk，从下一个较大的bin开始。</span></span><br><span class="line"><span class="comment">         这个搜索严格遵循最佳适配原则；即选择适合的最小块（在平局的情况下选择约最少最近使用的块）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         binmap避免了需要检查大多数块是否为空的情况。</span></span><br><span class="line"><span class="comment">         在热身阶段（即还没有返回任何块的情况下）跳过所有桶的特殊情况比看上去的要快得多。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;  <span class="comment">// 增加索引</span></span><br><span class="line">      bin = bin_at(av, idx);  <span class="comment">// 获取当前索引对应的桶</span></span><br><span class="line">      block = idx2block(idx);  <span class="comment">// 将索引转换为块</span></span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];  <span class="comment">// 获取对应块的位图</span></span><br><span class="line">      bit = idx2bit(idx);  <span class="comment">// 将索引转换为位图中的位</span></span><br></pre></td></tr></table></figure>

<p>获取下一个相邻bin 的空闲chunk 链表，并获取该bin 对于binmap 中的bit 位的值。Binmap 中的标识了相应的 bin 中是否有空闲 chunk 存在。Binmap 按 block 管理，每个 block 为一个 int，共 32 个 bit，可以表示 32 个 bin 中是否有空闲 chunk 存在。使用 binmap 可以加快查找 bin 是否包含空闲 chunk。这里只查询比所需 chunk 大的 bin 中是否有空闲 chunk 可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">              <span class="keyword">goto</span> use_top;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>Idx2bit()宏将 idx 指定的位设置为 1，其它位清零，map 表示一个 block（unsigned int） 值，如果 bit 大于 map，意味着 map 为 0，该 block 所对应的所有 bins 中都没有空闲 chunk， 于是遍历 binmap 的下一个 block，直到找到一个不为 0 的 block 或者遍历完所有的 block。 退出循环遍历后，设置 bin 指向 block 的第一个 bit 对应的 bin，并将 bit 置为 1，表示该 block 中 bit 1 对应的 bin，这个 bin 中如果有空闲 chunk，该 chunk 的大小一定满足要求。</p>
<p>….过了</p>
<p>如果从所有的 bins 中都没有获得所需的 chunk，可能的情况为 bins 中没有空闲 chunk， 或者所需的 chunk 大小很大，下一步将尝试从 top chunk 中分配所需 chunk。源代码实现如 下：</p>
<h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br></pre></td></tr></table></figure>

<p>将当前分配区的top chunk赋值给 victim，并获得 victim 的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;<span class="comment">//topchunk够用</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于 top chunk 切分出所需 chunk 后，还需要 MINSIZE 的空间来作为fencepost，所需必须满足 top chunk 的大小大于所需 chunk 的大小加上 MINSIZE 这个条件，才能从 top chunk 中分配所需 chunk。从 top chunk 切分出所需 chunk 的处理过程跟前面的 chunk 切分类似， 不同的是，原 top chunk 切分后的剩余部分将作为新的 top chunk，原 top chunk 的 fencepost 仍然作为新的top chunk 的 fencepost，所以切分之后剩余的 chunk 不用 set_foot。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">   here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果 top chunk 也不能满足要求，<strong>查看 fast bins 中是否有空闲 chunk 存在</strong>，由于开启了 ATOMIC_FASTBINS 优化情况下，free 属于 fast bins 的 chunk 时不需要获得分配区的锁，所以在调用_int_malloc()函数时，有可能有其它线程已经向 fast bins 中加入了新的空闲 chunk，也有可能是所需的 chunk 属于 small bins，但通过前面的步骤都没有分配到所需的 chunk，由于 分配 small bin chunk 时在前面的步骤都不会调用 malloc_consolidate()函数将 fast bins 中的 chunk 合并加入到 unsorted bin 中。所在这里如果 fast bin 中有 chunk 存在， 调用 malloc_consolidate()函数，并重新设置当前 bin 的 index。并转到最外层的循环，尝试重新分 配 small bin chunk 或是 large bin chunk。如果开启了 ATOMIC_FASTBINS 优化，有可能在由其 它线程加入到fast bins 中的 chunk 被合并后加入 unsorted bin 中，从 unsorted bin 中就可以 分配出所需的 large bin chunk 了，所以对没有成功分配的 large bin chunk 也需要重试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>山穷水尽了，只能想系统申请内存了。sysmalloc()函数可能分配的 chunk 包括 small bin chunk，large bin chunk 和 large chunk。</p>
<p>至此，_int_malloc()函数的代码就罗列完了，当还有两个关键函数没有分析，一个为 malloc_consolidate()，另一个为 sysmalloc()。</p>
<h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h2>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>leon
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://example.com/2025/04/22/glibc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" title="glibc源码阅读">http://example.com/2025/04/22/glibc源码阅读/</a>
  </li>
  <li class="post-copyright-license">
      <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/pwn/" rel="tag"><i class="fa fa-tag"></i> pwn</a>
              <a href="/tags/heap/" rel="tag"><i class="fa fa-tag"></i> heap</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/15/buuctf(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/" rel="prev" title="buuctf">
                  <i class="fa fa-angle-left"></i> buuctf
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/04/24/polarctf(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/" rel="next" title="Polar ctf">
                  Polar ctf <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">leon</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">419k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">6:21</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/le0n-daily" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
